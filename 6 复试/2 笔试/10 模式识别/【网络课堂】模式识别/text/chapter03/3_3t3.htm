<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><!-- InstanceBegin template="/Templates/frame_content.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<!-- InstanceBeginEditable name="doctitle" -->
<title>Untitled Document</title>
<!-- InstanceEndEditable --> 
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<!-- InstanceBeginEditable name="head" -->
<!-- InstanceEndEditable --> 
<link href="../../css/fc.css" rel="stylesheet" type="text/css">
<style type="text/css">
<!--
.bg {
	background-image: url(../../images/images/main__11.gif);
	background-position: right bottom;
	background-repeat: no-repeat;
	background-attachment: fixed;
}
-->
</style>
</head>

<body >
<table width="100%" height="100%" border="0" cellpadding="4" cellspacing="0">
  <tr>
    <td valign="top"><!-- InstanceBeginEditable name="text" -->
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td class="FCcontent">　　<span class="spe">要弄懂这种错误修正算法的原理，首先要弄清值<img src="../../images/image_content/3/3_3124.gif" width="69" height="29" align="absmiddle"> 
            相比较的含义。我们知道a<sub>i</sub>与a<sub>j</sub>代表两类增广权向量，y则代表规范化的增广权向量，这在感知准则函数中已定义过。<img src="../../images/image_content/3/3_3125.gif" width="29" height="30" align="absmiddle">是a<sub>i</sub>向量与y向量的点积，<img src="../../images/image_content/3/3_3126.gif" width="28" height="30" align="absmiddle">是a<sub>j</sub>向量与y向量的点积。一般来说点积值比较大则表示这两个向量在方向上比较一致，换句话说向量间的夹角较小。如果某一类样本比较分散，但是能用若干个增广权向量表示，使同一类规范化增广样本向量能够做到与代表自己一类的增广权向量的点积的最大值比，与其它类增广权向量的点积值要大，就可以做到正确分类。因此这种算法就是要用错误提供的信息进行叠代修正。所以它对每类样本集进行具体划分，而希望能知道每类所需的增广权向量数目。当然，实际上，该数目也可以在计算过程中按分类效果调整。<br>
            　　当每类的子类数目已知时，可以采用假设初始权向量，然后由样本提供的错误率信息进行迭代修正，直至收敛。该算法的基本要点是：<br>
            </span></td>
        </tr>
        <tr>
          <td align="center"><img src="../../images/image_content/3/3_3127.gif" width="400" height="418"><br>
            <img src="../../images/image_content/3/3_3128.gif" width="308" height="358"> 
          </td>
        </tr>
        <tr>
          <td class="FCcontent">　　对每个类别的子类赋予一初始增广权向量<img src="../../images/image_content/3/3_3129.gif" width="193" height="33" align="absmiddle">，其中括号中的数目表示迭代次数。然后对每次迭代所得增广权向量用样本去检测，如发生错误分类，则利用错误分类的信息进行修正。其做法是：<br>
            　　先将某一j类的增广样本向量y<sub>j</sub>，与该类所有增广权向量<img src="../../images/image_content/3/3_3130.gif" width="44" height="28" align="absmiddle">求内积<img src="../../images/image_content/3/3_3131.gif" width="67" height="38" align="absmiddle">，找到其中的最大值<img src="../../images/image_content/3/3_3132.gif" width="82" height="38" align="middle"><br>
            　　<img src="../../images/image_content/3/3_3133.gif" width="194" height="42" align="absmiddle">　　　　　(3-53)<br>
            　　另一方面将该y<sub>j</sub>与其它类(如i类)的权向量<img src="../../images/image_content/3/3_3134.gif" width="213" height="33" align="absmiddle">求内积，并将这些内积值与<img src="../../images/image_content/3/3_3135.gif" width="68" height="31" align="absmiddle">作比较，若<br>
            　　<img src="../../images/image_content/3/3_3136.gif" width="350" height="40" align="absmiddle">　　(3-54)<br>
            　　则表明权向量组<img src="../../images/image_content/3/3_3137.gif" width="232" height="26" align="absmiddle">，不影响y<sub>i</sub>的正确分类，因此由y<sub>i</sub>所提供的信息表明这些权向量都不再需要修改。但是如果存在某个或几个子类不满足上述条件，譬如某个子类<img src="../../images/image_content/3/3_3138.gif" width="24" height="23" align="absmiddle">的现有权向量<img src="../../images/image_content/3/3_3139.gif" width="47" height="29" align="absmiddle">使得<br>
            　　<img src="../../images/image_content/3/3_3140.gif" width="189" height="38" align="absmiddle">　　　　　(3-55)<br>
            　　这表明y<sub>j</sub>将错分类，而有关权向量需要修正。此时首先找到导致y<sub>j</sub>错分类的所有权向量中具有与y<sub>j</sub>内积最大值的权向量<img src="../../images/image_content/3/3_3141.gif" width="64" height="33" align="absmiddle"> 
            <br>
            　　<img src="../../images/image_content/3/3_3142.gif" width="198" height="42" align="absmiddle">　　　　　(3-56)<br>
            　　接着对<img src="../../images/image_content/3/3_3143.gif" width="124" height="34" align="absmiddle">作相应修正<br>
            　　<img src="../../images/image_content/3/3_3144.gif" width="186" height="65" align="absmiddle"><br>
            　　然后利用权向量的新值重复以上过程，直到收敛或迫使其收敛。这种算法在样本确实能被分段线性判别函数正确划分的条件下是收敛的。但当该条件不满足时，则需逐步减小ρ<sub>k</sub>的数值，迫使其“收敛”，显然会有相应的错误率存在。<br></td>
        </tr>
      </table>
      <!-- InstanceEndEditable --></td>
  </tr>
</table>
</body>
<!-- InstanceEnd --></html>
