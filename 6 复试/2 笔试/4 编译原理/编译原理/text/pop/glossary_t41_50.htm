<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=GB2312">
<title>词法分析</title>
<link rel="stylesheet" href="../../css/text.css" type="text/css">
<STYLE TYPE="text/css">
<!--
BODY {background-image:     url(../../img/pop/bg_center.gif);
background-repeat: no-repeat;
background-attachment: fixed;
}
-->
</STYLE>
</head>
<body bgcolor="#FFFFFF">
<table width="100%" border="0" cellspacing="0" cellpadding="0" class=text>
  <tr>
    <td><b>　<br>
      41．必经结点（dominators）和必经结点集（dominators set）</b><br>
      　　在程序流图中，对任意两个结点m和n，如果从流图的首结点出发，到达n的任一通路都要经过m，则称m是n的必经结点，记为m DOM n。流图中结点ｎ的所有必经结点的集合，称为结点n的必经结点集，记为D（n）。<br>
      <b><br>
      42．回边（back edge）<br>
      </b> 　　假设a→b是流图中的一条有向边，如果b DOM a，则称a→b是流图中的一条回边。<br>
      <b><br>
      43．T型图（T diagram）</b> <br>
      　　一个编译程序涉及到三个方面的语言，即源语言、目标语言和编译程序的书写语言。为了描述方便通常用T型图来表示一个编译程序所涉及到的这三个方面的语言。T型图的左上角表示源语言，右上角表示目标语言，底部表示书写语言(实现语言)。 
      <b><br>
      <br>
      44．自展（bootstrap）</b><br>
      　　自展的思想是先用目标机的汇编语言或机器语言书写源语言的一个子集的编译程序，然后再用这个子集作为书写语言，实现源语言的编译程序，如果把这个过程根据情况分成若干步，像滚雪球一样直到生成预计源语言的编译程序为止，我们把这样的实现方式称为自展技术。 
      <b><br>
      <br>
      45．Token</b> <br>
      　　具有集合意义的字符序列.是词法分析的输出<b>. Token </b>一般分为标识符,常数(常量),关键字,运算符及界符.<br>
      <b><br>
      46．交叉编译（Cross compile）</b> <br>
      　　所谓交叉编译是指把一个源语言在一个机器(称为宿主机)上编译产生另一个机器(称为目标机)的汇编语言或机器语言。<br>
      <b><br>
      47.前端（Front－end）和后端（Back end）<br>
      </b> 　　有时，常常把编译的过程分为前端(front end)和后端(back end)，前端由那样一些阶段组成：这些阶段的工作主要依赖于源语言而与目标机无关。通常这些阶段包括词法分析、语法分析、语义分析和中间代码生成，某些优化工作也可在前端做，也包括与前端每个阶段相关的出错处理工作和符号表管理工作。 
      后端工作指那些依赖于目标机而一般不依赖源语言，只与中间代码有关的那些阶段，即目标代码生成，以及相关出错处理和符号表操作。 <br>
      <b><br>
      48</b><b>．</b><b>LR(0)</b><b>项目和</b><b>LR(0)项目集规范族(</b><b>LR(0)items and 
      canonical collection of sets of LR(0) items)</b> <br>
      　　文法G的产生式的右部适当位置添加有一个圆点则称为一个<b>LR(0)</b>项目。<b></b> 构成识别一个文法活前缀的DFA项目集(状态)的全体称为这个文法的LR(0)项目集规范族。<br>
      <b><br>
      49</b><b>．四元式</b><b>(quadruples)</b> <br>
      　　四元式是一种中间代码的形式,是一个有四个域的纪录结构: 四个域分别称为 op,arg1,arg2 和 result 即操作符,运算对象1, 
      运算对象2 和运算结果.一个例子:( + ,a, b, c) <b><br>
      <br>
      50．传值（Call－by－value）和传地址（Call－by－reference）<br>
      </b> 　　是调用过程向被调用过程参数传递的两种方法. <br>
      　　传值也称值调用，即将实参计算处它的值，然后把它传给被调过程。具体如下：<br>
      　　①形式参数当作过程的局部变量处理，即在被调过程的活动记录中开辟了形参的存储空间，这些存储位置即是我们所说的实参或形式单元。<br>
      　　②调用过程计算实参的值，并将它们的右值（r－value）放在为形式单元开辟的空间中。<br>
      　　③被调用过程执行时，就像使用局部变量一样使用这些形式单元。<br>
      　　传值或值调用的重要特点是对形式参数的任何运算不影响调用过程的活动记录中实参的值。<br>
      　　当参数通过引用传递时，也称作传地址，或引用调用。调用过程传给被调过程的是指针，指向实参存储位置的指针。<br>
      　　①如实参是一个名字或是具有左值的表达式，则左值本身传递过去。 <br>
      　</td>
  </tr>
</table>
</body></html>