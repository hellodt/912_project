#[toc]
# intro
# icpc
## 赛事介绍

### ICPC

 **ICPC** （International Collegiate Programming Contest, 国际大学生程序设计竞赛）由 ICPC 基金会（ICPC Foundation）举办，是最具影响力的大学生计算机竞赛。ICPC 主要分为区域赛（Regionals）和总决赛（World Finals）两部分。由于以前 ACM 赞助这个竞赛，也有很多人习惯叫它 ACM 竞赛。

 <https://icpc.baylor.edu/> 

### CCPC

中国大学生程序设计竞赛，和 ICPC 显著的区别是很多学校是不报销的。

 <https://ccpc.io/> 

## 赛季赛程

-   ICPC/CCPC 网络赛（8 月底至 9 月初）
-   ICPC/CCPC 区域赛（9 月底至 11 月底）
-   ICPC EC Final/CCPC Final（12 月中旬）
-   ICPC World Finals（次年 4 月至 6 月）

## 训练指南

### 多校联合训练

暑期在 [HDU OJ](http://acm.hdu.edu.cn) 举行的训练赛，有奖金，题目质量高，历经多年积累已有丰富资源。

OJ 里查询用的关键词： `Multi-University Training Contest` 

### 国内区域赛

 <https://vjudge.net/> 

善用搜索，可以找到前辈精选的题集

### 训练营

寒假的时候头条/清华/CCPC(Wannafly Camp) 都办 Camp

Wannafly Camp

### 队伍维基

-   叉姐的 ICPCCamp Wiki <https://icpc.camp/> 

## 训练资源

-    **OI Wiki <https://oi-wiki.org> ** 
-   Codeforces Gym <https://codeforces.com/gyms> 

# latex
## 介绍

### 什么是 LaTeX

LaTeX（读作/ˈlɑːtɛx/或/ˈleɪtɛx/）是一个让你的文档看起来更专业的排版系统，而不是文字处理器。它尤其适合处理篇幅较长、结构严谨的文档，并且十分擅长处理公式表达。它是免费的软件，对大多数操作系统都适用。

LaTeX 基于 TeX（Donald Knuth 在 1978 年为数字化排版设计的排版系统）。TeX 是一种电脑能够处理的低级语言，但大多数人发现它很难使用。LaTeX 正是为了让它变得更加易用而设计的。目前 LaTeX 的版本是 LaTeX 2e。

如果你习惯于使用微软的 Office Word 处理文档，那么你会觉得 LaTeX 的工作方式让你很不习惯。Word 是典型的“所见即所得”的编辑器，你可以在编排文档的时侯查看到最终的排版效果。但使用 LaTeX 时你并不能方便地查看最终效果，这使得你专注于内容而不是外观的调整。

一个 LaTeX 文档是一个以 `.tex` 结尾的文本文件，可以使用任意的文本编辑器编辑，比如 Notepad，但对于大多数人而言，使用一个合适的 LaTeX 编辑器会使得编辑的过程容易很多。在编辑的过程中你可以标记文档的结构。完成后你可以进行编译——这意味着将它转化为另一种格式的文档。它支持多种格式，但最常用的是 PDF 文档格式。

### 在开始之前

下面列出在本文中使用到的记号：

-   希望你实施的操作会被打上一个箭头 $\rightarrow$ ；
-   你输入的字符会被装进代码块中；
-   菜单命令与按扭的名称会被标记为 **粗体** 。

尽管本书中的代码应该可以在任何的 LaTeX 编辑器中运行，在一些指定的示例和截图中，我们使用的环境是 TeXworks 0.4.5, Windows 7。

### Linux 环境配置

在此简单说明一下 Linux 环境下的 LaTeX 编译配置。首先，根据需要选择 TeX Live 包进行安装。该软件包含了 `pdflatex` ， `xelatex` 等命令。下文中的编译相当于使用这些命令编译。

## 文档结构

### 基本要素

 $\rightarrow$ 打开 TeXworks。

一个新的文档会被自动打开。

 $\rightarrow$ 进入 **Format** 菜单，选择 **Line Numbers** 。

行号并不是要素，但它可以帮助你比较代码与屏幕信息，找到错误。

 $\rightarrow$ 进入 **Format** 菜单，选择 **Syntax Coloring** ，然后选择 **LaTeX** 。

语法色彩会高亮代码，使得代码更加易读。

 $\rightarrow$ 输入以下文字：

```tex
\documentclass[a4paper,12pt]{article}

\begin{document}

A sentence of text.

\end{document}
```

 `\documentclass` 命令必须出现在每个 LaTeX 文档的开头。花括号内的文本指定了文档的类型。 **article** 文档类型适合较短的文章，比如期刊文章和短篇报告。其他文档类型包括 **report** （适用于更长的多章节的文档，比如博士生论文）， **proc** （会议论文集）， **book** 和 **beamer** 。方括号内的文本指定了一些选项——示例中它设置纸张大小为 A4，主要文字大小为 12pt。

 `\begin{document}` 和 `\end{document}` 命令将你的文本内容包裹起来。任何在 `\begin{documnet}` 之前的文本都被视为前导命令，会影响整个文档。任何在 `\end{document}` 之后的文本都会被忽视。

空行不是必要的，但它可以让长的文档更易读。

 $\rightarrow$ 按下 **Save** 按扭； $\rightarrow$ 在 **Libraries>Documents** 中新建一个名为 **LaTeX course** 文件夹； $\rightarrow$ 将你的文档命名为 **Doc1** 并将其保存为 **TeX document** 放在这个文件夹中。

将不同的 LaTeX 文档放在不同的目录下，在编译的时侯组合多个文件是一个很好的想法。

 $\rightarrow$ 确保 typeset 菜单设置为了 **xeLaTeX** 。 $\rightarrow$ 点击 **Typeset** 按扭。

这时你的源文件会被转换为 PDF 文档，这需要花费一定的时间。在编译结束后，TeXworks 的 PDF 查看器会打开并预览生成的文件。PDF 文件会被自动地保存在与 TeX 文档相同的目录下。

### 处理问题

如果在你的文档中存在错误，TeXworks 无法创建 PDF 文档时， **Typeset** 按扭会变成一个红叉，并且底部的终端输出会保持展开。这时：

 $\rightarrow$ 点击 **Abort typesetting** 按扭。 $\rightarrow$ 阅读终端输出的内容，最后一行可能会给出行号表示出现错误的位置。 $\rightarrow$ 找到文档中对应的行并修复错误。 $\rightarrow$ 再次点击 **Typeset** 按扭尝试编译源文件。

### 添加文档标题

 `\maketitle` 命令可以给文档创建标题。你需要指定文档的标题。如果没有指定日期，就会使用现在的时间，作者是可选的。

 $\rightarrow$ 在 `\begin{document}` 和 命令后紧跟着输入以下文本：

```tex
\title{My First Document}
\author{My Name}
\date{\today}
\maketitle
```

你的文档现在长成了这样：

```tex
\documentclass[a4paper,12pt]{article}

\begin{document}

\title{My First Document}
\author{My Name}
\date{\today}
\maketitle

A sentence of text.

\end{document}
```

 $\rightarrow$ 点击 **Typeset** 按扭，核对生成的 PDF 文档。

要点笔记：

-    `\today` 是插入当前时间的命令。你也可以输入一个不同的时间，比如 `\data{November 2013}` 。
-    **article** 文档的正文会紧跟着标题之后在同一页上排版。 **report** 会将标题置为单独的一页。

### 章节

如果需要的话，你可能想将你的文档分为章（Chatpers）、节（Sections）和小节（Subsections）。下列分节命令适用于 **article** 类型的文档：

-    `\section{...}` 
-    `\subsection{...}` 
-    `\subsubsection{...}` 
-    `\paragraph{...}` 
-    `\subparagraph{...}` 

花括号内的文本表示章节的标题。对于 **report** 和 **book** 类型的文档我们还支持 `\chapter{...}` 的命令。

 $\rightarrow$ 将 "A sentence of text." 替换为以下文本：

```tex
\section{Introduction}
This is the introduction.

\section{Methods}

\subsection{Stage 1}
The first part of the methods.

\subsection{Stage 2}
The second part of the methods.

\section{Results}
Here are my results.
```

你的文档会变成

```tex
\documentclass[a4paper,12pt]{article}

\begin{document}

\title{My First Document}
\author{My Name}
\date{\today}
\maketitle

\section{Introduction}
This is the introduction.

\section{Methods}

\subsection{Stage 1}
The first part of the methods.

\subsection{Stage 2}
The second part of the methods.

\section{Results}
Here are my results.

\end{document}
```

 $\rightarrow$ 点击 **Typeset** 按扭，核对 PDF 文档。应该是长这样的：

![p1](images/latex-for-beginners-1.png)

### 创建标签

你可以对任意章节命令创建标签，这样他们可以在文档的其他部分被引用。使用 `\label{labelname}` 对章节创建标签。然后输入 `\ref{labelname}` 或者 `\pageref{labelname}` 来引用对应的章节。

 $\rightarrow$ 在 `\subsection{Stage 1}` 下面另起一行，输入 `\label{sec1}` 。 $\rightarrow$ 在 **Results** 章节输入 `Referring to section \ref{sec1} on page \pageref{sec1}` 。

你的文档会变成这样：

```tex
\documentclass[a4paper,12pt]{article}

\begin{document}

\title{My First Document}
\author{My Name}
\date{\today}
\maketitle

\section{Introduction}
This is the introduction.

\section{Methods}

\subsection{Stage 1}
\label{sec1}
The first part of the methods.

\subsection{Stage 2}
The second part of the methods.

\section{Results}
Here are my results. Referring to section \ref{sec1} on page \pageref{sec1}

\end{document}
```

 $\rightarrow$ 编译并检查 PDF 文档（你可能需要连续编译两次）：

![p2](images/latex-for-beginners-2.png)

### 生成目录（TOC）

如果你使用分节命令，那么可以容易地生成一个目录。使用 `\tableofcontents` 在文档中创建目录。通常我们会在标题的后面建立目录。

你可能也想也想更改页码为罗马数字（i,ii,iii）。这会确保文档的正文从第 1 页开始。页码可以使用 `\pagenumbering{...}` 在阿拉伯数字和罗马数字见切换。

 $\rightarrow$ 在 `\maketitle` 之后输入以下内容：

```tex
\pagenumbering{roman}
\tableofcontents
\newpage
\pagenumbering{arabic}
```

 `\newpage` 命令会另起一个页面，这样我们就可以看到 `\pagenumbering` 命令带来的影响了。你的文档的前 14 行长这样：

```tex
\documentclass[a4paper,12pt]{article}

\begin{document}

\title{My First Document}
\author{My Name}
\date{\today}
\maketitle

\pagenumbering{roman}
\tableofcontents
\newpage
\pagenumbering{arabic}
```

 $\rightarrow$ 编译并核对文档（可能需要多次编译，下文不赘述）。

文档的第一页长这样：

![p3](images/latex-for-beginners-3.png)

第二页：

![p4](images/latex-for-beginners-4.png)

## 文字处理

### 中文字体支持

阅读本文学习 LaTeX 的人，首要学会的自然是 LaTeX 的中文字体支持。事实上，让 LaTeX 支持中文字体有许多方法。在此我们仅给出最 **简洁** 的解决方案：使用 CTeX 宏包。只需要在文档的前导命令部分添加：

```tex
\usepackage[UTF8]{ctex}
```

就可以了。在编译文档的时侯使用 `xelatex` 命令，因为它是支持中文字体的。

### 字体效果

LaTeX 有多种不同的字体效果，在此列举一部分：

```tex
\textit{words in italics}
\textsl{words slanted}
\textsc{words in smallcaps}
\textbf{words in bold}
\texttt{words in teletype}
\textsf{sans serif words}
\textrm{roman words}
\underline{underlined words}
```

效果如下：

![p5](images/latex-for-beginners-5.png)

 $\rightarrow$ 在你的文档中添加更多的文本并尝试各种字体效果。

### 彩色字体

为了让你的文档支持彩色字体，你需要使用包（package）。你可以引用很多包来增强 LaTeX 的排版效果。包引用的命令放置在文档的前导命令的位置（即放在 `\begin{document}` 命令之前）。使用 `\usepackage[options]{package}` 来引用包。其中 **package** 是包的名称，而 **options** 是指定包的特征的一些参数。

使用 `\usepackage{color}` 后，我们可以调用常见的颜色：

![p6](images/latex-for-beginners-6.png)

使用彩色字体的代码为

```tex
{\color{colorname}text}
```

其中 **colorname** 是你想要的颜色的名字， **text** 是你的彩色文本内容。注意到示例效果中的黄色与白色是有文字背景色的，这个我们同样可以使用 Color 包中的 `\colorbox` 命令来达到。用法如下：

```tex
\colorbox{colorname}{text}
```

 $\rightarrow$ 在 `\begin{document}` 前输入 `\usepackage{color}` 。 $\rightarrow$ 在文档内容中输入 `{\color{red}fire}` 。 $\rightarrow$ 编译并核对 PDF 文档内容。

单词 fire 应该是红色的。

你也可以添加一些参数来调用更多的颜色，甚至自定义你需要的颜色。但这部分超出了本书的内容。如果想要获取更多关于彩色文本的内容请阅读 LaTeX Wikibook 的 [Colors 章节](http://en.wikibooks.org/wiki/LaTeX/Colors) 。

### 字体大小

接下来我们列举一些 LaTeX 的字体大小设定命令：

```tex
normal size words
{\tiny tiny words}
{\scriptsize scriptsize words}
{\footnotesize footnotesize words}
{\small small words}
{\large large words}
{\Large Large words}
{\LARGE LARGE words}
{\huge huge words}
```

效果如下：

![p7](images/latex-for-beginners-7.png)

 $\rightarrow$ 尝试为你的文本调整字体大小。

### 段落缩进

LaTeX 默认每个章节第一段首行顶格，之后的段落首行缩进。如果想要段落顶格，在要顶格的段落前加 `\noindent` 命令即可。如果希望全局所有段落都顶格，在文档的某一位置使用 `\setlength{\parindent}{0pt}` 命令，之后的所有段落都会顶格。

### 列表

LaTeX 支持两种类型的列表：有序列表（enumerate）和无序列表（itemize）。列表中的元素定义为 `\item` 。列表可以有子列表。

 $\rightarrow$ 输入下面的内容来生成一个有序列表套无序列表：

```tex
\begin{enumerate}
\item First thing
\item Second thing
\begin{itemize}
\item A sub-thing
\item Another sub-thing
\end{itemize}
\item Third thing
\end{enumerate}
```

 $\rightarrow$ 编译并核对 PDF 文档。

列表长这样：

![p8](images/latex-for-beginners-8.png)

可以使用方括号参数来修改无序列表头的标志。例如， `\item[-]` 会使用一个杠作为标志，你甚至可以使用一个单词，比如 `\item[One]` 。

下面的代码：

```tex
\begin{itemize}
\item[-] First thing
\item[+] Second thing
\begin{itemize}
\item[Fish] A sub-thing
\item[Plants] Another sub-thing
\end{itemize}
\item[Q] Third thing
\end{itemize}
```

生成的效果为

![p9](images/latex-for-beginners-9.png)

### 注释和空格

我们使用 % 创建一个单行注释，在这个字符之后的该行上的内容都会被忽略，直到下一行开始。

下面的代码：

```tex
It is a truth universally acknowledged% Note comic irony
in the very first sentence
, that a single man in possession of a good fortune, must
be in want of a wife.
```

生成的结果为

![p10](images/latex-for-beginners-10.png)

多个连续空格在 LaTeX 中被视为一个空格。多个连续空行被视为一个空行。空行的主要功能是开始一个新的段落。通常来说，LaTeX 忽略空行和其他空白字符，两个反斜杠（ `\\` ）可以被用来换行。

 $\rightarrow$ 尝试在你的文档中添加注释和空行。

如果你想要在你的文档中添加空格，你可以使用 `\vaspace{...}` 的命令。这样可以添加竖着的空格，高度可以指定。如 `\vspace{12pt}` 会产生一个空格，高度等于 12pt 的文字的高度。

### 特殊字符

下列字符在 LaTeX 中属于特殊字符：

```text
# $ % ^ & _ { } ~ \
```

为了使用这些字符，我们需要在他们前面添加反斜杠进行转义：

```tex
\# \$ \% \^{} \& \_ \{ \} \~{}
```

注意在使用 `^` 和 `~` 字符的时侯需要在后面紧跟一对闭合的花括号，否则他们就会被解释为字母的上标，就像 `\^ e` 会变成 $\mathrm {\hat{e}}$ 。上面的代码生成的效果如下：

![p11](images/latex-for-beginners-11.png)

注意，反斜杠不能通过反斜杠转义（不然就变成了换行了），使用 `\textbackslash` 命令代替。

 $\rightarrow$ 输入代码来在你的文档中生成下面内容：

![p12](images/latex-for-beginners-12.png)

询问专家或者查看本书的 TeX 源代码获取帮助。

## 表格

表格（tabular）命令用于排版表格。LaTeX 默认表格是没有横向和竖向的分割线的——如果你需要，你得手动设定。LaTeX 会根据内容自动设置表格的宽度。下面的代码可以创一个表格：

```tex
\begin{tabular}{...}
```

省略号会由定义表格的列的代码替换：

-    `l` 表示一个左对齐的列；
-    `r` 表示一个右对齐的列；
-    `c` 表示一个向中对齐的列；
-    `|` 表示一个列的竖线；

例如， `{lll}` 会生成一个三列的表格，并且保存向左对齐，没有显式的竖线； `{|l|l|r|}` 会生成一个三列表格，前两列左对齐，最后一列右对齐，并且相邻两列之间有显式的竖线。

表格的数据在 `\begin{tabular}` 后输入：

-    `&` 用于分割列；
-    `\\` 用于换行；
-    `\hline` 表示插入一个贯穿所有列的横着的分割线；
-    `\cline{1-2}` 会在第一列和第二列插入一个横着的分割线。

最后使用 `\end{tabular}` 结束表格。举一些例子：

```tex
\begin{tabular}{|l|l|}
Apples & Green \\
Strawberries & Red \\
Orange & Orange\\
\end{tabular}

\begin{tabular}{rc}
Apples & Green\\
\hline 
Strawberries & Red \\
\cline{1-1}
Oranges & Orange \\
\end{tabular}

\begin{tabular}{|r|l|}
\hline
8 & here's \\
\cline{2-2}
86 & stuff\\
\hline \hline 
2008 & now \\
\hline 
\end{tabular}
```

效果如下：

![p13](images/latex-for-beginners-13.png)

### 实践

尝试画出下列表格：

![p14](images/latex-for-beginners-14.png)

## 图表

本章介绍如何在 LaTeX 文档中插入图表。这里我们需要引入 **graphicx** 包。图片应当是 PDF，PNG，JPEG 或者 GIF 文件。下面的代码会插入一个名为 myimage 的图片：

```tex
\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{myimage}
\caption{Here is my image}
\label{image-myimage}
\end{figure}
```

 `[h]` 是位置参数， **h** 表示把图表近似地放置在这里（如果能放得下）。有其他的选项： **t** 表示放在在页面顶端； **b** 表示放在在页面的底端； **p** 表示另起一页放置图表。你也可以添加一个 **!** 参数来强制放在参数指定的位置（尽管这样排版的效果可能不太好）。

 `\centering` 将图片放置在页面的中央。如果没有该命令会默认左对齐。使用它的效果是很好的，因为图表的标题也是居中对齐的。

 `\includegraphics{...}` 命令可以自动将图放置到你的文档中，图片文件应当与 TeX 文件放在同一目录下。

 `[width=1\textwidth]` 是一个可选的参数，它指定图片的宽度——与文本的宽度相同。宽度也可以以厘米为单位。你也可以使用 `[scale=0.5]` 将图片按比例缩小（示例相当于缩小一半）。

 `\caption{...}` 定义了图表的标题。如果使用了它，LaTeX 会给你的图表添加“Figure”开头的序号。你可以使用 `\listoffigures` 来生成一个图表的目录。

 `\label{...}` 创建了一个可以供你引用的标签。

### 实践

 $\rightarrow$ 在你文档的前导命令中添加 `\usepackage{graphicx}` 。 $\rightarrow$ 找到一张图片，放置在你的 **LaTeX course** 文件夹下。 $\rightarrow$ 在你想要添加图片的地方输入以下内容：

```tex
\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{ImageFilename}
\caption{My test image}
\end{figure}
```

将 **ImageFilename** 替换为你的文件的名字（不包括后缀）。如果你的文件名有空格，就使用双引号包裹，比如 `"screen 20"` 。

 $\rightarrow$ 编译并核对文件。

## 公式

使用 LaTeX 的主要原因之一是它可以方便地排版公式。我们使用数学模式来排版公式。

### 插入公式

你可以使用一对 `$` 来启用数学模式，这可以用于撰写行内数学公式。例如 `$1+2=3$` 的生成效果是 $1+2=3$ 。

如果你想要行间的公式，可以使用 `$$...$$` （现在我们推荐使用 `\[...\]` ，因为前者可能产生不良间距）。例如， `$$1+2=3$$` 的生产效果为

$$
1+2=3
$$

如果是生成带标号的公式，可以使用 `\begin{equation}...\end{equation}` 。例如 `\begin{equation}1+2=3\end{equation}` 生成的效果为：

$$
\begin{equation}1+2=3\end{equation}
$$

数字 6 代表的是章节的编号，仅当你的文档有设置章节时才会出现，比如 **report** 类型的文档。

使用 `\begin{eqnarray}...\end{eqnarray}` 来撰写一组带标号的公式。例如：

```tex
\begin{eqnarray}
a & = & b + c \\
  & = & y - z
\end{eqnarray}
```

生成的效果为

$$
\begin{eqnarray}
a & = & b + c \\
  & = & y - z
\end{eqnarray}
$$

要撰写不标号的公式就在环境标志的后面添加 `*` 字符，如 `{equation*}` ， `{eqnarray*}` 。

### 数学符号

尽管一些基础的符号可以直接键入，但大多数特殊符号需要使用命令来显示。

本书只是数学符号使用的入门教程，LaTeX Wikibook 的数学符号章节是另一个更好更完整的教程。如果想要了解更多关于数学符号的内容请移步。如果你想找到一个特定的符号，可以使用 [Detexfiy](http://detexify.kirelabs.org) ，它可以识别手写字符。

#### 上标和下标

上标（Powers）使用 `^` 来表示，比如 `$n^2$` 生成的效果为 $n^2$ 。

下标（Indices）使用 `_` 表示，比如 `$2_a$` 生成的效果为 $2_a$ 。

如果上标或下标的内容包含多个字符，请使用花括号包裹起来。比如 `$b_{a-2}$` 的效果为 $b_{a-2}$ 。

#### 分数

分数使用 `\frac{numerator}{denominator}` 命令插入。比如 `$$\frac{a}{3}$$` 的生成效果为

$$
\frac{a}{3}
$$

分数可以嵌套。比如 `$$\frac{y}{\frac{3}{x}+b}$$` 的生成效果为

$$
\frac{y}{\frac{3}{x}+b}
$$

#### 根号

我们使用 `\sqrt{...}` 命令插入根号。省略号的内容由被开根的内容替代。如果需要添加开根的次数，使用方括号括起来即可。

例如 `$$\sqrt{y^2}$$` 的生成效果为

$$
\sqrt{y^2}
$$

而 `$$\sqrt[x]{y^2}$$` 的生成效果为

$$
\sqrt[x]{y^2}
$$

#### 求和与积分

使用 `\sum` 和 `\int` 来插入求和式与积分式。对于两种符号，上限使用 `^` 来表示，而下限使用 `_` 表示。

 `$$\sum_{x=1}^5 y^z$$` 的生成效果为

$$
\sum_{x=1}^5y^z
$$

而 `$$\int_a^b f(x)$$` 的生成效果为

$$
\int_a^b f(x)
$$

#### 希腊字母

我们可以使用反斜杠加希腊字母的名称来表示一个希腊字母。名称的首字母的大小写决定希腊字母的形态。例如

-    `$\alpha$` = $\alpha$ 
-    `$\beta$` = $\beta$ 
-    `$\delta, \Delta$` = $\delta, \Delta$ 
-    `$\pi, \Pi$` = $\pi, \Pi$ 
-    `$\sigma, \Sigma$` = $\sigma, \Sigma$ 
-    `$\phi, \Phi, \varphi$` = $\phi, \Phi, \varphi$ 
-    `$\psi, \Psi$` = $\psi, \Psi$ 
-    `$\omega, \Omega$` = $\omega, \Omega$ 

### 实践

 $\rightarrow$ 撰写代码来生成下列公式：

![p15](images/latex-for-beginners-15.png)

如果需要帮助，可以查看本书的 TeX 源码。

## 参考文献

### 介绍

LaTeX 可以轻松插入参考文献以及目录。本文会介绍如何使用另一个 BibTeX 文件来存储参考文献。

### BibTeX 文件类型

BibTeX 文件包含了所有你想要在你文档中引用的文献。它的文件后缀名为 `.bib` 。它的名字应设置为你的 TeX 文档的名字。 `.bib` 文件是文本文件。你需要将你的参考文献按照下列格式输入：

```text
@article{
    Birdetal2001,
    Author = {Bird, R. B. and Smith, E. A. and Bird, D. W.},
    Title = {The hunting handicap: costly signaling in human foraging strategies},
    Journal = {Behavioral Ecology and Sociobiology},
    Volume = {50},
    Pages = {9-19},
    Year = {2001} 
}
```

每一个参考文献先声名它的文献类型（reference type）。示例中使用的是 @article，其他的类型包括 @book，@incollection 用于引用一本书的中的章节，@inproceedings 用于引用会议论文。可以 [在此](http://en.wikibooks.org/wiki/LaTeX/Bibliography_Management) 查看更多支持的类型。

接下来的花括号内首先要列出一个引用键值（citation key）。必须保证你引用的文献的引用键值是不同的。你可以自定义键值串，不过使用第一作者名字加上年分会是一个表义清晰的选择。

接下来的若干行包括文献的若干信息，格式如下：

```text
Field name = {field contents},
```

你可以使用 LaTeX 命令来生成特殊的文字效果。比如意大利斜体可以使用 `\emph{Rattus norvegicus}` 。

对于需要大写的字母，请用花括号包裹起来。BibTeX 会自动把标题中除第一个字母外所有大写字母替换为小写。比如 `Dispersal in the contemporary United States` 的生成效果为 $\text{Dispersal in the contemporary united states}$ ，而 `Dispersal in the contemporary {U}nited {S}tates` 的生成效果为 $\text{Dispersal in the contemporary United States}$ 。

你可以手写 BibTeX 文件，也可以使用软件来生成。

### 插入文献列表

使用下列命令在文档当前位置插入文献列表：

```tex
\bibliographystyle{plain}
\biblirgraphy{references}
```

参考文献写在 `references.bib` 里。

### 参考文献标注

使用 `\cite{citationkey}` 来在你想要引用文献的地方插入一个标注。如果你不希望在正文中插入一个引用标注，但仍想要在文献列表中显示这次引用，使用 `\nocite{citationkey}` 命令。

想要在引用中插入页码信息，使用方括号： `\cite[p. 215]{citationkay}` 。

要引用多个文献，使用逗号分隔： `\cite{citation01,citation02,citation03}` 。

### 引用格式

#### 数字标号引用

LaTeX 包含了多种行内数字标号引用的格式：

 **Plain** 方括号包裹数字的形式，如 $[1]$ 。文献列表按照第一作者的字母表顺序排列。每一个作者的名字是全称。

 **Abbrv** 与 **plain** 是相同的，但作者的名字是缩写。

 **Unsrt** 与 **plain** 是相同的，但文献列表的排序按照在文中引用的先后顺序排列。

 **Alpha** 与 **plain** 一样，但引用的标注是作者的名字与年份组合在一起，不是数字，如 $[Kop10]$ 。

#### 作者日期引用

如果你想使用作者日期的引用，使用 **natbib** 包。它使用 `\citep{...}` 命令来生成一个方括号标注，如 $[Koppe,2010]$ ，使用 `\citet{...}` 来生成一个标注，只把年份放到方括号里，如 $Koppe [2010]$ 。 [在此](http://mirror.ctan.org/macros/latex/contrib/natbib/natnotes.pdf) 查看它的更多用法。

Natbib 包也有三种格式： **plainnat** ， **abbrvnat** 和 **unsrtnat** ，他们与 **plain** ， **abbrv** 和 **unsrt** 的效果是一样的。

#### 其他引用格式

如果你需要使用不同的格式，你需要在同一个文件夹下创建一个格式文件（ `.bst` 文件），引用这个格式的时侯使用它的文件名调用 `\bibliographystyle{...}` 命令实现。

### 实践

 $\rightarrow$ 在同一文件夹下新建一个同名的 BibTeX 文件，用正确的格式输入参考文献的信息。 $\rightarrow$ 切换到 TeX 文档，并使用 `\cite` ， `\bibliographystyle` 和 `\bibliograph` 命令来引用文献。 $\rightarrow$ 编译 TeX 文件。 $\rightarrow$ 切换到 BibTeX 文件，并编译（点击 **Typeset** 按扭） $\rightarrow$ 切换到 TeX 文件并编译它 **两次** ，然后核对 PDF 文档。

## 更多阅读

一份（不太）简短的 LATEX 2ε 介绍 <https://github.com/OI-wiki/libs/blob/master/latex/lshort-zh-cn.pdf> 或 110 分钟了解 LaTeX 2.

LaTeX Project <http://www.latex-project.org/> Official website - has links to documentation, information about installing LATEX on your own computer, and information about where to look for help.

LaTeX Wikibook <http://en.wikibooks.org/wiki/LaTeX/> Comprehensive and clearly written, although still a work in progress. A downloadable PDF is also available.

Comparison of TeX Editors on Wikipedia <http://en.wikipedia.org/wiki/Comparison_of_TeX_editors> Information to help you to choose which L A TEX editor to install on your own computer.

TeX Live <http://www.tug.org/texlive/> “An easy way to get up and running with the TeX document production system”。Available for Unix and Windows (links to MacTeX for MacOSX users). Includes the TeXworks editor.

Workbook Source Files <http://edin.ac/17EQPM1> Download the .tex file and other files needed to compile this workbook.

 **本文译自 <http://www.docs.is.ed.ac.uk/skills/documents/3722/3722-2014.pdf> ** ，依据其他文献略有修改。

# resources
author: Konano, Enter-tainer, JulieSigtuna, GldHkkowo

## 在线评测平台

在线评测平台（英语：Online Judging System，简称 OJ），一般用于刷题训练，参与和组织比赛，以及用户之间的交流分享。

### 国内

-    [51Nod](https://www.51nod.com/) 有许多值得尝试的数学题和思维题。
-    [BZOJ](https://www.lydsy.com/JudgeOnline/) 因原属衡阳八中而得简称，汇聚多种习题和真题，题目质量相对较高，但可能需要联系邮箱。  
    BZOJ 上有大量题目只有付费用户才能提交。2018 年 BZOJ 测试数据泄露，催生了 DarkBZOJ。
-    [Comet OJ](https://www.cometoj.com) 始于 2018 年，旨在为广大算法爱好者提供一个竞技、练习、交流的平台，经常举办原创性的高质量比赛，有丰富的题库。
    <!-- - [CodeVS](http://www.codevs.cn/) 面向 OI 选手的过气 OJ。 -->
-    [FZUOJ](http://acm.fzu.edu.cn/) 始于 2008 年，福州大学在线评测系统。
-    [HDU Online Judge](http://acm.hdu.edu.cn/) 始于 2005 年，杭州电子科技大学在线评测系统，有多校训练的题目。
-    [hihoCoder](https://hihocoder.com/) 始于 2012 年，面向企业招聘，有些题目来自于每周一题，涉及知识点的学习。（登录后方可查看题面）
-    [计蒜客](https://www.jisuanke.com/) 北京矩道优达网络科技有限公司旗下的核心产品，提供按知识点和难度筛选的信息学题库和 ICPC 题库。
-    [Judge Duck Online](https://duck.ac/) 基于 [松松松](https://github.com/wangyisong1996) 开发的开源项目 [JudgeDuck](https://github.com/JudgeDuck) ，可以将评测程序的运行时间精确到 $\mu s$ 。（题目较少）
    <!--  - [JoyOI](http://www.joyoi.cn/) 原 Tyvj， [项目开源](https://github.com/joyoi) 。-->
-    [LibreOJ](https://loj.ac/) 始于 2017 年。
    目前由 [Menci](https://github.com/Menci) 维护。
    Libre 取自由之意，基于开源项目 [SYZOJ](https://github.com/syzoj/syzoj) 。
    题目所有测试数据以及提交的代码均对所有用户开放。
-    [Lutece](https://acm.uestc.edu.cn/home) 始于 2018 年，电子科技大学在线评测系统， [项目开源](https://github.com/lutece-awesome) 。
-    [洛谷](https://www.luogu.org/) 始于 2013 年，社区群体庞大，OI 界的真题和习题较全，提供有偿教育服务。
-    [牛客网](https://www.nowcoder.com/) 始于 2014 年，提供技术类求职备考、社群交流、企业招聘等服务。
-    [NOJ](http://acm.njupt.edu.cn/) 始于 2018 年，南京邮电大学在线评测系统， [项目开源](https://github.com/ZsgsDesign/NOJ) ，自身拥有题目两千余，同时支持对多个国内外 OJ 的提交，可以直接在 NOJ 提交别的 OJ 的题。
-    [NTUOJ](http://acm.csie.ntu.edu.tw) 始于 2007 年，台湾大学在线评测系统，基于开源项目 [Judge Girl](http://judgegirl.github.io/) 。
-    [OpenJudge](http://openjudge.cn/) 始于 2005 年，由 POJ 团队开发的小组评测平台。
-    [POJ](http://poj.org/) 始于 2003 年，北京大学在线评测系统，国内历史最悠久的 OJ 之一，很多英文题，既有基础题，也有值得一试的好题。
-    [PTA（拼题 A）](https://pintia.cn/) 始于 2016 年，浙江大学衍生的杭州百腾教育科技有限公司产品。
-    [清澄](http://www.tsinsen.com/) 始于 2005 年，由 [胡伟栋](http://www.hhwdd.com/) 开发，自 2019 年 9 月 1 日起不再对外提供服务。
-    [Universal Online Judge](https://uoj.ac/) 始于 2014 年，Universal 取通用之意， [项目开源](https://github.com/UniversalOJ/UOJ-System) ； [VFK](https://github.com/vfleaking) 的 OJ，多原创比赛题和 CCF/THU 题，难度较高。
-    [Vijos](https://vijos.org/) 始于 2005 年， [服务端](https://github.com/vijos/vj4) 和 [评测机](https://github.com/vijos/jd4) 等项目开源。
-    [ZOJ](https://zoj.pintia.cn/home) 始于 2001 年，浙江大学在线评测系统。

### 国外

-    [AizuOJ](https://onlinejudge.u-aizu.ac.jp) 始于 2004 年，日本会津大学在线评测系统；包含日本若干高中和大学编程比赛的题目，自带编程/数据结构/算法的入门课程。
-    [AtCoder](https://atcoder.jp/) 日本 OJ，日文版里会有日本高校的比赛，英文内不会显示。（题目有趣，质量较高）
-    [CodeChef](https://codechef.com/) 印度 OJ，周期性有比赛；系统基于 SPOJ 的 Sphere Engine。
-    [Codeforces](https://codeforces.com/) 始于 2010 年，俄罗斯 OJ，创始人是 [Mike Mirzayanov](https://www.linkedin.com/in/mike-mirzayanov-31772a93/) ，有多种系列的比赛，你也可以出题并申请组织比赛。（题目质量较高）
-    [CS Academy](https://csacademy.com/) 
-    [DMOJ](https://dmoj.ca/) 加拿大开源的 OJ，语言支持广；题库是各大比赛的存档，也有定期自行举办的比赛。
-    [HackerRank](https://www.hackerrank.com/) 有很多比赛
-    [ICPC Live Archive](https://icpcarchive.ecs.baylor.edu/) 存档了 1990 年至今的 ICPC 区域赛和总决赛题目；但部分比赛的评测数据仅为样例数据，且对 Special Judge 的支持不完善。
-    [ICPC Problem Archive](https://judge.icpc.global) 基于 Kattis 系统；存档了 2012 年至今的 ICPC 全球总决赛题目，并且会在总决赛开赛时同步发放题目（但不会有同步赛）。
-    [Kattis](https://open.kattis.com/) 题库主要包含类似 ICPC 比赛的题目；根据用户解题情况评定用户等级，推荐适合该用户水平的 trivial/easy/medium/hard 四类难度的题目，其中题目难度采用类 ELO 等级分系统来评估。
-    [LeetCode](https://leetcode.com/) 码农面试刷题网站，有中文分站： [LeetCode China](https://leetcode-cn.com/) 。
-    [Light OJ](http://lightoj.com) 一个快挂了的 OJ， `www` 域名无法访问，请使用 [根域名](http://lightoj.com) 访问
-    [opentrains](http://opentrains.snarknews.info/) 俄罗斯 [Open Cup](http://opencup.ru/) 比赛的训练平台，基于 [ejudge](https://ejudge.ru/) 开源系统搭建，支持虚拟比赛；题库包含历年 Open Cup 赛题以及 Petrozavodsk 训练营的题目。
-    [SPOJ](http://www.spoj.com) 始于 2003 年，其后台系统 [Sphere Engine](https://sphere-engine.com/) 于 2008 年商业化；支持题目点赞和标签功能。
-    [TopCoder](https://www.topcoder.com/) 始于 2001 年，其 [竞技编程社区](https://www.topcoder.com/community/competitive-programming/) 有很多比赛；目前主营业务是技术众包。
-    [TimusOJ](http://acm.timus.ru/) 始于 2000 年，由 Ural Federal University 开发，拥有俄罗斯最大的在线评测题库，题目主要来自乌拉尔联邦大学校赛、乌拉尔锦标赛、ICPC 乌拉尔区域赛、以及 Petrozavodsk 训练营。
-   Online Judge（前 [UVaOJ](https://uva.onlinejudge.org/) ）始于 1995 年，国际成名最早的 OJ，创始人是西班牙 University of Valladolid (UVa) 的 Miguel Ángel Revilla 教授；由于 [Revilla 教授于 2018 年不幸离世](https://www.elnortedecastilla.es/valladolid/muere-profesor-miguel-20180402225739-nt.html) ，且 Valladolid 大学终止维护，UVaOJ 自 2019 年 7 月起更名为 Online Judge。现在该平台的维护者 [正在 Github 上构建新的评测平台](https://github.com/TheOnlineJudge/ojudge) 。
-    [Yandex](https://contest.yandex.ru/) 存档了近几年的全俄罗斯信息学奥赛。

## 教程资料

-    [OI Wiki](https://oi-wiki.org) 
-    [Codeforces 上网友整理的一份教程合集](http://codeforces.com/blog/entry/57282) 
-    [英文版 E-Maxx 算法教程](https://cp-algorithms.com/) 
-    [演算法笔记](http://www.csie.ntnu.edu.tw/~u91029/) （台湾师范大学总结的教程）
-    [algo.is](https://algo.is/t-414-aflv-competitive-programming-course-2016/) 
-    [CS 97SI: Introduction to Programming Contests](http://web.stanford.edu/class/cs97si/) （斯坦福的一门课）
-    [如何为 ACM-ICPC 做准备？- geeksforgeeks](https://www.geeksforgeeks.org/how-to-prepare-for-acm-icpc/) 
-    [Topcoder 整理的教程](https://www.topcoder.com/community/competitive-programming/tutorials/) 
-    [校招面试指南](https://github.com/jwasham/coding-interview-university) 
-    [由 hzwer 收集整理自互联网的课件](https://github.com/hzwer/sharePPT) 
-    [Trinkle23897 的课件](https://github.com/Trinkle23897/oi_slides) 
-    [huzecong 的课件](https://github.com/huzecong/oi-slides) 

## 书籍

本列表内注明了书籍作者，译者未列其中；因无重名书籍且易于寻找，故不放 ISBN。

-   刘汝佳系列
    -   《算法竞赛入门经典》（紫）
        -    [第一版 配套资源仓库（镜像）](https://github.com/sukhoeing/aoapc-book/) 
        -    [第二版 配套资源仓库](https://github.com/aoapc-book/aoapc-bac2nd) 
        -    [第二版 习题选解](https://github.com/sukhoeing/aoapc-bac2nd-keys) 
    -   《算法竞赛入门经典 - 训练指南》（白/蓝）- 陈锋 合著
    -   《算法艺术与信息学竞赛》（蓝/黑）
-   《算法竞赛进阶指南》- 李煜东
    -    [配套资源仓库](https://github.com/lydrainbowcat/tedukuri) 
-   《啊哈算法》- 纪磊  
    面向初学者或有初步兴趣的人群，有幽默配图。
-   CCF 中学生计算机程序设计系列
    -   《CCF 中学生计算机程序设计 - 入门篇》- 陈颖，邱桂香，朱全民 [建议配合勘误使用。](https://zhuanlan.zhihu.com/p/85215961) 
    -   《CCF 中学生计算机程序设计 - 基础篇》- 江涛，宋新波，朱全民
    -   《CCF 中学生计算机程序设计 - 提高篇》- 徐先友，朱全民
    -   《CCF 中学生计算机程序设计 - 专业篇》（未出）
-   一本通系列
    -   《信息学奥赛一本通》- 董永建
    -   《信息学奥赛一本通 - 提高篇》- 黄新军，董永建 [建议选择性阅读。](https://www.zhihu.com/question/292926937) 
    -   《信息学奥赛一本通 - 高手训练》- 黄新军，董永建
-   其他由国内著名 OI 教练写的教材
    -   《信息学奥赛课课通》- 林厚从
    -   《聪明人的游戏：信息学探秘 - 提高篇》- 江涛，陈茂贤
    -   《计算概论：C++ 编程与信息学竞赛入门》- 金靖
    -   《算法竞赛宝典》- 张新华
-   ACM 国际大学生程序设计竞赛系列
    -   《ACM 国际大学生程序设计竞赛系列 知识与入门》- 俞勇
    -   《ACM 国际大学生程序设计竞赛系列 算法与实现》- 俞勇
    -   《ACM 国际大学生程序设计竞赛系列 题目与解读》- 俞勇
-   《算法竞赛入门到进阶》- 罗勇军，郭卫斌
-   《算法导论》第三版 - Thomas H.Cormen/Charles E.Leiserson/Ronald L.Rivest/Clifford Stein 
    黑书，大学经典教材。英文版原名_Introduction to Algorithms_
    -    [答案解析 (English)](https://github.com/walkccc/CLRS) 
-   《具体数学》第二版 - Ronald L. Graham/Donald E. Knuth/Oren Patashnik 
    英文版原名_Concrete Mathematics_
-   《组合数学》第五版 - Richard A.Brualdi 
    英文版原名_Introductory Conbinatorics_
-    [Competitive Programmer's Handbook](https://cses.fi/book/index.html) 
-   《挑战程序设计竞赛》全套 - 秋叶拓哉，岩田阳一，北川宜稔
    通俗易懂。
    -    [译者博客介绍页](http://blog.watashi.ws/2382/pccb-etc/) 
-   《算法概论》- Sanjoy Dasgupta/Christos Papadimitriou/Umesh Vazirani
    提纲挚领，但内容较少。
-    [Legend-K 的数据结构与算法的笔记](http://www.legend-k.com/Algorithm/Algorithm.pdf) 
-    [acm-cheat-sheet](https://github.com/soulmachine/acm-cheat-sheet) 
-    [Competitive Programmer’s Handbook](https://cses.fi/book/book.pdf) - Antti Laaksonen
    作者花了三年个人时间完成。面向算法竞赛，覆盖面广，详略得当。
-    [《挑战编程：程序设计竞赛训练手册》](http://acm.cs.buap.mx/downloads/Programming_Challenges.pdf) - Steven S. Skiena/Miguel A. Revilla
    由西班牙 University of Valladolid 的两位教授编写。
    -    [阅读经过翻译的在线电子版图书](http://www.tup.com.cn/upload/books/yz/030502-01.pdf) 
    -    [购买纸质版图书](http://www.tup.tsinghua.edu.cn/booksCenter/book_03050201.html) 

## 工具

-    [VisuAlgo](https://visualgo.net/en) （经典算法的可视化结果）
-    [USF](https://www.cs.usfca.edu/~galles/visualization/) （算法可视化）
-    [Algomation](http://www.algomation.com/) 
-    [Algorithm Visualizer](http://algorithm-visualizer.org) 
-    [OEIS](https://oeis.org) （整数数列搜索引擎）
-    [Inverse Symbolic Calculator](http://wayback.cecm.sfu.ca/projects/ISC/ISCmain.html) （实数反查表达式，专治不明常数）
-    [Try It Online](https://tio.run) （简单在线跑 600+ 种语言的代码，兹磁 IO 交互，超时 60s，可以分享代码）
-    [Ubuntu Pastebin](https://paste.ubuntu.com) （可以用来分享代码）
-    [uDebug](https://www.udebug.com) （提供一些 OJ 题目的调试辅助）
-    [cppreference.com](https://zh.cppreference.com/w/) （提供 C++ 内语法的查询等）
-    [图论画板](https://csacademy.com/app/graph_editor/) （同时推荐 [GraphViz](http://www.graphviz.org/) )
-    [ $\rm\LaTeX$ 数学公式参考](http://www.mohu.org/info/symbols/symbols.htm) 
-    [Godbolt](https://godbolt.org/) （在浏览器中查看编译后代码块对应的汇编语句）
-    [《100 个 gdb 小技巧》](https://github.com/hellogcc/100-gdb-tips) 
-    [Mathpix](https://mathpix.com/) （截图转 $\rm\LaTeX{}$ )
-    [ $\rm\LaTeX$ 手写符号识别](http://detexify.kirelabs.org/classify.html) 
-    [Wolfram Alpha](https://www.wolframalpha.com/) :（可以解答各种问题）

## 题集和资源

-    [POJ 训练计划](http://blog.csdn.net/skywalkert/article/details/46594541) 
-    [USACO](http://train.usaco.org/usacogate) 
-    [洛谷题单](https://www.luogu.com.cn/training/list) 
-    [-Morass- 贴在 Codeforces 上的一份题单](https://codeforces.com/blog/entry/55274) 
-   Codeforces 社区高质量算法文章合集 [之一](https://codeforces.com/blog/entry/57282)  [之二](https://codeforces.com/blog/entry/13529) 
-    [北京大学 ICPC 暑期课课件例题](https://vjudge.net/article/446) 
-    [北京大学 ICPC 暑期课课件](https://lib-pku.github.io/#acm-icpc%E6%9A%91%E6%9C%9F%E8%AF%BE) 
-    [GitHub.com:OI-wiki/libs](https://github.com/OI-wiki/libs) 
-    [多校联合训练](http://acm.hdu.edu.cn) 关键词： `Multi-University Training Contest` 
-    [Vjudge](https://vjudge.net/) 
-    [Project Euler](https://projecteuler.net/) 

# faq
## 交流方式

本项目主要使用 [Issues](https://github.com/24OI/OI-wiki/issues) / [QQ](https://jq.qq.com/?_wv=1027&k=5EfkM6K) / [Telegram](https://t.me/OIwiki) 进行交流沟通。

Telegram 群组链接为 [@OIwiki](https://t.me/OIwiki) ，QQ 群号码为 [ `588793226` ](https://jq.qq.com/?_wv=1027&k=5EfkM6K) ，欢迎加入。

## 贡献方式

请参考 [如何参与](./htc.md) 页面。

## F.A.Q.

### 目录在哪

目录在项目根目录下的 [mkdocs.yml](https://github.com/24OI/OI-wiki/blob/master/mkdocs.yml#L17) 文件中。

### 如何修改一个 topic 的内容

在对应页面右上方有一个编辑按钮<i class="md-icon">edit</i>，点击并确认阅读了 [如何贡献](./htc.md) 之后会跳转到 GitHub 上对应文件的位置。

或者也可以自行阅读目录 [(mkdocs.yml)](https://github.com/24OI/OI-wiki/blob/master/mkdocs.yml#L17) 查找文件位置。

### 如何添加一个 topic

1.  可以开一个 Issue，注明希望能添加的内容。
2.  可以开一个 Pull Request，在目录 [(mkdocs.yml)](https://github.com/24OI/OI-wiki/blob/master/mkdocs.yml#L17) 中加上新的 topic，并在 [docs](https://github.com/24OI/OI-wiki/tree/master/docs) 文件夹下对应位置创建一个空的 `.md` 文件。

!!! warning "注意"
    写 .md 文件时，请勿在开头写上标题。

### commit message 怎么写

我们推荐使用 [commitizen/cz-cli](https://github.com/commitizen/cz-cli) 来规范 commit message（并非强求）。

### 我尝试访问 GitHub 的时候遇到了困难

推荐在 hosts 文件中加入如下几行：（来源： [GoogleHosts-919f34e](https://github.com/googlehosts/hosts/blob/919f34e53c1099241af7d0b5e730b60899af7d18/hosts-files/hosts#L1467-#L1472) ）

```text
# Github Start
13.250.177.223	gist.github.com
13.250.177.223	github.com
13.229.188.59	www.github.com
151.101.56.133	raw.githubusercontent.com
# Github End
```

可以在 [GoogleHosts 主页](https://github.com/googlehosts/hosts) 上了解到更多信息。

### 我这里 pip 也太慢了

可以选择更换国内源，参考： [更改 pip 源至国内镜像 - L 瑜 - CSDN 博客](https://blog.csdn.net/lambert310/article/details/52412059) ，或者：

```bash
pip install -U -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/
```

### 我在客户端 clone 了这个项目，速度太慢

如果有安装 `git bash` ，可以加几个限制来减少下载量：

```bash
git clone https://github.com/24OI/OI-wiki.git --depth=1 -b master
```

参考： <https://blog.csdn.net/FreeApe/article/details/46845555> 

### 我没装过 Python 3

可以访问 [Python 官网](https://www.python.org/downloads/) 了解更多信息。

### 好像提示我 pip 版本过低

进入 cmd/shell 之后，

```bash
python -m pip install --upgrade pip
```

### 我安装依赖失败了

检查一下：网络？权限？查看错误信息？

### 我已经 clone 下来了，为什么部署不了

检查一下是否安装好了依赖？

### 我 clone 了很久之前的 repo，怎么更新到新版本呢

参考： <https://help.github.com/articles/syncing-a-fork/> 。

### 如果是装了之前的依赖怎么更新

```bash
pip install -U -r requirements.txt
```

### 为什么我的 markdown 格式乱了

可以查阅 [cyent 的笔记](https://cyent.github.io/markdown-with-mkdocs-material/) ，或者 [MkDocs 使用说明](https://github.com/ctf-wiki/ctf-wiki/wiki/Mkdocs-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E) 。

我们目前在使用 [remark-lint](https://github.com/remarkjs/remark-lint) 来自动化修正格式，可能还有一些 [配置](https://github.com/24OI/OI-wiki/blob/master/.remarkrc) 不够好的地方，欢迎指出。

#### GitHub 是不是不显示我的数学公式？

是的，GitHub 的预览不显示数学公式。但是请放心，mkdocs 是支持数学公式的，可以正常使用，只要是 MathJax 支持的句式都可以使用。

#### 我的数学公式怎么乱码了

如果是行间公式（用的 `$$` ），目前已知的问题是需要在 `$$` 两侧留有空行，且 `$$` 要 **单独** 放在一行里（且不要在前加空格）。格式如下：

```text
// 空行
$$
a_i
$$
// 空行
```

#### 我的公式为什么在目录里没有正常显示？好像双倍了？

是的，这个是 python-markdown 的一个 bug，可能近期会修复。

如果现在想要避免目录中出现双倍公式，可以参考 <https://github.com/24OI/OI-wiki/blame/master/docs/string/sam.md#L82> 

```text
### 结束位置 <script type="math/tex">endpos</script>
```

在目录中会变成

```text
结束位置 endpos
```

注：现在请尽量避免在目录中引入 MathJax 公式。

### 如何给一个页面单独声明版权信息

参考 [Metadata](https://squidfunk.github.io/mkdocs-material/extensions/metadata/#usage) 的使用，在页面开头加一行即可。

比如：

```text
copyright: SATA
```

注：默认的是‘CC BY-SA 4.0 和 SATA’。

### 如何给一个页面关闭字数统计（现已默认关闭）

参考 [Metadata](https://squidfunk.github.io/mkdocs-material/extensions/metadata/#usage) 的使用，在页面开头加一行即可。

比如：

```text
pagetime:
```

### 为什么作者信息统计处没有我的名字

是因为 Github API 在文件目录变更后不能跟踪统计，我们在文件头手动维护了一个作者列表来解决这个问题。如果你发现自己写过一个页面中的部分内容，但是没有被记录在页面的作者去，可以把自己的 Github ID 加入到文件头的 `author` 字段，格式是 `author: Ir1d, cjsoft` ，相邻两个 ID 之间用 `,·` （逗号和空格）隔开。

注：这里记录的 ID 是对应到 Github Profile 的地址（即点击 Github 页面右上角之后跳转到的个人主页的 url）

### 重定向文件怎么用

 `_redirects` 文件用于生成 [netlify 的配置](https://docs.netlify.com/routing/redirects/#syntax-for-the-redirects-file) 和 [用于跳转的文件](https://github.com/OI-wiki/OI-wiki/blob/master/scripts/gen_redirect.py) 

每一行表示一个重定向规则，分别写跳转的起点和终点的 url（不包含域名）：

```text
/path/to/src /path/to/desc
```

注：所有跳转均为 301 跳转，只有在修改目录中 url 造成死链的时候需要修改。

# wsl
author: Anti-Li

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![头图](./images/WSL1.png)

* * *

## 引言

众所周知，尽管现在大部分学校的竞赛练习环境都是构建 XP 等 Windows 系操作系统，但是在 NOI 系列赛中，早已用上了 NOI Linux 这个 Ubuntu 操作系统的阉割版。  
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![NOI 竞赛的环境要求](./images/WSL2.png)

<div align='center'> NOI 竞赛的环境要求 </div>
或许大家对自己 Windows 环境下的 Dev-C++ 等都已熟识，但是当场景突然切换到 Linux 的时候，你会不会不知所措？

> 「想用<kbd>Ctrl</kbd>+<kbd>C</kbd>复制，结果退出了程序」  
> 「平时 AC 的程序模板到了 Linux 上就 WA」……

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![平台差异（转自百度文库”NOIP 标准评测系统及相关问题“）](./images/WSL3.png)

<div align='center'> 平台差异（转自百度文库“NOIP 标准评测系统及相关问题”） </div>
为了防止考场上出现此类尴尬情况，我们必须要提前熟悉下 Linux 系统的操作方法。

虽然在 NOI 的官网已经放出了 NOI Linux 的 ISO 镜像，但是如果跑虚拟机的话，配置也相当麻烦，包括激活 VMware，用 VMware 装系统开虚拟机等步骤，且 NOI Linux 默认自带图形界面，两个系统一起运行是低配党的噩梦。

Windows 10 作为微软的新一代操作系统，紧跟时代潮流，在一周年更新时推出了 Linux 子系统（WSL），可以供装不起 VMware 等虚拟机的同学食用。  
缺点是没有 NOI 评测用的 **Arbiter** ，但是在各大 OJ 背书的情况下谁在乎呢……
???+ note "补充资料：何为 Linux 子系统（WSL）？(via 维基百科）"
    适用于 Linux 的 Windows 子系统（英语：Windows Subsystem for Linux，简称 WSL）是一个为在 Windows 10 和 Windows Server 2019 上能够原生运行 Linux 二进制可执行文件（ELF 格式）的兼容层。

    WSL提供了一个由微软开发的Linux兼容的内核接口（不包含Linux内核代码），然后可以在其上运行GNU用户空间，例如Ubuntu，openSUSE，SUSE Linux Enterprise Server，Debian和Kali Linux。这样的用户空间可能包含Bash shell和命令语言，使用本机GNU/Linux命令行工具（sed，awk等），编程语言解释器（Ruby，Python等），甚至是图形应用程序（使用主机端的X窗口系统）。

    WSL仅在版本1607之后的64位版本的Windows 10中可用。它也可在Windows Server 2019中使用。

* * *

## 启用 WSL

???+ warning
    本部分适用于 Windows 10 Fall Creators Update（也即内部版本 16215）和更高版本。

在安装适用于 WSL 的任何 Linux 分发版之前，你必须在下述两种方法中选择一种，以确保启用“适用于 Linux 的 Windows 子系统”可选功能：

### 使用 Powershell

1.  以管理员身份打开 PowerShell 并运行：
    ```powershell
    Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
    ```
2.  出现提示时，重启计算机。

### 使用 GUI

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL4.png)

1.  打开“控制面板”

2.  访问“程序和功能”子菜单“打开或关闭 Windows 功能”

3.  选择“适用于 Linux 的 Windows 子系统”

4.  点击确定

5.  重启

## 使用 Ubuntu

这次演示我们使用 Ubuntu，因为 NOI Linux 正是基于 Ubuntu 14.04 LTS 的 Linux 发行版。

只要学会了方法，你也可照葫芦画瓢，安装其他 Linux 发行版。

### 安装

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL5.png)进入 Microsoft Store，搜索 "Ubuntu"，然后选第一个安装。  
亦可打开 <https://www.microsoft.com/zh-cn/p/ubuntu/9nblggh4msv6> 

???+ warning
    Microsoft Store 的 Ubuntu 随着 Ubuntu 的更新而更新，因此内容可能会有所改变。
    
    如果你想获取稳定的 Ubuntu 长期支持版，可以在 Microsoft Store 安装 Ubuntu 的 LTS 版本。
    
    如本次演示中使用的是 **Ubuntu 16.04 LTS** 。

### 运行 Ubuntu

打开“开始”菜单找到 Ubuntu 并启动，或使用 wsl 命令从 Windows 命令行启动。

可以为 Ubuntu 创建应用程序磁贴或固定至任务栏，以在下次方便地打开。

### 初始化

第一次运行 Ubuntu，需要完成初始化。

等待一两分钟时间，系统会提示创建新的用户帐户及其密码，请确保选择一个容易记住的密码。/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL6.png)

## 基础配置

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL7.png)正如图片所示，这个系统纯净到连个编译器都没有，所以这一节来看看基础的环境配置。

### 更换为国内软件源

Ubuntu 默认的软件源在国外，我们可以换为国内的加快速度，如 [清华 TUNA 的软件源](https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/) 。

可以访问 [TUNA 的页面](https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/) 来获得国内源的信息。

???+ warning  
     **请在页面中寻找与自己系统版本相配的源（可使用 `sudo lsb_release -a` 查看 Ubuntu 版本）**  **除非你知道你在做什么，否则不要使用与自己的系统版本不匹配的源！** 

使用的命令

```bash
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
sudo vim /etc/apt/sources.list
# （按 i 之后将上文的源右键粘贴进去，编辑完后按 Esc，再输入 :wq 和回车）
sudo apt update
sudo apt upgrade -y
```

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL9.png)

### 安装中文环境

```bash
sudo apt install  language-pack-zh-han* -y
sudo locale-gen zh_CN.GB18030 && sudo locale-gen zh_CN.UTF-8
# 中文字体，别忘了同意 EULA
sudo apt install fontconfig -y
sudo apt install ttf-mscorefonts-installer -y
# 下面的再执行一遍以防万一
sudo apt install -y --force-yes --no-install-recommends fonts-wqy-microhei
sudo apt install -y --force-yes --no-install-recommends ttf-wqy-zenhei
sudo dpkg-reconfigure locales
```

使用 `sudo dpkg-reconfigure locales` 进入菜单，按空格选择带 `zh_CN` 的选项，选完后回车，下一个菜单中选 `zh_CN.UTF-8` 打回车。

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL10.png)/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL11.png)之后关上 Ubuntu 重开一遍登录，是不是变中文了？
再依次输入下列命令，把 `man` 帮助页替换为中文： [via](https://blog.csdn.net/qq_14989227/article/details/72954523) 

```bash
sudo apt install manpages-zh
sudo vi /etc/manpath.config
:1,$s#/usr/share/man#/usr/share/man/zh_CN#g
:wq
```

可以用 `man help` 测试下。

### 安装编译环境

```bash
sudo apt install build-essential vim ddd gdb fpc emacs gedit anjuta lazarus -y
wget http://download.noi.cn/T/noi/GUIDE-1.0.2-ubuntu.tar
tar -xvf GUIDE-1.0.2-ubuntu.tar
cd GUIDE-1.0.2-ubuntu
chmod +x install.sh && ./install.sh
```

这是基础的 + NOI 官方要求环境，如有需要可以用 `apt install 程序名` 来安装别的。
若想安装其他版本可以参考下 [这个](https://www.cnblogs.com/EasonJim/p/7144017.html) 

来个程序玩玩：

```bash
$ vim cpuid.cpp
$ g++ -Wall cpuid.cpp -o cpuid
$ ./cpuid
AMD Ryzen 5 1400 Quad-Core Processor
```

 **Tips：Linux 环境下可执行文件可不带扩展名，实现方式看上方命令行** 

## 进阶操作

### 安装图形环境，并使用远程桌面连接

推荐图形环境用 xfce4，不臃肿。

```bash
sudo apt install xfce4 tightvncserver -y
# 或使用 sudo apt install xubuntu-desktop -y
# xubuntu 安装的软件多，基础环境可用第一种
```

图形环境是个大头，因此要多等会，静静等待下载解包。
下面配置 xrdp：

```bash
sudo apt install xrdp -y
echo "xfce4-session" >~/.xsession
sudo service xrdp restart
```

为了防止和你计算机本来带的远程桌面冲突，最好换一下端口。/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL12.png)

<div align='center'> 不换端口的结果 </div>
 运行命令 `vim /etc/xrdp/xrdp.ini`，把 `port=3389` 改为别的（如 `port=3390`），然后保存即可。
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL13.png)
 运行 `sudo service xrdp restart`，然后去开始菜单，用 `localhost: 你配置的端口 ` 来访问。
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL14.png)
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL15.png)

### 补充：使用 Xming 连接

有网友说，这个可以用 Xming 连接，那我们就来研究一下。

#### 客户端：安装 Xterm

我们进入 Ubuntu 环境，安装 xterm：

```bash
sudo apt-get install xterm -y
```

#### 服务端：下载 Xming Server

去 <https://sourceforge.net/projects/xming/> 下载最新的 Xming Server，然后一路安装：  
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL16.png)  
如果你把 Launch Xming 框点掉了，记得去开始菜单再打开：  
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![别忘了！](./images/WSL17.png)  
之后再回到 Ubuntu，键入如下指令：

```bash
DISPLAY=:0 xterm
```

 **Duang！**   
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL18.png)  
不过貌似只支持命令行……这时上一种方法的优势就显而易见了  
如果你和我一样使用了 xfce4，在弹出的窗口中使用如下命令激活 xfce4：

```bash
xfce4-session
```

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL19.png)

效果图如下： **（在 Xming 中使用** <kbd>Ctrl</kbd>+<kbd>C</kbd> **就可以退出这个鬼畜界面）**   
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL20.png)

<div align='center'> 达成成就：Windows+Linux 二合一 </div>
### 与 Windows 内原硬盘分区交互

硬盘分区作为文件夹在 `/mnt/` 里放着，因此可以直接交互，比如说直接编译个二进制文件，或者往 Ubuntu 里传文件什么的……  
具体演示：  
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL22.png)  
/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/WSL23.png)

<div align='center'> 这里也可以建立一些 Windows（一般情况下）建不了的文件，例如带点文件夹 </div>
**乱码是因为我用的预览体验系统……不过用正式版也可以了！**

## FAQ

-   如何在子系统下进行 xxx？
    该怎么用怎么用，可以用自带命令行，实在不行参考教程唤醒图形界面。
    比如说 vim，在命令行中键入 `man vim` ，会给出一份详尽的使用方法。
    亦可使用 `vim --help` 。
-   占用量大？
    Sorry，这个系统和 Windows 10 共用 Host，所以理论上是比虚拟机占用小的。
    而且只要别装太多应用，应该还是可以带动的。
-   汉语化时提示不存在？
    玄学问题，可以忽略。修了个疏忽导致的错误，可以重上一下试试。

## 参考资料

这里列举了文中提到的链接，以便查阅。

1.   [适用于 Linux 的 Windows 子系统安装指南 (Windows 10), Microsoft Docs](https://docs.microsoft.com/zh-cn/windows/wsl/install-win10) 
2.   [适用于 Linux 的 Windows 子系统，Wikipedia](https://zh.wikipedia.org/zh-hans/%E9%80%82%E7%94%A8%E4%BA%8E_Linux_%E7%9A%84_Windows_%E5%AD%90%E7%B3%BB%E7%BB%9F) 
3.   [WSL-Ubuntu 维基，ubuntu wiki](https://wiki.ubuntu.com/WSL) 
4.   [Windows 10 版本 1803 中命令行的新增功能，Microsoft Devblogs](https://devblogs.microsoft.com/commandline/windows10v1803/) 
5.   [NOIP 标准评测系统及相关问题，smart0326, 2014-05-19, 百度文库](https://wenku.baidu.com/view/8246d96cdd36a32d72758143.html) 
6.   [WSL, 百度百科](https://baike.baidu.com/item/wsl/20359185) 
7.   [Run Bash on Ubuntu on Windows, Mike Harsh, 2016-05-30, Windows Blog](https://blogs.windows.com/buildingapps/2016/03/30/run-bash-on-ubuntu-on-windows/#cie8WdR3uSjgR5Ru.97) 
8.   [Windows Subsystem for Linux Documentation, MSDN](https://docs.microsoft.com/zh-cn/windows/wsl/about) 
9.   [NOI 系列活动标准竞赛环境，2016-11-08, NOI 官网](http://www.noi.cn/2016-11-08-03-42-01) 
10.  [购买 Ubuntu, Microsoft Store](https://www.microsoft.com/zh-cn/p/ubuntu/9nblggh4msv6) 
11.  [Ubuntu 镜像使用帮助，清华 TUNA](https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/) 
12.  [Ubuntu 的 man 命令帮助如何设置中文版，Frank 看庐山，2017-06-09](https://blog.csdn.net/qq_14989227/article/details/72954523) 
13.  [Xming X Server for Windows, SourceForge](https://sourceforge.net/projects/xming/) 
14.  [Sudo, Wikipedia](https://zh.wikipedia.org/wiki/Sudo) 

## 延伸内容

-    [Dev on Windows with WSL（在 Windows 上用 WSL 优雅开发）](https://dowww.spencerwoo.com) 

-    [Github 上的 Awesome-WSL](https://github.com/sirredbeard/Awesome-WSL) 

### 后记

本文最初发布于 [洛谷日报 #6](https://www.luogu.org/discuss/show/48491) ，现由原作者搬运至此，有删改。

# spj
一道题如果有多组解，我们就需要一个程序来判断答案合法性，这便是 Special Judge (spj)，又常被称作 checker，下面介绍部分评测工具/OJ 的 spj 编写方法。

???+ warning
    spj 还应当判断文件尾是否有多余内容，及输出格式是否正确（如题目要求数字间用一个空格隔开，而选手却使用了换行）。但是，目前前者只有 Testlib 可以方便地做到这一点，而后者几乎无人去特意进行这种判断。

    判断浮点数时应注意 nan，不合理的判断方式会导致输出 nan 即可 AC。

    在对选手文件进行读入操作时应该要检查是否正确读入了所需的内容，防止造成 spj 的运行错误。（部分 OJ 会将 spj 的运行错误作为系统错误处理）

以下均使用 C++，以“要求标准答案与选手答案差值小于 1e-3，文件名为 num，单个测试点满分为 10 分”为例。

## Testlib

Testlib 的介绍见 [Testlib/简介](./testlib/index.md) 页面，用法见 [Testlib/Checker](./testlib/checker.md) 页面。

必须使用 Testlib 做 spj 的 评测工具/OJ：Codeforces、洛谷、UOJ 等

可以使用 Testlib 做 spj 的 评测工具/OJ：LibreOJ (SYZOJ 2)、Lemon、牛客网等

SYZOJ 2 所需的修改版 Testlib 可以在 [这里](https://pastebin.com/3GANXMG7) 获取到，感谢 [cyand1317](https://loj.ac/article/124) 。

Lemon 所需的修改版 Testlib 可以在 [这里](https://paste.ubuntu.com/p/JsTspHHnmB/) 获取到，感谢 matthew99。注意此版本 Testlib 注册 checker 应使用 `registerLemonChecker()` 而非 `registerTestlibCmd()` 。

DOMJudge 所需的修改版 Testlib 可以在 [这里](https://github.com/cn-xcpc-tools/testlib-for-domjudge) 获取到。此版本 Testlib 同时兼容做 Special Judge 的 checker 和交互题的 interactor。

其他评测工具/OJ 大部分需要按照其 spj 编写格式修改 Testlib（并将 testlib.h 与 spj 一同上传，或将 testlib.h 置于 include 目录）。

```cpp
// clang-format off

#include "testlib.h"
#include <cmath>

int main(int argc, char *argv[]) {
  /*
   * inf：输入
   * ouf：选手输出
   * ans：标准输出
   */
  registerTestlibCmd(argc, argv);

  double pans = ouf.readDouble(), jans = ans.readDouble();

  if (abs(pans - jans) < 1e-3)
    quitf(_ok, "Good job\n");
  else
    quitf(_wa, "Too big or too small, expected %f, found %f\n", jans, pans);
}
```

## Lemon

 **Lemon 有现成的修改版 Testlib，建议使用 Testlib，见 [Testlib](#testlib) ** 

```cpp
#include <cmath>
#include <cstdio>

int main(int argc, char* argv[]) {
  /*
   * argv[1]：输入
   * argv[2]：选手输出
   * argv[3]：标准输出
   * argv[4]：单个测试点分值
   * argv[5]：输出最终得分 (0 ~ argv[4])
   * argv[6]：输出错误报告
   */
  FILE* fin = fopen(argv[1], "r");
  FILE* fout = fopen(argv[2], "r");
  FILE* fstd = fopen(argv[3], "r");
  FILE* fscore = fopen(argv[5], "w");
  FILE* freport = fopen(argv[6], "w");

  double pans, jans;
  fscanf(fout, "%lf", &pans);
  fscanf(fstd, "%lf", &jans);

  if (abs(pans - jans) < 1e-3) {
    fprintf(fscore, "%s", argv[4]);
    fprintf(freport, "Good job\n");
  } else {
    fprintf(fscore, "%d", 0);
    fprintf(freport, "Too big or too small, expected %f, found %f\n", jans,
            pans);
  }
}
```

## Cena

```cpp
#include <cmath>
#include <cstdio>

int main(int argc, char* argv[]) {
  /*
   * FILENAME.in：输入
   * FILENAME.out：选手输出
   * argv[1]：单个测试点分值
   * argv[2]：标准输出
   * score.log：输出最终得分 (0 ~ argv[1])
   * report.log：输出错误报告
   */
  FILE* fin = fopen("num.in", "r");
  FILE* fout = fopen("num.out", "r");
  FILE* fstd = fopen(argv[2], "r");
  FILE* fscore = fopen("score.log", "w");
  FILE* freport = fopen("report.log", "w");

  double pans, jans;
  fscanf(fout, "%lf", &pans);
  fscanf(fstd, "%lf", &jans);

  if (abs(pans - jans) < 1e-3) {
    fprintf(fscore, "%s", argv[1]);
    fprintf(freport, "Good job\n");
  } else {
    fprintf(fscore, "%d", 0);
    fprintf(freport, "Too big or too small, expected %f, found %f\n", jans,
            pans);
  }
}
```

## CCR

```cpp
#include <cmath>
#include <cstdio>

int main(int argc, char* argv[]) {
  /*
   * stdin：输入
   * argv[2]：标准输出
   * argv[3]：选手输出
   * stdout:L1：输出最终得分比率 (0 ~ 1)
   * stdout:L2：输出错误报告
   */
  FILE* fout = fopen(argv[3], "r");
  FILE* fstd = fopen(argv[2], "r");

  double pans, jans;
  fscanf(fout, "%lf", &pans);
  fscanf(fstd, "%lf", &jans);

  if (abs(pans - jans) < 1e-3) {
    printf("%d\n", 1);
    printf("Good job\n");
  } else {
    printf("%d\n", 0);
    printf("Too big or too small, expected %f, found %f\n", jans, pans);
  }
}
```

## Arbiter

```cpp
#include <cmath>
#include <cstdio>

int main(int argc, char* argv[]) {
  /*
   * argv[1]：输入
   * argv[2]：选手输出
   * argv[3]：标准输出
   * /tmp/_eval.score:L1：输出错误报告
   * /tmp/_eval.score:L2：输出最终得分
   */
  FILE* fout = fopen(argv[2], "r");
  FILE* fstd = fopen(argv[3], "r");
  FILE* fscore = fopen("/tmp/_eval.score", "w");

  double pans, jans;
  fscanf(fout, "%lf", &pans);
  fscanf(fstd, "%lf", &jans);

  if (abs(pans - jans) < 1e-3) {
    fprintf(fscore, "Good job\n");
    fprintf(fscore, "%d", 10);
  } else {
    fprintf(fscore, "Too big or too small, expected %f, found %f\n", jans,
            pans);
    fprintf(fscore, "%d", 0);
  }
}
```

## HUSTOJ

```cpp
#include <cmath>
#include <cstdio>

#define AC 0
#define WA 1

int main(int argc, char* argv[]) {
  /*
   * argv[1]：输入
   * argv[2]：标准输出
   * argv[3]：选手输出
   * exit code：返回判断结果
   */
  FILE* fin = fopen(argv[1], "r");
  FILE* fout = fopen(argv[3], "r");
  FILE* fstd = fopen(argv[2], "r");

  double pans, jans;
  fscanf(fout, "%lf", &pans);
  fscanf(fstd, "%lf", &jans);

  if (abs(pans - jans) < 1e-3)
    return AC;
  else
    return WA;
}
```

## QDUOJ

QDUOJ 就麻烦一点，因为它的带 spj 的题目没有标准输出，只能把 std 写进 spj 跑出标准输出再判断。

```cpp
#include <cmath>
#include <cstdio>

#define AC 0
#define WA 1
#define ERROR -1

double solve(...) {
  // std
}

int main(int argc, char* argv[]) {
  /*
   * argv[1]：输入
   * argv[2]：选手输出
   * exit code：返回判断结果
   */
  FILE* fin = fopen(argv[1], "r");
  FILE* fout = fopen(argv[2], "r");

  double pans, jans;
  fscanf(fout, "%lf", &pans);

  jans = solve(...);
  if (abs(pans - jans) < 1e-3)
    return AC;
  else
    return WA;
}
```

## LibreOJ (SYZOJ 2)

 **LibreOJ (SYZOJ 2) 有现成的修改版 Testlib，建议使用 Testlib，见 [Testlib](#testlib) ** 

```cpp
#include <cmath>
#include <cstdio>

int main(int argc, char* argv[]) {
  /*
   * in：输入
   * user_out：选手输出
   * answer：标准输出
   * code：选手代码
   * stdout：输出最终得分 (0 ~ 100)
   * stderr：输出错误报告
   */
  FILE* fin = fopen("in", "r");
  FILE* fout = fopen("user_out", "r");
  FILE* fstd = fopen("answer", "r");
  FILE* fcode = fopen("code", "r");

  double pans, jans;
  fscanf(fout, "%lf", &pans);
  fscanf(fstd, "%lf", &jans);

  if (abs(pans - jans) < 1e-3) {
    printf("%d", 100);
    fprintf(stderr, "Good job\n");
  } else {
    printf("%d", 0);
    fprintf(stderr, "Too big or too small, expected %f, found %f\n", jans,
            pans);
  }
}
```

## 牛客网

 **牛客网有现成的修改版 Testlib，建议使用 Testlib，见 [Testlib](#testlib) ** 

牛客网的官方教程： <https://www.nowcoder.com/discuss/84666> 

```cpp
#include <cmath>
#include <cstdio>

#define AC 0
#define WA 1

int main(int argc, char* argv[]) {
  /*
   * input：输入
   * user_output：选手输出
   * output：标准输出
   * exit code：返回判断结果
   */
  FILE* fin = fopen("input", "r");
  FILE* fout = fopen("user_output", "r");
  FILE* fstd = fopen("output", "r");

  double pans, jans;
  fscanf(fout, "%lf", &pans);
  fscanf(fstd, "%lf", &jans);

  if (abs(pans - jans) < 1e-3)
    return AC;
  else
    return WA;
}
```

## DOMJudge

 **DOMJudge 支持任何语言编写的 spj，参考 [problemarchive.org output validator 格式](https://www.problemarchive.org/wiki/index.php/Output_validator) 。** 

 **DOMJudge 有现成的修改版 Testlib，建议使用 Testlib，见 [Testlib](#testlib) ** 

DOMJudge 使用的 Testlib 及导入 Polygon 题目包方式的文档： <https://github.com/cn-xcpc-tools/testlib-for-domjudge> 

DOMJudge 的 [默认比较器](https://github.com/Kattis/problemtools/blob/master/support/default_validator/) 自带了浮点数带精度比较，只需要在题目配置的 `validator_flags` 中添加 `float_tolerance 1e-3` 即可。

```cpp
#include <cmath>
#include <cstdio>

#define AC 42
#define WA 43
char reportfile[50];

int main(int argc, char* argv[]) {
  /*
   * argv[1]: 输入
   * argv[2]: 标准输出
   * argv[3]: 评测信息输出的文件夹
   * stdin: 选手输出
   */
  FILE* fin = fopen(argv[1], "r");
  FILE* fstd = fopen(argv[2], "r");
  sprintf(reportfile, "%s/judgemessage.txt", argv[3]);
  FILE* freport = fopen(reportfile, "w");

  double pans, jans;
  scanf("%lf", &pans);
  fscanf(fstd, "%lf", &jans);

  if (abs(pans - jans) < 1e-3) {
    fprintf(freport, "Good job\n");
    return AC;
  } else {
    fprintf(freport, "Too big or too small, expected %f, found %f\n", jans,
            pans);
    return WA;
  }
}
```

也可以使用 Kattis Problem Tools 提供的头文件 [validate.h](https://github.com/Kattis/problemtools/blob/master/examples/different/output_validators/different_validator/validate.h) 编写，以实现更加复杂的功能。

# common-mistakes
本页面主要分享一下在竞赛中经常/很多人会出现的错误。

## 会引起 Compile Error 的错误

由于这类错误过于简单，~~相信是个正常人都会修~~，故略写。

-    `int main()` 写为 `int mian()` 。

-   写完 `struct` 或 `class` 忘记写分号。

-   数组开太大，（在 OJ 上）使用了不合法的函数（例如多线程），或者函数声明但未定义，会引起链接错误。

-   使用 `algorithm` 中的 `max` 函数时，一个参数类型为 `int` 而另一个参数类型为 `long long` 
    -   示例：
        ```cpp
        printf("%lld\n", max(0, query(1, 1, n, l, r)); // query 返回 long long 类型
        ```

-    `goto` 的时候，跳过了一些局部变量的初始化。

    -    `switch-case` 的时候，跳过了一些局部变量的初始化。

## 不会引起 Compile Error 但会引发 Warning 的错误

这类错误较难发现，但会在使用 `-W{warningtype}` 参数编译时被编译器指出，所以要多学会使用 `-W{warningtype}` 参数，常见的有 `-Wall` ， `-Wextra` ， `-Wshadow` 等。

-   由于运算符优先级产生的错误。
    -    `1 << 1 + 1` : 1 左移了 2，即该表达式返回的值是 4。

-   不正确地使用 `static` 修饰符。

-    `-1 >> 1 == 1` 。

-   赋值运算符和 `==` 不分。
    -   示例：
        ```cpp
        if (n = 1)
          puts("Yes");
        else
          puts("No");
        ```
        无论 $n$ 的值之前为多少，输出肯定是 `Yes` 。

-   使用 `scanf` 读入的时候没加取地址符 `&` 。更一般地，使用 `scanf` 或 `printf` 的时候参数类型与格式指定符不符。

-   没有考虑数组下标出现负数的情况。

-   同时使用位运算和逻辑运算符（ `==` ）并且未加括号（例如 `(x>>j)&3==2` ）。

-    `int` 字面量溢出，例如： `long long x = 0x7f7f7f7f7f7f7f7f` ， `1<<62` 。

-   未初始化局部变量，导致局部变量被赋予垃圾初值。

-   局部变量与全局变量重名，导致全局变量被意外覆盖。（开 `-Wshadow` 就可检查此类错误。）

## 既不会引起 Compile Error 也不会引发 Warning 的错误

这类错误无法被编译器发现，所以在调试时只能依靠你自己。

### 会导致 WA

-   多组数据未清空数组。

-   读入优化未判断负数。

-   所用数据类型不够大导致溢出，即常见的“三年 OI 一场空，不开 `long long` 见祖宗”，意思是因为没有使用 `long long` （开 `long long` ）导致大量丢分从而赛季作废。

-   存图时，节点编号 0 开始，而题目给的边中两个端点的编号从 1 开始，读入的时候忘记 -1。

-   大/小于号打错或打反。

-   在执行 `ios::sync_with_stdio(false);` 后混用两种 IO，导致输入/输出错乱。
    -   可以参考这个例子。
        ```cpp
        // 这个例子将说明，关闭与 stdio 的同步后，混用两种 IO 的后果
        // 建议单步运行来观察效果
        #include <cstdio>
        #include <iostream>
        int main() {
          std::ios::sync_with_stdio(false);
          // 关闭同步后，cin/cout 将使用独立缓冲区，而不是将输出同步至 scanf/printf
          // 的缓冲区，从而减少 IO 耗时
          std::cout << "a\n";
          // cout 下，使用'\n'换行时，内容会被缓冲而不会被立刻输出，应该使用 endl
          // 来换行并立刻刷新缓冲区
          printf("b\n");
          // printf 的 '\n' 会刷新 printf 的缓冲区，导致输出错位
          std::cout << "c\n";
          return 0;  //程序结束时，cout 的缓冲区才会被输出
        }
        ```
    -   特别的，也不能在执行 `ios::sync_with_stdio(false);` 后使用 `freopen` 。

-   由于宏的展开，且未加括号导致的错误：
    ```cpp
    #define square(x) x* x
    printf("%d", square(2 + 2));
    ```
    该宏返回的值并非 $4^2 = 16$ 而是 $2+2\times 2+2 = 8$ 。

-   哈希的时候没有使用 `unsigned` ，因为对负数的右移运算会在最高位补 1，详见 [位运算](../math/bit.md) 

-   没有删除调试信息。

-   误加了 `;` 。
    -   可以参考这个例子：
        ```cpp
        /* clang-format off */
        while (1);
            printf("OI Wiki!\n");
        ```

-   没有正确设置哨兵值。例如，平衡树的 `0` 节点。

-   在类或结构体的构造函数中，使用 : 初始化变量，且变量声明顺序不符合初始化时候的依赖关系。因为成员变量的初始化顺序只与它们在类中声明的顺序有关，而与在初始化列表中的顺序无关。

-   并查集合并集合时没有把两个元素的祖先合并：

```cpp
f[a] = b;              //错误
f[find(a)] = find(b);  // 正确
```

### 会导致 RE

-   对整数除以 $0$ 。
    -   对 $0$ 求逆元。

-   没删文件操作（某些 OJ）。

-   排序时比较函数的错误 `std::sort` 要求比较函数是严格弱序： `a<a` 为 `false` ；若 `a<b` 为 `true` ，则 `b<a` 为 `false` ；若 `a<b` 为 `true` 且 `b<c` 为 `true` ，则 `a<c` 为 `true` 。其中要特别注意第二点。
    如果不满足上述要求，排序时很可能会 RE。
    例如，编写莫队的奇偶性排序时，这样写是错误的：
    ```cpp
    bool operator<(const int a, const int b) {
      if (block[a.l] == block[b.l])
        return (block[a.l] & 1) ^ (a.r < b.r);
      else
        return block[a.l] < block[b.l];
    ```
    上述代码中 `(block[a.l]&1)^(a.r<b.r)` 不满足严格弱序的要求 2。
    改成这样就正确了。
    ```cpp
    bool operator<(const int a, const int b) {
      if (block[a.l] == block[b.l])
        return (block[a.l] & 1) ? (a.r < b.r) : (a.r > b.r);
      else
        return block[a.l] < block[b.l];
    ```

-   解引用空指针。

### 会导致 TLE

-   分治未判边界导致死递归。

-   死循环。

    -   循环变量重名。

    -   循环方向反了。

-   BFS 时不标记某个状态是否已访问过。

-   使用宏展开编写 min/max

    这种做法虽然算不上是「错误」，但是这里还是要拎出来说一下。

    常见的写法是这样的：

    ```cpp
    #define Min(x, y) ((x) < (y) ? (x) : (y))
    #define Max(x, y) ((x) > (y) ? (x) : (y))
    ```

    这样写虽然在正确性上没有问题，但是如果你直接对函数的返回值取 max，如 `a = Max(func1(), func2())` ，而这个函数的运行时间较长，则会大大影响程序的性能，因为宏展开后是 `a = func1() > func2() ? func1() : func2()` 的形式，调用了三次函数，比正常的 max 函数多调用了一次。

    这种错误在初学者写线段树时尤为多见，会大大增加程序的运行时间，甚至直接影响代码的时间复杂度。例如这份错误代码：

    ```cpp
    #define max(x, y) ((x) > (y) ? (x) : (y))

    int query(int t, int l, int r, int ql, int qr) {
      if (ql <= l && qr >= r) {
        ++ti[t];  // 记录结点访问次数方便测试
        return vi[t];
      }

      int mid = (l + r) >> 1;
      if (mid >= qr) {
        return query(lt(t), l, mid, ql, qr);
      }
      if (mid < ql) {
        return query(rt(t), mid + 1, r, ql, qr);
      }
      return max(query(lt(t), l, mid, ql, qr), query(rt(t), mid + 1, r, ql, qr));
    }
    ```

    会被卡到单次查询 $\Theta(n)$ 导致 TLE。

-   没删文件操作（另一些 OJ）。

-    `for (int i = 0; i < strlen(s); ++i)` ：在循环中重复执行复杂度非 $O(1)$ 的函数。（严格来说，这可能会引起时间复杂度的改变。）

### 会导致 MLE

-   数组过大。

-   STL 容器中插入了过多的元素。

    -   经常是在一个会向 STL 插入元素的循环中死循环了。

    -   也有可能被卡了。

### 错误类型不定

-   数组越界。上下都算。（多数是 RE。）

    -   未正确设置循环的初值导致访问了下标为 -1 的值。

    -   无向图边表未开 2 倍。

    -   线段树未开 4 倍空间。

    -   看错数据范围，少打一个零。

    -   错误预估了算法的空间复杂度。

    -   写线段树的时候， `pushup` 或 `pushdown` 叶节点。

-   解引用野指针。

    -   未初始化就解引用指针。

    -   指针指向的区域已经 `free` 或 `delete` 。

### 会导致常数过大

-   定义模数的时候，使用了全局变量（如 `int mod = 998244353` ，正确做法是 `const int mod = 998244353` ）。

-   使用了不必要的递归（需要注意的是，尾递归不在此列）。

-   将递归转化成迭代的时候，引入了大量额外运算。

### 只在程序在本地运行的时候造成影响的错误

-   文件操作有可能会发生的错误。

    -   对拍时未清除文件指针即 `fclose(fp)` 就又令 `fp = fopen()` , 这会使得进程出现大量的文件野指针。

    -    `freopen()` 中的文件名未加 `.in` / `.out` 。

-   使用堆空间忘记 `delete` 或 `free` 。

# docker-deploy
可以使用 Docker 部署环境。

以下步骤须在 root 用户下或 docker 组用户下执行

## 拉取 oi-wiki 镜像

```bash
# 以下命令在主机中运行其中一个即可
# Docker Hub 镜像（官方镜像仓库）
docker pull 24oi/oi-wiki
# DaoCloud Hub 镜像（国内镜像仓库）
docker pull daocloud.io/sirius/oi-wiki
# Tencent Hub 镜像（国内镜像仓库）
docker pull ccr.ccs.tencentyun.com/oi-wiki/oi-wiki
```

## 运行容器

```bash
# 以下命令在主机中运行
docker run -d -it [image]
```

-   设置 `[image]` （必须）以设置镜像，如从 Docker Hub 拉取的则为 `24oi/oi-wiki` ，DaoCloud Hub 拉取的则为 `daocloud.io/sirius/oi-wiki` 
-   设置 `--name [name]` （默认空，若想查看容器 id，则输入 `docker ps` ，若设置请替换 `[name]` 为自定义的容器名字）以设置容器名字
-   设置 `-p [port]:8000` （必须）（不写该语句则默认为不暴露端口，若设置请替换 `[port]` 为主机端口）以映射容器端口至主机端口（可以在主机使用 `http://127.0.0.1:[port]` 访问 **OI Wiki** ）

## 使用

基于 Ubuntu 16.04 部署

进入容器：

```bash
# 以下命令在主机中运行
docker exec -it [name] /bin/bash
```

若在上述运行容器中去掉 `-d` ，则可以直接进入容器 bash，退出后容器停止，加上 `-d` 则后台运行，请手动停止。上述进入容器针对加上 `-d` 的方法运行。

特殊用法：

```bash
# 以下命令在容器中运行
# 更新 git 仓库
wiki-upd

# 使用我们的自定义主题
wiki-theme

# 构建 mkdocs ，会在 site 文件夹下得到静态页面
wiki-bld

# 构建 mkdocs 并渲染 MathJax ，会在 site 文件夹下得到静态页面
wiki-bld-math

# 运行一个服务器，访问容器中 http://127.0.0.1:8000 或访问主机中 http://127.0.0.1:[port] 可以查看效果
wiki-svr

# 修正 Markdown
wiki-o
```

退出容器：

```bash
# 以下命令在容器中运行
# 退出
exit
```

## 停止容器

```bash
# 以下命令在主机中运行
docker stop [name]
```

## 启动容器

```bash
# 以下命令在主机中运行
docker start [name]
```

## 重启容器

```bash
# 以下命令在主机中运行
docker restart [name]
```

## 删除容器

```bash
# 以下命令在主机中运行
# 删除前请先停止容器
docker rm [name]
```

## 更新镜像

重新再 `pull` 一次即可，通常不会更新

## 删除镜像

```bash
# 以下命令在主机中运行
# 删除前请先删除使用 oi-wiki 镜像构建的容器
docker rmi [image]
```

## 疑问

如果您有疑问，欢迎提出 issue！

# about
# 关于本项目

Q：你们是为什么想要做这个 Wiki 的呢？

A：不知道你在学 **OI** 的时候，面对庞大的知识体系，有没有感到过迷茫无助的时候？ **OI Wiki** 想要做的事情可能类似于“让更多竞赛资源不充裕的同学能方便地接触到训练资源”。当然这么表述也不完全，做 Wiki 的动机可能也很纯粹，只是简单地想要对 **OI** 的发展做出一点点微小的贡献吧。XD

Q：我很感兴趣，怎么参与呢？

A： **OI Wiki** 现在托管在 [GitHub](https://github.com/24OI/OI-wiki) 上，你可以直接访问这个 [repo](https://github.com/24OI/OI-wiki) 来查看最新进展。参与的途径包括在 [GitHub](https://github.com/24OI/OI-wiki) 上面开 Issue、Pull Request，或者在交流群中分享你的想法、直接向管理员投稿。目前，我们使用的框架是用 Python 开发的 [mkdocs](https://mkdocs.readthedocs.io) ，支持 Markdown 格式（也支持插入数学公式）。

Q：可是我比较弱……不知道我能做点什么？

A：一切源于热爱。你可以协助其他人审核修改稿件，帮助我们宣传 **OI Wiki** ，为社区营造良好学习交流氛围！

Q：现在主要是谁在做这件事啊？感觉这是个大坑，真的能做好吗？

A：最开始主要是一些退役老年选手在做这件事，后来遇到了很多志同道合的小伙伴：有现役选手，退役玩家，也有从未参加过 **OI** 的朋友。目前，这个项目主要是由 **OI Wiki** Team 来维护。（下面是一张合影）

<a href="https://github.com/24OI/OI-wiki/graphs/contributors"><img src="https://opencollective.com/oi-wiki/contributors.svg?width=890&button=false" /></a>

当然，这个项目只靠我们的力量是很难做得十全十美的，我们诚挚地邀请你一起来完善 **OI Wiki** 。

Q：听说过 nocow 吧， **OI Wiki** 怎么保证我们添加的内容不会像 nocow 那样突然间就不见了呢？

A：我们把内容托管在 [GitHub](https://github.com/24OI/OI-wiki) 上面，即使我们的服务器翻车了，内容也不会丢失。另外，我们也会定期备份大家的心血，即使有一天 [GitHub](https://github.com/24OI/OI-wiki) 倒闭了（？），我们的内容也不会丢失。

Q： **OI Wiki** 好像现在大部分内容都是空的啊？

A：是的，目前进度只完成了 88%（重新统计于 2019.08），还远远称不上是一个合格的 Wiki。在过去的几个月里，主要添加的内容也比较基础。所以在这里进行征稿和招募，希望可以遇到有同样想法的朋友，我们一起把 **OI Wiki** 完善起来。

Q：为什么不直接去写 [中文维基](https://zh.wikipedia.org/) 呢？

A：因为我们希望可以真正帮到更多的选手或者对这些内容感兴趣的人，由于众所周知的原因，中文维基上的内容并不是无门槛就可以获取到的。

* * *

感谢你看到了最后，我们现在急需的，就是你的帮助。

 **OI Wiki** Team

2018.8

# polygon
## 简介

### 什么是 Polygon?

网址： <https://polygon.codeforces.com/> 

Polygon 是一个支持多人合作的出题平台，功能非常完善。

在 Codeforces (CF) 出题是必须使用 Polygon 的，在其它地方出题，尤其是多人合作出题时，使用 Polygon 也是不错的选择。

### 为什么要使用 Polygon？

-   有版本管理系统，多人合作时不会乱成一团，也不需要互相传文件。

-   出题系统完善，validator、generator、checker、solutions 环环相扣，输出自动生成。

-   可以为 solutions 设置标签，错解 AC、正解未 AC 都会警告，可以方便地逐一卡掉错解。

-   可以方便地对拍，拍出来的数据可以直接添加到题目数据中。

-   发现问题可以提 issue，而不会随着消息刷屏而一直没有 fix。

-   为日后出 CF 做准备。

-   ……

## 题目列表

题目列表中会显示一道题目的基本信息，如题面、题解撰写情况，数据造了多少，std、validator 和 checker 有没有设置。

可以双击题目列表的 "Name" 这一栏来写上 note，比如需要提醒自己做的事（need to add more tests/need to write tutorial），或者是这道题预订的 score distribution，可以根据自己的需要随意填写，当然也可以空着。

"Rev." 中的 "x/y" 的 x 指当前题目版本，y 指 package 的版本。如果两者不一样 y 会显示为红色。

"Edit session" 中的 "Start" 是指你的账号还没有看过这道题，"Continue (x) Discard" 是指你的账号处于这个题目的第 x 个版本，点击 "Start" 或 "Continue (x)" 就会进入题目管理界面，点击 "Discard" 会 **不可恢复地** 撤销你的所有更改，回到没有看过这题的状态。

如果你的账号上有一道题的更改没有提交，题目列表中这一整行就会变红。

## 题目管理

### 简述

Polygon 的大部分功能都不需要学，能看懂英文就基本能用了。

需要特别提醒的：

-   题面不能使用 Markdown，只能用 TeX。

-   Invocation 是用来测试 solution 的。

-   Stress 是用来对拍的。

-   数据在 Tests 中用 generator 造，generator 在 Files 中上传。

### General Info

在这个页面中可以设置题目的时间限制，空间限制，是否是交互题。

需要注意 "Statement description" 和 "Problem tutorial" 并不是用来写题面和题解的，这两个输入框可能是历史遗留原因。

### Statement

这个页面是用来写题面和题解的。还可以通过 "Review" 按钮来查看题面、validator 与 checker，一般用于审核。

题面和题解都需要使用 TeX 的语法，不能使用 Markdown。例如，需要使用 `\textbf{text}` 而不是 `**text**` 。但 Polygon 支持的实际上是 TeX 的一个非常小的子集，具体可以自己尝试。

可以通过最上方的 "In HTML" 链接查看渲染后的题面，通过 "Tutorial in HTML" 查看渲染后的题解。

如果需要在题面中添加图片，需要先在下面的 "Statement Resource Files" 中上传图片，然后在题面中加上 `\includegraphics{filename.png}` 。

### Files

"Source Files" 是用来存放 **除了 solutions 外** 的其它代码的，如 validator、checker、generator，如果是 IO 式交互题还有 interactor。

如果这些代码需要 include 其它文件，例如 [Tree-Generator](https://github.com/ouuan/Tree-Generator) ，需要放在 "Resource Files" 中。

grader 式交互参见 [官方教程](https://codeforces.com/blog/entry/66916) 。

### Checker

testlib.h 提供了一些内置的 checker，在选择框中有简要介绍，也可以选择后再点 "View source" 查看源码。

如果需要自己编写 checker，请参考 [checker 教程](./testlib/checker.md) 。

下面的 "Checker tests" 是通过 "Add test" 添加若干组输出以及对应的期望评测结果，然后点击 "Run tests" 就可以测试 checker 是否正确返回了评测结果。

### Interactor

仅 IO 式交互题需要，请参考 [interactor 教程](./testlib/interactor.md) 。

### Validator

validator 用来检测数据合法性，编写请参考 [validator 教程](./testlib/validator.md) 。

下面的 "Validator tests" 类似于 "Checker tests"，需要提供输入和期望是否合法，用来测试 validator。

### Tests

这个页面是用来管理数据的。

在 Polygon 上，推荐的做法是使用少量 **带命令行参数** 的 [generator](./testlib/generator.md) 来生成数据，而不是写一堆 generator 或者每生成一组数据都修改 generator。并且，只需要生成输入，输出会自动生成。

"Testset" 就是一个测试集，如果是给 CF 出题需要手动添加 "pretests" 这个 Testset，并且 "pretests" 需要是 "tests" 的子集。

"Add Test" 是手动添加一组数据，一般用于手动输入样例或较小的数据。虽然可以通过文件上传数据，但这是 **不推荐的** ，数据应该要么是手动输入的要么是使用 generator 在某个参数下生成的。

如果勾选了 "Use in statements"，这组数据就会成为样例，自动加在题面里。如果需要题面里显示的不是样例的输入输出（一般用于交互题），就可以点 "If you want to specify custom content of input or output data for statements click here"，然后输入你想显示在题面中的输入输出。

Tests 页面的下方是用来输入生成数据的脚本的，如 `generator-name [params] > test-index` 。可以使用 `generator-name [params] > $` ，就不用手动指定测试点编号了。

可以参考 [Polygon 提供的教程](https://polygon.codeforces.com/docs/freemarker-manual) 使用 Freemarker 来批量生成脚本。

"Preview Tests" 可以预览生成的数据。

### Stresses

这个页面是用来对拍的。

点击 "Add Stress" 就可以添加一组对拍，"Script pattern" 是一个生成数据的脚本，其中可以使用 "[10..100]" 之类的来表示在一个范围内随机选择。

然后运行对拍，如果拍出错就会显示 "Crashed"，并且可以一键把这组数据加到 Tests 中。

### Solution Files

这个页面是用来放解这道题的代码的，可以是正解也可以是错解，将错解传上来可以便捷地卡掉它们，也可以提醒自己需要卡掉它们。

### Invocations

这个页面是用来运行 solutions 的。

选择代码和测试点就可以运行了，之后可以在列表里点进去（"View"）查看详细信息。

评测状态 "FL" 表示评测出错了，一般是数据没有过 validate 或者 validator/checker/interactor 之类的 RE 了。"RJ" 有两种情况，一种是出现了 "FL"，另一种是这份代码第一个测试点就没有通过。

如果用时在时限的一半到两倍之间，会用黄色标识出来。

如果数据中存在变量没有达到最小值或最大值，会在最下方提醒。

### Issues

用来提 Issue 的地方。

### Packages

Package 包含了一道题的全部信息，在出 CF 时是 CF 评测的依据（例如，如果赛时要修锅，更新了 package 才会影响到 CF），其它时候可以用来导出。

"Verify" 是测试所有 solution 都符合标签（AC、WA、TLE），并且 checker 通过 checker tests，validator 通过 validator tests。

### Manage access

管理题目权限。

### 侧边栏

第一栏会显示一些基本信息，如果有哪里不符合规范（如 tests 没有包含 pretests、有重复的测试点）就会显示为黄色，鼠标移上去会显示具体信息。

"View changes" 可以看修改的历史记录。需要注意的是 "switch" 不能用来回退到某一个版本，只能在某个版本的基础上进行不产生冲突的修改，而这实际上是没有意义的，所以 switch 相当于是只读的。

"Update Working Copy" 是获取（他人的）更新。

"Commit Changes" 是提交你的更新。

commit 时如果有不合规范、需要警告的地方会列出来。

## 比赛管理

如果要出一场比赛，可以通过 "New Contest" 来创建比赛，就可以更加方便地管理题目。

比赛管理页面的题目列表右上角的 "Add problems?" 是把一道已有的题目加到比赛里。

侧边栏的 "New problem" 是新建一道题目加到比赛里。

上面的 "Manage problem access" 是查看每道题的权限，下面的 "Manage developers list" 是管理有这场比赛的权限的人。通过 "New problem" 创建一道题以及添加一个新的 developer 时会自动添加权限，但通过 "Add problems?" 加进来的题不会给已有的 developer 权限。

侧边栏还可以预览所有题面、所有题解、所有 validator & checker，下载整个比赛的 package，给题目重新编号。

## 注意事项

Polygon 虽然拥有版本管理系统，但是并没有冲突解决系统，一旦发生冲突就无法进入题目管理界面，只能撤销修改后手动重做。并且，只要修改了同一个文件，即使不是同一行也会发生冲突。

所以，使用 Polygon 时请与合作者保持沟通，commit 前保证没有其他人在修改。

# htc
在文章开始之前， **OI Wiki** 项目组全体成员十分欢迎您为本项目贡献页面。
正因为有了上百位像您一样的人，才有了 **OI Wiki** 的今天！
这篇文章将主要叙述一些在页面编辑过程中常见的问题，并给出相应的解决方案。
请您在撰稿或者修正 Wiki 页面以前，仔细阅读以下内容，以帮助您完成更高质量的内容。

如果您迫不及待想要快速上手，建议先阅读图片举例的章节。

## 如何参与协作

 **在开始编写一段内容之前，请查阅 [Issues](https://github.com/OI-wiki/OI-wiki/issues) ，确认没有别人在做相同的工作之后，** 

 **开个 [新 issue](https://github.com/OI-wiki/OI-wiki/issues/new) 记录你要编写的内容。** 

### 我之前没怎么用过 GitHub

参与 Wiki 的编写 **需要** 一个 GitHub 账号， **不需要** 高超的 GitHub 技巧。

举个栗子，假如我想要修改一个页面内容，应该怎么操作呢？

1.  在 OI Wiki 网站上找到对应页面。
2.  点击 正文右上方、目录左侧的 **“编辑此页”** <i class="md-icon">edit</i>按钮，在阅读了 [如何贡献](./htc.md) 后点击“开始编辑”按钮。
    </home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/!-- 3.  （应该已经跳转到了 GitHub 上的对应页面吧？）这时候右上方还会有一个 **“编辑此页”** <i class="md-icon">edit</i>的按钮，点击它就可以在线编辑了。 -->
3.  写好了之后点下方的绿色按钮（Propose file change），可能会提示没有权限。不必担心！GitHub 会自动帮你 fork 一份项目的文件并创建 Pull Request。
4.  之后点上方的绿色按钮（Create pull request）后，再点一下出现的绿色按钮（Create pull request）。
5.  提交之后就可以等待他人合并或者指出还要修改的地方，当然你也可以给他人的 PR 提出修改意见，或者只是点赞/踩。如果有消息，会有邮件通知和/或网页上的提醒（取决于在你个人 Settings 中的设置）。

（有木有很简单？）

如果还是不放心，可以参考 [这篇文章](https://juejin.im/entry/56e638591ea49300550885cc) ，或者试试 [Github 的官方教程](https://lab.github.com/) 。

### 我之前用过 GitHub

基本协作方式如下：

1.  Fork 主仓库到自己的仓库中。
2.  当想要贡献某部分内容时，请务必仔细查看 **Issues** ，以便确定是否有人已经开始了这项工作。当然，我们更希望你可以加入 QQ/Telegram 群组，方便交流。
3.  在决定将内容推送到本仓库时， **请你首先拉取本仓库代码进行合并，自行处理好冲突，同时确保在本地可以正常生成文档** ，然后再将分支 PR 到主仓库的 master 分支上。其中，PR 需要包含以下基本信息：

    标题：本次 PR 的目的（做了 **什么** 工作，修复了 **什么** 问题）；

    内容：如果必要的话，请给出对修复问题的叙述。如果修复了某个 issue 中的问题，请写上 `fix #xxxx` ，其中 `xxxx` 是 issue 的编号。

PR 标题示例：

-   修复了一个 bug（错误）
-   修复了动态 dp 页面的一个公式 typo（正确）
-   添加了新内容（错误）
-   为时间复杂度页面添加了证明（正确）

### 协作流程

1.  在收到一个新的 Pull Request 之后，GitHub 会给 reviewer 发送邮件
2.  与此同时，在 [Travis CI](https://travis-ci.org/OI-wiki/OI-wiki) 和 [Netlify](https://app.netlify.com/sites/oi-wiki) 上会运行两组测试，他们会把进度同步在 PR 页面的下方。Travis CI 主要是用来确认 PR 中内容的修改不会影响到网站构建的进程；Netlify 是用来把 PR 中的更新构建出来，方便 reviewer 审核（在测试完成后点击 Details 可以了解更多）
3.  在足够多 reviewer 投票通过一个 PR 之后，这个 PR 才可以合并到 master 分支中
4.  在合并到 master 分支之后，会在 Travis CI 上重新构建一遍网站内容，并更新到 gh-pages 分支
5.  这时服务器才会拉取 gh-pages 分支的更新，并重新部署最新版本的内容

## 贡献文档要求

当你打算贡献某部分的内容时，你应该尽量熟悉以下三部分：

-   文档存储的格式；
-   文档的合理性；
-   文档内容满足 remark-lint 和 $\mathrm \LaTeX$ 公式的格式要求。

## 文档存储的格式

1.   **文件名请务必都小写，以 `-` 分割，如 `file-name` 。** 
2.  请务必确保您的文档中引用的 **外链** 图片已经全部转存到了 **本库内** 对应的 `images` 文件夹中（防止触发某些网站的防盗链），建议处理成 `MD 文档名称 + 编号` 的形式（可参考已有文档中图片的处理方式）；（即格式为 `/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/xx.jpg)` ）。
3.  请确保您的文档中的引用链接的稳定性， **不推荐** 引用 **自建** 服务（如 OJ）中的资源（如题目）。
4.  站内链接请去掉网站域名，并且使用相对路径链接对应 `.md` 文件。如：在本页面（ `intro/htc` ）中链接杂项简介（ `misc` ），应使用 `[杂项简介](../misc/index.md)` 。

## 文档的合理性

所谓合理性，指所编写的 **内容** 必须具有如下的特性：

-   由浅入深，内容的难度应该具有渐进性。
-   逻辑性，对于每类内容的撰写应该尽量包含以下的内容：
    -   原理，说明该内容对应的原理；
    -   例子，给出 1 ~ 2 个典型的例子；
    -   题目，在该标题下， **只需要给出题目名字、题目链接** 。（题目链接 OJ 优先级：原 OJ（国外 OJ 要求国内可流畅访问）> UOJ > LOJ > 洛谷 > BZOJ）

除现有内容质量较低的情况外，建议尽量从 **补充** 的角度来做贡献，而非采取直接覆盖的方式。如果拿不准主意，可以加群讨论细节。

## 基本格式要求

### Remark-lint 的格式要求

 [remark-lint](https://github.com/remarkjs/remark-lint) 可以自动给项目内文件统一风格，我们现在启用的配置文件在 [.remarkrc](https://github.com/24OI/OI-wiki/blob/master/.remarkrc) 。

在配置过程中我们也遇到了一些 remark-lint 不能很好处理的问题：

1.  不要在页面中添加 `<h1>` 或者 `# 标题` 。
2.   `## 简介` 标题要空一格（英文半角空格），也不要写成 `## 简介 ##` 。
3.  列表：
    1.  列表前要有空行，新开一段；
    2.   `1. 例子` 点号后要有空格。
4.  行间公式前后各要有一行空行，否则会被当做是行内公式。
5.  涉及到目录的更改的时候：
    1.  需要改动 `mkdocs.yml` ；
    2.  请注意如果影响到作者信息统计，麻烦更新 [author 字段](faq.md#_11) ；（不改动目录的时候不需要维护 author 字段）
    3.  需要在项目内搜索一下是否有内链需要更新。
    4.  如果造成了死链，麻烦更新 [重定向文件](https://github.com/OI-wiki/OI-wiki/blob/master/docs/_redirects) 。详见 [重定向文件](faq.md#_12) 。
6.  使用 `???` 或 `/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/!/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/!/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/!` 开头的 Details 语法时，需要注意：开头至少有四个空格的行才会被当做是在 Details 语法的文本框中。
7.  代码样式的纯文本块请使用 ```` ```text```` ，直接使用 ```` ``` ```` 可能导致内容被错误地缩进。

### 标点符号的使用

1.  请在每句话的末尾添加 **句号** ；
2.  请正确使用标点符号，注意区分 **全角** 符号与 **半角** 符号的使用（汉语请使用全角符号，英语请使用半角符号）；
3.  注意 **逗号** 的使用（应当使用顿号却使用了逗号等等）；
4.  注意 **括号** 的位置；
5.  请特别注意，我们通常习惯使用 `「` 与 `」` 来提高 **中文引号** 的辨识度，同时也常用 **分号** 来表示列表环境中各复句之间的关系。

请参考下面的例子更好地使用标点符号：

> -   中学生学科竞赛主要包括信息学奥林匹克竞赛、信息学奥林匹克竞赛、信息学奥林匹克竞赛、信息学奥林匹克竞赛和信息学奥林匹克竞赛（我就是这个样，你来打我啊）。
> -   “你吃了吗？”，李四问张三。
> -   我想对你说：“我真是太喜欢你了。”
> -   「苟利国家生死以，岂因祸福避趋之！」
> -   推荐题目：「LOJ #104 普通平衡树」
> -   以下是这个算法的基本流程：
>     -   第一步，初始化到各点的距离为无穷大，将所有点设置为未被访问过，初始化一个队列；
>     -   第二步，将起点放入队列，将起点设置为已被访问过，更新到起点的距离为 $0$ ；
>     -   第三步，取出队首元素，将该元素设置为未被访问过；
>     -   第四步，遍历所有与此元素相连的边，若到这个点存在更短的距离，则进行松弛操作；
>     -   第五步，若这个点未被访问过，则将这个点放入队列，且设置这个点为已经访问过；
>     -   第六步，回到第三步，直到队列为空。

### LaTeX 公式的格式要求

LaTeX 作为公式排版的首选，我们应当正确地使用它。因此对于 LaTeX 的使用我们有严格的要求。如果您想要快速上手，可以阅读本章节末给出的表格。

1.  首先从使用 Roman 体表示常量和函数做起。LaTeX 已经预先定义好了一些常见的常量、函数、运算符等，我们可以直接调用，包括但不限于：

    ```latex
    \log, \ln, \lg, \sin, \cos, \tan, \sec, \csc, \cot, \gcd, \min, \max, \exp, \inf, \mod, \bmod, \pmod
    ```

    所以在输入常量、函数名、运算符等时，请先检查一下是否应该使用 Roman 体或其它字体，LaTeX 符号的书写可参考 [此页](https://katex.org/docs/supported.html) 内容（不是全部），也可以百度求解。

    如果遇到没有预先定义好的需要使用 Roman 体的 **函数名** ，我们可以使用 `$\operatorname{something}$` 来产生，如我们可以使用 `$\operatorname{lcm}$` 产生正体的最小公倍数（函数）符号。同理，产生 Roman 体的 **常量** 应用 `$\mathrm{}$` ；产生 Roman 体粗体符号应用 `$\mathbf{}$` ；产生 Italic 体粗体符号应用 `$\boldsymbol{}$` （如向量 $\boldsymbol{a}$ ）。其他非数学内容，包括英文、特殊符号等，一律使用 `$\text{}$` 。中文我们则建议不放在 LaTeX 公式中。

2.  在行内使用分数的时侯，请使用 `$\dfrac{}{}$` 。比如 `$\dfrac{1}{2}$` ，效果 $\dfrac{1}{2}$ ，而不是 `$\frac{1}{2}$` ，效果 $\frac{1}{2}$ 。尽可能避免在行内使用巨运算符（指 $\sum$ ， $\prod$ ， $\int$ 等）。

3.  在不会引起歧义的情况下，请用 `$\times$` 代替星号，叉乘请使用 `$\times$` ，点乘请使用 `$\cdot$` 。如 $a\times b$ , $a\cdot b$ ，而不是 $a\ast b$ 。

4.  请用 `$\cdots$` （居于排版基线与顶线中间）， `$\ldots$` （居于排版基线的位置）， `$\vdots$` （竖着的省略号）代替 `$...$` 。如 $a_1,a_2,\cdots a_n$ ，而不是 $a_1,a_2,... a_n$ 。

5.  请注意，不要在非代码区域使用任何程序设计语言的表示方式，而是使用 LaTeX 公式。例如，使用 `$=$` 而不是 `$==$` （如 $a=b$ ，而不是 $a==b$ ）、使用 `` `a<<1` `` 或者 `$a\times 2$` 而不是 `$a<<1$` 、使用 `$a\bmod b$` 代替 `$a\%b$` （如 $a\bmod b$ ，而不是 $a\%b$ ）等。

6.  公式中不要使用中括号连缀（即 C++ 高维数组的表示方式）而多使用下标。即 $a_{i,j,k}$ 而不是 $a[i][j][k]$ 。在公式中下标较复杂的情况下建议改用多元函数（ $f(i,j,k)$ ）或内联代码格式。对于一元简单函数使用 `$f_i$` 、 `$f(i)$` 或 `$f[i]$` 均可。

7.  为了统一且书写方便，复杂度分析时大 $O$ 记号请直接使用 `$O()$` 而不是 `$\mathcal O()$` 。

8.  请不要滥用 LaTeX 公式。这不仅会造成页面加载缓慢（因为 MathJax 的效率低是出了名的），同时也会导致页面的排版混乱。我们通常使用 LaTeX 公式字体表示变量名称。我们的建议是，如非必要，尽量减少公式与普通正文字体的 **大量** 混合使用，如非必要，尽量不要使用公式，如：

           我们将要学习 $Network-flow$ 中的 $SPFA$ 最小费用流，需要使用 $Edmonds-Karp$ 算法进行增广。

    就是一个典型的 **滥用公式字体** 的例子。（在页面中使用斜体请用 `*文本*` 表示。）

9.  请正确使用对应的 LaTeX 符号，尤其是公式中的希腊字母等特殊符号。如欧拉函数请使用 `$\varphi$` ，圆的直径请使用 `$\Phi$` ，黄金分割请使用 `$\phi$` 。这些符号虽然同样表示希腊字母 Phi，但是在不同的环境下有不同的含义。切记 **不要使用输入法的插入特殊符号** 来插入这种符号。

    另外，由于 LaTeX 历史原因，空集的符号应为 `$\varnothing$` 而不是 `$\emptyset$` ；由于近百年来数学符号演变，定义集合符号应使用 **人民教育出版社 A 版** 书写的版本，即 实数集 `$\mathbf{R}$` ，正整数集 `$\mathbf{N}^*$` 等。同理，其他的符号按照中国国内最常使用的版本来书写，重点参照数学和信息技术课本。

我们可以使用一个表格来总结一下上述内容。注意本表格没有举出所有符号的用法，只给出常见的错误。类似的情况类比即可。

| 不符合规定的用法            | 渲染效果              | 符合规定的用法                                    | 渲染效果                                        |
| ------------------- | ----------------- | ------------------------------------------ | ------------------------------------------- |
|  `$log, ln, lg$`    |  $log, ln, lg$    |  `$\log$, $\ln$, $\lg$`                    |  $\log$ , $\ln$ , $\lg$                     |
|  `$sin, cos, tan$`  |  $sin, cos, tan$  |  `$\sin$, $\cos$, $\tan$`                  |  $\sin$ , $\cos$ , $\tan$                   |
|  `$gcd, lcm$`       |  $gcd, lcm$       |  `$\gcd$, $\operatorname{lcm}$`            |  $\gcd$ , $\operatorname{lcm}$              |
|  `$ 小于 a 的质数 $`     |  $小于 a 的质数$       |  `小于 $a$ 的质数`                              | 小于 $a$ 的质数                                  |
|  `$...$`            |  $...$            |  `$\cdots$, $\ldots$, $\vdots$, $\ddots$`  |  $\cdots$ , $\ldots$ , $\vdots$ , $\ddots$  |
|  `$a*b$` （两个数相乘）    |  $a*b$            |  `$a\times b$, $a\cdot b$`                 |  $a\times b$ , $a\cdot b$                   |
|  `$SPFA$` （英文名称）    |  $SPFA$           |  `SPFA`                                    | SPFA                                        |
|  `$a==b$`           |  $a==b$           |  `$a=b$`                                   |  $a=b$                                      |
|  `$f[i][j][k]$`     |  $f[i][j][k]$     |  `$f_{i,j,k}$, $f(i,j,k)$`                 |  $f_{i,j,k}$ , $f(i,j,k)$                   |
|  `$R,N^*$` （集合）     |  $R,N^*$          |  `$\mathbf{R}$, $\mathbf{N}^*$`            |  $\mathbf{R}$ , $\mathbf{N}^*$              |
|  `$\emptyset$`      |  $\emptyset$      |  `$\varnothing$`                           |  $\varnothing$                              |

### Markdown 格式与主题扩展格式要求

1.  请注意您的文档结构。文档结构应当是十分条理的，具有清晰的层次的。请不要让诸如「五级标题」这种事情再次发生了，一篇正常的文章是用不到如此复杂的结构层次的。

2.  表示强调时请使用 `**SOMETHING**` 而非某级标题，因为使用标题会导致文章结构层次混乱和（或）目录出现问题。

3.  请正确使用 Markdown 的区块功能，插入行内代码请使用一对反引号包围代码区块，行间代码请使用一对 ```` ``` ```` 包围代码区块，其中反引号就是键盘左上角波浪线下面那个符号，行间代码请在第一个 ```` ``` ```` 的后面加上语言名称（如： ```` ```cpp```` ）。

4.  所有用作序号的数字建议使用中文，如：

    -   数列的第一项；
    -   输入文件的第一行。

5.  我们建议使用主题扩展的 `???+note` 格式来描述题面。具体格式如下：

    ```text
    ???+note "标题"
    	内容
    	多行内容

    ??? note "标题"
        内容
        多行内容
    ```

    两种格式的区别是，带 `+` 的会默认保持展开，而不带 `+` 的会默认保持折叠。效果可以参考图例的例 7。

    如果需要嵌套折叠框，推荐使用 [MDUI 的阴影样式](https://www.mdui.org/docs/shadow#use) ，提高内层折叠框的海拔。

     **OI Wiki** 支持 `.mdui-shadow-[0-24]` ，一般情况下最多用到两层折叠框，外层用 `note` 即可（其实就是 `mdui-shadow-2` ），内层推荐使用 `mdui-shadow-6` 。

    示例：

    ````text
    ??? note "题解"
        内容

        ??? mdui-shadow-6 "参考代码"
            ```cpp
            代码
            ```
    ````

如果对 mkdocs-material（我们使用的这个主题）还有什么问题，还可以查阅 [MkDocs 使用说明](https://github.com/ctf-wiki/ctf-wiki/wiki/Mkdocs-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E) 和 [cyent 的笔记](https://cyent.github.io/markdown-with-mkdocs-material/) ，前者介绍了 mkdocs-material 主题的插件使用方式，而后者介绍了 Markdown 传统语法和 mkdocs-material 支持的扩展语法。

### 伪代码格式

伪码具体格式没有严格要求，请参考算法导论或学术论文，注意不要写成 Python。

Wiki 内使用 LaTeX 书写伪码，整体处于 array 环境中，缩进使用 `$\qquad$` ，文字描述使用 `$\text$` ，关键字使用 `$\textbf$` ，赋值使用 `$\gets$` 。

参考示例：

$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{The edges of the graph } e , \text{ where each element in } e \text{ is } (u, v, w) \\
  &  \text{ denoting that there is an edge between } u \text{ and } v \text{ weighted } w . \\
2 &  \textbf{Output. } \text{The edges of the MST of the input graph}.\\
3 &  \textbf{Method. } \\ 
4 &  result \gets \varnothing \\
5 &  \text{sort } e \text{ into nondecreasing order by weight } w \\ 
6 &  \textbf{for} \text{ each } (u, v, w) \text{ in the sorted } e \\ 
7 &  \qquad \textbf{if } u \text{ and } v \text{ are not connected in the union-find set } \\
8 &  \qquad\qquad \text{connect } u \text{ and } v \text{ in the union-find set} \\
9 &  \qquad\qquad  result \gets result\;\bigcup\ \{(u, v, w)\} \\
10 &  \textbf{return }  result
\end{array}
$$

```latex
$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{The edges of the graph } e , \text{ where each element in } e \text{ is } (u, v, w) \\
  &  \text{ denoting that there is an edge between } u \text{ and } v \text{ weighted } w . \\
2 &  \textbf{Output. } \text{The edges of the MST of the input graph}.\\
3 &  \textbf{Method. } \\ 
4 &  result \gets \varnothing \\
5 &  \text{sort } e \text{ into nondecreasing order by weight } w \\ 
6 &  \textbf{for} \text{ each } (u, v, w) \text{ in the sorted } e \\ 
7 &  \qquad \textbf{if } u \text{ and } v \text{ are not connected in the union-find set } \\
8 &  \qquad\qquad \text{connect } u \text{ and } v \text{ in the union-find set} \\
9 &  \qquad\qquad  result \gets result\;\bigcup\ \{(u, v, w)\} \\
10 &  \textbf{return }  result
\end{array}
$$
```

## 图解

可能上述要求把握起来有些困难，接下来我们给出一些图片来具体分析哪种格式应该使用，哪种不该使用：

### 例 1

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/htc-1.png)

将复杂的 LaTeX 公式使用行间格式，可以使得页面错落有致。但 **OI Wiki** 作为一个以中文为主体的站点，我们希望大部分纲领性的信息（如标题）尽量使用中文（除英文专有名词）。

### 例 2

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/htc-2.png)

较复杂度的 LaTeX 公式请注意等号的对齐，同时可以适当引用 Wiki 的页面 **链接** 来完善内容。

### 例 3

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/htc-4.png)

一般情况下，我们建议将引用的资料在页面末位罗列。同时一定要避免使用 LaTeX 公式表达代码，上图中两个中括号就是不规范的写法。我们建议使用 `dp(i,j)` 或者 `dp_{i,j}` 。

### 例 4

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/htc-5.png)

注意我们描述 **乘法** 的时侯一般使用 `\times` 或者 `\cdot` ，特殊情况（如卷积）下会使用 `*` （也可以写成 `\ast` ）。标题是简洁的词组，但我们不希望正文部分由词组拼凑而成。上图中“两个要素”，建议更改为“动态规划的原理具有以下两个要素”，上下文保持连贯。可取的地方是，适当使用 **有序** 列表可以更有条理地表述内容，同时注意，在使用列表的时侯，每一项如果是一句话，需要在末位添加 **标点符号** 。通常是添加分号，在最后一项末位添加句号。

### 例 5

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/htc-6.png)

适当引用 **图片** 可以增强文章易读性，使用 **伪代码** 的方式表达算法过程可以方便又简洁地描述算法过程，相比于直接贴模板代码更加好懂。（伪代码格式已更新，现在书写伪代码请参考新的伪代码格式。）

### 例 6

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/htc-7.png)

同样的问题，标题使用英文。并且在使用完括号后没有句号。另外，上图中的行间公式虽然没有使用艾弗森括号，但是由于下标嵌套过多，使得最底层的下标字体很小，整个公式也并不美观。建议将 `son_{now,i}` 更换为 `son(now,i)` ，或者把 `f_{now}` 替换为 `f(now)` 。我们希望尽量控制下标嵌套在两层以内（上标的运用主要是数学表达式，因此可以允许多次嵌套，如 $2^{2^{2^{2^{\cdots}}}}$ ，《上帝造题的七分钟》）。

### 例 7

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/htc-8.png)

使用 MkDocs 扩展语法，让例题题面与算法描述区分开。将代码折叠，可以让文章更紧凑。（毕竟看 Wiki 的大多数是了解思路，除了模板代码需要阅读外，习题的代码大多可以折叠）。在描述函数操作时，使用行内代码和 LaTeX 公式都是不错的选择。

### 例 8

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/htc-9.png)

在文末罗列出参考文献，可以使页面的内容更严谨，真实可信。

# roadmap


# common-tricks
本页面主要分享一下在竞赛中的小技巧。

## 利用局部性

局部性是指程序倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。局部性分为时间局部性和空间局部性。

-   消除循环中的低效率，比如遍历字符串的时候：
    ```cpp
    for (int i = 0; i < strlen(s); ++i)
      ;
    // 不如
    int len = strlen(s);
    for (int i = 0; i < len; ++i)
      ;
    ```
-   循环展开。通过适当的循环展开可以减少整个计算中关键路径上的操作数量
    ```cpp
    for (int i = 0; i < n; ++i) {
      res = res OP a[i];
    }
    // 不如
    int i;
    for (i = 0; i < n; i += 2) {
      res = res OP a[i];
      res = res OP a[i + 1];
    }
    for (; i < n; ++i) {
      res = res OP a[i];
    }
    ```
-   重新结合变换，增加了可以并行执行的运算数量
    ```cpp
    for (int i = 0; i < n; ++i) res = (res OP a[i])OP a[i + 1];
    // 不如
    for (int i = 0; i < n; ++i) res = res OP(a[i] OP a[i + 1]);
    ```

## 循环宏定义

我们写代码时，像下面这样的循环代码写得会非常多：

```cpp
for (int i = 0; i < N; i++) {
}
```

为了简化这样的循环代码，我们可以使用宏定义：

```cpp
#define f(x, y, z) for (int x = (y), __ = (z); x < __; ++x)
```

这样写循环代码时，就可以简化成 `f(i, 0, N)` 。例如：

```cpp
// a is a STL container
f(i, 0, a.size()) { ... }
```

另外推荐一个比较有用的宏定义：

```cpp
#define _rep(i, a, b) for (int i = (a); i <= (b); ++i)
```

> 注：参考《算法竞赛入门经典 习题与解答》

## 善用 namespace

使用 namespace 能使程序可读性更好，便于调试。

??? note "示例代码"
    ```cpp
    // NOI 2018 屠龙勇士 40分部分分代码
    #include <algorithm>
    #include <cmath>
    #include <cstring>
    #include <iostream>
    using namespace std;
    long long n, m, a[100005], p[100005], aw[100005], atk[100005];
    namespace one_game {
    //其实namespace里也可以声明变量
    void solve() {
      for (int y = 0;; y++)
        if ((a[1] + p[1] * y) % atk[1] == 0) {
          cout << (a[1] + p[1] * y) / atk[1] << endl;
          return;
        }
    }
    }  // namespace one_game
    namespace p_1 {
    void solve() {
      if (atk[1] == 1)  // solve 1-2
      {
        sort(a + 1, a + n + 1);
        cout << a[n] << endl;
        return;
      } else if (m == 1)  // solve 3-4
      {
        long long k = atk[1], kt = ceil(a[1] * 1.0 / k);
        for (int i = 2; i <= n; i++)
          k = aw[i - 1], kt = max(kt, (long long)ceil(a[i] * 1.0 / k));
        cout << k << endl;
      }
    }
    }  // namespace p_1
    int main() {
      int T;
      cin >> T;
      while (T--) {
        memset(a, 0, sizeof(a));
        memset(p, 0, sizeof(p));
        memset(aw, 0, sizeof(aw));
        memset(atk, 0, sizeof(atk));
        cin >> n >> m;
        for (int i = 1; i <= n; i++) cin >> a[i];
        for (int i = 1; i <= n; i++) cin >> p[i];
        for (int i = 1; i <= n; i++) cin >> aw[i];
        for (int i = 1; i <= m; i++) cin >> atk[i];
        if (n == 1 && m == 1)
          one_game::solve();  // solve 8-13
        else if (p[1] == 1)
          p_1::solve();  // solve 1-4 or 14-15
        else
          cout << -1 << endl;
      }
      return 0;
    }
    ```

## 善用标识符进行调试

我们在本地测试的时候，往往要加入一些调试语句。要提交到 OJ 的时候，就要把他们全部删除，有些麻烦。

我们可以通过定义标识符的方式来进行本地调试。

大致的程序框架是这样的：

```cpp
#define DEBUG
#ifdef DEBUG
// do something
#endif
// or
#ifndef DEBUG
// do something
#endif
```

 `#ifdef` 会检查程序中是否有通过 `#define` 定义的对应标识符，如果有定义，就会执行下面的内容， `#ifndef` 恰恰相反，会在没有定义相应标识符的情况下执行后面的语句。

我们提交程序的时候，只需要将 `#define DEBUG` 一行注释掉即可。

当然，我们也可以不在程序中定义标识符，而是通过 `-DDEBUG` 的编译选项在编译的时候定义 `DEBUG` 标识符。这样就可以在提交的时候不用修改程序了。

不少 OJ 都开启了 `-DONLINE_JUDGE` 这一编译选项，善用这一特性可以节约不少时间。

## 对拍

有的时候我们写了一份代码，但是不知道它是不是正确的。这时候就可以用对拍的方法来进行检验或调试。

什么是对拍呢？具体而言，就是通过对比两个程序的输出来检验程序的正确性。你可以将自己程序的输出与其他程序（打的暴力或者其他 dalao 的标程）的输出进行对比，从而判断自己的程序是否正确。

当然，对拍过程要多次进行，我们需要通过批处理的方法来实现对拍的自动化。

具体而言，我们需要一个数据生成器，两个要进行对拍的程序。

每次运行一次 [数据生成器](../topic/problemsetting/#_17) ，将生成的数据写入输入文件，通过重定向的方法使两个程序读入数据，并将输出写入指定文件，利用 Windows 下的 `fc` 命令比对文件（Linux 下为 `diff` 命令），从而检验程序的正确性。

如果发现程序出错，可以直接利用刚刚生成的数据进行调试啦。

对拍程序的大致框架如下：

```cpp
#include <stdio.h>
#include <stdlib.h>
int main() {
  // For Windows
  //对拍时不开文件输入输出
  //当然，这段程序也可以改写成批处理的形式
  while (1) {
    system("gen > test.in");  //数据生成器将生成数据写入输入文件
    system("test1.exe < test.in > a.out");  //获取程序1输出
    system("test2.exe < test.in > b.out");  //获取程序2输出
    if (system("fc a.out b.out")) {
      //该行语句比对输入输出
      // fc返回0时表示输出一致，否则表示有不同处
      system("pause");  //方便查看不同处
      return 0;
      //该输入数据已经存放在test.in文件中，可以直接利用进行调试
    }
  }
}
```

## <span id="mempool">内存池</span>

当我们需要动态分配内存的时候，频繁使用 new/malloc 会占用大量的时间和空间，甚至生成大量的内存碎片从而降低程序的性能，可能会使原本正确的程序 TLE/MLE。

这时候我们就需要使用到「内存池」这种技巧：在真正使用内存之前，先申请分配一定大小的内存作为备用，当需要动态分配时则直接从备用内存中分配一块即可。

当然在大多数 OI 题当中，我们可以预先算出需要使用到的最大内存并一次性申请分配。

如申请动态分配 $32$ 位有符号整数数组的代码：

```cpp
inline int* newarr(int sz) {
  static int pool[maxn], *allocp = pool;
  return allocp += sz, allocp - sz;
}
```

线段树动态开点的代码：

```cpp
inline Node* newnode() {
  static Node pool[maxn << 1], *allocp = pool - 1;
  return ++allocp;
}
```

注：本页面 [部分内容](https://github.com/24OI/OI-wiki/commit/e9fa69af9d7f1583cb5ddad837c04bb1b03d7939) 最初发表于 [洛谷日报 #86](https://studyingfather.blog.luogu.org/some-coding-tips-for-oiers) ，由原作者整理并搬运至此，略有删改。

# non-trad
author: Ir1d, hsfzLZH1, CBW2007, Xeonacid, H-J-Granger, kawa-yoiko

## 导语

我们知道，通过提交程序、由评测机输入数据并判断输出数据的题目叫传统题。而 OI 发展迅速，普通的传统题已经不能满足我们的所有需求，所以在近几年，有几种非传统题慢慢进入大家的视野。

## 提交答案题

提交答案题，顾名思义，就是直接提交答案的题目。该种题目一般会给你输入文件，然后要求提交包含有 XXX1.out、XXX2.out、XXX3.out......XXXn.out 的压缩包、文件夹或纯文件。评测机做的事情就很简单了：比较答案文件与标准答案即可。

做这种题目一般有两种方法：

1.  手玩。这种方法简单粗暴，但是遇到较大的数据就没辙了。
2.  编写一个程序来获得答案文件。

## 交互题

在交互题中，选手程序需要通过与测评程序交互来完成任务。一类常见的情形是，选手程序向测评程序发出询问，并得到其反馈。测评程序可能对选手的询问作出限制，或调整应答策略来尽可能增加询问次数，这也给题目带来了更多变化。

交互方式主要有如下两种。虽然技术上有不小的差异，但在考察算法的本质上它们并没有实际区别。

### STDIO 交互

STDIO 交互（标准 I/O 交互）是 Codeforces、AtCoder 等在线平台的交互手段，也是 ICPC 系列赛事中的标准。 [LOJ #559.「LibreOJ Round #9」ZQC 的迷宫](https://loj.ac/problem/559) 是一道典型的 STDIO 交互题。 [这里](https://codeforces.com/blog/entry/45307) 是 Codeforces 的一个更加简要的说明。

对于这类题目，选手只需像往常一样将询问写到标准输出， **刷新输出缓冲** 后从标准输入读取结果。选手程序刷新输出缓冲后，通过管道连接它的测评程序（称为交互器）才能立刻接收到这些数据。在 C/C++ 中， `fflush(stdout)` 和 `std::cout << std::flush` 可以实现这个操作；Pascal 则是 `flush(output)` 。

### Grader 交互

Grader 交互方式常见于 IOI、APIO 等国际 OI 赛事（特别是 CMS 平台的竞赛）。 [UOJ #206.【APIO2016】Gap](https://uoj.ac/problem/206) 是一道典型的 grader 交互题。

对于这类题目，选手只需编写一个特定的函数完成某项任务，它通过调用给定的若干辅助函数来进行交互。为了便于选手在本地测试，题目会下发一个头文件与一个参考测评程序 `grader.cpp` （对于 Pascal 语言是一个库 `graderlib` ），选手将自己的程序与 `grader.cpp` 一同编译方可得到可执行文件。

```sh
g++ grader.cpp my_solution.cpp -o my_solution -Wall -O2
./my_solution   # 执行程序
```

编译得到的程序表现与传统题程序类似。它会打开固定的文件，以固定的格式读取数据，调用选手编写的函数，并将结果和若干信息（例如询问的次数、答案正确性）显示在标准输出上。

实际测评时，选手的程序会与一个不同的 `grader.cpp` 编译。这个 `grader.cpp` 将以类似的方式调用选手编写的函数，并记录其得分。一般来说，这个版本的 `grader.cpp` 所有全局符号都会设为 `static` ，也即不能通过冲突命名的方式破解它，但是任何尝试突破 grader 限制的行为都是会导致 disqualification 的哦。

### 差别

STDIO 交互的一个明显优势在于它可以支持任何编程语言，但是输入输出的耗时容易成为问题设计的瓶颈，导致有时无法区分程序的时间效率差别。而 grader 交互则恰好相反，由于函数调用的开销不大，常常可以允许 $10^6$ 数量级的询问次数，但是语言的限制是其短板。

如果自己设计题目或举办比赛，就要记得权衡这些啦。

## 通信题

在通信题中，选手需要编写 **两个** 程序，合作完成某项任务。第一个程序接收问题的输入，并产生某些输出；第二个程序的输入会与第一个的输出相关（有时是原封不动地作为一个参数，有时会由评测端处理得到），它需要产生问题的解。 [UOJ #178. 新年的贺电](https://uoj.ac/problem/178) 和 [#454.【UER #8】打雪仗](https://uoj.ac/problem/454) 都是典型的通信题。

本地测试的方法由于题目设定的不同而多种多样，常用的如：

-   手工输入
-   编写一个辅助程序，转换第一个程序的输出到第二个程序的输入
-   用双向管道将两个程序的标准输入/输出连接起来

由于评测平台对于通信题的支持有限，因而目前为止通信题只常见于 IOI 系列赛和 UOJ 等少数在线平台举办的比赛，仍是一个有待探索的领域。期待着在未来，通信题能带来更多全新的挑战和新鲜的 idea。

## 函数补全题

函数补全题，当然就是补全函数啦！这种题通常有一下几种情况：

-   会给你一个程序，并告知你的函数将被嵌入在哪里。
-   不给出程序，而将输入信息作为你的函数的参数。

其实你可以理解为一道交互题中，你变成了编写前面讲到的辅助函数，而选手代码就是给出的程序。

这种题在 [LeetCode](https://leetcode.com/) 、 [PTA - 拼题 A](https://pintia.cn/problem-sets) 上比较多见，没见过的可以去看一看。

## 其他类型

比如说 [Quine](https://loj.ac/problem/4) ，这道题要求的是编写一个程序使得你的程序能够输出它本身（要求程序包含可见字符）。

这是一道经典题，但是在绝大多数 OJ 上都很难实现。

# oj-tool
## cf-tool

GitHub 地址： [xalanq/cf-tool](https://github.com/xalanq/cf-tool/) 

cf-tool 是 Codeforces 的命令行界面的跨平台（支持 Windows、Linux、OS X）工具，其支持很多常用操作。

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/cf-tool1.jpg)

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/cf-tool2.jpg)

### 特点

-   支持 Codeforces 中的所有编程语言。
-   支持 contests 和 gym。
-   提交代码。
-   动态刷新提交后的情况。
-   拉取问题的样例。
-   本地编译和测试样例。
-   拉取某人的所有代码。
-   从指定模板生成代码（包括时间戳，作者等信息）。
-   列出某场比赛的所有题目的整体信息。
-   用默认的网页浏览器打开题目页面、榜单、提交页面等。
-   丰富多彩的命令行。

### 下载

前往 [cf-tool/releases](https://github.com/xalanq/cf-tool/releases) 下载最新版。

之后的更新可以直接使用 `upgrade` 命令获取。

### 使用

将下载好的可执行文件 `cf` （或者 `cf.exe` ）放置到合适的位置后（见常见问题的第二条），然后打开命令行，用 `cf config` 命令来配置一下用户名、密码和代码模板。

### 例子

以下简单模拟一场比赛的流程。

 `cf race 1136` 

要开始打 1136 这场比赛了！其中 1136 可以从比赛的链接获取，比方说这个例子的比赛链接就为 <https://codeforces.com/contest/1136> 。

如果比赛还未开始，则该命令会进行倒计时。比赛已开始或倒计时完后，工具会自动用默认浏览器打开比赛的所有题目页面，并拉取样例到本地。

 `cd 1136/a` 

进入 A 题的目录，此时该目录下会包含该题的样例。

 `cf gen` 

用默认模板生成一份代码，在这里不妨设为 `a.cpp` 。

 `vim a.cpp` 

用 Vim 写代码（或者用其他的编辑器或 IDE 进行）。

 `cf test` 

编译并测试样例。

 `cf submit` 

提交代码。

 `cf list` 

查看当前比赛各个题目的信息。

 `cf stand` 

用浏览器打开榜单，查看排名。

### 常见问题

1.  我双击了这个程序但是没啥效果

    cf-tool 是命令行界面的工具，你应该在终端里运行这个工具。

2.  我无法使用 `cf` 这个命令

    你应该将 `cf` 这个程序放到一个已经加入到系统变量 PATH 的路径里（比如说 Linux 里的 `/usr/bin/` )。

    或者你直接去搜 "怎样添加路径到系统变量 PATH"。

3.  如何加一个新的测试数据

    新建两个额外的测试数据文件 `inK.txt` 和 `ansK.txt` （K 是包含 0~9 的字符串）。

4.  在终端里启用 tab 补全命令

    使用这个工具 [Infinidat/infi.docopt_completion](https://github.com/Infinidat/infi.docopt_completion) 即可。

    注意：如果有一个新版本发布（尤其是添加了新命令），你应该重新运行 `docopt-completion cf` 。

## Codeforces Visualizer

网站： <https://cfviz.netlify.com/> 。

您可以在 [GitHub](https://github.com/sjsakib/cfviz/) 上查阅到它的源代码。

这个网站有三个功能：

-   用炫酷的图表来可视化某个用户名的各种信息（比如通过题目的难度分布）。
-   对比两个用户。
-   计算一场比赛的 Rating 预测。

大家可以自行尝试一下。

## Competitive companion

网站： <https://github.com/jmerle/competitive-companion> 

功能介绍：

-   这个工具是一个浏览器插件 用来解析网页里面的测例数据
-   支持解析几乎所有的主流 oj 平台（比如 codeforces atcoder）

推荐理由：使用这个插件后 再也不用手动复制任何的测例数据

使用方法：

1.  在谷歌或者火狐浏览器上安装插件 该工具会将解析到的测例数据以 JSON 格式的形式发到指定的端口
2.  在本地安装任何可以从端口监听读取数据的工具即可 可参考 <https://github.com/jmerle/competitive-companion-example> 

图片演示：

/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![演示](images/cf-tool3.gif)

## CP Editor

CP Editor 是一款专门为算法竞赛（Competitive Programming）设计的轻量级跨平台自由软件 IDE，有自动获取网页上的样例，一键编译运行并测试样例，在 IDE 内提交至 CF 等功能。

 [/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![Latest Stable](https://img.shields.io/github/v/release/cpeditor/cpeditor?label=latest%20stable)](https://github.com/coder3101/cp-editor/releases/latest)  [/home/llj/Desktop/OI-wiki-master/docs/intro//home/llj/Desktop/OI-wiki-master/docs/intro/![Latest Release](https://img.shields.io/github/v/release/cpeditor/cpeditor?include_prereleases&label=latest%20release&sort=semver)](https://github.com/coder3101/cp-editor/releases) 

-    [项目主页](https://cpeditor.github.io/) （含 feature 介绍）
-    [GitHub Repo](https://github.com/cpeditor/cpeditor) （含使用说明、贡献指南等文档）
-    [Gitee 镜像](https://gitee.com/ouuan/cpeditor) （同步自 GitHub，不一定是最新的）
-    [GitHub Releases](https://github.com/cpeditor/cpeditor/releases) 
-    [Gitee 发行版](https://gitee.com/ouuan/cpeditor/releases) 
-    [Telegram 群组](https://t.me/cpeditor) 
-    [QQ 群入群链接](https://jq.qq.com/?_wv=1027&k=50eq8yF) （1081647997）

大家在使用之余还可以在 GitHub 上报告 bug，请求 feature，或是入群讨论，参与贡献。如果觉得不错的话，可以在 [GitHub](https://github.com/cpeditor/cpeditor) 上给开发者们一个 star。

# oi
author: Ir1d, Planet6174, abc1763613206, StudyingFather, cjsoft, TrisolarisHD, luoguyuntianming, ChungZH, Xeonacid, yizr-cnyali, i-Yirannn

## 赛事介绍

OI 竞赛是一项全球的赛事，每年夏天会有世界级竞赛（IOI）举行，参赛选手大多都经过层层选拔。对于大部分选手而言，每年新赛季从 10 月的 NOIP（省级选拔赛）开始。

OI 竞赛中允许使用的语言包括 Pascal（NOI 将于 2020 年停止使用 Pascal，NOIP 将于 2022 年停止使用 Pascal），C 和 C++。其中 C++ 的版本不同考试有不同的规定。考试题目一般为算法或者数据结构相关的内容，题目形式包括传统题（最常见的规定输入和输出到文件的题目）和非传统题（提交答案题、交互题、补全代码题等等）。

### NOIP

NOIP（National Olympiad in Informatics in Provinces）是全国青少年信息学奥林匹克联赛，顾名思义，是以省为单位排名评奖，截至 2019 年，对于大部分高校来说，获得提高组省一等奖可以用于获得自主招生资格。

NOIP 分为初赛和复赛两个阶段。初赛会考察一些计算机基础知识和算法基础，复赛是上机考试，也分提高组和普及组（2018 年于上海试点入门组），时间上一般是 11 月的第二个周末，周六上午提高组一试 8:30-12:00（3.5 小时，共 3 题），下午 14:30-18:00 普及组（3.5 小时，共 4 题），周日上午提高组二试 8:30-12:00（3.5 小时，共 3 题）。全国使用同一套试卷，但是评奖规则是按照省内情况由 CCF（中国计算机学会）统一指定，并于赛后在 [NOI 官方网站](http://www.noi.cn) 上公布。各省的一等奖分数线略有不同。

NOIP 于 2019 年 8 月 16 日 [被 CCF 暂停](http://www.noi.cn/newsview.html?id=932&hash=72F731&type=1) ，于 2020 年 1 月 21 日 [被宣布恢复](http://www.noi.cn/newsview.html?id=1172&hash=AC7D99&type=1) 。

### CSP J/S

CSP (Certified Software Professional Junior/Senior) 是继 NOIP 在 2019 年被取消之后 CCF 开设的非专业级软件能力认证，面向全年龄段。
具体赛制、时间基本同 NOIP 一致。在部分地区，CSP 2019 设有小学组。

目前暂不清楚获得 CSP J/S 认证对自主招生资格的获取是否有帮助。

### 省选

省队选拔赛是用于选拔各省参加全国赛的代表队，各个省队的名额有复杂的计算公式，一般和之前的成绩和参赛人数有关。省选由各个省自行决定，目前的趋势是很多省份选择联合命题。通常来讲，NOIP 分数需要在省选中占一定比例。根据规则，初中选手只能选拔成为 E 类选手，不参加 A、B 类选拔。A 类选手 5 人（4 男一女），其他选手根据给定名额和所得分数依次进入 B 队。一个学校参加 NOI 的名额不超过本省 A、B 名额总数的三分之一（四舍五入），得分最高且入选 A 队的女选手不占该比例。（简称 1/3 限制或 1/3 淘汰）

自 2020 年起，NOI 省队选拔由 CCF 统一命题和评测，有能力命题的省可自行命题，但选拔方式需得到 CCF 的批准。

### NOI

NOI（National Olympiad in Informatics）是全国信息学奥林匹克竞赛，一般在七月份举行，有现场赛和网络赛。现场赛选手分为五类，其中 A、B、C 类为正式选手，D、E 类选手为邀请赛选手。A、B 类对应省队的 A、B 类选手（其中 A 类在计算成绩时会有 5 分加分），C 类名义上是学校对 CCF 做出突出贡献后的奖励名额，D 类名义上是个人对 CCF 做出突出贡献后的奖励名额（基本为大额捐款），E 类选手为初中组选手，如果成绩超过分数线的话，只有成绩证明而没有奖牌（同等分数含金量要低一些）。正式选手前 50 名组成国家集训队，获得保送资格。网络赛报名形式上没有门槛。

在国际平台上，为了与其他同样称作 NOI 的比赛区分，有时会被称作 CNOI。

### WC

WC（Winter Camp）是全国青少年信息学奥林匹克竞赛冬令营，是每年冬天在当年 NOI 举办地进行的一项活动，内容包括若干天的培训和一天的考试。这项考试主要用于从国家集训队（50 人）选拔国家候选队（15 人），但是前一年 NOIP 取得较好成绩的选手也可以参加（不参与选拔）。

### APIO

APIO（Asia-Pacific Informatics Olympiad）是亚太地区信息学奥林匹克竞赛，CCF 每年会在五月初举办中国赛区镜像赛。在比赛日前后会有培训活动。

### CTS

CTS（旧称 CTSC, China Team Selection Competition）是中国队选拔赛。用来从国家候选队（15 人）中选拔国家队（6 人）准备参加当年夏天的 IOI 比赛，其中正式选手 4 人，替补选手 2 人，但是和 WC 一样的，前一年 NOIP 取得较好成绩的选手也可以参加（不参与选拔）。

注：APIO 和 CTS 都是以省为单位报名，一般是按照 NOIP 成绩排序来确定谁会有机会参加 APIO 和 CTS（二者一般时间上非常接近）。

### IOI

IOI（International Olympiad in Informatics）是国际信息学奥林匹克竞赛，每个国家有四人参赛，比赛一般会有直播。IOI 赛制中每个题目会有 subtask（子任务），每个子任务对应一定的分数。

### 学科营

#### PKU

-   北京大学信息学冬季体验营（PKUWC）在冬令营前后举行。
-   北京大学信息学体验营（PKUSC）一般在六月份在校内举行。由于在学校机房比赛，机房环境是 Windows，比赛系统是 OpenJudge。
-   北京大学中学生暑期课堂（信息学）在暑假举行，面向高二年级理科学生。

## 赛制介绍

### OI 赛制

一般的 OI 赛制可以理解为单人在 5 个小时的时间内尝试解决 3 道题。每个题目可以不全部解决，会有多个数据点，题目的分数一般是数据点得分之和。每个数据点还可能会有部分分，就是数据点内部也不需要完全正确才能得到分数。评分方式是在比赛结束后统一评测，只有一次提交机会。
NOIP、NOI、省选都是 OI 赛制。

### IOI 赛制

目前国内比赛也在逐渐向 IOI 赛制靠拢。
IOI 赛制可以赛时任意提交，可以即时查看评测结果，APIO、IOI 都是 IOI 赛制。

### ICPC 赛制

在 ICPC 比赛中一般是三个人使用一台机器，每个题目只有在所有数据点全部正确后才能得到分数。比赛过程中可以有多次提交机会，实时评测并返回结果。比赛排名根据做题数和罚时来评判，罚时是通过题目的用时之和加上错误提交次数乘以一个系数。在 ICPC 相关赛事中，选手允许带一定量的纸质资料。

参见 [ICPC/CCPC 赛事与赛制](./icpc.md) 。

### Codeforces (CF) 赛制

 [Codeforces](https://codeforces.com) 是一个在线评测系统，定期会举办比赛。它的比赛特点是在比赛过程中只测试一部分数据（pretests），而在比赛结束后返回完整的所有测试点的测试结果（system tests）。比赛时可以多次提交，允许 hack 别人的代码（此处 hack 的意思是提交一个测试数据，使得别人的代码无法给出正确答案）。当然，如果想要 hack，必须要锁定自己的代码（换言之，比赛时无法重新提交该题）。Hack 时不允许将选手程序拷贝到本地进行测试（你看到的会是代码转换成图片的版本）。

Codeforces 同时提供另外一种赛制，称作扩展 ICPC（extended ICPC）。在这一赛制中，在比赛过程中会测试全部数据，但比赛结束以后会有 12 小时的全网 Hack 时间。Hack 时允许将选手程序拷贝到本地进行测试。

## 其他国家和地区的 OI 竞赛

### 美国：USACO

官网地址： <https://www.usaco.org/> 

USACO 或许是国内选手最熟悉的外国 OI 竞赛（可能也是中文题解最多的外国 OI 竞赛）。  
每年冬季到初春，USACO 会每月举办一场网络赛。一场比赛持续 $3\sim5$ 个小时。  
根据官网的介绍，USACO 的比赛分成这 4 档难度（2015~2016 学年之前为 3 档）：

-   铜牌组，适合编程初学者，尤其是只学了最最基础的算法（如：排序，二分查找）的学生。
-   银牌组，适合开始学习基本的算法技巧（如：递归，搜索，贪心算法）和基础数据结构的学生。
-   金牌组，学生会遇到更复杂的算法（如：最短路径，DP）和更高级的数据结构。
-   铂金组，适合有着扎实的算法设计能力的选手，铂金组可以帮助他们以复杂且更开放的问题来挑战自我。

在国内，目前 USACO 题目最齐全的是洛谷。

### 波兰：POI

官网： <https://oi.edu.pl/>   
官方提交地址： <https://szkopul.edu.pl/p/default/problemset/> 

POI 是不少省选选手最常刷的外国 OI 比赛。  
根据（已经凉凉的） <http://main.edu.pl/en/> 的描述，POI 的流程如下：

-   第一轮：五题，网络赛，公开赛。
-   第二轮：包含一场练习赛，和两场正式比赛。
-   第三轮：赛制同上。
-   ONTAK：POI 训练营（类似国内的集训队）

你可能还听说过 PA。PA 的大意是“算法大战”（我也不知道为啥它叫这名字）。

目前在国内 OJ 中，POI 题目最全的是 BZOJ。

### 克罗地亚：COCI

官网地址： <http://www.hsin.hr/coci/>   
（有时候英文版的更新会延迟，克罗地亚语版本： <http://www.hsin.hr/honi/> ）

难度跨度很大的比赛，大约是从普及 - $\sim$ 省选 -。以往 COCI 所有的题目均提供题目、数据、题解和标程，然而从 2017 年底之后，COCI 的题解和标程就断更了（不是没有英语版翻译，而是连克罗地亚语的版本都没有）。2019-2020 赛季重新开始更新题解和标程。

洛谷、BZOJ 和 LibreOJ 都有少量的 COCI 题目。

### 日本：JOI

官网地址： <https://www.ioi-jp.org/>   
日本信息学奥赛（日本情報オリンピック）一般简称为 JOI。JOI 所有的题目都提供题目、数据、题解和标程。近两年的 JOI 决赛和春训营提供了英语题面，但并没有英语题解。历年的 JOI Open 都提供了英语版题面和题解。绝大部分 JOI 题可以左转 AtCoder 提交。

JOI 的流程：

-   预赛（予選）
-   决赛（本選/JOI Final）
-   春训营（春季トレーニング合宿/JOI Spring Camp/JOISC）
-   公开赛（通信教育/JOI Open Contest）
    预赛难度较低，自 2019/2020 赛季起，预赛分为多轮。
    目前 LibreOJ 和 BZOJ 有近些年的 JOI Final、JOISC 和 JOI Open 的题目。
    JOI Final 的难度在提高 - $\sim$ 提高 + 左右。JOISC 和 JOI Open 的题目的难度在提高 $\sim$ NOI - 不等。
    你可以在 JOI 官网或者 AtCoder 上找到更多的 JOI 题（日文题面）

### 俄罗斯：ROI

俄罗斯信息学奥赛（олимпиадная информатика）一般简称为 ROI。  
官网： <http://neerc.ifmo.ru/school/archive/index.html>   
在线提交地址： <https://contest.yandex.ru/roiarchive/> ，Codeforces 上也有一些  
一般简称为 ROI。流程：

-   市级比赛（Municipal stage/Муниципальный этап）
-   州级比赛（Regional Stage/Региональный этап）
-   决赛（Final Stage/Заключительный этап）

目前 LibreOJ 有近几年的 ROI 决赛题的译文。  
除此之外，俄罗斯较大型的、面向中学生的比赛还有：

-   信息学网络奥赛（Интернет-олимпиады по информатике）： <http://neerc.ifmo.ru/school/io/index.html> 。该比赛由 ROI 出题人举办；
-   全国中学生团队信息学竞赛（Всероссийской командной олимпиады школьников）： <http://neerc.ifmo.ru/school/russia-team/index.html> ；
-   上面这个比赛的预选赛 Moscow Team Olympiad 可以在 Codeforces 上提交；
-   Innopolis Open： <https://olymp.innopolis.ru/en/ooui/information/> 
-   中学生编程公开赛（Открытая олимпиада школьников по программированию）： <https://olympiads.ru/zaoch/> 。官网称该比赛对标 ROI。

### 加拿大：CCC & CCO

CCC: Canadian Computing Competition  
CCO: Canadian Computing Olympiad  
官网地址： <https://cemc.math.uwaterloo.ca/contests/past_contests.html#ccc>   
CCC 提交地址： [https://dmoj.ca/problems/？category=4](https://dmoj.ca/problems/?category=4)   
CCO 提交地址： [https://dmoj.ca/problems/？category=24](https://dmoj.ca/problems/?category=24)   
CCC 在 DMOJ 有官方 (?) 题解。  
CCC Junior/Senior 贴近 NOIP 普及组/提高组难度。CCO 想要拿到金牌可能得有 NOI 银的水平。

### 台湾地区：資訊奧林匹亞競賽

台湾地区把 OI 中的 informatics 翻译成“资讯”而非大陆通用的翻译“信息”。  
台湾地区的选手如果想去参加 IOI，需要经过这几轮比赛：

-   區域資訊學科能力競賽
-   全國資訊學科能力競賽
-   資訊研習營（TOI）

### 其他国家

法国与澳大利亚：FARIO <http://orac.amt.edu.au/cgi-bin/train/hub.pl>   
难度与 NOI 类似。

韩国：한국 정보 올림 피아드： <https://www.digitalculture.or.kr/koi/>   
 <https://www.digitalculture.or.kr/koi/selectOlymPiadDissentList.do>   
 <https://www.acmicpc.net/problemset>   
难度太低。

英国 British Informatics Olympiad： <https://www.olympiad.org.uk/>   
难度太低。

捷克：Matematická olympiáda–kategorie P： <http://mo.mff.cuni.cz/p/archiv.html> 

罗马尼亚：Olimpiada Nationala de Informatica： <http://olimpiada.info/>   
题面、测试数据、题解请在含有 Subiecte 字样的标签页中寻找。

## 其它国际 OI 竞赛

### BalticOI

BalticOI 面向的是波罗的海周边各国。BalticOI 2018 的参赛国有立陶宛、波兰、爱沙尼亚、芬兰等 9 国。题目难度大。  
除了 2017 年，BalticOI 每年都公开题面、测试数据和题解。然而 BalticOI 没有一个固定的官网，每年的主办方都会新建一个网站……  
关于历年的官网地址，Planet6174 整理出了一个 [帖子](https://loj.ac/article/416) 。  
目前 LibreOJ 有近十年的 BalticOI 题。

### BalkanOI

BalkanOI 面向巴尔干地区周边各国。BalkanOI 2018 的参赛国有罗马尼亚、希腊、保加利亚、塞尔维亚等 12 国。题目难度大。  
BalkanOI 只有某几年公开题面、测试数据和题解，官网地址参见上面那个帖子。

### CEOI

CEOI 2018 的参赛国与上面两个比赛有部分重叠，包括波兰、罗马尼亚、格鲁吉亚、克罗地亚等国。题目难度大。  
CEOI 每年都公开题面、测试数据和题解，官网地址参见上面那个帖子。  
在国内 OJ 中，BZOJ 的 CEOI 题相对最齐。

### European Junior Olympiad in Informatics (eJOI)

参赛国包含俄罗斯、亚美尼亚、保加利亚、波兰等国。题目难度较大。  
eJOI 每年都公开题面、测试数据和题解，官网地址参见上面那个帖子。

### International School for Informatics“Junior”(ISIJ)

似乎没有官网。见 CCF 新闻 <http://www.noi.cn/newsview.html?id=911&hash=2D52A8&type=1> 。  
据 300iq 说题目质量很糟糕。

### Nordic Olympiads in Informatics (NOI)

官网地址： <http://nordic.progolymp.se>   
近两年才开始举办的比赛，面向北欧各国。

# judgers
author: bear-good

很多时候，你拿到了一套题，想要在本地测试一下自己能得多少分，这时候就需要评测软件了。

## Cena

Cena 是由刘其帅和李子星使用 Pascal 语言编写的开源评测工具，是流传最广泛的本地评测工具。Cena 最初开源于 Google Code 平台，由于不明原因 Google 删除了 Cena 项目，目前可以在 [Web Archive](https://web.archive.org/web/20131023112258/http://code.google.com/p/cena/) 上找到 Cena 的官网。

Cena 的源代码可以在 [这里](https://github.com/oi-archive/cena) 找到。

Cena 对权限的限制不是很明确，测试的时候可以读测点 AC QAQ

## Lemon

Lemon 是 zhipeng-jia 写的开源的评测工具，仓库 [zhipeng-jia/project-lemon](https://github.com/zhipeng-jia/project-lemon) 。

Ir1d 提供了一份 linux 下编译好的版本在 [FreestyleOJ/Project_lemon](https://github.com/FreestyleOJ/Project_lemon/tree/Built) 。

Menci 提供了一份更新的版本在 [Menci/Lemon](https://github.com/Menci/Lemon/) 。（已存档，停止维护）

Dust1404 维护了支持子文件夹和单题测试等功能的版本在 [Dust1404/Project_LemonPlus](https://github.com/Dust1404/Project_LemonPlus) 。（作者 AFO，停止维护）

iotang 维护了支持子文件夹和单题测试等功能的版本在 [iotang/Project_LemonLime](https://github.com/iotang/Project_LemonLime) 。

 **注意** macOS 下 Lemon 可能会出现内存测试不准确的情况，这是由于 mac 下没有一些 Linux 的监测工具，而 Lemon-Linux 也没有对于 macOS 的使用优化。

### 自行编译

在 Ubuntu 下编译：

```bash
sudo apt update
sudo apt install qt5-default build-essential git -y
git clone --depth=1 http://github.com/menci/lemon.git
cd lemon
# 可以修改 make 文件来调整 make job 的线程数
sed -i 's/make $/make -j 1 $/g' make
./make
cp Lemon ~
cd ..
```

### 数据格式

首先打开 lemon 选择新建试题，而后打开新建试题的文件夹

题目和数据应该如以下格式所示

```text
├── data
│   ├── gendata.py
│   ├── product
│   │   ├── product100.in
│   │   ├── product100.out
│   │   ├── product10.in
│   │   ├── product10.out
│   │   ├── product11.in
...
```

当所有试题添加完成后，回到 lemon 选择自动添加试题

此时你的题目和数据点应该都显示在 lemon 当中了

## Arbiter

Arbiter 为北京航空航天大学为 NOI Linux 开发的评测工具，现已用于各大 NOI 系列程序设计竞赛的评测。据吕凯风在 2016 年冬令营上的讲稿《下一代测评系统》，Arbiter 是由北京航空航天大学的团队（貌似叫 GAIT）在尹宝林老师的带领下开发完成的。不过该测评工具在开发完成后就一直没有维护与更新，导致测评体验极差，和 NOI Linux 自带的 GUIDE 一样沦为选手与教练疯狂吐槽的对象。但是 NOIP 与 NOI 的题目测评是在 Arbiter 下进行的，因此仍然需要了解 Arbiter 的使用方法。

此测评软件仅能在 NOI Linux 下找到，不过市面上有热心群众 [提取出了 Arbiter](https://github.com/leedagee/arbiter-distro) 供其他操作系统使用，不过仍建议使用 NOI Linux 及相关配套编译器。

### 使用方法

首先准备好选手源程序文件夹。选手文件夹如 NOIP 格式创建：

```text
players/
| -- <contestant_1's ID>
|     | -- <problem_1>
|     |   `-- <problem_1>.c/cpp/pas
|     | -- <problem_2>
|     |   `-- <problem_2>.c/cpp/pas
|     | ...
|     | -- <problem_x>
|        `-- <problem_x>.c/cpp/pas
| -- <contestant_2's ID>
|     | -- <problem_1>
|     ...
...
```

其中， `<contestant_x's ID>` 指的是选手编号，形如 `<省份>-< 编号 >` ，例如 HL-001,JL-125 等等， `<problem_x>` 指的是题目名称。

当然，在自测时可以使用字母，短线（即 `-` ）和数字的组合作为选手编号。

准备好选手文件夹还不够，需要准备选手名单。名单格式如下：

```text
<contestant_1's ID>, <contestant_1's name>
<contestant_2's ID>, <contestant_2's name>
...
```

其中 `<contestant_x's name>` 表示选手姓名，保存这个文件为纯文本文件，文件编码是 GB2312。

当然也可以手动添加，稍后介绍。

这样的话，选手源程序文件夹已经搞定，现在配置数据。

每组数据的命名格式如下：

```text
<problem_x><y>.in <problem_x><y>.ans
```

其中， `<y>` 是数据编号，编号从 1 开始。

默认测试数据后缀名是 `.ans` ，选手输出的后缀名是 `.out` ，不能混淆。不用将每题的测试数据放置在各自文件夹里，只需要放在一起即可。

这样就准备好了，现在开始测评文件夹的配置。

工具栏 - 应用程序 - 编程 - Arbiter 测评系统，启动 Arbiter。

/home/llj/Desktop/OI-wiki-master/docs/intro/![Arbiter_Home](./images/arbiter_home.png)

如果要打开已经建立的比赛，请点击 OPEN，这里新建一个竞赛，选择 New，设置一下名称和比赛目录即可。

注意，需要新建一个文件夹，然后选择其为比赛目录。

/home/llj/Desktop/OI-wiki-master/docs/intro/![AddProblem](./images/arbiter_addproblem.png)

在左边试题概要里右键 - 添加考试，再在考试标签上右键 - 添加试题，新建出试题即可。

单击考试左边的 `+` 即可全部显示，单击试题标签对试题名称进行修改，改为题目的英文名称，同时修改题目时间与空间限制和比较方式。比较方式十分不推荐用全文完全直接比较，对于 Windows 下制作的数据十分不友好。比较方式不选的话默认为字符串比较中的单行单字符串比较方式。如果测试数据不同的话一定要注意比较方式的选择！

/home/llj/Desktop/OI-wiki-master/docs/intro/![](./images/arbiter_problem.png)

（建了一些无聊的问题）

这一步 **十分重要：** 点击文件 - 保存！一定要保存，否则没有题目配置文件！每一次对题目配置的修改都要保存！

此时，打开考试文件夹，会发现有如下内容。

```text
<name>/
| -- data
| -- evaldata
| -- filter
| -- final
| -- players
| -- result
| -- tmp
`-- day1.info
`-- player.info
`-- setup.cfg
`-- task1_1.info
`-- task1_2.info
`-- task1_3.info
`-- team.info
```

我们把已经建好的选手程序文件夹放在 `players/` 目录下，将所有测试数据（不放在文件夹里）放在 `evaldata` 中。

 `filter/` 文件夹放置了一些比较器及其源代码，写自定义比较器时可以参考， `result/` 文件夹存放选手的测评结果， `tmp/` 文件夹是测评时文件夹。

配置好后，就是正式测评环节了。点开“试题评测”标签，然后会出现如下所示情况。

/home/llj/Desktop/OI-wiki-master/docs/intro/![Pretest](./images/arbiter_pretest.png)

如果已经建立好选手名单了，选择右边的导入名单进行导入。如果人数较少，可以选择右边的添加选手进行导入。

导入好后是这样的。

/home/llj/Desktop/OI-wiki-master/docs/intro/![Test](./images/arbiter_test.png)

因为我取得编号是 `HL-001` ，所以会自动识别出“所属”一栏。如果不是 NOIP 规范的编号是识别不出来的。

这个时候，要用 **向上箭头** 把测评第 0 场变为测评第 1 场，如果直接修改的话会识别失败。

然后选择右边的全选，再选择下面的评测选定选手，选择要测评的题目（有全部试题），等待测评结束即可。

### 注意事项，槽点

#### 自定义校验器的编写

注意编译后自定义校验器名称为 `<problem>_e` ，其中 `<problem>` 为题目名称，必须放在 `filter/` 文件夹下。在配置题目时选择自定义校验器，然后选择需要的自定义校验器。

可以参考 `filter/` 下的源代码编写。

#### 测评时注意事项

以下信息均来自敝校教练。

据说很容易死机，需要注意。

据说大量测评时移动鼠标会导致死机，需要注意。

据说不定时闪退，和 Anjuta 一样，需要注意。

据说配置时需要注意权限问题（但是我并未遇到）。

由于 Linux 运行时栈限制，如果要开无限栈，应在终端先输入 `ulimit -s unlimited` 后执行 `arbiter` 打开测评器。

……

#### 诶我怎么只能看见代码不能看见每个点得多少分

测试点详细信息需要在 `result/` 文件夹下查看，文件夹下会有选手的结果文件夹，结果文件的后缀名为 `.result` ，用纯文本方式查看即可。

~~（我觉得这个设计很值得吐槽）~~

#### 诶这个测评系统好难看

我觉得也是……

#### 诶怎么测提交答案题啊

在试题管理中题目配置的地方，将提交方式由源代码改为答案文件。然后选择自定义校验器即可。

#### 诶这个测评系统有没有漏洞

至少不能读取答案文件……

 `bits/stdc++.h` 测得可用。

 `#pragma G++ optimize("O2")` 竟然可用。

 `__attribute__((__optimize__("-O2")))` 竟然也可用。

我可能用的是假 Arbiter……

#### 吐槽

讲个故事：

有一天，一位竞赛教练在用 GUIDE 的时候发现单步调试功能出现了 Bug，于是他致信北航相关项目负责人询问解决办法，得到的回复是：“这个项目已经停止更新了。”

希望一个成熟的线下测评系统早日实现……

## CCR-Plus

一款开源的界面好看的评测工具 GitHub 地址： [sxyzccr/CCR-Plus](https://github.com/sxyzccr/CCR-Plus) 

# thanks
disqus:

本项目目前接受捐赠，扫描下方二维码可以投食（请务必备注 `‘捐赠’+ 自己的信息` ）。

所有款项将被用于 **OI Wiki** 的域名、服务器、运维等必须支出
大额捐赠将会记录在本页面下方或日后更合适的位置来表示感谢。

<div align="center">
<img src='/intro/images/alipay.png' width='256' />
<img src='/intro/images/wechat.png' width='256' />
</div>

* * *

|       id      |  amount |    date    |
| :-----------: | :-----: | :--------: |
|       陌陌      |   10 元  |  2020.2.6  |
|     匿名捐赠者     |   10 元  |  2020.2.5  |
|     Yisin     |   10 元  |  2020.2.4  |
|    GinRyan    |   50 元  | 2019.11.30 |
|    JuicyMio   |   10 元  | 2019.11.30 |
|     匿名捐赠者     |   10 元  | 2019.11.14 |
|    QQ 联系 12   |   5 元   | 2019.10.28 |
|     匿名捐赠者     |   5 元   | 2019.10.27 |
|     增肥中的小肥    |   50 元  | 2019.10.24 |
|    ianahao    |   10 元  | 2019.10.12 |
|     Sundy     |   10 元  | 2019.10.11 |
|     三鸽最可爱     | 23.33 元 |  2019.8.17 |
|     Fburan    | 10.24 元 |  2019.8.17 |
|     匿名捐赠者     |   30 元  |  2019.8.8  |
| Billchenchina |  100 元  |  2019.8.7  |
|   贷款捐头的匿名入土   |   30 元  |  2019.8.4  |
|     sshwy     |   50 元  |  2019.8.4  |
|     匿名捐赠者     |   10 元  |  2018.9.9  |
|     匿名捐赠者     |   20 元  |  2018.8.31 |
|    Xeonacid   |   30 元  |  2018.8.30 |
|     匿名捐赠者     |  240 元  |  2018.8.29 |
|     Anguei    |   5 元   |  2018.8.29 |

# hulu
disqus:

Hulu 是美国领先的互联网专业视频服务平台，成立于 2006 年，目前由迪士尼控股，在美国拥有超过 2900 万付费用户。通过 Hulu，用户可以在电脑、可联网电视机、手机、平板电脑等多种设备上观看长视频和电视直播。

<div style="text-align:center;font-weight:bold;margin-top: 35px;font-size: 25pt;"> Hulu 是全美领先的流媒体平台 </div>
<img style="display: block;margin: 0 auto;" src="https://i.loli.net/2020/02/03/6oCP7XOKj9AvzMR.png" />

2017 年，Hulu 自制剧《使女的故事》成为艾美奖和金球奖双料最大赢家，斩获十余奖项；2019 年，Hulu 自制纪录片《滑板少年》获奥斯卡最佳纪录片提名。

<div style="text-align:center;font-weight:bold;margin-top: 35px;font-size: 25pt;"> Hulu 办公室分布 </div>
<img style="display: block;margin: 0 auto;" src="https://i.loli.net/2020/02/03/Z87FfMHA6kxqclt.png" />

Hulu 总部位于美国洛杉矶，在全球一共拥有 8 个办公室。北京办公室是仅次于总部的第二大研发中心，也是从 Hulu 成立伊始就具有重要战略地位的研发中心。

<div style="text-align:center;font-weight:bold;margin-top: 35px;font-size: 25pt;"> Hulu 北京办公室 </div>
<img style="display: block;margin: 0 auto;" src="https://i.loli.net/2020/02/03/M9dIrShWJDNoGia.png" />

Hulu 北京办公室成立于 2007 年，目前规模为 200 人，其中博士和硕士比例超过百分之八十。Hulu 北京于 2018 和 2019 连续两年当选“大中华区最佳职场 ®”。

<div style="text-align:center;font-weight:bold;margin-top: 35px;font-size: 25pt;"> Hulu 校园机会 </div>

<div style="text-align:center;font-weight:small">
<a href="https://sm.ms/image/Ls1cPJAB36gUztN" target="_blank"><img src="https://i.loli.net/2020/02/03/iSGMqmy8fTDJ5bz.png" ></a>
</div>

正如 Hulu 的产品是技术与娱乐的最佳结合，在 Hulu 工作，既能与一群志同道合的技术达人合作学习，又能享受充满乐趣的工作环境。Hulu 北京面向校园群体开放全年实习生招聘项目。欢迎关注 **Hulu 微信公众号** 了解更多关于 Hulu 的信息！

## general
本页面介绍 Testlib checker/interactor/validator 的一些通用状态/对象/函数、一些用法及注意事项。请在阅读其他页面前完整阅读本页面的内容。

## 通用状态

| 结果                 | Testlib 别名     | 含义                                                                                     |
| ------------------ | -------------- | -------------------------------------------------------------------------------------- |
| Ok                 |  `_ok`         | 答案正确。                                                                                  |
| Wrong Answer       |  `_wa`         | 答案错误。                                                                                  |
| Presentation Error |  `_pe`         | 答案格式错误。注意包括 Codeforces 在内的许多 OJ 并不区分 PE 和 WA。                                          |
| Partially Correct  |  `_pc(score)`  | 答案部分正确。仅限于有部分分的测试点，其中 `score` 为一个正整数，从 $0$ （没分）到 $100$ （可能的最大分数）。                      |
| Fail               |  `_fail`       | validator 中表示输入不合法，不通过校验。<br>checker 中表示程序内部错误、标准输出有误或选手输出比标准输出更优，需要裁判/出题人关注。（也就是题目锅了） |

通常用程序的返回值表明结果，但是也有一些其他方法：创建一个输出 xml 文件、输出信息到 stdout 或其他位置……这些都通过下方函数表中的 `quitf` 函数来完成。

## 通用对象

| 对象      | 含义    |
| ------- | ----- |
|  `inf`  | 输入文件流 |
|  `ouf`  | 选手输出流 |
|  `ans`  | 参考输出流 |

## 通用函数

非成员函数：

| 调用                                                                                                  | 含义                                                    |
| --------------------------------------------------------------------------------------------------- | ----------------------------------------------------- |
|  `void registerTestlibCmd(int argc, char* argv[])`                                                  | 注册程序为 checker                                         |
|  `void registerInteraction(int argc, char* argv[])`                                                 | 注册程序为 interactor                                      |
|  `void registerValidation()` / `void registerValidation(int argc, char* argv[])`                    | 注册程序为 validator                                       |
|  `void registerGen(int argc, char* argv[], int randomGeneratorVersion)`                             | 注册程序为 generator<br> `randomGeneratorVersion` 推荐为 `1`  |
|  `void quit(TResult verdict, string message)` / `void quitf(TResult verdict, string message, ...)`  | 结束程序，返回 `verdict` ，输出 `message`                       |
|  `void quitif(bool condition, TResult verdict, string message, ...)`                                | 如果 `condition` 成立，调用 `quitf(verdict, message, ...)`   |

流成员函数：

| 调用                                                                                                                                                                    | 含义                                                                                 |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
|  `char readChar()`                                                                                                                                                    | 读入一个字符                                                                             |
|  `char readChar(char c)`                                                                                                                                              | 读入一个字符，必须为 `c`                                                                     |
|  `char readSpace()`                                                                                                                                                   | 等同于 `readChar(' ')`                                                                |
|  `string readToken()` / `string readWord()`                                                                                                                           | 读入一个串，到空白字符（空格、Tab、EOLN 等）停止                                                       |
|  `string readToken(string regex)` / `string readWord(string regex)`                                                                                                   | 读入一个串，必须与 `regex` 匹配                                                               |
|  `long long readLong()`                                                                                                                                               | 读入一个 64 位整数                                                                        |
|  `long long readLong(long long L, long long R)`                                                                                                                       | 读入一个 64 位整数，必须在 $[L,R]$ 之间                                                         |
|  `vector<long long> readLongs(int n, long long L, long long R)`                                                                                                       | 读入 $N$ 个 64 位整数，必须均在 $[L,R]$ 之间                                                    |
|  `int readInt()` / `int readInteger()`                                                                                                                                | 读入一个 32 位整数                                                                        |
|  `int readInt(int L, int R)` / `int readInteger(L, R)`                                                                                                                | 读入一个 32 位整数，必须在 $[L,R]$ 之间                                                         |
|  `vector<int> readInts(int n, int L, int R)` / `vector<int> readIntegers(int n, int L, int R)`                                                                        | 读入 $N$ 个 32 位整数，必须均在 $[L,R]$ 之间                                                    |
|  `double readReal()` / `double readDouble()`                                                                                                                          | 读入一个双精度浮点数                                                                         |
|  `double readReal(double L, double R)` / `double readDouble(double L, double R)`                                                                                      | 读入一个双精度浮点数，必须在 $[L,R]$ 之间                                                          |
|  `double readStrictReal(double L, double R, int minPrecision, int maxPrecision)` / `double readStrictDouble(double L, double R, int minPrecision, int maxPrecision)`  | 读入一个双精度浮点数，必须在 $[L,R]$ 之间，小数位数必须在 $[minPrecision,maxPrecision]$ 之间，不得使用指数计数法等非正常格式 |
|  `string readString()` / `string readLine()`                                                                                                                          | 读入一行                                                                               |
|  `string readString(string regex)` / `string readLine(string regex)`                                                                                                  | 读入一行，必须与 `regex` 匹配                                                                |
|  `void readEoln()`                                                                                                                                                    | 读入 EOLN                                                                            |
|  `void readEof()`                                                                                                                                                     | 读入 EOF                                                                             |
|  `void quit(TResult verdict, string message)` / `void quitf(TResult verdict, string message, ...)`                                                                    | 结束程序，若 `Stream` 为 `ouf` 返回 `verdict` ，否则返回 `_fail` ；输出 `message`                   |
|  `void quitif(bool condition, TResult verdict, string message, ...)`                                                                                                  | 如果 `condition` 成立，调用 `quitf(verdict, message, ...)`                                |

未完待续……

## 极简正则表达式

上面的输入函数中的一部分允许使用“极简正则表达式”特性，如下所示：

-   字符集。如 `[a-z]` 表示所有小写英文字母， `[^a-z]` 表示除小写英文字母外任何字符。
-   范围。如 `[a-z]{1,5}` 表示一个长度在 $[1,5]$ 范围内且只包含小写英文字母的串。
-   “或”标识符。如 `mike|john` 表示 `mike` 或 `john` 其一。
-   “可选”标识符。如 `-?[1-9][0-9]{0,3}` 表示 $[-9999,9999]$ 范围内的非零整数（注意那个可选的负号）。
-   “重复”标识符。如 `[0-9]*` 表示零个或更多数字， `[0-9]+` 表示一个或更多数字。
-   注意这里的正则表达式是“贪婪”的（“重复”会尽可能匹配）。如 `[0-9]?1` 将不会匹配 `1` （因为 `[0-9]?` 将 `1` 匹配上，导致模板串剩余的那个 `1` 无法匹配）。

## 首先 include testlib.h

请确保 testlib.h 是你 include 的 **第一个** 头文件，Testlib 会重写/禁用（通过名字冲突的方式）一些与随机有关的函数（如 `random()` ），保证随机结果与环境无关，这对于 generator 非常重要， [generator 页面](./generator.md) 会详细说明这一点。

## 使用项别名

推荐给 `readInt/readInteger/readLong/readDouble/readWord/readToken/readString/readLine` 等的有限制调用最后多传入一个 `string` 参数，即当前读入的项的别名，使报错易读。例如使用 `inf.readInt(1, 100, "n")` 而非 `inf.readInt(1, 100)` ，报错信息将为 `FAIL Integer parameter [name=n] equals to 0, violates the range [1, 100]` 。

## 使用 `ensuref/ensure()` 

这两个函数用于检查条件是否成立（类似于 `assert()` ）。例如检查 $x_i \neq y_i$ ，我们可以使用

```cpp
ensuref(x[i] != y[i], "Graph can't contain loops");
```

还可以使用 C 风格占位符如

```cpp
ensuref(s.length() % 2 == 0,
        "String 's' should have even length, but s.length()=%d",
        int(s.length()));
```

它有一个简化版 `ensure()` ，我们可以直接使用 `ensure(x> y)` 而不添加说明内容（也不支持添加说明内容），如果条件不满足报错将为 `FAIL Condition failed: "x > y"` 。很多情况下不加额外的说明的这种报错很不友好，所以我们通常使用 `ensuref()` 并加以说明内容，而非使用 `ensure()` 。

???+ warning
    注意全局与成员 `ensuref/ensure()` 的区别

    全局函数 `::ensuref/ensure()` 多用于 generator 和 validator 中，如果检查失败将统一返回 `_fail` 。

    成员函数 `InStream::ensuref/ensure()` 一般用于判断选手和参考程序的输出是否合法。当 `InStream` 为 `ouf` 时，返回 `_wa` ；为 `inf` （一般不在 checker 中检查输入数据，这应当在 validator 中完成）或 `ans` 时，返回 `_fail` 。详见[Checker - 编写 readAns 函数](./checker.md#_3)。

 **本文主要翻译并综合自 [Testlib - Codeforces](https://codeforces.com/testlib) 系列。 `testlib.h` 的 GitHub 存储库为 [MikeMirzayanov/testlib](https://github.com/MikeMirzayanov/testlib) 。** 

## interactor
Interactor，即交互器，用于交互题与选手程序交互。交互题的介绍见 [非传统题](../non-trad.md#_3) 。

???+note
    Testlib 仅支持 Codeforces 形式交互题，即两程序交互。不支持 NOI 形式的选手编写函数与其他函数交互。

请在阅读下文前先阅读 [通用](./general.md) 。

Testlib 为 interactor 提供了一个特殊的流 `std::fstream tout` ，它是一个 log 流，你可以在 interactor 中向它写入，并在 checker 中用 `ouf` 读取。

在 interactor 中，我们从 `inf` 读取题目测试数据，将选手程序（和标程）的标准输入写入 `stdout` （在线），从 `ouf` 读选手输出（在线），从 `ans` 读标准输出（在线）。

如果 interactor 返回了 ok 状态，checker（如果有的话）将接管工作，检查答案合法性。

## 用法

Windows:

```bat
interactor.exe <Input_File> <Output_File> [<Answer_File> [<Result_File> [-appes]]],
```

Linux:

```bash
./interactor.out <Input_File> <Output_File> [<Answer_File> [<Result_File> [-appes]]],
```

## 简单的例子

???+note 题目
    interactor 随机选择一个 $[1,10^9]$ 范围内的整数，你要写一个程序来猜它，你最多可以询问 $50$ 次一个 $[1,10^9]$ 范围内的整数。

    interactor 将返回：

     `1` ：询问与答案相同，你的程序应当停止询问。

     `0` ：询问比答案小。

     `2` ：询问比答案大。

注意在此题中我们不需要 `ans` ，因为我们不需要将标准输出与其比较；而在其他题中可能需要这么做。

```cpp
int main(int argc, char** argv) {
  registerInteraction(argc, argv);
  int n = inf.readInt();  // 选数
  cout.flush();           // 刷新缓冲区
  int left = 50;
  bool found = false;
  while (left > 0 && !found) {
    left--;
    int a = ouf.readInt(1, 1000000000);  // 询问
    if (a < n)
      cout << 0 << endl;
    else if (a > n)
      cout << 2 << endl;
    else
      cout << 1 << endl, found = true;
    cout.flush();
  }
  if (!found) quitf(_wa, "couldn't guess the number with 50 questions");
  ouf.readEof();
  quitf(_ok, "guessed the number with %d questions!", 50 - left);
}
```

 **本文主要翻译自 [Interactors with testlib.h - Codeforces](https://codeforces.com/blog/entry/18455) 。 `testlib.h` 的 GitHub 存储库为 [MikeMirzayanov/testlib](https://github.com/MikeMirzayanov/testlib) 。** 

## validator
Validator，即校验器。当你造好了一道题的数据，感觉有点虚，担心数据不合法（不符合题目的限制条件）：上溢、图不连通、不是树……你便需要 validator 来帮助你检查数据是否合法。即便你非常有自信，也最好用 validator 检查一下，比较稳妥。

因为 Coderforces 支持 hack 功能，所以所有 Codeforces 上的题目都必须要有 validator，UOJ 也如此。 [Polygon](../polygon.md) 内建了对 validator 的支持。

请在阅读下文前先阅读 [通用](./general.md) 。

## 概述

我们要做的事情很简单，就是把输入完全读进来然后判断是否合法（当然很多工作可以通过带判断的输入函数），但是有一些小提示：

-   写 validator 时你不能对被 validate 的数据做任何假设，它可能包含任何内容。因此，你要对各种不合法的情况进行判断（使用 Testlib 会大大简化这一流程）。
    -   例如输入一个点数为 $n$ 的树，你的主要工作是判断 $n$ 是否符合范围和判断是否是树。但是切不可在判断过 $n$ 范围之后就不对接下来输入的边的起点与终点的范围进行判断，否则可能会导致你的 validator RE。
    -   即使不会 RE 也不应该不判断，这会导致你的报错不正确。如上例，如果不判断，报错可能会是“不是一棵树”，但是正确的报错应当是“边起点/终点不在 $[1,n]$ 之间”。
-   同时，你也不能对选手的读入方式做任何假设（例如，选手可能逐字符地读入数字，在数字与数字之间只读入一个空格），因此，你必须保证能通过 validate 的数据完全符合输入格式。比如，数据中的每一个空白字符都要在 validator 中显式地读入（如空格和换行）。
-   结束时不要忘记 `inf.readEof()` 。
-   如果题目开放 hack（或者说，validator 的错误信息会给别人看），请使报错信息尽量友好。
    -   读入变量时使用“项别名”。
    -   在判断使用的表达式不那么易懂时，使用 ensuref 而非 ensure。

## 使用方法

直接命令行 `./val` 即可，数据通过 stdin 输入，如果想从文件输入可 `./val < a.in` 。

若数据没有问题则什么都不会输出且返回 0，否则会输出错误信息并返回一个非 0 值。

## 示例

以下是 [CF Gym 100541A - Stock Market](https://codeforces.com/gym/100541/problem/A) 的 validator：

```cpp
#include "testlib.h"

int main(int argc, char* argv[]) {
  registerValidation(argc, argv);
  int testCount = inf.readInt(1, 10, "testCount");
  inf.readEoln();

  for (int i = 0; i < testCount; i++) {
    int n = inf.readInt(1, 100, "n");
    inf.readSpace();
    inf.readInt(1, 1000000, "w");
    inf.readEoln();

    for (int i = 0; i < n; ++i) {
      inf.readInt(1, 1000, "p_i");
      if (i < n - 1) inf.readSpace();
    }
    inf.readEoln();
  }

  inf.readEof();
}
```

更多示例可以在 [GitHub](https://github.com/MikeMirzayanov/testlib/tree/master/validators) 中找到。

 **本文部分来自 [Validators with testlib.h - Codeforces](https://codeforces.com/blog/entry/18426) 。 `testlib.h` 的 GitHub 存储库为 [MikeMirzayanov/testlib](https://github.com/MikeMirzayanov/testlib) 。** 

## index
如果你正在使用 C++ 出一道算法竞赛题目，Testlib 是编写相关程序（generator, validator, checker, interactor）时的优秀辅助工具。它是俄罗斯和其他一些国家的出题人的必备工具，许多比赛也都在用它：ROI、ICPC 区域赛、所有 Codeforces round……

Testlib 库仅有 `testlib.h` 一个文件，使用时仅需在所编写的程序开头添加 `#include "testlib.h"` 即可。

Testlib 的具体用途：

-   编写 [Generator](./generator.md) ，即数据生成器。
-   编写 [Validator](./validator.md) ，即数据校验器，判断生成数据是否符合题目要求，如数据范围、格式等。
-   编写 [Interactor](./interactor.md) ，即交互器，用于交互题。
-   编写 [Checker](./checker.md) ，即 [Special Judge](../spj.md) 。

Testlib 与 Codeforces 开发的 [Polygon](https://polygon.codeforces.com/) 出题平台完全兼容。

 `testlib.h` 在 2005 年移植自 `testlib.pas` ，并一直在更新。Testlib 与绝大多数编译器兼容，如 VC++ 和 GCC g++，并兼容 C++11。

 **本文主要翻译自 [Testlib - Codeforces](https://codeforces.com/testlib) 。 `testlib.h` 的 GitHub 存储库为 [MikeMirzayanov/testlib](https://github.com/MikeMirzayanov/testlib) 。** 

## checker
Checker，即 [Special Judge](../spj.md) ，用于检验答案是否合法。使用 Testlib 可以让我们免去检验许多东西，使编写简单许多。

Checker 从命令行参数读取到输入文件名、选手输出文件名、标准输出文件名，并确定选手输出是否正确，并返回一个预定义的结果：

请在阅读下文前先阅读 [通用](./general.md) 。

## 简单的例子

???+note 题目
    给定两个整数 $a,b$ （ $-1000 \le a,b \le 1000$ ），输出它们的和。

这题显然不需要 checker 对吧，但是如果一定要的话也可以写一个：

```cpp
#include "testlib.h"

int main(int argc, char* argv[]) {
  registerTestlibCmd(argc, argv);

  int pans = ouf.readInt(-2000, 2000, "sum of numbers");

  // 假定标准输出是正确的，不检查其范围
  // 之后我们会看到这并不合理
  int jans = ans.readInt();

  if (pans == jans)
    quitf(_ok, "The sum is correct.");
  else
    quitf(_wa, "The sum is wrong: expected = %d, found = %d", jans, pans);
}
```

## 编写 readAns 函数

假设你有一道题输入输出均有很多数，如：给定一张 DAG，求 $s$ 到 $t$ 的最长路并输出路径（可能有多条，输出任一）。

下面是一个 **不好** 的 checker 的例子。

### 不好的实现

```cpp
// clang-format off

#include "testlib.h"
#include <map>
#include <vector>
using namespace std;

map<pair<int, int>, int> edges;

int main(int argc, char* argv[]) {
  registerTestlibCmd(argc, argv);
  int n = inf.readInt();  // 不需要 readSpace() 或 readEoln()
  int m = inf.readInt();  // 因为不需要在 checker 中检查标准输入合法性（有
                          // validator）
  for (int i = 0; i < m; i++) {
    int a = inf.readInt();
    int b = inf.readInt();
    int w = inf.readInt();
    edges[make_pair(a, b)] = edges[make_pair(b, a)] = w;
  }
  int s = inf.readInt();
  int t = inf.readInt();

  // 读入标准输出
  int jvalue = 0;
  vector<int> jpath;
  int jlen = ans.readInt();
  for (int i = 0; i < jlen; i++) {
    jpath.push_back(ans.readInt());
  }
  for (int i = 0; i < jlen - 1; i++) {
    jvalue += edges[make_pair(jpath[i], jpath[i + 1])];
  }

  // 读入选手输出
  int pvalue = 0;
  vector<int> ppath;
  vector<bool> used(n, false);
  int plen = ouf.readInt(2, n, "number of vertices");  // 至少包含 s 和 t 两个点
  for (int i = 0; i < plen; i++) {
    int v = ouf.readInt(1, n, format("path[%d]", i + 1).c_str());
    if (used[v - 1])  // 检查每条边是否只用到一次
      quitf(_wa, "vertex %d was used twice", v);
    used[v - 1] = true;
    ppath.push_back(v);
  }
  // 检查起点终点合法性
  if (ppath.front() != s)
    quitf(_wa, "path doesn't start in s: expected s = %d, found %d", s,
          ppath.front());
  if (ppath.back() != t)
    quitf(_wa, "path doesn't finish in t: expected t = %d, found %d", t,
          ppath.back());
  // 检查相邻点间是否有边
  for (int i = 0; i < plen - 1; i++) {
    if (edges.find(make_pair(ppath[i], ppath[i + 1])) == edges.end())
      quitf(_wa, "there is no edge (%d, %d) in the graph", ppath[i],
            ppath[i + 1]);
    pvalue += edges[make_pair(ppath[i], ppath[i + 1])];
  }

  if (jvalue != pvalue)
    quitf(_wa, "jury has answer %d, participant has answer %d", jvalue, pvalue);
  else
    quitf(_ok, "answer = %d", pvalue);
}
```

这个 checker 主要有两个问题：

1.  它确信标准输出是正确的。如果选手输出比标准输出更优，它会被判成 WA，这不太妙。同时，如果标准输出不合法，也会产生 WA。对于这两种情况，正确的操作都是返回 Fail 状态。
2.  读入标准输出和选手输出的代码是重复的。在这道题中写两遍读入问题不大，只需要一个 `for` 循环；但是如果有一道题输出很复杂，就会导致你的 checker 结构混乱。重复代码会大大降低可维护性，让你在 debug 或修改格式时变得困难。

读入标准输出和选手输出的方式实际上是完全相同的，这就是我们通常编写一个用流作为参数的读入函数的原因。

### 好的实现

```cpp
// clang-format off

#include "testlib.h"
#include <map>
#include <vector>
using namespace std;

map<pair<int, int>, int> edges;
int n, m, s, t;

// 这个函数接受一个流，从其中读入
// 检查路径的合法性并返回路径长度
// 当 stream 为 ans 时，所有 stream.quitf(_wa, ...)
// 和失败的 readXxx() 均会返回 _fail 而非 _wa
// 也就是说，如果输出非法，对于选手输出流它将返回 _wa，
// 对于标准输出流它将返回 _fail
int readAns(InStream& stream) {
  // 读入输出
  int value = 0;
  vector<int> path;
  vector<bool> used(n, false);
  int len = stream.readInt(2, n, "number of vertices");
  for (int i = 0; i < len; i++) {
    int v = stream.readInt(1, n, format("path[%d]", i + 1).c_str());
    if (used[v - 1]) {
      stream.quitf(_wa, "vertex %d was used twice", v);
    }
    used[v - 1] = true;
    path.push_back(v);
  }
  if (path.front() != s)
    stream.quitf(_wa, "path doesn't start in s: expected s = %d, found %d", s,
                 path.front());
  if (path.back() != t)
    stream.quitf(_wa, "path doesn't finish in t: expected t = %d, found %d", t,
                 path.back());
  for (int i = 0; i < len - 1; i++) {
    if (edges.find(make_pair(path[i], path[i + 1])) == edges.end())
      stream.quitf(_wa, "there is no edge (%d, %d) in the graph", path[i],
                   path[i + 1]);
    value += edges[make_pair(path[i], path[i + 1])];
  }
  return value;
}

int main(int argc, char* argv[]) {
  registerTestlibCmd(argc, argv);
  n = inf.readInt();
  m = inf.readInt();
  for (int i = 0; i < m; i++) {
    int a = inf.readInt();
    int b = inf.readInt();
    int w = inf.readInt();
    edges[make_pair(a, b)] = edges[make_pair(b, a)] = w;
  }
  int s = inf.readInt();
  int t = inf.readInt();

  int jans = readAns(ans);
  int pans = readAns(ouf);
  if (jans > pans)
    quitf(_wa, "jury has the better answer: jans = %d, pans = %d\n", jans,
          pans);
  else if (jans == pans)
    quitf(_ok, "answer = %d\n", pans);
  else  // (jans < pans)
    quitf(_fail, ":( participant has the better answer: jans = %d, pans = %d\n",
          jans, pans);
}
```

注意到这种写法我们同时也检查了标准输出是否合法，这样写 checker 让程序更短，且易于理解和 debug。此种写法也适用于输出 YES（并输出方案什么的），或 NO 的题目。

???+ note
    对于某些限制的检查可以用 `InStream::ensure/ensuref()` 函数更简洁地实现。如上例第 23 至 25 行也可以等价地写成如下形式：

    ```cpp
    stream.ensuref(!used[v - 1], "vertex %d was used twice", v);
    ```

???+ warning
    请在 `readAns` 中避免调用 **全局** 函数 `::ensure/ensuref()` ，这会导致在某些应判为 WA 的选手输出下返回 `_fail` ，产生错误。

## 建议与常见错误

-   编写 `readAns` 函数，它真的可以让你的 checker 变得很棒。

-   读入选手输出时永远限定好范围，如果某些变量忘记了限定且被用于某些参数，你的 checker 可能会判定错误或 RE 等。

    ##### 反面教材

    ```cpp
    // ....
    int k = ouf.readInt();
    vector<int> lst;
    for (int i = 0; i < k; i++)  // k = 0 和 k = -5 在这里作用相同（不会进入循环体）
      lst.push_back(ouf.readInt());
    // 但是我们并不想接受一个长度为 -5 的 list，不是吗？
    // ....
    int pos = ouf.readInt();
    int x = A[pos];
    // 可能会有人输出 -42, 2147483456 或其他一些非法数字导致 checker RE
    ```

    ##### 正面教材

    ```cpp
    // ....
    int k = ouf.readInt(0, n);  // 长度不合法会立刻判 WA 而不会继续 check 导致 RE
    vector<int> lst;
    for (int i = 0; i < k; i++) lst.push_back(ouf.readInt());
    // ....
    int pos = ouf.readInt(0, (int)A.size() - 1);  // 防止 out of range
    int x = A[pos];
    // ....
    ```

-   使用项别名

## 使用方法

通常我们不需要本地运行它，评测工具/OJ 会帮我们做好这一切。但是如果需要的话，以以下格式在命令行运行：

```bash
./checker <input-file> <output-file> <answer-file> [<report-file> [<-appes>]]
```

 **本文主要翻译自 [Checkers with testlib.h - Codeforces](https://codeforces.com/blog/entry/18431) 。 `testlib.h` 的 GitHub 存储库为 [MikeMirzayanov/testlib](https://github.com/MikeMirzayanov/testlib) 。** 

## generator
Generator，即数据生成器。当数据很大，手造会累死的时候，我们就需要它来帮助我们自动造数据。

## 简单的例子

生成两个 $[1,n]$ 范围内的整数：

```cpp
// clang-format off

#include "testlib.h"
#include <iostream>

using namespace std;

int main(int argc, char* argv[]) {
  registerGen(argc, argv, 1);
  int n = atoi(argv[1]);
  cout << rnd.next(1, n) << " ";
  cout << rnd.next(1, n) << endl;
}
```

## 为什么要使用 Testlib？

有人说写 generator 不需要用 Testlib，它在这没什么用。实际上这是个不正确的想法。一个好的 generator 应该满足这一点： **在任何环境下对于相同输入它给出相同输出** 。写 generator 就避免不了生成随机值，平时我们用的 `rand()` 或 C++11 的 `mt19937/uniform_int_distribution` ，当操作系统不同、使用不同编译器编译、不同时间运行等，它们的输出都可能不同（对于非常常用的 `srand(time(0))` ，这是显然的），而这就会给生成数据带来不确定性。

 **请确保所有与随机相关的函数均使用 Testlib 而非标准库提供的。** 

而 Testlib 中的随机值生成函数则保证了相同调用会输出相同值，与 generator 本身或平台均无关。另外。它给生成各种要求的随机值提供了很大便利，如 `rnd.next("[a-z]{1,10}")` 会生成一个长度在 $[1,10]$ 范围内的串，每个字符为 `a` 到 `z` ，很方便吧！

## Testlib 能做什么？

在一切之前，先执行 `registerGen(argc, argv, 1)` 初始化 Testlib（其中 `1` 是使用的 generator 版本，通常保持不变），然后我们就可以使用 `rnd` 对象来生成随机值。随机数种子取自命令行参数的哈希值，对于某 generator `g.cpp` ， `g 100` (Unix-Like) 和 `g.exe "100"` (Windows) 将会有相同的输出，而 `g 100 0` 则与它们不同。

 `rnd` 对象的类型为 `random_t` ，你可以建立一个新的随机值生成对象，不过通常你不需要这么做。

该对象有许多有用的成员函数，下面是一些例子：

| 调用                                | 含义                                                                                                                                                                                                                                                      |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  `rnd.next(4)`                    | 等概率生成一个 $[0,4)$ 范围内的整数                                                                                                                                                                                                                                  |
|  `rnd.next(4, 100)`               | 等概率生成一个 $[4,100]$ 范围内的整数                                                                                                                                                                                                                                |
|  `rnd.next(10.0)`                 | 等概率生成一个 $[0,10.0)$ 范围内的浮点数                                                                                                                                                                                                                              |
|  `rnd.next("one | two | three")`  | 等概率从 `one` , `two` , `three` 三个串中返回一个                                                                                                                                                                                                                   |
|  `rnd.wnext(4, t)`                |  `wnext()` 是一个生成不等分布（具有偏移期望）的函数， $t$ 表示调用 `next()` 的次数，并取生成值的最大值。例如 `rnd.wnext(3, 1)` 等同于 `max({rnd.next(3), rnd.next(3)})` ； `rnd.wnext(4, 2)` 等同于 `max({rnd.next(4), rnd.next(4), rnd.next(4)})` 。如果 $t<0$ ，则为调用 $-t$ 次，取最小值；如果 $t=0$ ，等同于 `next()` 。 |
|  `rnd.any(container)`             | 等概率返回一个具有随机访问迭代器（如 `std::vector` 和 `std::string` ）的容器内的某一元素的引用                                                                                                                                                                                          |

另外，不要使用 `std::random_shuffle()` ，请使用 Testlib 中的 `shuffle()` ，它同样接受一对迭代器。它使用 `rnd` 来打乱序列，即满足如上“好的 generator”的要求。

## 示例：生成一棵树

下面是生成一棵树的主要代码，它接受两个参数——顶点数和伸展度。例如，当 $n=10,t=1000$ 时，可能会生成链；当 $n=10,t=-1000$ 时，可能会生成菊花。

```cpp
#define forn(i, n) for (int i = 0; i < int(n); i++)

registerGen(argc, argv, 1);

int n = atoi(argv[1]);
int t = atoi(argv[2]);

vector<int> p(n);

/* 为节点 1..n-1 设置父亲 */
forn(i, n) if (i > 0) p[i] = rnd.wnext(i, t);

printf("%d\n", n);

/* 打乱节点 1..n-1 */
vector<int> perm(n);
forn(i, n) perm[i] = i;
shuffle(perm.begin() + 1, perm.end());

/* 根据打乱的节点顺序加边 */
vector<pair<int, int> > edges;
for (int i = 1; i < n; i++)
  if (rnd.next(2))
    edges.push_back(make_pair(perm[i], perm[p[i]]));
  else
    edges.push_back(make_pair(perm[p[i]], perm[i]));

/* 打乱边 */
shuffle(edges.begin(), edges.end());

for (int i = 0; i + 1 < n; i++)
  printf("%d %d\n", edges[i].first + 1, edges[i].second + 1);
```

## 一次性生成多组数据

跟不使用 Testlib 编写的时候一样，每次输出前重定向输出流就好，不过 Testlib 提供了一个辅助函数 `startTest(test_index)` ，它帮助你将输出流重定向到 `test_index` 文件。

## 一些注意事项

-   严格遵循题目的格式要求，如空格和换行，注意文件的末尾应有一个换行。
-   对于大数据首选 `printf` 而非 `cout` ，以提高性能。（不建议在使用 Testlib 时关闭流同步）
-   不使用 UB（Undefined Behavior，未定义行为），如本文开头的那个示例，输出如果写成 `cout << rnd.next(1, n) << " " << rnd.next(1, n) << endl;` ，则 `rnd.next()` 的调用顺序没有定义。

## 新特性：解析命令行参数

在之前，我们通常使用类似 `int n = atoi(argv[3]);` 的代码，但是这样并不好。有以下几点原因：

-   不存在第三个命令行参数的时候是不安全的；
-   第三个命令行参数可能不是有效的 32 位整数。

现在，你可以这样写： `int n = opt<int>(3)` 。与此同时，你也可以使用 `int64_t m = opt<int64_t>(1);` ， `bool t = opt<bool>(2);` 和 `string s = opt(4);` 等。

另外，testlib 同时也支持命名参数。如果有很多参数，这样 `g 10 20000 a true` 的可读性就会比 `g -n10 -m200000 -t=a -increment` 差。

在这种情况下，现在你可以在 generator 中使用以下代码：

```cpp
int n = opt<int>("n");
long long n = opt<long long>("m");
string t = opt("t");
bool increment = opt<bool>("increment");
```

你可以自由地混合使用按下标和按名称读取参数的方式。

支持的用于编写命名参数的方案有以下几种：

-    `--key=value` 或 `-key=value` ；
-    `--key value` 或 `-key value` ——如果 `value` 不是新参数的开头（不以连字符 `-` 开头或一个/两个连字符后没有跟随字母）；
-    `--k12345` 或 `-k12345` ——如果 key `k` 是一个字母，且后面是一个数字；
-    `-prop` 或 `--prop` ——启用 bool 属性。

下面是一些例子：

```text
g1 -n1
g2 --len=4 --s=oops
g3 -inc -shuffle -n=5
g4 --length 5 --total 21 -ord
```

## 更多示例

可以在 [GitHub](https://github.com/MikeMirzayanov/testlib/tree/master/generators) 中找到。

 **本文主要翻译自 [Генераторы на testlib.h - Codeforces](https://codeforces.com/blog/entry/18291) 。新特性翻译自 [Testlib: Opts—parsing command line options](https://codeforces.com/blog/entry/72702) 。 `testlib.h` 的 GitHub 存储库为 [MikeMirzayanov/testlib](https://github.com/MikeMirzayanov/testlib) 。** 

# lang
# pas-cpp
author: kexplorning, Ir1d

> 用来急救，不多废话。

???+note "药方食用提示"
    本急救贴可以让您充分了解以下内容（对应 [C++ 语法快速提要](#c-start-here) ）：

    - 基本语法（块语句、注释、导入库、简单输入输出、声明变量、赋值……）
    - C++ 的 Hello World 与 A+B Problem 写法与解释

    [对应语法](#syntax) 部分较为紧凑，正式食用可能需要额外参考资料（已给出）。此部分不包括指针与 C 风格数组的介绍，也没有结构体、运算符重载等等。

    [重要不同之处](#differences) 部分为 C++ 的语法特点，也是 Pascal 转 C++ 时会碰到的坑。

    如要快速查找，请见附录：

    - [附 A：Pascal 与 C++ 运算符与数学函数语法对比表](#apascal-c-pascal-vs-c-operator-syntax-table)
    - [附 B：文章检索](#b-index) - 按 C++ 语句语法索引

<!-- 

INFO: 恭喜你找到了隐藏彩蛋！

> ！！⚠️ **警告** ⚠️！！
> 
> ~~☠ **有毒物品警告**~~  ~~☣️ **腐化身心警告**~~
> 
> ~~此药方仅适用于 Pascal 中毒症状早期；若您是晚期，本药方不能使您快速康复（不能让您理解指针），请节哀顺变（顺其自然），或遵循本 Wiki 其他页面等医嘱，或删除技能树重练。~~
> 
> ~~本药方治疗机理为**以毒攻毒**，故副作用是 C++ 中毒症状，请服用此方前再三确认。本药方贡献者与本 Wiki 不承担您使用发生意外时的任何责任。~~
> 
> 欢迎对本药方进行小白鼠测试（可在初具规模之后，使用猿类进行实验），也非常欢迎通过发评论、发 issue、提交 PR 进行实验结果反馈与药方改进。
> ~~若您想要特效药，本 Wiki 有[一剂](./python)：~~
> 
> > 人生苦短，我用 Python。
> 
> 可以让您超脱世间，驾鹤西去，再也不用因 OI 而困扰。 

-->

## C++ 快速安装与环境配置

> 注意：这里假设使用的系统是 Windows。

### 方式一：使用 IDE

以下 IDE 选择一个即可：

-    [Dev-C++](https://sourceforge.net/projects/orwelldevcpp/) 
-    [Code::Blocks](https://sourceforge.net/projects/codeblocks/) 
-    [Visual Studio](https://visualstudio.microsoft.com/) （Community 版本够用）

### 方式二：使用 代码编辑器 + 编译器 + 调试器

如果愿意折腾就去配吧，此处略，需要注意配置环境变量。

## C++ 语法快速提要 Start Here

C++ 程序都是从 `main` 这个部分开始运行的。

大括号表示块语句的开始与结束： `{` 就相当于 Pascal 里面的 `begin` ，而 `}` 就相当于 `end` 。

注意，和 Pascal 一样，C++ 每句话结束要加分号 `;` ，不过大括号结尾不需要有分号，而且程序结束末尾不用打句号 `.` 。

 `//` 表示行内注释， `/* */` 表示块注释。

按照惯例，看看 Hello World 吧。

### Hello World：第一个 C++ 程序

```cpp
#include <iostream>  // 导入 iostream 库

int main(int argc, char const *argv[])  // main 部分
{
  std::cout << "Hello World!" << std::endl;

  return 0;
}
```

然后编译运行一下，看看结果。

#### 简要解释

第一行， `#include <iostream>` 的意思是，导入 `iostream` 这个库。

??? note "Pascal 的库文件"
    Pascal 其实是有库文件的，只不过，很多同学从来都没有用过……

看到第三行的 `main` 吗？程序从 `main` 开始执行。

接下来最重要的一句话是

```cpp
std::cout << "Hello World!" << std::endl;
```

 `std::cout` 是输出（ `cout` 即 C-out）的命令。你可能看过有些 C++ 程序中直接写的是 `cout` 。

??? note "有关 std:: 前缀"
    有关 `std::` 这个前缀的问题，请见 [这节](../basic/#cin-cout) 底下的注释「什么是 std？」。

中间的 `<<` 很形象地表示流动，其实它就是表示输出怎么「流动」的。这句代码的意思就是， `"Hello World!"` 会先被推到输出流，之后 `std::endl` 再被推到输出流。

而 `std::endl` 是 **输出** 换行（ `endl` 即 end-line）命令，这与 Pascal 的 `writeln` 类似，不过 C++ 里面可没有 `coutln` 。Pascal 与 C++ 的区别在于， `write('Hello World!')` 等价于 `std::cout << "Hello World!"` ，而 `writeln('Hello World!')` 等价于 `std::cout << "Hello World!" << std::endl` 。

此处 `"Hello World!"` 是字符串，Pascal 中字符串都是用单引号 `'` 不能用双引号，而 C++ 的字符串必须用双引号。C++ 中单引号包围的字符会有别的含义，后面会再提及的。

好了，到这里 Hello World 应该解释的差不多了。

可能有同学会问，后面那个 `return 0` 是什么意思？那个 `int main(int argc, char const *argv[])` 是啥意思？ **先别管它** ，一开始写程序的时候先把它当作模板来写吧（这里也是用模板写的）。不过，入门时并不会用到 `main` 中参数，所以写成 `int main()` 也是没有关系的。

#### 简单练习

1.  试着换个字符串输出。
2.  试着了解转义字符。

### A+B Problem：第二个 C++ 程序

经典的 A+B Problem。

```cpp
#include <iostream>

int main(int argc, char const *argv[]) {
  int a, b, c;

  std::cin >> a >> b;

  c = a + b;

  std::cout << c << std::endl;

  return 0;
}
```

注：代码空行较多，若不习惯可去掉空行。

#### 简要解释

 `std::cin` 是读入（ `cin` 即 C-in）， `>>` 也与输出语法的类似。

这里多出来的语句中最重要的是两个，一个是变量声明语句

```cpp
int a, b, c;
```

你可能习惯于 Pascal 里面的声明变量

```pas
var
a, b, c: integer;
```

C++ 的声明是直接以数据类型名开头的，在这里， `int` （整型）开头表示接下来要声明变量。

接着一个最重要的语句就是赋值语句

```cpp
c = a + b;
```

这是 Pascal 与 C++ 语法较大的不同， **这是个坑** ：Pascal 是 `:=` ，C++ 是 `=` ；而 C++ 判断相等是 `==` 。

C++ 也可直接在声明时进行变量初始化赋值

```cpp
int a = 0, b = 0, c = 0;
```

#### 简单练习

1.  重写一遍代码，提交到 OJ 上，并且 AC。
2.  更多的输入输出语法参考 [这节内容](../basic/#scanf-printf) ，并试着了解 C++ 的格式化输出。

### 结束语与下一步

好了，到现在为止，你已经掌握了一些最基本的东西了，剩下就是找 Pascal 和 C++ 里面对应的语法和不同的特征。

不过在此之前，强烈建议先看 [变量作用域：全局变量与局部变量](#scope) ，也可使用 [附 B：文章检索](#index) 查阅阅读。

请善用<kbd>Alt</kbd>+<kbd>←</kbd>与<kbd>Alt</kbd>+<kbd>→</kbd>返回跳转。

## 对应语法 Syntax

### 变量 Variable

#### 基本数据类型 Fundamental types

C++ 与 Pascal 基本上差不多，常见的有

-    `bool` Boolean 类型
-    `int` 整型
-   浮点型
    -    `float` 
    -    `double` 
-    `char` 字符型
-    `void` 无类型

C++ 的单引号是专门用于表示单个字符的（字符型），比如 `'a'` ，而字符串（字符型数组）必须要用双引号。

C++ 还要很多额外的数据类型，请参考更多资料。

扩展阅读：

-    [基础类型 - cppreference.com](https://zh.cppreference.com/w/cpp/language/types) 

#### 常量声明 Constant

```cpp
const double PI = 3.1415926;
```

若不清楚有关宏展开的问题，建议使用常量，而不用宏定义。

### 运算符 Operator

请直接参考

-    [附 A：Pascal 与 C++ 运算符与数学函数语法对比表](#apascal-c-pascal-vs-c-operator-syntax-table) 
-    [运算 - OI Wiki](../op/) 

### 条件

####  `if` 语句

```pas
if (a = b) and (a > 0) and (b > 0) then
    begin
        b := a;
    end
else
    begin
        a := b;
    end;
```

```cpp
if (a == b && a > 0 && b > 0) {
  b = a;
} else {
  a = b;
}
```

布尔运算与比较

-    `and` -> `&&` 
-    `or` -> `||` 
-    `not` -> `!` 
-    `=` -> `==` 
-    `<>` -> `!=` 

注释：

1.  Pascal 中 `and` 与 C++ 中 `&&` 优先级不同，C++ 不需要给判断条件加括号。
2.  Pascal 中判断相等是 `=` ，赋值是 `:=` ；C++ 中判断相等是 `==` ，赋值是 `=` 。
3.  如果在 `if` 语句的括号内写了 `a = b` 而不是 `a == b` ，程序不会报错，而且会把 `b` 赋值给 `a` ， `a = b` 这个语句的返回结果是 `true` 。
4.  C++ 不需要思考到底要不要在 `end` 后面加分号。
5.  C++ 布尔运算中，非布尔值可以自动转化为布尔值。

???+note "易错提醒"
    特别注意： **不要把 `==` 写成 `=` ！** 

    由于 C/C++ 比 Pascal 语法灵活，如果在判断语句中写了 `if (a=b) {`，那么程序会顺利运行下去，因为 C++ 中 `a=b` 是有返回值的。

####  `case` 与 `switch` 

用到得不多，此处不详细展开。

需要注意：C++ 没有 `1..n` ，也没有连续不等式（比如 `1 < x < 2` ）。

### 循环 Loop

以下三种循环、六份代码实现的功能是一样的。

####  `while` 循环

 `while` 很相似。（C++ 此处并非完整程序，省略一些框架模板，后同）

```pas
var i: integer;

begin
    i := 1;
    while i <= 10 do
        begin
            write(i,' ');
            inc(i); // 或者 i := i + 1;
        end;
end.
```

```cpp
int i = 1;
while (i <= 10) {
  std::cout << i << " ";
  i++;
}
```

####  `for` 循环

C++ 的 `for` 语句非常不同。

```pas
var i: integer;

begin
    for i:= 1 to 10 do
        begin
            write(i, ' ');
        end;
end.
```

```cpp
for (int i = 1; i <= 10; i++) {
  std::cout << i << " ";
}
```

注释：

1.   `for (int i = 1; i <= 10; i++){` 这一行语句很多， `for` 中有三个语句。
2.  第一个语句 `int i = 1;` 此时声明一局部变量 `i` 并初始化。（这个设计比 Pascal 要合理得多。）
3.  第二个语句 `i <= 10;` 作为判断循环是否继续的标准。
4.  第三个语句 `i++` ，在每次循环结尾执行，意思大约就是 Pascal 中的 `inc(i)` ，此处写成 `++i` 也是一样的。 `i++` 与 `++i` 的区别请参考其他资料。

####  `repeat until` 与 `do while` 循环

注意， `repeat unitl` 与 `do while` 是不同的，请对比以下代码

```pas
var i: integer;

begin
    i := 1;
    repeat
        write(i, ' ');
        inc(i);
    until i = 11;
end.
```

```cpp
int i = 1;
do {
  std::cout << i << " ";
  i++;
} while (i <= 10);
```

#### 循环控制 Loop Control

C++ 中 `break` 的作用与 Pascal 是一样的，退出循环。

而 `continue` 也是一样的，跳过当前循环，进入下一次循环（回到开头）。

### 数组与字符串 Array and String

#### 不定长数组：标准库类型 Vector

C++ 标准库中提供了 `vector` ，相当于不定长数组，调用前需导入库文件。

```cpp
#include <iostream>
#include <vector>  // 导入 vector 库

int main(int argc, char const *argv[]) {
  std::vector<int> a;  // 声明 vector a 并定义 a 为空 vector 对象
  int n;

  std::cin >> n;
  // 读取 a
  for (int i = 0; i < n; i++) {
    int t;
    std::cin >> t;
    a.push_back(t);  // 将读入的数字 t，放到 vector a 的末尾；该操作复杂度 O(1)
    /* 这里不能使用下标访问来赋值，因为声明时，a 大小依然为空，
    此处使用 `a[i] = t;` 是错误做法。
    */
  }

  // 将读入到 a 中的所有数打印出
  for (int i = 0; i < n; i++) {
    std::cout << a[i] << ", ";  // !注意，a 中第一个数是 a[0]；
    // 如果下标越界，它会返回一个未知的值（溢出），而不会报错
  }
  std::cout << std::endl;

  return 0;
}
```

C++ 访问数组成员，与 Pascal 类似，不过有很重要的区别：数组的第一项是 `a[0]` ，而 Pascal 中是可以自行指定的。

扩展阅读：

-    [序列式容器 - OI Wiki](../csl/sequence-container/) 

#### 字符串：标准库类型 String

C++ 标准库中提供了 `string` ，与 `vector` 可以进行的操作有些相同，同样需要导入库文件。

```cpp
#include <iostream>
#include <string>

int main(int argc, char const *argv[]) {
  std::string s;  // 声明 string s

  std::cin >> s;  // 读入 s；
  // 读入时会忽略开头所有空格符（空格、换行符、制表符），读入的字串直到下一个空格符为止。

  std::cout << s << std::endl;

  return 0;
}
```

扩展阅读：

-    [string - OI Wiki](../csl/string/) 

#### C 风格数组 Array

如果要用不定长的数组请用 Vector，不要用 C 风格的数组。

C 风格的数组与指针有密切关系，所以此处不多展开。

扩展阅读：

-    [数组 - OI Wiki](../array/) 

## 重要不同之处 Differences

### 变量作用域 Scope：全局变量与局部变量

C++ 几乎可以在 **任何地方** 声明变量。

以下对于 C++ 的变量作用域的介绍摘自 [变量作用域 - OI Wiki](../var/#_3) ：

> 作用域是变量可以发挥作用的代码块。
>
> 变量分为全局变量和局部变量。在所有函数外部声明的变量，称为全局变量。在函数或一个代码块内部声明的变量，称为局部变量。
>
> 全局变量的作用域是整个文件，全局变量一旦声明，在整个程序中都是可用的。
>
> 局部变量的作用域是声明语句所在的代码块，局部变量只能被函数内部或者代码块内部的语句使用。
>
> 由一对大括号括起来的若干语句构成一个代码块。
>
> ```cpp
> int g = 20;  // 声明全局变量
> int main() {
>   int g = 10;         // 声明局部变量
>   printf("%d\n", g);  // 输出 g
>   return 0;
> }
> ```
>
> 在一个代码块中，局部变量会覆盖掉同名的全局变量，比如上面的代码输出的 `g` 就是 `10` 而不是 `20` 。为了防止出现意料之外的错误，请尽量避免局部变量与全局变量重名的情况。

在写 Pascal 过程/函数时，容易忘记声明局部变量 `i` 或者 `j` ，而一般主程序里会有循环，于是大部分情况下 `i` 与 `j` 都是全局变量，于是，在这种情况下，过程/函数中对 `i` 操作极易出错。更要命的是，如果忘记声明这种局部变量，编译器编译不报错，程序可以运行。（有很多难找的 bug 就是这么来的。）

所以，在使用 C++ 时，声明变量，比如循环中使用的 `i` ， **不要用全局变量，能用局部变量就用局部变量** 。如果这么做，不用担心函数中变量名（比如 `i` ）冲突。

??? note "额外注"
    Pascal 可在某种程度上避免这个问题，仿照 C++ 的方法，主程序只有调用过程/函数，不声明 `i`  `j` 这类极易名称冲突的全局变量，如果需要循环，另写一个过程进行调用。

### C++ 可以自动转换类型

```cpp
int i = 2;
if (i) {  // i = 0 会返回 false，其余返回 true
  std::cout << "true";
} else {
  std::cout << "false";
}
```

不光是 `int` 转成 `bool` ，还有 `int` 与 `float` 相互转换。在 Pascal 中可以把整型赋给浮点型，但不能反过来。C++ 没有这个问题。

```cpp
int a;
a = 3.2;      // 此时 a = 3
float b = a;  // 此时 b = 3.0
```

区分 `/` 是整除还是浮点除法，是通过除数与被除数的类型判断的

```cpp
float a = 32 / 10;    // 32/10 的结果是 3（整除）；a = 3.0
float b = 32.0 / 10;  // 32.0/10 的结果是 3.2；b = 3.2
```

 `pow(a, b)` 计算 $a^b$ ，该函数返回的是浮点型，如果直接用来计算整数的幂，由于有自动转换，不需要担心它会报错

```cpp
int a = pow(2, 3);  // 计算 2^3
```

还有 `char` 与 `int` 之间相互转换。

```cpp
char a = 48;              // ASCII 48 是 '0'
int b = a + 1;            // b = 49
std::cout << (a == '0');  // true 输出 1
```

其实 C++ 中的 `char` 与 `bool` 本质上是整型。

扩展阅读：

-    [隐式转换 - cppreference.com](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 注意内容可能过于专业

### C++ 很多语句有返回值：以如何实现读取数量不定数据为例

有些时候需要读取到数据结束，比如，求一组不定数量的数之和（数据可以多行），直到文件末尾，实现方式是

??? note "文件末尾 EOF"
    EOF，文件末尾标识符，在命令行中 Windows 上以<kbd>Ctrl</kbd>+<kbd>Z</kbd>输入（还需按<kbd>Enter</kbd>），\*unix 系统以<kbd>Ctrl</kbd>+<kbd>D</kbd>输入。

```cpp
#include <iostream>

int main(int argc, char const *argv[]) {
  int sum = 0, a = 0;

  while (std::cin >> a) {
    sum += a;
  }
  std::cout << sum << std::endl;

  return 0;
}
```

实现原理： `while (std::cin >> a)` 中 `std::cin >> a` 若在输入有问题或遇到文件结尾时，会返回 false，使得循环中断。

### 函数 Function：C++ 只有函数没有过程但有 `void` ，没有函数值变量但有 `return` 。

Pascal 函数与 C++ 函数对比示例：

```pas
function abs(x:integer):integer;
begin
    if x < 0 then
        begin
            abs := -x;
        end
    else
        begin
            abs := x;
        end;
end;
```

```cpp
int abs(int x) {
  if (x < 0) {
    return -x;
  } else {
    return x;
  }
}
```

C++ 中函数声明 `int abs` ，就定义了 `abs()` 函数且返回值为 `int` 型（整型），函数的返回值就是 `return` 语句给出的值。

如果不想有返回值（即 Pascal 的「过程」），就用 `void` 。 `void` 即「空」，什么都不返回。

```pas
var ans: integer;

procedure printAns(ans:integer);
begin
    writeln(ans);
end;

begin
    ans := 10;
    printAns(ans);
end.
```

```cpp
#include <iostream>

void printAns(int ans) {
  std::cout << ans << std::endl;

  return;
}

int main(int argc, char const *argv[]) {
  int ans = 10;
  printAns(ans);

  return 0;
}
```

C++ 的 `return` 与 Pascal 中给函数变量赋值有一点非常大的不同。C++ 的 `return` 即返回一个值，执行完这个语句，函数就执行结束了；而 Pascal 中给函数变量赋值并不会跳出函数本身，而是继续执行。于是，如果 Pascal 需要某处中断函数/过程，就需要一个额外的命令，即 `exit` 。而 C++ 则不需要，如果需要在某处中断，可以直接使用 `return` 。比如（由于实在想不出来简短且实用的代码，所以就先这样）

```cpp
#include <iostream>

void printWarning(int x) {
  if (x >= 0) {
    return;  // 该语句在此处相当于 Pascal 中的 `exit;`
  }
  std::cout << "Warning: input a negative number.";
}

int main(int argc, char const *argv[]) {
  int a;

  std::cin >> a;
  printWarning(a);

  return 0;
}
```

而在某种意义上，前面的 `abs` 函数，这样才是严格等效的

```pas
function abs(x:integer):integer;
begin
    if x < 0 then
        begin
            abs := -x; exit; // !注意此处
        end
    else
        begin
            abs := x;  exit; // !注意此处
        end;
end;
```

```cpp
int abs(int x) {
  if (x < 0) {
    return -x;
  } else {
    return x;
  }
}
```

???+note "特别提醒"
    C++ 中 `exit` 是退出程序；不要顺手把 `exit` 打上去，要用 `return` ！

C++ 把函数和过程统统视作函数，连 `main` 都不放过，比如写 `int main` ，C++ 视 `main` 为一个整型的函数，这里返回值是 `0` 。它是一种习惯约定，返回 `0` 代表程序正常退出。

也许你已经猜到了， `main(int argc, char const *argv[])` 中的参数就是 `int argc` 与 `char const *argv[]` ，不过意义请参考其他资料。

### 在函数中传递参数 Passing Parameters to Functions

C++ 中没有 Pascal 的 `var` 关键字可以改变传递的参数

```pas
var a, b: integer;

procedure swap(var x,y:integer);
var temp:integer;
begin
    temp := x;
    x := y;
    y := temp;
end;

begin
    a := 10; b:= 20;    
    swap(a, b);
    writeln(a, ' ', b);
end.
```

```cpp
#include <iostream>

void swap(int* x, int* y) {
  int temp;
  temp = *x;
  *x = *y;
  *y = temp;
}

int main(int argc, char const* argv[]) {
  int a = 10, b = 20;
  swap(&a, &b);
  std::cout << a << " " << b;

  return 0;
}
```

注意，此处 C++ 代码涉及指针问题。指针问题还是很麻烦的，建议去阅读相关资料。

C++ 中函数传递参数还有其他方法，其中一种是 **直接使用全局变量传递参数** ，如果不会用指针，可以先用这种方法。

## C++ 标准库与参考资料 Reference

千万不要重复造轮子（除非为了练习），想要自己动手写一个功能出来之前，先去看看有没有这个函数或者数据结构。

### C++ 标准库

C++ 标准库中 `<algorithm>` 有很多有用的函数比如快排、二分查找等，可以直接调用。请参考这个页面： [STL 算法 - OI Wiki](../csl/algorithm/) 。

还有 STL 容器，比如数组、向量（可变大小的数组）、队列、栈等，附带很多函数。请参考这个页面： [STL 容器简介 - OI Wiki](../csl/container/) 。

如果要找关于字符串操作的函数见

-    [std::basic_string - cppreference.com](https://zh.cppreference.com/w/cpp/string/basic_string) 
-    [ `<string>` - C++ Reference](https://www.cplusplus.com/reference/string/) 

C/C++ 的指针是很灵活的东西，如果想要彻底理解指针，建议找本书或者参考手册仔细阅读。

-    [指针 - OI Wiki](../pointer) 

### 错误排查与技巧

-    [常见错误 - OI Wiki](../../intro/common-mistakes/) 
-    [常见技巧 - OI Wiki](../../intro/common-tricks/) 

### C++ 语言资料

-    [学习资源 - OI Wiki](../../intro/resources/) 
-    [cppreference.com](https://zh.cppreference.com/) - 最重要的 C/C++ 参考资料
-    [C++ 教程 - 菜鸟教程](https://www.runoob.com/cplusplus/cpp-tutorial.html) 
-    [C++ Language - C++ Tutorials](https://www.cplusplus.com/doc/tutorial/) 
-    [Reference - C++ Reference](https://www.cplusplus.com/reference/) 
-    [C++ Standard Library - Wikipedia](https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library) 
-    [The Ultimate Question of Programming, Refactoring, and Everything](https://www.gitbook.com/book/alexastva/the-ultimate-question-of-programming-refactoring-/details) 
-    [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html) 

## 后记

写到这里，很多同学会觉得这一点都不急救啊，有很多东西没有提到啊。那也是没办法的事情。

虽然是为了急救，但很多东西像怎么把字符串转化为数字，怎么搜索字符串中的字符，这些东西也不适合一篇精悍短小的急救帖，如果把这些都写出来，那就是 C++ 入门教程，所以请充分利用本 Wiki、参考手册与搜索引擎。

需要指出的一点是，上面说 C++ 的语法，其实有很多语法是从 C 语言来的，标题这么写比较好——《Pascal 转 C/C++ 急救帖》。

Pascal 在上个世纪后半叶是门很流行的语言，它早于 C 语言，不过随着 UNIX 系统的普及，微软使用 C 语言，现在 Pascal 已经成为历史了。Pascal 后期发展也是有的，比如 Free Pascal 这个开源编译器项目，增加面向对象的特性（Delphi 语言）。Pascal 目前的用处除了在信息竞赛外，有一个特点是其他语言没有的——编译支持非常非常多老旧机器，比如 Gameboy 这种上个世纪的任天堂游戏机，还有一个用处就是以伪代码的形式（Pascal 风格的伪代码）出现在各种教科书中。

最后，Pascal 的圈子其实很小，C/C++ 的圈子很大，帮助手册与教程很多很全，一定要掌握好英语。世界上还有很多很多编程语言，而计算机这门学科与技术不光是信息竞赛和编程语言。

### 本文 Pascal 语言的参考文献

-    [Lazarus wiki](https://wiki.freepascal.org/) 
-    [Free Pascal Reference guide](https://freepascal.org/docs-html/current/ref/ref.html) 

## 附 A：Pascal 与 C++ 运算符与数学函数语法对比表 Pascal vs C++ Operator Syntax Table

> 仅包括最常用的运算符与函数。

### 基本算术

|      | Pascal      | C++       |
| ---- | ----------- | --------- |
| 加法   |  `a + b`    |  `a + b`  |
| 减法   |  `a - b`    |  `a - b`  |
| 乘法   |  `a * b`    |  `a * b`  |
| 整除   |  `a div b`  |  `a / b`  |
| 浮点除法 |  `a / b`    |  `a / b`  |
| 取模   |  `a mod b`  |  `a % b`  |

### 逻辑

|     | Pascal      | C++        |
| --- | ----------- | ---------- |
| 非   |  `not(a)`   |  `!a`      |
| 且   |  `a and b`  |  `a && b`  |
| 或   |  `a or b`   |  `a || b`  |

### 比较

|      | Pascal     | C++        |
| ---- | ---------- | ---------- |
| 相等   |  `a = b`   |  `a == b`  |
| 不等   |  `a <> b`  |  `a != b`  |
| 大于   |  `a > b`   |  `a > b`   |
| 小于   |  `a < b`   |  `a < b`   |
| 大于等于 |  `a >= b`  |  `a >= b`  |
| 小于等于 |  `a <= b`  |  `a <= b`  |

### 赋值

|     | Pascal                          | C++        |
| --- | ------------------------------- | ---------- |
|     |  `a := b`                       |  `a = b`   |
|     |  `a := a + b`                   |  `a += b`  |
|     |  `a := a - b`                   |  `a -= b`  |
|     |  `a := a * b`                   |  `a *= b`  |
|     |  `a := a div b` 或 `a := a / b`  |  `a /= b`  |
|     |  `a := a mod b`                 |  `a &= b`  |

### 自增/自减

|     | Pascal     | C++     |
| --- | ---------- | ------- |
| 自增  |  `inc(a)`  |  `a++`  |
| 自增  |  `inc(a)`  |  `++a`  |
| 自减  |  `dec(a)`  |  `a--`  |
| 自减  |  `dec(a)`  |  `--a`  |

### 数学函数

> 使用需要导入 `<cmath>` 库。

|         | Pascal       | C++              |
| ------- | ------------ | ---------------- |
| 绝对值     |  `abs(a)`    |  `abs(a)` （整数）   |
| 绝对值     |  `abs(a)`    |  `fabs(a)` （浮点数） |
|  $a^b$  | N/A (\*)     |  `pow(a, b)`     |
| 截断取整    |  `trunc(a)`  |  `trunc(a)`      |
| 近似取整    |  `round(a)`  |  `round(a)`      |

\*Extended Pascal 中有 `a**b` 不过需要导入 `Math` 库。

其他函数请参考：

-    [常用数学函数 - cppreference.com](https://zh.cppreference.com/w/cpp/numeric/math) 

## 附 B：文章检索 Index

> 按 C++ 语句语法索引。

-    [基本语法](#c-start-here) 
-    [变量](#variable) 
    -    [数据类型](#fundamental-types) 
    -    [常量声明](#constant) 
    -    [作用域](#scope) 
-    [运算符](#operator) 
-    [if 语句](#if) 
    -   if
    -   else
-    [循环语句](#loop) 
    -    [for 语句](#for) 
    -    [while 语句](#while) 
    -    [do while 语句](#repeat-until-do-while) 
    -    [break, continue](#loop-control) 
-    [函数](#functionc-void-return) 
    -    [函数定义，return](#functionc-void-return) 
    -    [函数传参](#passing-parameters-to-functions) 
-    [数组与字符串](#array-and-string) 
    -    [不定长数组 Vector](#vector) 
    -    [C 风格数组](#c-array) 
    -    [字符串 String](#string) 
-    [资料](#c-reference) 

# struct
author: Ir1d, cjsoft, Lans1ot
结构体（struct），可以看做是一系列称为成员元素的组合体。

可以看做是自定义的数据类型。

_本页描述的 `struct` 不同于 C 中 `struct` ，在 C++ 中 `struct` 被扩展为类似 [ `class` ](./class.md) 的类说明符_。

## 定义结构体

```cpp
struct Object {
  int weight;
  int value;
} e[array_length];

const Object a;
Object b, B[array_length], tmp;
Object *c;
```

上例中定义了一个名为 `Object` 的结构体，两个成员元素 `value,weight` ，类型都为 `int` 。

在 `}` 后，定义了数据类型为 `Object` 的常量 `a` ，变量 `b` ，变量 `tmp` ，数组 `B` ，指针 `c` 。对于某种已经存在的类型，都可以使用这里的方法进行定义常量、变量、指针、数组等。

_关于指针：不必强求掌握。_

### 定义指针

如果是定义内置类型的指针，则与平常定义指针一样。

如果是定义结构体指针，在定义中使用 `StructName*` 进行定义。

```cpp
struct Edge {
  /*
  ...
  */
  Edge* nxt;
};
```

上例仅作举例，不必纠结实际意义。

## 访问/修改成员元素

可以使用 `变量名.成员元素名` 进行访问（其中双引号不写入程序，下同）。

如 : 输出 `var` 的 `v` 成员： `cout << var.v` 。

也可以使用 `指针名->成员元素名` 或者 使用 `(*指针名).成员元素名` 进行访问。

如 : 将结构体指针 `ptr` 指向的结构体的成员元素 `v` 赋值为 `tmp` ： `(*ptr).v = tmp` 或者 `ptr->v = tmp` 。

## 为什么需要结构体？

首先，条条大路通罗马，可以不使用结构体达到相同的效果。但是结构体能够显式地将成员元素（在算法竞赛中通常是变量）捆绑在一起，如本例中的 `Object` 结构体，便将 `value,weight` 放在了一起（定义这个结构体的实际意义是表示一件物品的重量与价值）。这样的好处边是限制了成员元素的使用。  
想象一下，如果不使用结构体而且有两个数组 `value[],Value[]` ，很容易写混淆。但如果使用结构体，能够减轻出现使用变量错误的几率。

并且不同的结构体（结构体类型，如 `Object` 这个结构体）或者不同的结构体变量（结构体的实例，如上方的 `e` 数组）可以拥有相同名字的成员元素（如 `tmp.value,b.value` ），同名的成员元素相互独立（拥有独自的内存，比如说修改 `tmp.value` 不会影响 `b.value` 的值）。  
这样的好处是可以使用尽可能相同或者相近的变量去描述一个物品。比如说 `Object` 里有 `value` 这个成员变量；我们还可以定义一个 `Car` 结构体，同时也拥有 `value` 这个成员；如果不使用结构体，或许我们就需要定义 `valueOfObject[],valueOfCar[]` 等不同名称的数组来区分。

_如果想要更详细的描述一种事物，还可以定义成员函数。请参考 [类](./class.md) 获取详细内容。_

## 更多的操作？

详见 [类](./class.md) 

## 参考资料

1.   [cppreference class](https://zh.cppreference.com/w/cpp/language/class) 
2.   [cplusplus Data structures](http://www.cplusplus.com/doc/tutorial/structures/) 

# java
## 关于 Java

Java 是一种广泛使用的计算机编程语言，拥有 **跨平台** 、 **面向对象** 、 **泛型编程** 的特性，广泛应用于企业级 Web 应用开发和移动应用开发。

## 环境安装

使用 [OpenJDK](https://jdk.java.net/) 作为实例，下载下来的都是压缩包，解压缩此处略过

### Windows

将解压缩后的文件夹放到你想放的位置，假设你解压后放到了 `C:\Program Files\Java\jdk-14` ,

![第一步](images/java1.png)

![第二步](images/java2.png)

![第三步](images/java3.png)

![第四步](images/java4.png)

![第五步](images/java5.png)

![第六步](images/java6.png)

### Linux

#### 使用包管理器安装

可以使用包管理器提供的 JDK。具体指令如下

```bash
sudo apt install default-jre
sudo apt install default-jdk
```

如果 `CentOS` 则使用的是 `yum` 安装，命令如下：

```bash
sudo yum install java-1.8.0-openjdk
```

在稍后询问是否安装时按下 `y` 继续安装
或是你已经下好了 `rpm` 文件，可以使用以下命令安装

```bash
sudo yum localinstall jre-9.0.4_linux_x64_bin.rpm #安装jre-9.0
sudo yum localinstall jdk-9.0.4_linux-x64_bin.rpm #安装jdk-9.0
```

#### 手动安装

```bash
sudo mv jdk-14 /opt
```

并在 `.bashrc` 文件末尾添加

```bash
export JAVA_HOME="/opt/jdk-14/bin"
export PATH=${JAVA_HOME}:$PATH
```

在控制台中输入命令 `source ~/.bashrc` 即可重载。如果是使用的 zsh 或其他命令行，在 `~/.zshrc` 或对应的文件中添加上面的内容

### MacOS

如果是 MacOS，你可以使用以下命令安装包

```bash
cd ~/Downloads
curl -v -j -k -L -H "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/8u121-b13/e9e7ea248e2c4826b92b3f075a80e441/jdk-8u121-macosx-x64.dmg > jdk-8u121-macosx-x64.dmg
hdiutil attach jdk-8u121-macosx-x64.dmg
sudo installer -pkg /Volumes/JDK\ 8\ Update\ 121/JDK\ 8\ Update\ 121.pkg -target /
diskutil umount /Volumes/JDK\ 8\ Update\ 121
rm jdk-8u121-macosx-x64.dmg
```

或者直接在官方网站下载 `pkg` 包或 `dmg` 包安装

## 基本语法

 **_注意_**  `Java` 类似 `C/C++` 语言，有一个函数作为程序执行的起始点，所有的程序只有一个主函数，每次执行的时候都会从主类开始，主函数是整个程序的入口，一切从此处开始。

### 注释

和 `C/C++` 一样， `Java` 使用 `//` 和 `/* */` 分别注释单行和多行

### 基本数据类型

|   类型名   |   意义  |
| :-----: | :---: |
| boolean |  布尔类型 |
|   byte  |  字节类型 |
|   char  |  字符型  |
|  double | 双精度浮点 |
|  float  | 单精度浮点 |
|   int   |   整型  |
|   long  |  长整型  |
|  short  |  短整型  |
|   null  |   空   |

### 申明变量

```java
int a = 12;//设置a为整数类型,并给a赋值12
String str = "Hello, OI-wiki"; //申明字符串变量str
char ch = "W";
double PI = 3.1415926;
```

### final 关键字

 `final` 含义是这是最终的、不可更改的结果，被 final 修饰的变量只能被赋值一次，赋值后不再改变。

```java
final double PI = 3.1415926;
```

### 数组

```java
int[] ary = new int[10];
//有十个元素的整数类型数组
//其语法格式为 数据类型[] 变量名 = new 数据类型[数组大小]
```

### 字符串

-   字符串是 `Java` 一个内置的类。

```java
//最为简单的构造一个字符串变量的方法如下
String a = "Hello";
//还可以使用字符数组构造一个字符串变量
char[] stringArray = {'H','e','l','l','o'};
String s = new String(stringArray);
```

### 输出

可以对变量进行格式化输出

|   符号   |   意义  |
| :----: | :---: |
|  `%f`  |  浮点类型 |
|  `%s`  | 字符串类型 |
|  `%d`  |  整数类型 |
|  `%c`  |  字符类型 |

```java
class test{
    public static void main(String[] args) {
        int a = 12;
        char b = 'A';
        double s = 3.14;
        String str = "Hello world";
        System.out.println("%f",s);
        System.out.println("%d",a);
        system.out.println("%c",b);
        system.out.println("%s",str);
    }
}
```

### 控制语句

#### 选择

-   if

```java
class test{
    public static void main(String[] args) {
        if(/*判断条件*/){
              //条件成立时执行这里面的代码
          }
      }
}
```

-   if...else

```java
class test{
    public static void main(String[] args) {
        if(/*判断条件*/){
            //条件成立时执行这里面的代码
        }else{
            //条件不成立时执行这里面的代码
        }
    }
}
```

-   if...else if...else

```java
class test{
    public static void main(String[] args) {
        if(/*判断条件*/){
            //判断条件成立执行这里面的代码
        }else if(/*判断条件2*/){
            //判断条件2成立执行这里面的代码
        }else{
          //上述条件都不成立执行这里面的代码
        }
    }
}
```

#### 循环

-   for

```java
class test{
    public static void main(String[] args) {
            for(/*初始化*/;/*循环的判断条件*/;/*每次循环后执行的步骤*/){
                //当循环的条件成立执行循环体内代码
            }
    }
}
```

-   while

```java
class test{
    public static void main(String[] args) {
        while(/*判定条件*/){
            //条件成立时执行循环体内代码
        }
    }
}
```

-   do...while

```java
class test{
    public static void main(String[] args) {
        do{
          //需要执行的代码
        }while(/*循环判断条件*/);
    }
}
```

-   switch...case

```java
class test{
      public static void main(String[] args) {
        switch(/*表达式*/){
          case /*值-1*/:
              //当表达式取得的值符合值-1执行此段代码
          break; //如果不加上break语句,会让程序按顺序往下执行,执行所有的case语句
          case /*值-2*/:
              //当表达式取得的值符合值-2执行此段代码
          break;
          default:
              //当表达式不符合上面列举的值的时候执行这里面的代码
        }
      }
}
```

## 注意事项

### 类名与文件名一致

创建 Java 源程序需要类名和文件名一致才能编译通过，否则编译器会提示找不到 `类` 。通常该文件名会在具体 OJ 中指定。

例：

Add.java

```java
class Add{
    public static void main(String[] args) {
        // ...
    }
}
```

在该文件中需使用 Add 为类名方可编译通过。

# array
数组是存放相同类型对象的容器，数组中存放的对象没有名字，而是要通过其所在的位置访问。数组的大小是固定的，不能随意改变数组的长度。

## 定义数组

数组的声明形如 `a[d]` ，其中， `a` 是数组的名字， `d` 是数组中元素的个数。在编译时， `d` 应该是已知的，也就是说， `d` 应该是一个整型的常量表达式。

```cpp
unsigned int d1 = 42;
const int d2 = 42;
int arr1[d1];  // 错误：d1 不是常量表达式
int arr2[d2];  // 正确：arr2 是一个长度为 42 的数组
```

不能将一个数组直接赋值给另一个数组：

```cpp
int arr1[3];
int arr2 = arr1;  // 错误
arr2 = arr1;      // 错误
```

应该尽量将较大的数组定义为全局变量。因为局部变量会被创建在栈区中，过大（大于栈的大小）的数组会爆栈，进而导致 RE。如果将数组声明在全局作用域中，就会在静态区中创建数组。

## 访问数组元素

可以通过下标运算符 `[]` 来访问数组内元素，数组的索引（即方括号中的值）从 0 开始。以一个包含 10 个元素的数组为例，它的索引为 0 到 9，而非 1 到 10。但在 OI 中，为了使用方便，我们通常会将数组开大一点，不使用数组的第一个元素，从下标 1 开始访问数组元素。

例 1：从标准输入中读取一个整数 $n$ ，再读取 $n$ 个数，存入数组中。其中， $n\leq 1000$ 。

```cpp
#include <iostream>
using namespace std;

int arr[1001];  // 数组 arr 的下标范围是 [0, 1001)

int main() {
  int n;
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> arr[i];
  }
}
```

例 2：（接例 1）求和数组 `arr` 中的元素，并输出和。满足数组中所有元素的和小于等于 $2^{31} - 1$ 

```cpp
#include <iostream>
using namespace std;

int arr[1001];

int main() {
  int n;
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> arr[i];
  }

  int sum = 0;
  for (int i = 1; i <= n; ++i) {
    sum += i;
  }

  printf("%d\n", sum);
  return 0;
}
```

### 越界访问下标

数组的下标 $\mathit{idx}$ 应当满足 $0\leq \mathit{idx}< \mathit{size}$ ，如果下标越界，则会产生不可预料的后果，如段错误（Segmentation Fault），或者修改预期以外的变量。

## 多维数组

多维数组的实质是「数组的数组」，即外层数组的元素是数组。一个二维数组需要两个维度来定义：数组的长度和数组内元素的长度。访问二维数组时需要写出两个索引：

```cpp
int arr[3][4];  // 一个长度为 3 的数组，它的元素是「元素为 int 的长度为的 4
                // 的数组」
arr[2][1] = 1;  // 访问二维数组
```

我们经常使用嵌套的 for 循环来处理二维数组。

例：从标准输入中读取两个数 $n$ 和 $m$ ，分别表示黑白图片的高与宽，满足 $n,m\leq 1000$ 。对于接下来的 $n$ 行数据，每行有用空格分隔开的 $m$ 个数，代表这一位置的亮度值。现在我们读取这张图片，并将其存入二维数组中。

```cpp
const int maxn = 1001;
int pic[maxn][maxn];
int n, m;

cin >> n >> m;
for (int i = 1; i <= n; ++i)
  for (int j = 1; j <= n; ++j) cin >> pic[i][j];
```

同样地，你可以定义三维、四维，以及更高维的数组。

# pointer


# class
author: Ir1d, cjsoft, Lans1ot
类（class）是结构体的拓展，不仅能够拥有成员元素，还拥有成员函数。

在面向对象编程（OOP）中，对象就是类的实例，也就是变量。

C++ 中 `struct` 关键字定义的也是类，上文中的 **结构体** 的定义来自 C。因为某些历史原因，C++ 保留并拓展了 `struct` 。

## 定义类

类使用关键字 `class` 或者 `struct` 定义，下文以 `class` 举例。

```cpp
class ClassName {
  ...
};

// Example:
class Object {
 public:
  int weight;
  int value;
} e[array_length];

const Object a;
Object b, B[array_length];
Object *c;
```

与使用 `struct` 大同小异。该例定义了一个名为 `Object` 的类。该类拥有四个成员元素，分别为 `weight,value` ；并在 `}` 后定义了一个数组 `B` 。

定义类的指针形同 [ `struct` ](./struct.md) 。

### 访问说明符

不同于 [ `struct` ](./struct.md) 中的举例，本例中出现了 `public` ，这属于访问说明符。

-    `public` ：该访问说明符之后的各个成员都可以被公开访问，简单来说就是无论 **类内** 还是 **类外** 都可以访问。
-    `protected` ：该访问说明符之后的各个成员可以被 **类内** 、派生类或者友元的成员访问，但类外 **不能访问** 。
-    `private` ：该访问说明符之后的各个成员 **只能** 被 **类内** 成员或者友元的成员访问， **不能** 被从类外或者派生类中访问。

对于 `struct` ，它的所有成员都是默认 `public` 。对于 `class` ，它的所有成员都是默认 `private` 。

_关于 "友元" 和 "派生类"，可以参考下方折叠框，或者查询网络资料进行详细了解。_

_对于算法竞赛来说，友元和派生类并不是必须要掌握的知识点。_

??? note "关于友元以及派生类的基本概念"

    友元（`friend`）: 使用`friend`关键字修饰某个函数或者类。可以使得在**被修饰者**在不成为成员函数或者成员类的情况下，访问该类的私有（`private`）或者受保护（`protected`）成员。简单来说就是只要带有这个类的`friend`标记，就可以访问私有或受保护的成员元素。

    派生类（`derived class`）: C++允许使用一个类作为**基类**，并通过基类**派生**出**派生类**。其中派生类（根据特定规则）继承基类中的成员变量和成员函数。可以提高代码的复用率。

    派生类似" is "的关系。如猫（派生类）" is " 哺乳动物（基类）。

     对于上面`private`和`protected`的区别，可以看做派生类可以访问基类的`protected`的元素（`public`同），但不能访问`private`元素。

## 访问与修改成员元素的值

方法形同 [ `struct` ](./struct.md) 

-   对于变量，使用 `.` 符号。
-   对于指针，使用 `->` 符号。

## 成员函数

成员函数，顾名思义。就是类中所包含的函数。

??? note "常见成员函数举例"
    ```cpp
    vector.push_back();
    set.insert();
    queue.empty();
    ```

```cpp
class Class_Name {
  ... type Funciton_Name(...) { ... }
};

// Example:
class Object {
 public:
  int weight;
  int value;
  void print() {
    cout << weight << endl;
    return;
  }
  void change_w(int);
};

void Object::change_w(int _weight) { weight = _weight; }
```

该类有一个打印 `Object` 成员元素的函数，以及更改成员元素 `weight` 的函数。

和函数类似，对于成员函数，也可以先声明，在定义，如第十四行（声明处）以及十七行后（定义处）。

如果想要调用 `var` 的 `print` 成员函数，可以使用 `var.print()` 进行调用。

### 重载运算符

??? note "何为重载"
    C++ 允许编写者为名称相同的函数或者运算符指定不同的定义。这称为 **重载** （overload）。

    如果同名函数的参数种类、数量、返回类型不相同其中一者或多者两两不相同，则这些同名函数被看做是不同的。

    如果在调用时不会出现混淆（指调用某些同名函数时，无法根据所填参数种类和数量唯一地判断出被调用函数。常发生在具有默认参数的函数中），则编译器会根据调用时所填参数判断应调用函数。

    而上述过程被称作重载解析。

重载运算符，可以部分程度上代替函数，简化代码。

下面给出重载运算符的例子。

```cpp
class Vector {
 public:
  int x, y;
  Vector() : x(0), y(0) {}
  Vector(int _x, int _y) : x(_x), y(_y) {}
  int operator*(const Vector& other) { return x * other.y + y * other.x; }
  Vector operator+(const Vector&);
  Vector operator-(const Vector&);
};

Vector Vector::operator+(const Vector& other) {
  return Vector(x + other.x, y + other.y);
}

Vector Vector::operator-(const Vector& other) {
  return Vector(x - other.x, y - other.y);
}
//关于4,5行表示为x,y赋值，具体实现参见后文。
```

该例定义了一个向量类，并重载了 `* + -` 运算符，并分别代表向量内积，向量加，向量减。

重载运算符的模板大致可分为下面几部分。

```text
/*类定义内重载*/ 返回类型 operator符号(参数){...}

/*类定义内声明，在外部定义*/ 返回类型 类名称::operator符号(参数){...}
```

对于自定义的类，如果重载了某些运算符（一般来说只需要重载 `<` 这个比较运算符），便可以使用相应的 STL 容器或算法，如 [ `sort` ](../basic/stl-sort.md) 。

_如要了解更多，参见“参考资料”第四条。_

??? note " 可以被重载的运算符"

      ```cpp
         =
         +  -  *  /  =  %
         +=  -=  *=  /=  %=
         <  >  ==  !=  <=  >=
         &  |  !  ^  ~
         &=  |=  ^=
         //----------
         <<  <<=  >>  >>=
         ++  --
         &&  ||
         []  ()  ,
         ->*  ->  new  delete  new[]  delete[]
      ```

### 在实例化变量时设定初始值

为完成这种操作，需要定义 **默认构造函数** (Default constructor)。

```cpp
class ClassName {
  ... ClassName(...)... { ... }
};

// Example:
class Object {
 public:
  int weight;
  int value;
  Object() {
    weight = 0;
    value = 0;
  }
};
```

该例定义了 `Object` 的默认构造函数，该函数能够在我们实例化 `Object` 类型变量时，将所有的成员元素初始化为 `0` 。

若无显式的构造函数，则编译器认为该类有隐式的默认构造函数。换言之，若无定义任何构造函数，则编译器会自动生成一个默认构造函数，并会根据成员元素的类型进行初始化（与定义 内置类型 变量相同）。

在这种情况下，成员元素都是未初始化的，访问未初始化的变量的结果是未定义的（也就是说并不知道会返回和值）。

如果需要自定义初始化的值，可以再定义（或重载）构造函数。

??? note "关于定义(或重载)构造函数"
    一般来说，默认构造函数是不带参数的，这区别于构造函数。构造函数和默认构造函数的定义大同小异，只是参数数量上的不同。

    构造函数可以被重载（当然首次被叫做定义）。需要注意的是，如果已经定义了构造函数，且构造函数的参数列表不为空，那么编译器便不会再生成无参数的默认构造函数。这会可能会使试图以默认方法构造变量的行为编译失败（指不填入初始化参数）。

使用 C++11 或以上时，可以使用 `{}` 进行变量的初始化。

??? note "关于`{}`"
    使用 `{}` 进行初始化，会用到 std::initializer_list 这一个轻量代理对象进行初始化。

    初始化步骤大概如下

    1. 尝试寻找参数中有`std::initializer_list`的默认构造函数，如果有则调用（调用完后不再进行下面的查找，下同）。

    2. 尝试将`{}`中的元素填入其他构造参数，如果能将参数按照顺序填满（默认参数也算在内），则调用该默认构造函数。

    3. 若无`private`成员元素，则尝试在**类外**按照元素定义顺序或者下标顺序依次赋值。

    _上述过程只是完整过程的简化版本，详细内容参见"参考资料九"_

```cpp
class Object {
 public:
  int weight;
  int value;
  Object() {
    weight = 0;
    value = 0;
  }
  Object(int _weight = 0, int _value = 0) {
    weight = _weight;
    value = _value;
  }
  // the same as
  // Object(int _weight,int _value):weight(_weight),value(_value) {}
};

// the same as
// Object::Object(int _weight,int _value){
//   weight = _weight;
//   value = _value;
// }
//}

Object A;        // ok
Object B(1, 2);  // ok
Object C{1, 2};  // ok,(C++11)
```

??? note "关于隐式类型转换"
    有时候会写出如下的代码

    ```cpp
    class Node {
     public:
      int var;
      Node(int _var) : var(_var) {}
    };
    Node a = 1;
    ```

    看上去十分不符合逻辑，一个 `int` 类型不可能转化为 `node` 类型。但是编译器不会进行 `error` 提示。

    原因是在进行赋值时，首先会将 `1` 作为参数调用 `node::node(int)` ，然后调用默认的复制函数进行赋值。

    但大多数情况下，编写者会希望编译器进行报错。这时便可以在构造函数前追加 `explicit` 关键字。这会告诉编译器必须显式进行调用。

    ```cpp
    class Node {
     public:
      int var;
      explicit Node(int _var) : var(_var) {}
    };
    ```

    也就是说 `node a=1` 将会报错，但 `node a=node(1)` 不会。因为后者显式调用了构造函数。当然大多数人不会写出后者的代码，但此例足以说明 explicit 的作用。

    _不过在算法竞赛中，为了避免此类情况常用的是"加强对代码的规范程度"，从源头上避免_

### 销毁

这是不可避免的问题。每一个变量都将在作用范围结束走向销毁。

但对于已经指向了动态申请的内存的指针来说，该指针在销毁时不会自动释放所指向的内存，需要手动释放动态内存。

如果结构体的成员元素包含指针，同样会遇到这种问题。需要用到析构函数来手动释放动态内存。

 **析构** 函数（Destructor）将会在该变量被销毁时被调用。重载的方法形同构造函数，但需要在前加 `~` 

_默认定义的析构函数通常对于算法竞赛已经足够使用，通常我们只有在成员元素包含指针时才会重载析构函数。_

```cpp
class Object {
 public:
  int weight;
  int value;
  int* ned;
  Object() {
    weight = 0;
    value = 0;
  }
  ~Object() { delete ned; }
};
```

### 为类变量赋值

默认情况下，赋值时会按照对应成员元素赋值的规则进行。也可以使用 `类名称()` 或 `类名称{}` 作为临时变量来进行赋值。

前者只是调用了复制构造函数（copy constructor)，而后者在调用复制构造函数前会调用默认构造函数。

另外默认情况下，进行的赋值都是对应元素间进行 **浅拷贝** ，如果成员元素中有指针，则在赋值完成后，两个变量的成员指针具有相同的地址。

```cpp
// A,tmp1,tmp2,tmp3类型为Object
tmp1 = A;
tmp2 = Object(...);
tmp3 = {...};
```

如需解决指针问题或更多操作，需要重载相应的构造函数。

_更多 构造函数（constructor）内容，参见“参考资料”第六条。_

## 参考资料

1.   [cppreference class](https://zh.cppreference.com/w/cpp/language/class) 
2.   [cppreference access](https://zh.cppreference.com/w/cpp/language/access) 
3.   [cppreference default_constructor](https://zh.cppreference.com/w/cpp/language/default_constructor) 
4.   [cppreference operator](https://zh.cppreference.com/w/cpp/language/operators) 
5.   [cplusplus Data structures](http://www.cplusplus.com/doc/tutorial/structures/) 
6.   [cplusplus Special members](http://www.cplusplus.com/doc/tutorial/classes2/) 
7.   [C++11 FAQ](http://www.stroustrup.com/C++11FAQ.html) 
8.   [cppreference Friendship and inheritance](http://www.cplusplus.com/doc/tutorial/inheritance/) 
9.   [cppreference value initialization](https://zh.cppreference.com/w/cpp/language/value_initialization) 

# var
## 数据类型

C++ 内置了六种基本数据类型：

| 类型   | 关键字    |
| ---- | ------ |
| 布尔型  | bool   |
| 字符型  | char   |
| 整型   | int    |
| 浮点型  | float  |
| 双浮点型 | double |
| 无类型  | void   |

| 类型     | 字节数   | 范围                                              |
| ------ | ----- | ----------------------------------------------- |
| char   | 1 个字节 | -128 到 127 或者 0 到 255                           |
| int    | 4 个字节 | -2147483648 到 2147483647( $2^{31} - 1$ )        |
| float  | 4 个字节 |  $-3.4\times 10^{38}$ 到 $3.4\times 10^{38}$     |
| double | 8 个字节 |  $-1.7\times 10^{-308}$ 到 $1.7\times 10^{308}$  |

一些基本类型可以使用一个或多个类型修饰符进行修饰，例如 `signed` ， `unsigned` 修饰类型表示所修饰的数有没有符号， `short` ， `long` 表示类型的长短，即类型所能表示的范围。另外还有一些其他的修饰符例如 `const` ，可以用来描述一些更加复杂的东西，将会在下面讲解。

## 声明变量

使用关键词加上变量名即可声明。

```c++
int oi;
double wiki;
char org = 'c';
```

在目前我们所接触到的程序段中，声明在花括号包裹的地方的变量是局部变量，而声明在没有花括号包裹的地方的变量是全局变量。实际有例外，但是现在不必了解。

声明时没有初始化值的全局变量会被初始化为 0。而局部变量没有这种特性，需要手动赋初始值，否则可能引起难以发现的 bug。

## 变量作用域

作用域是变量可以发挥作用的代码块。

变量分为全局变量和局部变量，意义已经在上面讲解。

全局变量的作用域是整个文件，全局变量一旦声明，在整个程序中都是可用的。

局部变量的作用域是声明语句所在的代码块，局部变量只能被函数内部或者代码块内部的语句使用。

由一对大括号括起来的若干语句构成一个代码块。

```c++
int g = 20;  // 声明全局变量
int main() {
  int g = 10;         // 声明局部变量
  printf("%d\n", g);  // 输出 g
  return 0;
}
```

在一个代码块中，局部变量会覆盖掉同名的全局变量，比如上面的代码输出的 g 就是 10 而不是 20。为了防止出现意料之外的错误，请尽量避免局部变量与全局变量重名的情况。

## 常量

常量是固定值，在程序执行期间不会改变。

常量的值在定义后不能被修改。声明时加一个 `const` 关键字即可。

```c++
const int a = 2;
a = 3;
```

如果修改了常量的值，在编译环节就会报错： `error: assignment of read-only variable‘a’` 。

# new
 **注意** ：考虑到算法竞赛的实际情况，本文将不会全面研究语法，只会讲述在算法竞赛中可能会应用到的部分。

本文语法参照 **C++11** 标准。语义不同的将以 **C++11** 作为标准，C++14、C++17 的语法视情况提及并会特别标注。

##  `auto` 类型说明符

 `auto` 类型说明符用于自动推导变量等的类型。例如：

```cpp
auto a = 1;        // a 是 int 类型
auto b = a + 0.1;  // b 是 double 类型
```

## 基于范围的 `for` 循环

下面是 **C++20 前** 基于范围的 `for` 循环的语法：

```cpp
for (range_declaration : range_expression) loop_statement
```

上述语法产生的代码等价于下列代码（ `__range` 、 `__begin` 和 `__end` 仅用于阐释）：

```cpp
auto&& __range = range_expression;
for (auto __begin = begin_expr, __end = end_expr; __begin != __end; ++__begin) {
  range_declaration = *__begin;
  loop_statement
}
```

### range_declaration 范围声明

范围声明是一个具名变量的声明，其类型是由范围表达式所表示的序列的元素的类型，或该类型的引用。通常用 `auto` 说明符进行自动类型推导。

### range_expression 范围表达式

范围表达式是任何可以表示一个合适的序列（数组，或定义了 `begin` 和 `end` 成员函数或自由函数的对象）的表达式，或一个花括号初始化器列表。正因此，我们不应在循环体中修改范围表达式使其任何尚未被遍历到的“迭代器”（包括“尾后迭代器”）非法化。

这里有一个例子：

```cpp
for (int i : {1, 1, 4, 5, 1, 4}) std::cout << i;
```

### loop_statement 循环语句

循环语句可以是任何语句，常为一条复合语句，它是循环体。

这里有一个例子：

```cpp
#include <iostream>

struct C {
  int a, b, c, d;
  C(int a = 0, int b = 0, int c = 0, int d = 0) : a(a), b(b), c(c), d(d) {}
};

int* begin(C& p) { return &p.a; }
int* end(C& p) { return &p.d + 1; }

int main() {
  C n = C(1, 9, 2, 6);
  for (auto i : n) std::cout << i << " ";
  std::cout << std::endl;
  // 下面的循环与上面的循环等价
  auto&& __range = n;
  for (auto __begin = begin(n), __end = end(n); __begin != __end; ++__begin) {
    auto ind = *__begin;
    std::cout << ind << " ";
  }
  std::cout << std::endl;
  return 0;
}
```

## Lambda 表达式

Lambda 表达式是能够捕获作用域中的变量的无名函数对象，我们可以将其理解为一个匿名的内联函数。下面是 Lambda 表达式的语法：

```text
[capture] (parameters) mutable -> return-type {statement} 
```

### capture 捕获子句

Lambda 表达式以 capture 子句开头，它指定哪些变量被捕获，以及捕获是通过值还是引用：有 `&` 符号前缀的变量通过引用访问，没有该前缀的变量通过值访问。空的 capture 子句 `[]` 指示 Lambda 表达式的主体不访问封闭范围中的变量。

我们也可以使用默认捕获模式： `&` 表示捕获到的所有变量都通过引用访问， `=` 表示捕获到的所有变量都通过值访问。之后我们可以为特定的变量 **显式** 指定相反的模式。

例如 Lambda 体要通过引用访问外部变量 `a` 并通过值访问外部变量 `b` ，则以下子句等效：

-    `[&a, b]` 
-    `[b, &a]` 
-    `[&, b]` 
-    `[b, &]` 
-    `[=, &a]` 
-    `[&a, =]` 

默认捕获时，会捕获 Lambda 中提及的变量。

### parameters 参数列表

大多数情况下类似于函数的参数列表，例如：

```cpp
auto lam = [](int a, int b) { return a + b; };
std::cout << lam(1, 9) << " " << lam(2, 6) << std::endl;
```

 **C++14** 中，若参数类型是泛型，则可以使用 `auto` 声明类型：

```cpp
auto lam = [](auto a, auto b)
```

一个例子：

```cpp
int x[] = {5, 1, 7, 6, 1, 4, 2};
std::sort(x, x + 7, [](int a, int b) { return (a > b); });
for (auto i : x) std::cout << i << " ";
```

这将打印出 `x` 数组从大到小排序后的结果。

### mutable 可变规范

利用可变规范，Lambda 表达式的主体可以修改通过值捕获的变量。若使用此关键字，则 parameters **不可省略** （即使为空）。

### return-type 返回类型

若 Lambda 主体只包含一个 `return` 语句或不返回值，则可以省略此部分。若 Lambda 表达式主体包含一个 `return` 语句，则返回类型将被自动推导，返回类型遵循 parameters（除非你想指定一个）。否则编译器会将返回类型推断为 `void` 。

例如，上文的 `lam` 也可以写作

```cpp
auto lam = [](int a, int b) -> int
```

再举两个例子

```cpp
auto x1 = [](int i) { return i; };  // OK
auto x2 = [] { return {1, 2}; };    // ERROR: 返回类型被推导为 void
```

### statement Lambda 主体

Lambda 主体可包含任何函数可包含的部分。普通函数和 Lambda 表达式主体均可访问以下变量类型：

-   从封闭范围捕获变量
-   参数
-   本地声明的变量
-   在一个 `class` 中声明时，捕获 `this` 
-   具有静态存储时间的任何变量，如全局变量

下面是一个例子

```cpp
#include <iostream>

int main() {
  int m = 0, n = 0;
  [&, n](int a) mutable { m = (++n) + a; }(4);
  std::cout << m << " " << n << std::endl;
  return 0;
}
```

最后我们得到输出 `5 0` 。这是由于 `n` 是通过值捕获的，在调用 Lambda 表达式后仍保持原来的值 `0` 不变。 `mutable` 规范允许 `n` 在 Lambda 主体中被修改，将 `mutable` 删去则编译不通过。

## decltype 说明符

 `decltype` 说明符可以推断表达式的类型。

```cpp
#include <iostream>
#include <vector>

int main() {
  int a = 1926;
  decltype(a) b = a / 2 - 146;         // b 是 int 类型
  std::vector<decltype(b)> vec = {0};  // vec 是 std::vector <int> 类型
  std::cout << a << vec[0] << b << std::endl;
  return 0;
}
```

## constexpr

 `constexpr` 说明符声明可以在编译时求得函数或变量的值。其与 `const` 的主要区别是一定会在编译时进行初始化。用于对象声明的 `constexpr` 说明符蕴含 `const` ，用于函数声明的 `constexpr` 蕴含 `inline` 。来看一个例子

```cpp
int frac(int x) { return x ? x * frac(x - 1) : 1; }
int main() {
  constexpr int a = frac(5);  // ERROR: 函数调用在常量表达式中必须具有常量值
  return 0;
}
```

在 `int frac(int x)` 之前加上 `constexpr` 则编译通过。

## std::tuple

 `std::tuple` 定义于头文件 `<tuple>` ，是固定大小的异类值汇集（在确定初始元素后不能更改，但是初始元素能有任意多个）。它是 `std::pair` 的推广。来看一个例子：

```cpp
#include <iostream>
#include <tuple>
#include <vector>

constexpr auto expr = 1 + 1 * 4 - 5 - 1 + 4;

int main() {
  std::vector<int> vec = {1, 9, 2, 6, 0};
  std::tuple<int, int, std::string, std::vector<int> > tup =
      std::make_tuple(817, 114, "514", vec);
  std::cout << std::tuple_size<decltype(tup)>::value << std::endl;

  for (auto i : std::get<expr>(tup)) std::cout << i << " ";
  // std::get<> 中尖括号里面的必须是整型常量表达式
  // expr 常量的值是 3，注意 std::tuple 的首元素编号为 0，
  // 故我们 std::get 到了一个 std::vector<int>
  return 0;
}
```

### 成员函数

| 函数            | 作用                   |
| ------------- | -------------------- |
|  `operator=`  | 赋值一个 `tuple` 的内容给另一个 |
|  `swap`       | 交换二个 `tuple` 的内容     |

例子

```cpp
constexpr std::tuple<int, int> tup = {1, 2};
std::tuple<int, int> tupA = {2, 3}, tupB;
tupB = tup;
tupB.swap(tupA);
```

### 非成员函数

| 函数              | 作用                           |
| --------------- | ---------------------------- |
|  `make_tuple`   | 创建一个 `tuple` 对象，其类型根据各实参类型定义 |
|  `std::get`     | 元组式访问指定的元素                   |
|  `operator==` 等 | 按字典顺序比较 `tuple` 中的值          |
|  `std::swap`    | 特化的 `std::swap` 算法           |

例子

```cpp
std::tuple<int, int> tupA = {2, 3}, tupB;
tupB = std::make_tuple(1, 2);
std::swap(tupA, tupB);
std::cout << std::get<1>(tupA) << std::endl;
```

## std::function

类模板 `std::function` 是通用多态函数封装器，定义于头文件 `<functional>` 。 `std::function` 的实例能存储、复制及调用任何可调用（_Callable_）目标——函数、Lambda 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。

存储的可调用对象被称为 `std::function` 的 **目标** 。若 `std::function` 不含目标，则称它为 **空** 。调用空 `std::function` 的目标将导致抛出 `std::bad_function_call` 异常。

来看例子

```cpp
#include <functional>
#include <iostream>

struct Foo {
  Foo(int num) : num_(num) {}
  void print_add(int i) const { std::cout << num_ + i << '\n'; }
  int num_;
};

void print_num(int i) { std::cout << i << '\n'; }

struct PrintNum {
  void operator()(int i) const { std::cout << i << '\n'; }
};

int main() {
  // 存储自由函数
  std::function<void(int)> f_display = print_num;
  f_display(-9);

  // 存储 Lambda
  std::function<void()> f_display_42 = []() { print_num(42); };
  f_display_42();

  // 存储到成员函数的调用
  std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;
  const Foo foo(314159);
  f_add_display(foo, 1);
  f_add_display(314159, 1);

  // 存储到数据成员访问器的调用
  std::function<int(Foo const&)> f_num = &Foo::num_;
  std::cout << "num_: " << f_num(foo) << '\n';

  // 存储到函数对象的调用
  std::function<void(int)> f_display_obj = PrintNum();
  f_display_obj(18);
}
```

## 参考

1.   [C++ reference](https://en.cppreference.com/) 
2.   [C++ 参考手册](https://zh.cppreference.com/) 
3.   [C++ in Visual Studio](https://docs.microsoft.com/en-us/cpp/overview/visual-cpp-in-visual-studio?view=vs-2019) 

# c-cpp
本文介绍 C 与 C++ 之间重要的或者容易忽略的区别。尽管 C++ 几乎是 C 的超集，C/C++ 代码混用一般也没什么问题，但是了解 C/C++ 间比较重要区别可以避免碰到一些奇怪的 bug。如果你是以 C 为主力语言的 OIer，那么本文也能让你更顺利地上手 C++。C++ 相比 C 增加的独特特性可以阅读 [C++ 进阶](./class.md) 部分的教程。

## 宏与模板

C++ 的模板在设计之初的一个用途就是用来替换宏定义。学会模板编程是从 C 迈向 C++ 的重要一步。模板不同于宏的文字替换，在编译时会得到更全面的编译器检查，便于编写更健全的代码，利用 inline 关键字还能获得编译器充分的优化。模板特性在 C++11 后支持了可变长度的模板参数表，可以用来替代 C 中的可变长度函数并保证类型安全。

## 指针与引用

C++ 中你仍然可以使用 C 风格的指针，但是对于变量传递而言，更推荐使用 C++ 的 [引用](./reference.md) 特性来实现类似的功能。由于引用指向的对象不能为空，因此可以避免一些空地址访问的问题。不过指针由于其灵活性，也仍然有其用武之处。值得一提的是，C 中的 `NULL` 空指针在 C++ 中有类型安全的替代品 `nullptr` 。引用和指针之间可以通过 [ `*` 和 `&` 运算符](./op.md) 相互转换。

## struct

尽管在 C 和 C++ 中都有 struct 的概念，但是他们对应的东西是不能混用的！C 中的 struct 用来描述一种固定的内存组织结构，而 C++ 中的 struct 就是一种类， **它与类唯一的区别就是它的成员和继承行为默认是 public 的** ，而一般类的默认成员是 private 的。这一点在写 C/C++ 混合代码时尤其致命。

另外，声明 struct 时 C++ 也不需要像 C 那么繁琐，C 版本：

```c
typedef struct Node_t{
    struct Node_t *next;
    int key;
} Node;
```

C++ 版本

```cpp
struct Node {
  Node *next;
  int key;
};
```

## const

const 在 C 中只有限定变量不能修改的功能，而在 C++ 中，由于大量新特性的出现，const 也被赋予的更多用法。C 中的 const 在 C++ 中的继任者是 constexpr，而 C++ 中的 const 的用法请参见 [常值](./const.md) 页面的说明。

## 内存分配

C++ 中新增了 `new` 和 `delete` 关键字用来在“自由存储区”上分配空间，这个自由存储区可以是堆也可以是静态存储区，他们是为了配合“类”而出现的。其中 `delete[]` 还能够直接释放动态数组的内存，非常方便。 `new` 和 `delete` 关键字会调用类型的构造函数和析构函数，相比 C 中的 `malloc()` 、 `realloc()` 、 `free()` 函数，他们对类型有更完善的支持，但是效率不如 C 中的这些函数。

简而言之，如果你需要动态分配内存的对象是基础类型或他们的数组，那么你可以使用 `malloc()` 进行更高效的内存分配；但如果你新建的对象是非基础的类型，那么建议使用 `new` 以获得安全性检查。值得注意的是尽管 `new` 和 `malloc()` 都是返回指针，但是 `new` 出来的指针 **只能** 用 `delete` 回收，而 `malloc()` 出来的指针也只能用 `free()` 回收，否则会有内存泄漏的风险。

# python
## 关于 Python

Python 是一种目前已在世界上广泛使用的解释型面向对象语言，非常适合用来测试算法片段和原型，也可以用来刷一些 OJ。

### 为什么要学习 Python

-   Python 是一种 **解释型** 语言：类似于 PHP 与 Perl，它在开发过程中无需编译，即开即用，跨平台兼容性好。
-   Python 是一种 **交互式** 语言：您可以在命令行的提示符 `>>>` 后直接输入代码，这将使您的代码更易于调试。
-   Python 易学易用，且覆盖面广：从简单的输入输出到科学计算甚至于大型 WEB 应用，Python 可以帮助您在 **极低的学习成本** 下快速写出适合自己的程序，从而让您的程序生涯如虎添翼，为以后的学习和工作增加一项实用能力。
-   Python 易读性强，且在世界广泛使用：这意味着您能够在使用过程中比其他语言 **更快获得支持** ， **更快解决问题** 。
-   哦，还有一个最重要的：它在各平台下的环境易于配置，并且目前市面上大部分流行的 Linux 发行版（甚至于 `NOI Linux` ）中也大都 **内置** 了个版本比较旧的 Python，这意味着您能真正在考场上使用它，让它成为您的最佳拍档。

### 学习 Python 时需要注意的事项

-   目前的 Python 分为 Python 2 和 Python 3 两个版本，其中 Python 2 虽然 [几近废弃](https://pythonclock.org/) ，但是仍被一些老旧系统和代码所使用。我们通常不能确定在考场上可以使用的版本，因而会 **介绍较新版本的 Python** ，但还是建议读者了解一下 Python 2 的相关语法，并比较两者之间的差异。
-   如果您之前使用 C++ 语言，那么很遗憾地告诉您，Python 的语法结构与 C++ 差异还是比较大的，请注意使用的时候不要混淆。
-   由于 Python 是高度动态的解释型语言，因此其程序运行有大量的额外开销。通常而言，实现同样功能时 Python 代码越少速度越快（但不要追求极端）。尤其是 **for 循环在 Python 中运行的奇慢无比** 。因此在使用 Python 时若想获得高性能，尽量使用 `filter` , `map` 等内置函数，或者使用 [“列表理解”](https://www.pythonforbeginners.com/basics/list-comprehensions-in-python) 语法的手段来避免循环。

## 环境安装

### Windows

访问 <https://www.python.org/downloads/> ，下载自己需要的版本并安装。
另外为了方便，请务必勾选 ** `Add Python 3.x to PATH` ** 以确保将 Python 加入环境变量！
如在如下的 Python 3.7.4 安装界面中，应该如图勾选最下一项复选框。

![py3.7.4](./images/python1.png)

安装完成后，您可以在开始菜单找到安装好的 Python。

![start](./images/python2.png)

如果您按上图勾选了加入环境变量，您还可以通过 **命令提示符** ( `Win + R` -> `cmd` ）的方式使用 Python。

正常启动后，它会先显示欢迎信息与版本信息，再显示版权声明，之后就会出现提示符 ** `>>>` ** ，一般情况下如下所示：

```bash
$ python3
Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

这就是 Python 的 **IDLE** 。

???+ note "何谓 [**IDLE**](https://docs.python.org/zh-cn/3/glossary.html#term-idle)？"
    Python 的 IDE，“集成开发与学习环境”的英文缩写。是 Python 标准发行版附带的基本编程器和解释器环境。在其他 Python 发行版（如 Anaconda）中还包含 [IPython](https://ipython.org/) ， [Spyder](https://www.spyder-ide.org/) 等更加先进的 IDE。

### macOS/Linux

通常情况下，正如上文所说，大部分的 Linux 发行版中已经自带了 Python，如果您只打算学学语法并无特别需求，一般情况下不用再另外安装。通常而言，在 Linux 终端中运行 `python` 进入的是 Python 2，而运行 `python3` 进入的是 Python 3。

而由于种种依赖问题（如 CentOS 的 yum )，自行编译安装后通常还要处理种种问题，这已经超出了本文的讨论范畴。

而在这种情况下您一般能直接通过软件包管理器来进行安装，如在 Ubuntu 下安装 `Python 3` ：

```bash
sudo apt install python3
```

更多详情您可以直接在搜索引擎上使用关键字 `系统名称(标志版本) 安装 Python 2/3` 来找到对应教程。

???+ note "运行 `python` 还是 `python3` ？"
    根据 [Python 3 官方文档](https://docs.python.org/zh-cn/3/tutorial/interpreter.html) 的说法，在 Unix 系统中， `Python 3.X` 解释器 **默认安装** （指使用软件包管理器安装）后的执行文件并不叫作 `python` ，这样才不会与同时安装的 `Python 2.X` 冲突。同样的，默认安装的 pip 软件也是类似的情况，Python 3 包管理器的文件名为 `pip3` 您可以根据自己的使用习惯自建软链或者 shell 别名，但还请注意不要与自带的冲突。

### 关于镜像和 pip

目前国内关于 **源码** 的镜像缓存主要是 [北京交通大学](https://mirror.bjtu.edu.cn/python/) 和 [华为开源镜像站](https://mirrors.huaweicloud.com/python/) 在做，如果您有下载问题的话可以到那里尝试一下。

如果您还有使用 pip 安装其他模块的需求，请参照 [TUNA 的镜像更换帮助](https://mirrors.tuna.tsinghua.edu.cn/help/pypi/) 。

???+ note "[**pip**](https://pypi.org/project/pip/) 是什么？"
    Python 的默认包管理器，用来安装第三方 Python 库。它的功能很强大，能够处理版本依赖关系，还能通过 wheel 文件支持二进制安装。pip 的库现在托管在 [PyPI](https://pypi.org) （即“Python 包索引”）平台上，用户也可以指定第三方的包托管平台。

关于 PyPI 的镜像，可以使用如下大镜像站的资源：

-    [清华大学 TUNA 镜像站](https://mirrors.tuna.tsinghua.edu.cn/help/pypi/) 
-    [中国科学技术大学镜像站](http://mirrors.ustc.edu.cn/help/pypi.html) 
-    [豆瓣的 PyPI 源](https://pypi.douban.com/simple) 
-    [华为开源镜像站](https://mirrors.huaweicloud.com/) 

## 基本语法

Python 以其简洁易懂的语法而出名。它基本的语法结构可以非常容易地在网上找到，例如 [菜鸟教程](http://www.runoob.com/python/python-basic-syntax.html) 就有不错的介绍。这里仅介绍一些对 OIer 比较实用的语言特性。

### 关于注释

在此提前声明一下 Python 中注释的写法，因为在后面的讲解中会频繁用到。

```python3
# 用 # 字符开头的是单行注释

""" 跨多行字符串会用三个引号
    包裹，但也常被用来做多
    行注释.(NOTE: 在字符串中不会考虑缩进问题)
"""
```

加入注释代码并不会影响程序的正常运行。我们鼓励加入注释来使您的代码更加易懂易用。

### 基本数据类型与运算

有人说，你可以把你系统里装的 Python 当作一个多用计算器，这是事实。  
你可以在提示符 `>>>` 后面输入一个表达式，就像其他大部分语言（如 C++）一样使用运算符 `+` 、 `-` 、 `*` 、 `/` 来对数字进行运算；还可以使用 `()` 来进行符合结合律的分组，例如：

```python3
>>> 233 # 整数就是整数
233

>>> 5 + 6 # 算术也没有什么出乎意料的
11
>>> 50 - 4 * 8
18
>>> (50 - 4) * 8
368

>>> 15 / 3 # 但是除法除外，它会永远返回浮点 float 类型
5.0
>>> (50 - 4 * 8) / 9
2.0
>>> 5 / 3
1.6666666666666667

>>> 5.0 * 6 # 浮点数的运算结果也是浮点数
30.0
```

整数（比如 `5` 、 `8` 、 `16` ）有 `int` 类型，有小数部分的（如 `2.33` 、 `6.0` ）则有 `float` 类型。随着更深入的学习你可能会接触到更多的类型，但是在速成阶段这些已经足够使用。

在上面的实践中你也看到了，除法运算（ `/` ）永远返回浮点类型（在 Python 2 中返回整数）。如果你想要整数或向下取整的结果的话，可以使用整数除法（ `//` )。同样的，你也可以像 C++ 中一样，使用模（ `%` ）来计算余数。

```python3
>>> 5 / 3 # 正常的运算会输出浮点数
1.6666666666666667
>>> 5 // 3 # 使用整数除法则会向下取整，输出整数类型
1
>>> -5 // 3 # 符合向下取整原则，注意与C/C++不同
-2
>>> 5.0 // 3.0 # 如果硬要浮点数向下取整也可以这么做
1.0
>>> 5 % 3 # 取模
2
>>> -5 % 3 # 负数取模结果一定是非负数，这点也与C/C++不同，不过都满足 (a//b)*b+(a%b)==a 
1
```

特别的，Python 封装了乘方（ `**` ）的算法，这也表明 Python 附有 **大整数支持** 。值得一提的是，Python 还通过内置的 `pow(a, b, mod)` 提供了 [快速幂](../math/quick-pow.md) 的高效实现。

```python3
>>> 5 ** 2
25
>>> 2 ** 16
65536
>>> 2 ** 512
13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096
>>> pow(2, 512, 10000) # 即 2**512 % 10000 的快速实现
4096

>>> 2048 ** 2048 # 在IDLE里试试大整数？
```

### 输入输出

Python 中的输入输出主要通过内置函数 `raw_input` (Python 2)/ `input` (Python 3) 和 `print` 完成，这一部分内容可以参考 [Python 的官方文档](https://docs.python.org/3/tutorial/inputoutput.html) 。 `input` 函数用来从标准输入流中读取一行， `print` 则是向标准输出流中输出一行。在 Python 3 中对 `print` 增加了 `end` 参数指定结尾符，可以用来避免 `print` 自动换行。如果需要更灵活的输入输出操作，可以在引入 `sys` 包之后利用 `sys.stdin` 和 `sys.stdout` 操标准作输入输出流。

另外，如果要进行格式化的输出的话可以利用 Python 中字符串的语法。格式化有两种方法，一种是利用 `%` 操作符，另一种是利用 `format` 函数。前者语法与 C 兼容，后者语法比较复杂，可以参考 [官方文档](https://docs.python.org/3/library/string.html#formatstrings) 。

```python3
>>> print(12)
12
>>> print(12, 12) # 该方法在 Python 2 和 Python 3 中的表现不同
12 12
>>> print("%d" % 12) # 与C语法兼容
12
>>> print("%04d %.3f" % (12, 1.2))
0012 1.200
>>> print("{name} is {:b}".format(5, name="binary of 5"))
binary of 5 is 101
```

### 开数组

从 C++ 转过来的同学可能很迷惑怎么在 Python 中开数组，这里就介绍在 Python 开数组的语法。

#### 使用 `list` 

主要用到的是 Python 中列表（ `list` ）的特性，值得注意的是 Python 中列表的实现方式类似于 C++ 的 `vector` 。

```python3
>>> [] # 空列表
[]
>>> [1] * 10 # 开一个10个元素的数组
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
>>> [1, 1] + [2, 3] # 数组拼接
[1, 1, 2, 3]
>>> a1 = list(range(8)) # 建立一个自然数数组
>>> a1
[0, 1, 2, 3, 4, 5, 6, 7]

>>> [[1] * 3] * 3 # 开一个3*3的数组
[[1, 1, 1], [1, 1, 1], [1, 1, 1]]
>>> [[1] * 3 for _ in range(3)] # 同样是开一个3*3的数组
[[1, 1, 1], [1, 1, 1], [1, 1, 1]]
>>> a2 = [[1]] * 5; a[0][0] = 2; # 猜猜结果是什么？
>>> a2
[[2], [2], [2], [2], [2]]

>>> # 以下是数组操作的方法
>>> len(a1) # 获取数组长度
8
>>> a1.append(8) # 向末尾添加一个数
>>> a1[0] = 0 # 访问和赋值
>>> a1[-1] = 7 # 从末尾开始访问
>>> a1[2:5] # 提取数组的一段
[2, 3, 4]
>>> a1[5:2:-1] # 倒序访问
[5, 4, 3]
>>> a1.sort() # 数组排序

>>> a2[0][0] = 10 # 访问和赋值二维数组
>>> for i, a3 in enumerate(a2):
        for j, v in enumerate(a3):
            temp = v # 这里的v就是a[i][j]
```

注意上面案例里提到的多维数组的开法。由于列表的乘法只是拷贝引用，因此 `[[1]] * 3` 这样的代码生成的三个 `[1]` 实际上是同一个对象，修改其内容时会导致所有数组都被修改。所以开多维数组时使用 for 循环可以避免这个问题。

#### 使用 Numpy

??? note "什么是 Numpy"
     [Numpy](https://numpy.org/) 是著名的 Python 科学计算库，提供高性能的数值及矩阵运算。在测试算法原型时可以利用 Numpy 避免手写排序、求最值等算法。 `Numpy` 的核心数据结构是 `ndarray` ，即 n 维数组，它在内存中连续存储，是定长的。此外 Numpy 核心是用 C 编写的，运算效率很高。

下面的代码将介绍如何利用 Numpy 建立多维数组并进行访问。

```python3
>>> import numpy as np # Numpy 是第三方库，需要安装和引用

>>> np.empty(3) # 开容量为3的空数组
array([0.00000000e+000, 0.00000000e+000, 2.01191014e+180])

>>> np.empty((3, 3)) # 开3*3的空数组
array([[6.90159178e-310, 6.90159178e-310, 0.00000000e+000],
       [0.00000000e+000, 3.99906161e+252, 1.09944918e+155],
       [6.01334434e-154, 9.87762528e+247, 4.46811730e-091]])

>>> np.zeros((3, 3)) # 开3*3的数组，并初始化为0
array([[0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])

>>> a1 = np.zeros((3, 3), dtype=int) # 开3×3的整数数组
>>> a1[0][0] = 1 # 访问和赋值
>>> a1[0, 0] = 1 # 更友好的语法
>>> a1.shape # 数组的形状
(3, 3)
>>> a1[:2, :2] # 取前两行、前两列构成的子阵，无拷贝
array([[1, 0],
       [0, 0]])
>>> a1[0, 2] # 获取第1和3列，无拷贝
array([[1, 0],
       [0, 0],
       [0, 0]])

>>> np.max(a1) # 获取数组最大值
1
>>> a1.flatten() # 将数组展平
array([1, 0, 0, 0, 0, 0, 0, 0, 0])
>>> np.sort(a1, axis=1) # 沿行方向对数组进行排序，返回排序结果
array([[0, 0, 1],
       [0, 0, 0],
       [0, 0, 0]])
>>> a1.sort(axis=1) # 沿行方向对数组进行原地排序
```

## 常用内置库

在这里介绍一些写算法可能用得到的内置库，具体用法可以自行搜索或者阅读 [官方文档](https://docs.python.org/3/library/index.html) 。

| 包名                                                                      | 用途               |
| ----------------------------------------------------------------------- | ---------------- |
|  [ `array` ](https://docs.python.org/3/library/array.html)              | 定长数组             |
|  [ `argparse` ](https://docs.python.org/3/library/argparse.html)        | 命令行参数处理          |
|  [ `bisect` ](https://docs.python.org/3/library/bisect.html)            | 二分查找             |
|  [ `collections` ](https://docs.python.org/3/library/collections.html)  | 提供有序字典、双端队列等数据结构 |
|  [ `fractions` ](https://docs.python.org/3/library/fractions.html)      | 有理数              |
|  [ `heapq` ](https://docs.python.org/3/library/heapq.html)              | 基于堆的优先级队列        |
|  [ `io` ](https://docs.python.org/3/library/io.html)                    | 文件流、内存流          |
|  [ `itertools` ](https://docs.python.org/3/library/itertools.html)      | 迭代器相关            |
|  [ `math` ](https://docs.python.org/3/library/math.html)                | 常用数学函数           |
|  [ `os.path` ](https://docs.python.org/3/library/os.html)               | 系统路径相关           |
|  [ `random` ](https://docs.python.org/3/library/random.html)            | 随机数              |
|  [ `re` ](https://docs.python.org/3/library/re.html)                    | 正则表达式            |
|  [ `struct` ](https://docs.python.org/3/library/struct.html)            | 转换结构体和二进制数据      |
|  [ `sys` ](https://docs.python.org/3/library/sys.html)                  | 系统信息             |

## 对比 C++ 与 Python

相信大部分算法竞赛选手已经熟练掌握了 C++98 的语法。接下来我们展示一下 Python 语法的一些应用。

接下来的例子是 [Luogu P4779「【模板】单源最短路径（标准版）」](https://www.luogu.org/problem/P4779) 的代码。我们将 C++ 代码与 Python 代码做出对比：

从声明一些常量开始：

C++：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, M = 2e5 + 5;
```

Python：

```python
try: # 引入优先队列模块
    import Queue as pq #python version < 3.0
except ImportError:
    import queue as pq #python3.*

N = int(1e5 + 5)
M = int(2e5 + 5)
INF = 0x3f3f3f3f
```

然后是声明前向星结构体和一些其他变量。

C++：

```cpp
struct qxx {
  int nex, t, v;
};
qxx e[M];
int h[N], cnt;
void add_path(int f, int t, int v) { e[++cnt] = (qxx){h[f], t, v}, h[f] = cnt; }

typedef pair<int, int> pii;
priority_queue<pii, vector<pii>, greater<pii>> q;
int dist[N];
```

Python：

```python
class qxx:  # 前向星类（结构体）
    def __init__(self):
        self.nex = 0
        self.t = 0
        self.v = 0

e = [qxx() for i in range(M)]  # 链表
h = [0 for i in range(N)]
cnt = 0

dist = [INF for i in range(N)]
q = pq.PriorityQueue()  # 定义优先队列，默认第一元小根堆

def add_path(f, t, v):  # 在前向星中加边
    # 如果要修改全局变量，要使用global来声名
    global cnt, e, h
    # 调试时的输出语句，多个变量使用元组
    # print("add_path(%d,%d,%d)" % (f,t,v))
    cnt += 1
    e[cnt].nex = h[f]
    e[cnt].t = t
    e[cnt].v = v
    h[f] = cnt
```

然后是求解最短路的 Dijkstra 算法代码：

C++：

```cpp
void dijkstra(int s) {
  memset(dist, 0x3f, sizeof(dist));
  dist[s] = 0, q.push(make_pair(0, s));
  while (q.size()) {
    pii u = q.top();
    q.pop();
    if (dist[u.second] < u.first) continue;
    for (int i = h[u.second]; i; i = e[i].nex) {
      const int &v = e[i].t, &w = e[i].v;
      if (dist[v] <= dist[u.second] + w) continue;
      dist[v] = dist[u.second] + w;
      q.push(make_pair(dist[v], v));
    }
  }
}
```

Python：

```python
def nextedgeid(u):  # 生成器，可以用在for循环里
    i = h[u]
    while i:
        yield i
        i = e[i].nex


def dijkstra(s):
    dist[s] = 0
    q.put((0, s))
    while not q.empty():
        u = q.get()  # get函数会顺便删除堆中对应的元素
        if dist[u[1]] < u[0]:
            continue
        for i in nextedgeid(u[1]):
            v = e[i].t
            w = e[i].v
            if dist[v] <= dist[u[1]]+w:
                continue
            dist[v] = dist[u[1]]+w
            q.put((dist[v], v))
```

最后是主函数部分

C++：

```cpp
int n, m, s;
int main() {
  scanf("%d%d%d", &n, &m, &s);
  for (int i = 1; i <= m; i++) {
    int u, v, w;
    scanf("%d%d%d", &u, &v, &w);
    add_path(u, v, w);
  }
  dijkstra(s);
  for (int i = 1; i <= n; i++) printf("%d ", dist[i]);
  return 0;
}
```

Python：

```python
# 如果你直接运行这个python代码（不是模块调用什么的）就执行命令
if __name__ == '__main__':
    # 一行读入多个整数。注意它会把整行都读进来
    n, m, s = map(int, input().split())
    for i in range(m):
        u, v, w = map(int, input().split())
        add_path(u, v, w)

    dijkstra(s)

    for i in range(1, n+1):
        # 两种输出语法都是可以用的
        print("{}".format(dist[i]), end=' ')
        # print("%d" % dist[i],end=' ')

    print()  # 结尾换行
```

完整的代码如下：

??? note "C++"
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e5 + 5, M = 2e5 + 5;
    
    struct qxx {
      int nex, t, v;
    };
    qxx e[M];
    int h[N], cnt;
    void add_path(int f, int t, int v) { e[++cnt] = (qxx){h[f], t, v}, h[f] = cnt; }
    
    typedef pair<int, int> pii;
    priority_queue<pii, vector<pii>, greater<pii>> q;
    int dist[N];
    
    void dijkstra(int s) {
      memset(dist, 0x3f, sizeof(dist));
      dist[s] = 0, q.push(make_pair(0, s));
      while (q.size()) {
        pii u = q.top();
        q.pop();
        if (dist[u.second] < u.first) continue;
        for (int i = h[u.second]; i; i = e[i].nex) {
          const int &v = e[i].t, &w = e[i].v;
          if (dist[v] <= dist[u.second] + w) continue;
          dist[v] = dist[u.second] + w;
          q.push(make_pair(dist[v], v));
        }
      }
    }
    
    int n, m, s;
    int main() {
      scanf("%d%d%d", &n, &m, &s);
      for (int i = 1; i <= m; i++) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        add_path(u, v, w);
      }
      dijkstra(s);
      for (int i = 1; i <= n; i++) printf("%d ", dist[i]);
      return 0;
    }
    ```

??? note "Python"
    ```python
    try:  # 引入优先队列模块
        import Queue as pq  # python version < 3.0
    except ImportError:
        import queue as pq  # python3.*
    
    N = int(1e5+5)
    M = int(2e5+5)
    INF = 0x3f3f3f3f
    
    class qxx:  # 前向星类（结构体）
        def __init__(self):
            self.nex = 0
            self.t = 0
            self.v = 0
    
    e = [qxx() for i in range(M)]  # 链表
    h = [0 for i in range(N)]
    cnt = 0
    
    dist = [INF for i in range(N)]
    q = pq.PriorityQueue()  # 定义优先队列，默认第一元小根堆
    
    def add_path(f, t, v):  # 在前向星中加边
        # 如果要修改全局变量，要使用global来声名
        global cnt, e, h
        # 调试时的输出语句，多个变量使用元组
        # print("add_path(%d,%d,%d)" % (f,t,v))
        cnt += 1
        e[cnt].nex = h[f]
        e[cnt].t = t
        e[cnt].v = v
        h[f] = cnt
    
    def nextedgeid(u):  # 生成器，可以用在for循环里
        i = h[u]
        while i:
            yield i
            i = e[i].nex
    
    def dijkstra(s):
        dist[s] = 0
        q.put((0, s))
        while not q.empty():
            u = q.get()
            if dist[u[1]] < u[0]:
                continue
            for i in nextedgeid(u[1]):
                v = e[i].t
                w = e[i].v
                if dist[v] <= dist[u[1]]+w:
                    continue
                dist[v] = dist[u[1]]+w
                q.put((dist[v], v))
    
    # 如果你直接运行这个python代码（不是模块调用什么的）就执行命令
    if __name__ == '__main__':
        # 一行读入多个整数。注意它会把整行都读进来
        n, m, s = map(int, input().split())
        for i in range(m):
            u, v, w = map(int, input().split())
            add_path(u, v, w)
    
        dijkstra(s)
    
        for i in range(1, n+1):
            # 两种输出语法都是可以用的
            print("{}".format(dist[i]), end=' ')
            # print("%d" % dist[i],end=' ')
    
        print()  # 结尾换行
    ```

## 参考文档

1.  Python 官方中文文档， <https://docs.python.org/zh-cn/3/tutorial/> 
2.  Learn Python3 In Y Minutes, <https://learnxinyminutes.com/docs/python3/> 

# file-op
author: Ir1d, cqnuljs, akakw1, MingqiHuang, Chrogeek, henrytbtrue, Planet6174, StudyingFather

## 文件的概念

文件是根据特定的目的而收集在一起的有关数据的集合。C/C++ 把每一个文件都看成是一个有序的字节流，每个文件都是以 **文件结束标志** （EOF）结束，如果要操作某个文件，程序应该首先打开该文件，每当一个文件被打开后（请记得关闭打开的文件），该文件就和一个流关联起来，这里的流实际上是一个字节序列。  
C/C++ 将文件分为文本文件和二进制文件。文本文件就是简单的文本文件（重点），另外二进制文件就是特殊格式的文件或者可执行代码文件等。

## 文件的操作步骤

1、打开文件，将文件指针指向文件，决定打开文件类型；  
2、对文件进行读、写操作（比赛中主要用到的操作，其他一些操作暂时不写）；  
3、在使用完文件后，关闭文件。

##  `freopen` 函数

### 函数简介

函数用于将指定输入输出流以指定方式重定向到文件，包含于头文件 `stdio.h (cstdio)` 中，该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的

函数主要有三种方式：读、写和附加

### 命令格式

```cpp
FILE* freopen(const char* filename, const char* mode, FILE* stream);
```

### 参数说明

-    `filename` : 要打开的文件名
-    `mode` : 文件打开的模式，表示文件访问的权限
-    `stream` : 文件指针，通常使用标准文件流 ( `stdin/stdout` ) 或标准错误输出流 ( `stderr` )
-   返回值：文件指针，指向被打开文件

### 文件打开格式（选读）

-    `r` ：以只读方式打开文件，文件必须存在，只允许读入数据 **（常用）** 
-    `r+` ：以读/写方式打开文件，文件必须存在，允许读写数据
-    `rb` ：以只读方式打开二进制文件，文件必须存在，只允许读入数据
-    `rb+` ：以读写方式打开二进制文件，文件必须存在，允许读写数据
-    `rt+` ：以读写方式打开文本文件，允许读写
-    `w` ：以只写方式打开文件，文件不存在会新建文件，否则清空内容，只允许写入数据 **（常用）** 
-    `w+` ：以读/写方式打开文件，文件不存在将新建文件，否则清空内容，允许读写数据
-    `wb` ：以只读方式打开二进制文件，文件不存在将会新建文件，否则清空内容，只允许写入数据
-    `wb+` ：以读写方式打开二进制文件，文件不存在将新建文件，否则清空内容，允许读写数据
-    `a` ：以附加方式打开只写文件，文件不存在将新建文件，写入数据将被附加在文件末尾（保留 EOF 符）
-    `a+` ：以附加方式打开只写文件，文件不存在将新建文件，写入数据将被附加在文件末尾（不保留 EOF 符）
-    `at+` ：以读写方式打开文本文件，写入数据将被附加在文件末尾
-    `ab+` ：以读写方式打开二进制文件，写入数据将被附加在文件末尾

### 使用方法

读入文件内容：

```cpp
freopen("data.in", "r", stdin);
// data.in 就是读取的文件名，要和可执行文件放在同一目录下
```

输出到文件：

```cpp
freopen("data.out", "w", stdout);
// data.out 就是输出文件的文件名，和可执行文件在同一目录下
```

关闭标准输入/输出流

```cpp
fclose(stdin);
fclose(stdout);
```

!!! 注
     `printf/scanf/cin/cout` 等函数默认使用 `stdin/stdout` ，将 `stdin/stdout` 重定向后，这些函数将输入/输出到被定向的文件

### 模板

```cpp
#include <cstdio>
#include <iostream>
int main(void) {
  freopen("data.in", "r", stdin);
  freopen("data.out", "w", stdout);
  /*
  中间的代码不需要改变，直接使用 cin 和 cout 即可
  */
  fclose(stdin);
  fclose(stdout);
  return 0;
}
```

参考书目：信息学奥赛一本通

##  `fopen` 函数（选读）

函数大致与 `freopen` 相同，函数将打开指定文件并返回打开文件的指针

### 函数原型

```cpp
FILE* fopen(const char* path, const char* mode)
```

各项参数含义同 `freopen` 

### 可用读写函数（基本）

-    `fread/fwrite` 
-    `fgetc/fputc` 
-    `fscanf/fprintf` 
-    `fgets/fputs` 

### 使用方式

```cpp
FILE *in, *out;  // 定义文件指针
in = fopen("data.in", "r");
out = fopen("data.out", "w");
/*
do what you want to do
*/
fclose(stdin);
fclose(stdout);
```

## C++ 的 `ifstream/ofstream` 文件输入输出流

### 使用方法

读入文件内容：

```cpp
ifstream fin("data.in");
// data.in 就是读取文件的相对位置或绝对位置
```

输出到文件：

```cpp
ofstream fout("data.out");
// data.out 就是输出文件的相对位置或绝对位置
```

关闭标准输入/输出流

```cpp
fin.close();
fout.close();
```

### 模板

```cpp
#include <cstdio>
#include <fstream>
ifstream fin("data.in");
ofstream fout("data.out");
int main(void) {
  /*
  中间的代码改变 cin 为 fin ，cout 为 fout 即可
  */
  fin.close();
  fout.close();
  return 0;
}
```

# reference
引用可以看成是 C++ 封装的指针，用来传递它所指向的对象。在 C++ 代码中实际上会经常和引用打交道，但是通常不会显式地表现出来。引用的基本原则是在声明时必须指向对象，以及对引用的一切操作都相当于对原对象操作。另外，引用不是对象，因此不存在引用的数组、无法获取引用的指针，也不存在引用的引用。

> 尽管引用不是对象，但是可以通过 [ `reference_wrapper` ](https://zh.cppreference.com/w/cpp/utility/functional/reference_wrapper) 把它对象化，间接实现相似的效果。

引用主要分为两种，左值引用和右值引用。此外还有两种特殊的引用：转发引用和垂悬引用，不作详细介绍。另外，本文还牵涉到一部分常值的内容，请用 [常值](./const.md) 一文辅助阅读。

## 左值引用

??? note "左值和右值"
    在赋值表达式 `X = Y` 中，我们说 X 是左值，它被用到的是在内存中的 **地址** ，在编译时可知；而 Y 则是右值，它被用到的是它的 **内容** （值），内容仅在运行时可知。在 C++11 之后值的概念被进一步分类，分为泛左值、纯右值和亡值，具体参见 [相关文档](https://zh.cppreference.com/w/cpp/language/value_category) 。值得一提的是，尽管右值引用在 C++11 后才支持，但是右值概念却更早就被定义了。

??? note "左值表达式"
    如果一个表达式返回的是左值（即可以被修改），那么这个表达式被称为左值表达式。右值表达式亦然。

通常我们会接触到的引用为左值引用，它通常被用来被赋值和访问，指向右值，它的名称来源于它通常放在等号左边。左值需要 **在内存中有实体** ，而不能指向临时变量。以下是来自 [参考手册](https://zh.cppreference.com/w/cpp/language/reference) 的一段示例代码。

```cpp
#include <iostream>
#include <string>

int main() {
  std::string s = "Ex";
  std::string& r1 = s;
  const std::string& r2 = s;

  r1 += "ample";  // 修改 r1，即修改了 s
  //  r2 += "!";               // 错误：不能通过到 const 的引用修改
  std::cout << r2 << '\n';  // 打印 r2，访问了s，输出 "Example"
}
```

左值引用最常用的地方是函数参数，通过左值引用传参可以起到与通过指针传参相同的效果。

```cpp
#include <iostream>
#include <string>

// 参数中的 s 是引用，在调用函数时不会发生拷贝
char& char_number(std::string& s, std::size_t n) {
  s += s;          // 's' 与 main() 的 'str' 是同一对象
                   // 此处还说明左值也是可以放在等号右侧的
  return s.at(n);  // string::at() 返回 char 的引用
}

int main() {
  std::string str = "Test";
  char_number(str, 1) = 'a';  // 函数返回是左值，可被赋值
  std::cout << str << '\n';   // 此处输出 "TastTest"
}
```

## 右值引用 (C++ 11)

右值引用是用来赋给其他变量的引用，指向右值，它的名称来源于它通常放在赋值号右边。右值 **可以在内存里也可以在 CPU 寄存器中** 。另外，右值引用可以被看作一种 **延长临时对象生存期的方式** 。

```cpp
#include <iostream>
#include <string>

int main() {
  std::string s1 = "Test";
  //  std::string&& r1 = s1;           // 错误：不能绑定到左值

  const std::string& r2 = s1 + s1;  // 可行：到常值的左值引用延长生存期
  //  r2 += "Test";                    // 错误：不能通过到常值的引用修改

  std::string&& r3 = s1 + s1;  // 可行：右值引用延长生存期
  r3 += "Test";  // 可行：能通过到非常值的右值引用修改
  std::cout << r3 << '\n';
}
```

在上述代码中， `r3` 是一个右值引用，引用的是右值 `s1 + s1` 。 `r2` 是一个左值引用，可以发现 **右值引用可以转为 const 修饰的左值引用** 。

## 一些例子

###  `++i` 和 `i++` 

 `++i` 和 `i++` 是典型的左值和右值。 `++i` 的实现是直接给 i 变量加一，然后返回 i 本身。因为 i 是内存中的变量，因此可以是左值。实际上前自增的函数签名是 `T& T::operator++();` 。而 `i++` 则不一样，它的实现是用临时变量存下 i，然后再对 i 加一，返回的是临时变量，因此是右值。后自增的函数签名是 `T T::operator++(int);` 。

```cpp
int n1 = 1;
int n2 = ++n1;
int n3 = ++++n1;  // 因为是左值，所以可以继续操作
int n4 = n1++;
//  int n5 = n1++ ++;   // 错误，无法操作右值
//  int n6 = n1 + ++n1; // 未定义行为
int&& n7 = n1++;  // 利用右值引用延长生命期
int n8 = n7++;    // n8 = 1
```

### 移动语义和 `std::move` (C++11)

在 C++11 之后，C++ 利用右值引用新增了移动语义的支持，用来避免对象在堆空间的复制（但是无法避免栈空间复制），STL 容器对该特性有完整支持。具体特性有 [移动构造函数](https://zh.cppreference.com/w/cpp/language/move_constructor) 、 [移动赋值](https://zh.cppreference.com/w/cpp/language/move_assignment) 和具有移动能力的函数（参数里含有右值引用）。
另外， `std::move` 函数可以用来产生右值引用，需要包含 `<utility>` 头文件。

```cpp
// 移动构造函数
std::vector<int> v{1, 2, 3, 4, 5};
std::vector<int> v2(std::move(v));  // 移动v到v2, 不发生拷贝
assert(v.empty());

// 移动赋值函数
std::vector<int> v3;
v3 = std::move(v2);
assert(v2.empty());

// 有移动能力的函数
std::string s = "def";
std::vector<std::string> numbers;
numbers.push_back(std::move(s));
```

注意上述代码仅在 C++11 之后可用。

### 函数返回引用

让函数返回引用值可以避免函数在返回时对返回值进行拷贝，如

```cpp
char &get_val(std::string &str, int index) { return str[index]; }
```

你不能返回在函数中的局部变量的引用，如果一定要在函数内的变量。请使用动态内存。例如如下两个函数都会产生悬垂引用，导致未定义行为。

```cpp
std::vector<int>& getLVector() {  // 错误：返回局部变量的左值引用
  std::vector<int> x{1};
  return x;
}
std::vector<int>&& getRVector() {  // 错误：返回局部变量的右值引用
  std::vector<int> x{1};
  return std::move(x);
}
```

当右值引用指向的空间在进入函数前已经分配时，右值引用可以避免返回值拷贝。

```cpp
struct Beta {
  Beta_ab ab;
  Beta_ab const& getAB() const& { return ab; }
  Beta_ab&& getAB() && { return std::move(ab); }
};

Beta_ab ab = Beta().getAB();  // 这里是移动语义，而非拷贝
```

## 参考内容

1.   [C++ 语言文档——引用声明](https://zh.cppreference.com/w/cpp/language/reference) 
2.   [C++ 语言文档——值类别](https://zh.cppreference.com/w/cpp/language/value_category) 
3.   [Is returning by rvalue reference more efficient?](https://stackoverflow.com/questions/1116641/is-returning-by-rvalue-reference-more-efficient) 

# op
author: Ir1d, aofall

## 算术运算符

| 运算符       | 功能  |
| --------- | --- |
|  `+` （单目） | 正   |
|  `-` （单目） | 负   |
|  `*` （双目） | 乘法  |
|  `/`      | 除法  |
|  `%`      | 取模  |
|  `+` （双目） | 加法  |
|  `-` （双目） | 减法  |

??? note "单目与双目运算符"
    单目运算符（又称一元运算符）指被操作对象只有一个的运算符，而双目运算符（又称二元运算符）的被操作对象有两个。例如 `1 + 2` 中加号就是双目运算符，它有 `1` 和 `2` 两个被操作数。此外 C++ 中还有唯一的一个三目运算符 `?:` 。

算术运算符中有两个单目运算符（正、负）以及五个双目运算符（乘法、除法、取模、加法、减法），其中单目运算符的优先级最高。

其中取模运算符 `%` 意为计算两个整数相除得到的余数，即求余数。

而 `-` 为双目运算符时做减法运算符，如 `2-1` ；为单目运算符时做负值运算符，如 `-1` 。

使用方法如下

 `op=x-y*z` 

得到的 `op` 的运算值遵循数学中加减乘除的优先规律，首先进行优先级高的运算，同优先级自左向右运算，括号提高优先级。

## 位运算符

| 运算符       | 功能   |
| --------- | ---- |
|  `~`      | 逐位非  |
|  `&` （双目） | 逐位与  |
|  `|`      | 逐位或  |
|  `^`      | 逐位异或 |
|  `<<`     | 逐位左移 |
|  `>>`     | 逐位右移 |

位操作的意义请参考 [位运算](../math/bit.md) 页面。需要注意的是，位运算符的优先级低于普通的算数运算符。

## 自增/自减 运算符

有时我们需要让变量进行增加 1（自增）或者减少 1（自减），这时自增运算符 `++` 和自减运算符 `--` 就派上用场了。

自增/自减运算符可放在变量前或变量后面，在变量前称为前缀，在变量后称为后缀，单独使用时前缀后缀无需特别区别，如果需要用到表达式的值则需注意，具体可看下面的例子。详细情况可参考 [引用](./reference.md) 介绍的例子部分。

```cpp
i = 100;

op1 = i++;  // op1 = 100，先 op1 = i，然后 i = i + 1

i = 100;

op2 = ++i;  // op2 = 101，先 i = i + 1，然后赋值 op2

i = 100;

op3 = i--;  // op3 = 100，先赋值 op3，然后 i = i - 1

i = 100;

op4 = --i;  // op4 = 99，先 i = i - 1，然后赋值 op4
```

## 复合赋值运算符

复合赋值运算符实际上是表达式的缩写形式。

 `op=op+2` 可写为 `op+=2` 

 `op=op-2` 可写为 `op-=2` 

 `op=op*2` 可写为 `op*=2` 

## 比较运算符

| 运算符    | 功能   |
| ------ | ---- |
|  `>`   | 大于   |
|  `>=`  | 大于等于 |
|  `<`   | 小于   |
|  `<=`  | 小于等于 |
|  `==`  | 等于   |
|  `!=`  | 不等于  |

其中特别需要注意的是要将等于运算符 `==` 和赋值运算符 `=` 区分开来，这在判断语句中尤为重要。

 `if(op=1)` 与 `if(op==1)` 看起来类似，但实际功能却相差甚远。第一条语句是在对 op 进行赋值，若赋值为非 0 时为真值，表达式的条件始终是满足的，无法达到判断的作用；而第二条语句才是对 `op` 的值进行判断。

## 逻辑运算符

| 运算符    | 功能  |
| ------ | --- |
|  `&&`  | 逻辑与 |
|  `||`  | 逻辑或 |
|  `!`   | 逻辑非 |

```cpp
Result = op1 && op2;  //当 op1 与 op2 都为真时则 Result 为真

Result = op1 || op2;  //当 op1 或 op2 其中一个为真时则 Result 为真

Result = !op1;  //当 op1 为假时则 Result 为真
```

## 逗号运算符

逗号运算符可将多个表达式分隔开来，被分隔开的表达式按从左至右的顺序依次计算，整个表达式的值是最后的表达式的值。逗号表达式的优先级在所有运算符中的优先级是 **最低** 的。

```cpp
exp1, exp2, exp3;  //最后的值为 exp3 的运算结果。

Result = 1 + 2, 3 + 4, 5 + 6;
//得到 Result 的值为 3 而不是 11，因为赋值运算符 "="
//的优先级比逗号运算符高，先进行了赋值运算才进行逗号运算。

Result = (1 + 2, 3 + 4, 5 + 6);

// 若要让 Result 的值得到逗号运算的结果则应将整个表达式用括号提高优先级，此时
// Result 的值才为 11。
```

## 成员访问运算符

| 运算符       | 功能       |
| --------- | -------- |
|  `[]`     | 数组下标     |
|  `.`      | 对象成员     |
|  `&` （单目） | 取地址/获取引用 |
|  `*` （单目） | 间接寻址/解引用 |
|  `->`     | 指针成员     |

这些运算符用来访问对象的成员或者内存，除了最后一个运算符外上述运算符都可被重载。与 `&` ， `*` 和 `->` 相关的内容请阅读 [指针](./pointer.md) 和 [引用](./reference.md) 教程。这里还省略了两个很少用到的运算符 `.*` 和 `->*` ，其具体用法可以参见 [C++ 语言手册](https://zh.cppreference.com/w/cpp/language/operator_member_access) 。

```cpp
auto result1 = v[1];  // 获取v中下标为2的对象
auto result2 = p.q;   // 获取p对象的q成员
auto result3 = p -> q;  // 获取p指针指向的对象的q成员，等价于 (*p).q
auto result4 = &v;      // 获取指向v的指针
auto result5 = *v;      // 获取v指针指向的对象
```

## C++ 运算符优先级总表

来自 [百度百科](https://baike.baidu.com/item/运算符优先级/4752611) ，有修改。

|          运算符         |    描述    |                              例子                              | 可重载性 |
| :------------------: | :------: | :----------------------------------------------------------: | :--: |
|       **第一级别**       |          |                                                              |      |
|         `::`         |  作用域解析符  |                       `Class::age = 2;`                      | 不可重载 |
|       **第二级别**       |          |                                                              |      |
|         `()`         |   函数调用   |                        `isdigit('1')`                        |  可重载 |
|         `()`         |   成员初始化  |          `c_tor(int x, int y) : _x(x), _y(y*10){};`          |  可重载 |
|         `[]`         |  数组数据获取  |                        `array[4] = 2;`                       |  可重载 |
|         `->`         |  指针型成员调用 |                       `ptr->age = 34;`                       |  可重载 |
|          `.`         |  对象型成员调用 |                        `obj.age = 34;`                       | 不可重载 |
|         `++`         |  后自增运算符  |           `for (int i = 0; i < 10; i++) cout << i;`          |  可重载 |
|         `--`         |  后自减运算符  |           `for (int i = 10; i > 0; i--) cout << i;`          |  可重载 |
|     `const_cast`     |  特殊属性转换  |               `const_cast<type_to>(type_from);`              | 不可重载 |
|    `dynamic_cast`    |  特殊属性转换  |              `dynamic_cast<type_to>(type_from);`             | 不可重载 |
|     `static_cast`    |  特殊属性转换  |              `static_cast<type_to>(type_from);`              | 不可重载 |
|  `reinterpret_cast`  |  特殊属性转换  |            `reinterpret_cast<type_to>(type_from);`           | 不可重载 |
|       `typeid`       |   对象类型符  |  `cout << typeid(var).name(); cout << typeid(type).name();`  | 不可重载 |
|   **第三级别** （从右向左结合）  |          |                                                              |      |
|          `!`         |   逻辑取反   |                        `if( !done ) …`                       |  可重载 |
|          `~`         |   按位取反   |                       `flags = ~flags;`                      |  可重载 |
|         `++`         |  前自增运算符  |             `for (i = 0; i < 10; ++i) cout << i;`            |  可重载 |
|         `--`         |  前自减运算符  |             `for (i = 10; i > 0; --i) cout << i;`            |  可重载 |
|          `-`         |    负号    |                         `int i = -1;`                        |  可重载 |
|          `+`         |    正号    |                         `int i = +1;`                        |  可重载 |
|          `*`         |   指针取值   |                     `int data = *intPtr;`                    |  可重载 |
|          `&`         |   值取指针   |                    `int *intPtr = &data;`                    |  可重载 |
|         `new`        | 动态元素内存分配 |  `long *pVar = new long; MyClass *ptr = new MyClass(args);`  |  可重载 |
|       `new []`       | 动态数组内存分配 |                 `long *array = new long[n];`                 |  可重载 |
|       `delete`       | 动态析构元素内存 |                        `delete pVar;`                        |  可重载 |
|      `delete []`     | 动态析构数组内存 |                      `delete [] array;`                      |  可重载 |
|       `(type)`       |  强制类型转换  |                   `int i = (int) floatNum;`                  |  可重载 |
|       `sizeof`       |  返回类型内存  |    `int size = sizeof floatNum; int size = sizeof(float);`   | 不可重载 |
|       **第四级别**       |          |                                                              |      |
|         `->*`        |  类指针成员引用 |                       `ptr->*var = 24;`                      |  可重载 |
|         `.*`         |  类对象成员引用 |                       `obj.*var = 24;`                       | 不可重载 |
|       **第五级别**       |          |                                                              |      |
|          `*`         |    乘法    |                       `int i = 2 * 4;`                       |  可重载 |
|          `/`         |    除法    |                    `float f = 10.0 / 3.0;`                   |  可重载 |
|          `%`         | 取余数（模运算） |                      `int rem = 4 % 3;`                      |  可重载 |
|       **第六级别**       |          |                                                              |      |
|          `+`         |    加法    |                       `int i = 2 + 3;`                       |  可重载 |
|          `-`         |    减法    |                       `int i = 5 - 1;`                       |  可重载 |
|       **第七级别**       |          |                                                              |      |
|         `<<`         |    位左移   |                    `int flags = 33 << 1;`                    |  可重载 |
|         `>>`         |    位右移   |                    `int flags = 33 >> 1;`                    |  可重载 |
|       **第八级别**       |          |                                                              |      |
|          `<`         |    小于    |                      `if( i < 42 ) ...`                      |  可重载 |
|         `<=`         |   小于等于   |                      `if( i <= 42 ) ...`                     |  可重载 |
|          `>`         |    大于    |                      `if( i > 42 ) ...`                      |  可重载 |
|         `>=`         |   大于等于   |                      `if( i >= 42 ) ...`                     |  可重载 |
|       **第九级别**       |          |                                                              |      |
|         `==`         |    等于    |                      `if( i == 42 ) ...`                     |  可重载 |
|         `!=`         |    不等于   |                      `if( i != 42 ) ...`                     |  可重载 |
|       **第十级别**       |          |                                                              |      |
|          `&`         |   位与运算   |                     `flags = flags & 42;`                    |  可重载 |
|       **第十一级别**      |          |                                                              |      |
|          `^`         |   位异或运算  |                     `flags = flags ^ 42;`                    |  可重载 |
|       **第十二级别**      |          |                                                              |      |
|          `|`         |   位或运算   |                     `flags = flags | 42;`                    |  可重载 |
|       **第十三级别**      |          |                                                              |      |
|         `&&`         |   逻辑与运算  |              `if (conditionA && conditionB) ...`             |  可重载 |
|       **第十四级别**      |          |                                                              |      |
|         `||`         |   逻辑或运算  |              `if (conditionA || conditionB) ...`             |  可重载 |
|   **第十五级别** （从右向左结合） |          |                                                              |      |
|         `? :`        |   条件运算符  |                   `int i = a > b ? a : b;`                   | 不可重载 |
|          `=`         |    赋值    |                         `int a = b;`                         |  可重载 |
|         `+=`         |   加赋值运算  |                           `a += 3;`                          |  可重载 |
|         `-=`         |   减赋值运算  |                           `b -= 4;`                          |  可重载 |
|         `*=`         |   乘赋值运算  |                           `a *= 5;`                          |  可重载 |
|         `/=`         |   除赋值运算  |                           `a /= 2;`                          |  可重载 |
|         `%=`         |   模赋值运算  |                           `a %= 3;`                          |  可重载 |
|         `&=`         |  位与赋值运算  |                     `flags &= new_flags;`                    |  可重载 |
|         `^=`         |  位异或赋值运算 |                     `flags ^= new_flags;`                    |  可重载 |
|         `|=`         |  位或赋值运算  |                     `flags |= new_flags;`                    |  可重载 |
|         `<<=`        |  位左移赋值运算 |                        `flags <<= 2;`                        |  可重载 |
|         `>>=`        |  位右移赋值运算 |                        `flags >>= 2;`                        |  可重载 |
|   **第十六级别** （从右向左结合） |          |                                                              |      |
|        `throw`       |   异常抛出   |                  `throw EClass("Message");`                  | 不可重载 |
|       **第十七级别**      |          |                                                              |      |
|          `,`         |   逗号分隔符  |          `for (i = 0, j = 0; i < 10; i++, j++) ...`          |  可重载 |

# index
这部分将会介绍编程相关的知识，包括一些编辑器的介绍，C++ 从入门到进阶，一些其它语言的简介。

程序是算法与数据结构的载体，是解决 OI 问题的工具。

在 OI 中，最常用的编程语言是 C++。

学习编程是学习 OI 最基础的部分。

# func
author: Ir1d

# basic
## 代码框架

如果你不想深究背后的原理，初学时可以直接将这个“框架”背下来：

```cpp
#include <cstdio>
#include <iostream>

int main() {
  // do something...
  return 0;
}
```

??? note "什么是 include？"
     `#include` 其实是一个预处理命令，意思为将一个文件“放”在这条语句处，被“放”的文件被称为头文件。也就是说，在编译时，编译器会“复制”头文件 `iostream` 中的内容，“粘贴”到 `#include <iostream>` 这条语句处。这样，你就可以使用 `iostream` 中提供的 `std::cin` 、 `std::cout` 、 `std::endl` 等对象了。

    如果你学过 C 语言，你会发现目前我们接触的 C++ 中的头文件一般都不带 `.h` 后缀，而那些 C 语言中的头文件 `xx.h` 都变成了 `cxx` ，如 `stdio.h` 变成了 `cstdio` 。因为 C++ 为了和 C 保持兼容，都直接使用了 C 语言中的头文件，为了区分 C++ 的头文件和 C 的头文件，使用了 `c` 前缀。
      
    一般来说，应当根据你需要编写的 C++ 程序的需要来确定你要 `#include` 哪些头文件。但如果你 `#include` 了多余的头文件，只会增加编译时间，几乎不会对运行时间造成影响。目前我们只接触到了 `iostream` 和 `cstdio` 两个头文件，如果你只需要 `scanf` 和 `printf`，就可以不用 `#include <iostream>` 。

    可以 `#include` 自己写的头文件吗？答案是，可以。

    你可以自己写一个头文件，如： `myheader.h` 。然后，将其放到和你的代码相同的目录里，再 `#include "myheader.h"` 即可。需要注意的是，自定义的头文件需要使用引号而非尖括号。当然，你也可以使用编译命令 `-I <header_file_path>` 来告诉编译器在哪找头文件，就不需要将头文件放到和代码相同的目录里了。

??? note "什么是 `main()` ？"
    可以理解为程序运行时就会执行 `main()` 中的代码。

    实际上， `main` 函数是由系统或外部程序调用的。如，你在命令行中调用了你的程序，也就是调用了你程序中的 `main` 函数（在此之前先完成了全局 [变量](./var.md) 的构造）。

    最后的 `return 0;` 表示程序运行成功。默认情况下，程序结束时返回 0 表示一切正常，否则返回值表示错误代码。这个值返回给谁呢？其实就是调用你写的程序的系统或外部程序，它会在你的程序结束时接收到这个返回值。如果不写 `return` 语句的话，程序正常结束默认返回值也是 0。

    在 C 或 C++ 中，程序的返回值不为 0 会导致运行时错误（RE）。

## 注释

在 C++ 代码中，注释有两种写法：

1.  行内注释

    以 `//` 开头，行内位于其后的内容全部为注释。

2.  注释块

    以 `/*` 开头， `*/` 结尾，中间的内容全部为注释，可以跨行。

注释对程序运行没有影响，可以用来解释程序的意思，还可以在让某段代码不执行（但是依然保留在源文件里）。

在工程开发中，注释可以便于日后维护、他人阅读。

在 OI 中，很少有人写许多注释，但注释可以便于在写代码的时候理清思路，或者便于日后复习。而且，如果要写题解、教程的话，适量的注释可以便于读者阅读，理解代码的意图。

## 输入与输出

###  `cin` 与 `cout` 

```cpp
#include <iostream>

int main() {
  int x, y;                          // 声明变量
  std::cin >> x >> y;                // 读入 x 和 y
  std::cout << y << std::endl << x;  // 输出 y，换行，再输出 x
  return 0;                          // 结束主函数
}
```

???+note "什么是变量？"
    可以参考 [变量](./var.md) 页面。

???+note " 什么是 `std` ？" 
    std 是 C++ 标准库所使用的 **命名空间** 。使用命名空间是为了避免重名。

    关于命名空间的详细知识，可以参考 [命名空间](./namespace.md) 页面。

###  `scanf` 与 `printf` 

 `scanf` 与 `printf` 其实是 C 语言提供的函数。大多数情况下，它们的速度比 `cin` 和 `cout` 更快，并且能够方便地控制输入输出格式。

```cpp
#include <cstdio>

int main() {
  int x, y;
  scanf("%d%d", &x, &y);   // 读入 x 和 y
  printf("%d\n%d", y, x);  // 输出 y，换行，再输出 x
  return 0;
}
```

其中， `%d` 表示读入/输出的变量是一个有符号整型 ( `int` 型）的变量。

类似地：

1.   `%s` 表示字符串。
2.   `%c` 表示字符。
3.   `%lf` 表示双精度浮点数 ( `double` )。
4.   `%lld` 表示长整型 ( `long long` )。根据系统不同，也可能是 `%I64d` 。
5.   `%u` 表示无符号整型  ( `unsigned int` )。
6.   `%llu` 表示无符号长整型 ( `unsigned long long` )，也可能是 `%I64u` 。

除了类型标识符以外，还有一些控制格式的方式。许多都不常用，选取两个常用的列举如下：

1.   `%1d` 表示长度为 1 的整型。在读入时，即使没有空格也可以逐位读入数字。在输出时，若指定的长度大于数字的位数，就会在数字前用空格填充。若指定的长度小于数字的位数，就没有效果。
2.   `%.6lf` ，用于输出，保留六位小数。

这两种运算符的相应地方都可以填入其他数字，例如 `%.3lf` 表示保留三位小数。

??? note "“双精度浮点数”，“长整型”是什么"
    这些表示变量的类型。和上面一样，会留到 [变量](./var.md) 中统一讲解。

??? note "为什么 `scanf` 中有 `&` 运算符？"
    在这里， `&` 实际上是取址运算符，返回的是变量在内存中的地址。而 scanf 接收的参数就是变量的地址。具体可能要在 [指针](./pointer.md) 才能完全清楚地说明，现在只需要记下来就好了。

??? note " 什么是 `\n` ？" 
     `\n` 是一种 **转义字符** ，表示换行。

    转义字符用来表示一些无法直接输入的字符，如由于字符串字面量中无法换行而无法直接输入的换行符，由于有特殊含义而无法输入的引号，由于表示转义字符而无法输入的反斜杠。

    常用的转义字符有：

    1. `\t` 表示制表符。

    2. `\\` 表示 `\` 。

    3. `\"` 表示 `"` 。

    4. `\0` 表示空字符，用来表示 C 风格字符串的结尾。

    5. `\r` 表示回车。Linux 中换行符为 `\n` ，Windows 中换行符为 `\r\n` 。在 OI 中，如果输出需要换行，使用 `\n` 即可。但读入时，如果使用逐字符读入，可能会由于换行符造成一些问题，需要注意。例如，`gets` 将 `\n` 作为字符串结尾，这时候如果换行符是 `\r\n`，`\r` 就会留在字符串结尾。

    6. 特殊地， `%%` 表示 `%` ，只能用在 `printf` 或 `scanf` 中，在其他字符串字面量中只需要简单使用 `%` 就好了。

    ??? note "什么是字面量？"
        “字面量”是在代码里直接作为一个值的程序段，例如 `3` 就是一个 `int` 字面量，`'c'` 就是一个 char 字面量。我们上面写的程序中的 `"hello world"` 也是一个字符串字面量。

        不加解释、毫无来由的字面量又被称为“魔术数”（magic number），如果代码需要被人阅读的话，这是一种十分不被推荐的行为。

## 一些扩展内容

### C++ 中的空白字符

在 C++ 中，所有空白字符（空格、制表符、换行），多个或是单个，都被视作是一样的。（当然，引号中视作字符串的一部分的不算。）

因此，你可以自由地使用任何代码风格（除了行内注释、字符串字面量与预处理命令必须在单行内），例如：

```cpp
/* clang-format off */

#include <iostream>

 int 

    main(){
int/**/x, y;  std::cin
>> x >>y;
                std::cout <<
          y  <<std::endl   
     << x
          
          ;
    
    return       0;     }
```

当然，这么做是不被推荐的。

一种也被广泛使用但与 **OI Wiki** 要求的码风不同的代码风格：

```cpp
/* clang-format off */

#include <iostream>

int main()
{
    int x, y;

    std::cin >> x >> y;
    std::cout << y << std::endl << x;

    return 0;
}
```

###  `#define` 命令

 `#define` 是一种预处理命令，用于定义宏，本质上是文本替换。例如：

```cpp
#include <iostream>
#define n 233
// n 不是变量，而是编译器会将代码中所有 n 文本替换为 233，但是作为标识符一部分的
// n 的就不会被替换，如 fn 不会被替换成 f233，同样，字符串内的也不会被替换

int main() {
  std::cout << n;  // 输出 233
  return 0;
}
```

??? note "什么是标识符？"
    标识符就是可以用作变量名的一组字符。例如， `abcd` 和 `abc1` 都是合法的标识符，而 `1a` 和 `c+b` 都不是合法的标识符。

    标识符由英文字母、下划线开头，中间只允许出现英文字母、下划线和数字。值得注意的是，关键字（如 `int`, `for`, `if`）不能用作标识符。

??? note "什么是预处理命令？"
    预处理命令就是预处理器所接受的命令，用于对代码进行初步的变换，包含 `#include` 和 `#define` 等。

宏可以带参数，带参数的宏可以像函数一样使用：

```cpp
#include <iostream>
#define sum(x, y) ((x) + (y))
#define square(x) ((x) * (x))

int main() {
  std::cout << sum(1, 2) << ' ' << 2 * sum(3, 5) << std::endl;  // 输出 3 16
}
```

但是带参数的宏和函数有区别。因为宏是文本替换，所以会引发许多问题。如：

```cpp
#include <iostream>
#define sum(x, y) x + y
// 这里应当为 #define sum(x, y) ((x) + (y))
#define square(x) ((x) * (x))

int main() {
  std::cout << sum(1, 2) << ' ' << 2 * sum(3, 5) << std::endl;
  // 输出为 3 11，因为 #define 是文本替换，后面的语句被替换为了 2 * 3 + 5
  int i = 1;
  std::cout << square(++i) << ' ' << i;
  // 输出未定义，因为 ++i 被执行了两遍
  // 而同一个语句中多次修改同一个变量是未定义行为（有例外）
}
```

使用 `#define` 是有风险的（由于 `#define` 作用域是整个程序，因此可能导致文本被意外地替换），因此应谨慎使用。较为推荐的做法是：使用 `const` 限定符声明常量，使用函数代替宏。

但是，在 OI 中， `#define` 依然有用武之处（以下两种是不被推荐的用法，会降低代码的规范性）：

1.   `#define int long long` + `signed main()` 。通常用于避免忘记开 long long 导致的错误，或是调试时排除忘开 long long 导致错误的可能性。（也可能导致增大常数甚至 TLE，或者因为爆空间而 MLE）
2.   `#define For(i, l, r) for (int i = (l); i <= (r); ++i)` 、 `#define pb push_back` 、 `#define mid ((l + r) / 2)` ，用于减短代码长度。

不过， `#define` 也有优点，比如结合 `#if` 等预处理指令有奇效，比如：

```cpp
#ifdef LINUX
// code for linux
#else
// code for other OS
#endif
```

可以在编译的时候通过 `-DLINUX` 来控制编译出的代码，而无需修改源文件。这还有一个优点：通过 `-DLINUX` 编译出的可执行文件里并没有其他操作系统的代码，那些代码在预处理的时候就已经被删除了。

 `#define` 还能使用 `#` 、 `##` 运算符，极大地方便调试。

# helloworld
disqus:

## 环境配置

工欲善其事，必先利其器。

### 集成开发环境

IDE 操作较为简单，一般入门玩家会选用 IDE 来编写代码。在竞赛中最常见的是 [Dev-C++](./editor/devcpp.md) （如果考试环境是 Windows 系统，一般也会提供这一 IDE）。

### 编译器

#### Windows

推荐使用 GNU 编译器。需要去 [MinGW Distro](https://nuwen.net/mingw.html) 下载 MinGW 并安装。此外 Windows 下也可以选择 [Microsoft Visual C++ 编译器](https://docs.microsoft.com/en-us/cpp/build/projects-and-build-systems-cpp) ，需要去 [Visual Studio 页面](https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019) 下载安装。

#### macOS

在终端中执行：

```bash
xcode-select --install
```

#### Linux

使用 `g++ -v` 来检查是否安装过 `g++` 。

使用如下命令可以安装：

```bash
sudo apt update && sudo apt install g++
```

#### 在命令行中编译代码

熟练之后也有玩家会使用更灵活的命令行来编译代码，这样就不依赖 IDE 了，而是使用自己熟悉的文本编辑器编写代码。

```bash
g++ test.cpp -o test -lm
```

 `g++` 是 C++ 语言的编译器（C 语言的编译器为 `gcc` ）， `-o` 用于指定可执行文件的文件名，编译选项 `-lm` 用于链接数学库 `libm` ，从而使得使用 `math.h` 的代码可以正常编译运行。

注：C++ 程序不需要 `-lm` 即可正常编译运行。历年 NOI/NOIP 试题的 C++ 编译选项中都带着 `-lm` ，故这里也一并加上。

## 第一份代码

通过这样一个示例程序来展开 C++ 入门之旅吧～

C++ 语言

```c++
#include <iostream>  // 引用头文件

using namespace std;
// 引入命名空间（相关阅读 https://oi-wiki.org/lang/namespace/#using ）

int main() {                // 定义 main 函数
  cout << "Hello, world!";  // 输出 Hello, world!
  return 0;                 // 返回 0，结束 main 函数
}
```

C 语言

```c
#include <stdio.h>          // 引用头文件

int main() {                // 定义 main 函数
  printf("Hello, world!");  // 输出 Hello, world!
  return 0;                 // 返回 0，结束 main 函数
}
```

注意：C 语言在这里仅做参考（它基本上已经过时），C++ 完全兼容 C 语言，并且拥有许多新的功能，可以让选手在赛场上事半功倍。具体请见 [C 与 C++ 区别](/lang/c-cpp/) 

# const
C++ 定义了一套完善的只读量定义方法，被常量修饰符 `const` 修饰的对象或类型都是只读量，只读量的内存存储与一般变量没有任何区别，但是编译器会在编译期进行冲突检查，避免对只读量的修改。因此合理使用 `const` 修饰符可以增加代码健壮性。

## 常类型

在类型的名字前增加 const 修饰会将该类型的变量标记为不可变的。具体使用情况有常量和常引用（指针）两种。

### 常量

这里的常量即常变量，指的是 const 类型的变量（而不是标题里泛指的只读量）。常类型量在声明之后便不可重新赋值，也不可访问其可变成员，只能访问其常成员。常成员的定义见后文。

??? note "类型限定符"
    C++ 中类型限定符一共有三种：常量（const）、可变（mutable）和易变（volatile），其中默认情况下是可变变量，声明易变变量的情形是为了刻意避免编译器优化。

```cpp
const int a = 0;  // a 的类型为 const int

// a = 1; // 报错，不能修改常量
```

### 常引用、常指针

常引用和常指针也与常量类似，但区别在于他们是限制了访问，而没有更改原变量的类型。

```cpp
int a = 0;
const int b = 0;

int *p1 = &a;
*p1 = 1;
const int *p2 = &a;
// *p2 = 2; // 报错，不能通过常指针修改变量
// int *p3 = &b; // 报错，不能用普通指针指向 const 变量
const int *p4 = &b;

int &r1 = a;
r1 = 1;
const int &r2 = a;
// r2 = 2; // 报错，不能通过常引用修改变量
// int &p3 = b; // 报错，不能用普通引用指向 const 变量
const int &r4 = b;
```

另外需要区分开的是“常类型指针”和“常指针变量”（即常指针、指针常量），例如下列声明

```cpp
int* const p1;        // 类型为int的常指针，需要初始化
const int* p2;        // 类型为const int的指针
const int* const p3;  // 类型为const int的常指针

int (*f1)(int);  // 普通的函数指针
// int (const *f2)(int); // 指向常函数的指针，不可行
int (*const f3)(int) = some_func;  // 指向函数的常指针，需要初始化
int const* (*f4)(int);             // 指向返回常指针的函数指针
int const* (*const f5)(int) = some_func;  // 指向返回常指针的函数的常指针
```

我们把常类型指针又称 **底层指针** 、常指针变量又称 **顶层指针** 。

另外，C++ 中还提供了 `const_cast` 运算符来强行去掉或者增加引用或指针类型的 const 限定，不到万不得已的时候请不要使用这个关键字。

### 常参数

在函数参数里限定参数为常类型可以避免在类型里意外修改参数，该方法通常用于引用参数。此外，在类型参数中添加 const 修饰符还能增加代码可读性，能区分输入和输出参数。

```cpp
void sum(const std::vector<int> &data, int &total) {
  for (auto iter = data.begin(); iter != data.end(); ++iter)
    total += *iter;  // iter 是 const 迭代器，解引用后的类型是 const int
}
```

## 常成员

常成员指的是类型中被 const 修饰的成员，常成员可以用来限制对常对象的修改。其中，常成员变量与常量声明相同，而常成员函数声明方法为在成员函数声明的 **末尾** （参数列表的右括号的右边）添加 const 修饰符。

```cpp
// 常成员的例子
struct X {
  X();
  const int* p;  // 类型为 int* 的常成员
  int* const q;  // 类型为 const int* 的可变成员

  const int r() const;
  // 第一个 const 修饰返回值，而最后的 const 修饰的是这个成员函数。
};

X a;
*(a.p)++;  // 可行
// *(a.q)++; // 报错，不可修改 const int 类型变量

// 常成员函数的例子
const std::vector<int> c{1, 2};
// c.push_back(3); // 报错，不可访问常量的可变成员
// vector::push_back() 不是常成员
int s = c.size();  // vector::size() 是常成员，可以访问
```

## 常表达式 constexpr（C++11）

constexpr 说明符的作用是声明可以在编译时求得函数或变量的值，它的行为和 C 语言中的 const 关键字是一致的，会将变量结果直接编译到栈空间中。constexpr 还可以用来替换宏定义的常量，规避 [宏定义的风险](./basic.md#define) 。constexpr 修饰的是变量和函数，而 const 修饰的是类型。

> 实际上把 const 理解成 **"readonly"** ，而把 constexpr 理解成 **"const"** 更加直观。

```cpp
constexpr int a = 10;  // 直接定义常量

constexpr int FivePlus(int x) { return 5 + x; }

void test(const int x) {
  std::array<x> c1;            // 错误，x在编译期不可知
  std::array<FivePlus(6)> c2;  // 可行，FivePlus编译期可以推断
}
```

## 参考资料

-    [C++ 关键字——const](https://zh.cppreference.com/w/cpp/keyword/const) 
-    [C++ 关键字——constexpr](https://zh.cppreference.com/w/cpp/keyword/constexpr) 

# branch
一个程序默认是按照代码的顺序执行下来的，有时我们需要选择性的执行某些语句，这时候就需要分支的功能来实现。选择合适的分支语句可以提高程序的效率。

## if 语句

### 基本 if 语句

以下是基本 if 语句的结构。

```cpp
if (条件) {
  主体;
}
```

if 语句通过对条件进行求值，若结果为真（非 0），执行语句，否则不执行。

如果主体中只有单个语句的话，花括号可以省略。

### if...else 语句

```cpp
if (条件) {
  主体1;
} else {
  主体2;
}
```

if...else 语句和 if 语句类似，else 不需要再写条件。当 if 语句的条件满足时会执行 if 里的语句，if 语句的条件不满足时会执行 else 里的语句。同样，当主体只有一条语句时，可以省略花括号。

### else if 语句

```cpp
if (条件1) {
  主体1;
} else if (条件2) {
  主体2;
} else if (条件3) {
  主体3;
} else {
  主体4;
}
```

else if 语句是 if 和 else 的组合，对多个条件进行判断并选择不同的语句分支。在最后一条的 else 语句不需要再写条件。例如，若条件 1 为真，执行主体 1，条件 3 为真而条件 1 和条件 2 都为假，执行主体 3，所有的条件都为假才执行主体 4。

实际上，这一个语句相当于第一个 if 的 else 分句只有一个 if 语句，就将花括号省略之后放在一起了。如果条件相互之间是并列关系，这样写可以让代码的逻辑更清晰。

在逻辑上，大约相当于这一段话：

> 解一元二次方程的时候，方程的根与判别式的关系：
>
> -   如果 ( $\Delta<0$ )
>     方程无解；
> -   否则，如果 ( $\Delta=0$ )
>     方程有两个相同的实数解；
> -   否则
>     方程有两个不相同的实数解；

## switch 语句

```cpp
switch (选择句) {
  case 标签1:
    主体1;
  case 标签2:
    主体2;
  default:
    主体3;
}
```

switch 语句执行时，先求出选择句的值，然后根据选择句的值选择相应的标签，从标签处开始执行。其中，选择句必须是一个整数类型表达式，而标签都必须是整数类型的常量。例如：

```cpp
int i = 1;  //这里的 i 的数据类型是整型 ，满足整数类型的表达式的要求
switch (i) {
  case 1:
    cout << "OI WIKI" << endl;
}
```

```cpp
char i = 'A';
// 这里的 i 的数据类型是字符型 ，但 char
// 也是属于整数的类型，满足整数类型的表达式的要求
switch (i) {
  case 'A':
    cout << "OI WIKI" << endl;
}
```

switch 语句中还要根据需求加入 break 语句进行中断，否则在对应的 case 被选择之后接下来的所有 case 里的语句和 default 里的语句都会被运行。具体例子可看下面的示例。

```cpp
char i = 'B';
switch (i) {
  case 'A':
    cout << "OI" << endl;
    break;

  case 'B':
    cout << "WIKI" << endl;

  default:
    cout << "Hello World" << endl;
}
```

以上代码运行后输出的结果为 `WIKI` 和 `Hello World` ，如果不想让下面分支的语句被运行就需要 break 了，具体例子可看下面的示例。

```cpp
char i = 'B';
switch (i) {
  case 'A':
    cout << "OI" << endl;
    break;

  case 'B':
    cout << "WIKI" << endl;
    break;

  default:
    cout << "Hello World" << endl;
}
```

以上代码运行后输出的结果为 WIKI，因为 break 的存在，接下来的语句就不会继续被执行了。default 语句不需要 break，因为下面没有语句了。

switch 的 case 分句中也可以选择性的加花括号。不过要注意的是，如果需要在 switch 语句中定义变量，花括号是必须要加的。例如：

```cpp
char i = 'B';
switch (i) {
  case 'A': {
    int i = 1, j = 2;
    cout << "OI" << endl;
    ans = i + j;
    break;
  }

  case 'B': {
    int qwq = 3;
    cout << "WIKI" << endl;
    ans = qwq * qwq;
    break;
  }

  default: { cout << "Hello World" << endl; }
}
```

??? note "如何理解 switch"
    在上文中，用了大量“case 分句”，“case 子句”等用语，实际上，在底层实现中，switch 相当于一组跳转语句。也因此，有 Duff's Device 这种奇技淫巧，希望了解的人可以自行学习。

    另外还有一种理解 switch 的方式，就是从其逻辑意义去理解。在这种理解里，case 代表的就是一组子句，而 switch 根据选择句的值选择某个 case 分句进行执行。在这种理解中，除了极少数例外，case 是必须要加 break 和花括号的。

# namespace
## 概述

C++ 的 **命名空间** 机制可以用来解决复杂项目中名字冲突的问题。

举个例子：C++ 标准库的所有内容均定义在 `std` 命名空间中，如果你定义了一个叫 `cin` 的变量，则可以通过 `cin` 来访问你定义的 `cin` 变量，通过 `std::cin` 访问标准库的 `cin` 对象，而不用担心产生冲突。

## 声明

下面的代码声明了一个名字叫 `A` 的命名空间：

```cpp
namespace A {
int cnt;
void f(int x) { cnt = x; }
}  // namespace A
```

声明之后，在这个命名空间外部，你可以通过 `A::f(x)` 来访问命名空间 `A` 内部的 `f` 函数。

命名空间的声明是可以嵌套的，因此下面这段代码也是允许的：

```cpp
namespace A {
namespace B {
void f() { ... }
}  // namespace B
void f() {
  B::f();  // 实际访问的是 A::B::f()，由于当前位于命名空间 A
           // 内，所以可以省略前面的 A::
}
}  // namespace A

void f()  //这里定义的是全局命名空间的 f 函数，与 A::f 和 A::B::f 都不会产生冲突
{
  A::f();
  A::B::f();
}
```

##  `using` 指令

声明了命名空间之后，如果在命名空间外部访问命名空间内部的成员，需要在成员名前面加上 `命名空间::` 。

有没有什么比较方便的方法能让我们直接通过成员名访问命名空间内的成员呢？答案是肯定的。我们可以使用 `using` 指令。

 `using` 指令有如下两种形式：

1.   `using 命名空间::成员名;` ：这条指令可以让我们省略某个成员名前的命名空间，直接通过成员名访问成员，相当于将这个成员导入了当前的作用域。
2.   `using namespace 命名空间;` ：这条指令可以直接通过成员名访问命名空间中的 **任何** 成员，相当于将这个命名空间的所有成员导入了当前的作用域。

因此，如果执行了 `using namespace std;` ，就会将 `std` 中的所有名字引入到全局命名空间当中。这样，我们就可以用 `cin` 代替 `std::cin` ，用 `cout` 代替 `std::cout` 。

!!! warning "`using` 指令可能会导致命名冲突！"
    由于 `using namespace std;` 会将 `std` 中的 **所有名字** 引入，因此如果声明了与 `std` 重名的变量或函数，就可能会因为命名冲突而导致编译错误。

    因此在工程中，并不推荐使用 `using namespace 命名空间;` 的指令。

有了 `using` 指令， [C++ 语法基础](./basic.md#cin-cout) 中的代码可以有这两种等价写法：

```cpp
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main() {
  int x, y;
  cin >> x >> y;
  cout << y << endl << x;
  return 0;
}
```

```cpp
#include <iostream>

using namespace std;

int main() {
  int x, y;
  cin >> x >> y;
  cout << y << endl << x;
  return 0;
}
```

## 应用

在一些具有多个子任务的问题中，我们可以对每个子任务各开一个命名空间，在其中定义我们解决该子任务所需要的变量与函数，这样各个子任务间互不干扰，会在一定程度上方便调试，也会改善程序的可读性。

# loop
有时，我们需要做一件事很多遍，为了不写过多重复的代码，我们需要循环。

有时，循环的次数不是一个常量，那么我们无法将代码重复多遍，必须使用循环。

## for 语句

以下是 for 语句的结构：

```cpp
for (初始化; 判断条件; 更新) {
  循环体;
}
```

执行顺序：

/home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang/![](images/loop1.png)

e.g. 读入 n 个数：

```cpp
for (int i = 1; i <= n; ++i) {
  cin >> a[i];
}
```

for 语句的三个部分中，任何一个部分都可以省略。其中，若省略了判断条件，相当于判断条件永远为真。

## while 语句

以下是 while 语句的结构：

```cpp
while (判断条件) {
  循环体;
}
```

执行顺序：

/home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang/![](images/loop2.png)

e.g. 验证 3x+1 猜想：

```cpp
while (x > 1) {
  if (x % 2 == 1) {
    x = 3 * x + 1;
  } else {
    x = x / 2;
  }
}
```

## do...while 语句

以下是 do...while 语句的结构：

```cpp
do {
  循环体;
} while (判断条件);
```

执行顺序：

/home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang/![](images/loop3.png)

与 while 语句的区别在于，do...while 语句是先执行循环体再进行判断的。

e.g. 枚举排列：

```cpp
do {
  // do someting...
} while (next_permutation(a + 1, a + n + 1));
```

## 三种语句的联系

```cpp
// for 语句

for (statement1; statement2; statement3) {
  statement4;
}

// while 语句

statement1;
while (statement2) {
  statement4;
  statement3;
}
```

在 statement4 中没有 `continue` 语句（见下文）的时候是等价的，但是下面一种方法很少用到。

```cpp
// while 语句

statement1;
while (statement2) {
  statement1;
}

// do...while 语句

do {
  statement1;
} while (statement2);
```

在 statement1 中没有 `continue` 语句的时候这两种方式也也是等价的。

```cpp
while (1) {
  // do something...
}

for (;;) {
  // do something...
}
```

这两种方式都是永远循环下去。（可以使用 `break` （见下文）退出。）

可以看出，三种语句可以彼此代替，但一般来说，语句的选用遵守以下原则：

1.  循环过程中有个固定的增加步骤（最常见的是枚举）时，使用 for 语句；
2.  只确定循环的终止条件时，使用 while 语句；
3.  使用 while 语句时，若要先执行循环体再进行判断，使用 do...while 语句。一般很少用到，常用场景是用户输入。

## break 与 continue 语句

break 语句的作用是退出循环。

continue 语句的作用是跳过循环体的余下部分，回到循环的开头（for 语句的更新，while 语句的判断条件）。

```cpp
for (int i = 1; i <= 10; ++i) {
  std::cout << i << std::endl;
  if (i > 3) break;
  if (i > 2) continue;
  std::cout << i << std::endl;
}

/*
输出如下：
1
1
2
2
3
4
*/
```

break 与 continue 语句均可在三种循环语句的循环体中使用。

一般来说，break 与 continue 语句用于让代码的逻辑更加清晰，例如：

```cpp
// 逻辑较为不清晰，大括号层次复杂

for (int i = 1; i <= n; ++i) {
  if (i /home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang/!= x) {
    for (int j = 1; j <= n; ++j) {
      if (j /home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang/!= x) {
        // do something...
      }
    }
  }
}

// 逻辑更加清晰，大括号层次简单明了

for (int i = 1; i <= n; ++i) {
  if (i == x) continue;
  for (int j = 1; j <= n; ++j) {
    if (j == x) continue;
    // do something...
  }
}
```

```cpp
// for 语句判断条件复杂，没有体现“枚举”的本质

for (int i = l; i <= r && i % 10 /home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang/!= 0; ++i) {
  // do something...
}

// for 语句用于枚举，break 用于“到何时为止”

for (int i = l; i <= r; ++i) {
  if (i % 10 == 0) break;
  // do something...
}
```

```cpp
// 语句重复，顺序不自然

statement1;
while (statement3) {
  statement2;
  statement1;
}

// 没有重复语句，顺序自然

while (1) {
  statement1;
  if (/home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang//home/llj/Desktop/OI-wiki-master/docs/lang/!statement3) break;
  statement2;
}
```

## pq
author: Xeonacid, ouuan, Ir1d, WAAutoMaton, Chrogeek, abc1763613206, Planet6174, i-Yirannn

##  `__gnu_pbds :: priority_queue` 

附： [官方文档地址——复杂度及常数测试](https://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/pq_performance_tests.html#std_mod1) 

```cpp
#include <ext/pb_ds/priority_queue.hpp>
using namespace __gnu_pbds;
__gnu_pbds ::priority_queue<T, Compare, Tag, Allocator>
```

## 模板形参

-    `T` : 储存的元素类型
-    `Compare` : 提供严格的弱序比较类型
-    `Tag` : 是 `__gnu_pbds` 提供的不同的五种堆，Tag 参数默认是 `pairing_heap_tag` 五种分别是：
    -    `pairing_heap_tag` ：配对堆
        官方文档认为在非原生元素（如自定义结构体/ `std :: string` / `pair` ) 中，配对堆表现最好
    -    `binary_heap_tag` ：二叉堆 
        官方文档认为在原生元素中二叉堆表现最好，不过我测试的表现并没有那么好
    -    `binomial_heap_tag` ：二项堆
        二项堆在合并操作的表现要优于配对堆\*但是其取堆顶元素的
    -    `rc_binomial_heap_tag` ：冗余计数二项堆
    -    `thin_heap_tag` ：除了合并的复杂度都和 Fibonacci 堆一样的一个 tag
-    `Allocator` ：空间配置器，由于 OI 中很少出现，故这里不做讲解

由于本篇文章只是提供给学习算法竞赛的同学们，故对于后四个 tag 只会简单的介绍复杂度，第一个会介绍成员函数和使用方法。

经作者本机 Core i5@3.1 GHz On macOS 测试堆的基础操作，结合 GNU 官方的复杂度测试，Dijkstra 测试，都表明：
至少对于 OIer 来讲，除了配对堆的其他四个 tag 都是鸡肋，要么没用，要么常数大到不如 `std` 的，且有可能造成 MLE，故这里只推荐用默认的配对堆。同样，配对堆也优于 `algorithm` 库中的 `make_heap()` 。

## 构造方式

要注明命名空间因为和 `std` 的类名称重复。

    __gnu_pbds ::priority_queue<int> __gnu_pbds::priority_queue<int, greater<int> >
    __gnu_pbds ::priority_queue<int, greater<int>, pairing_heap_tag>
    __gnu_pbds ::priority_queue<int>::point_iterator id; // 迭代器
    // 在 modify 和 push 的时候都会返回一个 point_iterator，下文会详细的讲使用方法
    id = q.push(1);

## 成员函数

-    `push()` : 向堆中压入一个元素，返回该元素位置的迭代器。
-    `pop()` : 将堆顶元素弹出。
-    `top()` : 返回堆顶元素。
-    `size()` 返回元素个数。
-    `empty()` 返回是否非空。
-    `modify(point_iterator, const key)` : 把迭代器位置的 `key` 修改为传入的 `key` ，并对底层储存结构进行排序。
-    `erase(point_iterator)` : 把迭代器位置的键值从堆中擦除。
-    `join(__gnu_pbds :: priority_queue &other)` : 把 `other` 合并到 `*this` 并把 `other` 清空。

使用的 tag 决定了每个操作的时间复杂度：

|                          | push                                 | pop                                  | modify                               | erase                                  | Join                |
| ------------------------ | ------------------------------------ | :----------------------------------- | ------------------------------------ | -------------------------------------- | ------------------- |
|  `pairing_heap_tag`      |  $O(1)$                              | 最坏 $\Theta(n)$ 均摊 $\Theta(\log(n))$  | 最坏 $\Theta(n)$ 均摊 $\Theta(\log(n))$  | 最坏 $\Theta(n)$ 均摊 $\Theta(\log(n))$    |  $O(1)$             |
|  `binary_heap_tag`       | 最坏 $\Theta(n)$ 均摊 $\Theta(\log(n))$  | 最坏 $\Theta(n)$ 均摊 $\Theta(\log(n))$  |  $\Theta(n)$                         |  $\Theta(n)$                           |  $\Theta(n)$        |
|  `binomial_heap_tag`     | 最坏 $\Theta(\log(n))$ 均摊 $O(1)$       |  $\Theta(\log(n))$                   |  $\Theta(\log(n))$                   |  $\Theta(\log(n))$                     |  $\Theta(\log(n))$  |
|  `rc_binomial_heap_tag`  |  $O(1)$                              |  $\Theta(\log(n))$                   |  $\Theta(\log(n))$                   |  $\Theta(\log(n))$                     |  $\Theta(\log(n))$  |
|  `thin_heap_tag`         |  $O(1)$                              | 最坏 $\Theta(n)$ 均摊 $\Theta(\log(n))$  | 最坏 $\Theta(\log(n))$ 均摊 $O(1)$       | 最坏 $\Theta(n)$ 0 均摊 $\Theta(\log(n))$  |  $\Theta(n)$        |

## 示例

```cpp
#include <algorithm>
#include <cstdio>
#include <ext/pb_ds/priority_queue.hpp>
#include <iostream>
using namespace __gnu_pbds;
// 由于面向OIer, 本文以常用堆 : pairing_heap_tag作为范例
// 为了更好的阅读体验，定义宏如下 ：
#define pair_heap __gnu_pbds ::priority_queue<int>
pair_heap q1;  //大根堆, 配对堆
pair_heap q2;
pair_heap ::point_iterator id;  // 一个迭代器
int main() {
  id = q1.push(1);
  // 堆中元素 ： [1];
  for (int i = 2; i <= 5; i++) q1.push(i);
  // 堆中元素 :  [1, 2, 3, 4, 5];
  std ::cout << q1.top() << std ::endl;
  // 输出结果 : 5;
  q1.pop();
  // 堆中元素 : [1, 2, 3, 4];
  id = q1.push(10);
  // 堆中元素 : [1, 2, 3, 4, 10];
  q1.modify(id, 1);
  // 堆中元素 :  [1, 1, 2, 3, 4];
  std ::cout << q1.top() << std ::endl;
  // 输出结果 : 4;
  q1.pop();
  // 堆中元素 : [1, 1, 2, 3];
  id = q1.push(7);
  // 堆中元素 : [1, 1, 2, 3, 7];
  q1.erase(id);
  // 堆中元素 : [1, 1, 2, 3];
  q2.push(1), q2.push(3), q2.push(5);
  // q1中元素 : [1, 1, 2, 3], q2中元素 : [1, 3, 5];
  q2.join(q1);
  // q1中无元素，q2中元素 ：[1, 1, 1, 2, 3, 3, 5];
}
```

## index
author: HeRaNO, Xeonacid

pb_ds 库全称 Policy-Based Data Structures。

pb_ds 库封装了很多数据结构，比如哈希（Hash）表，平衡二叉树，字典树（Trie 树），堆（优先队列）等。

就像 `vector` 、 `set` 、 `map` 一样，其组件均符合 STL 的相关接口规范。部分（如优先队列）包含 STL 内对应组件的所有功能，但比 STL 功能更多。

pb_ds 只在使用 libstdc++ 为标准库的编译器下可以用。

 **参考资料： [《C++ 的 pb_ds 库在 OI 中的应用》](https://github.com/OI-Wiki/libs/blob/master/lang/pb-ds/C%2B%2B的pb_ds库在OI中的应用.pdf) ** 

## tree


## eclipse
author: Doveqise, partychicken, Xeonacid

## Eclipse 编辑器指北

### 介绍

Eclipse 是著名的跨平台开源集成开发环境（IDE）。最初主要用来 Java 语言开发，当前亦有人通过插件使其作为 C++、Python、PHP 等其他语言的开发工具。

Eclipse 的本身只是一个框架平台，但是众多插件的支持，使得 Eclipse 拥有较佳的灵活性，所以许多软件开发商以 Eclipse 为框架开发自己的 IDE。

Eclipse 最初是由 IBM 公司开发的替代商业软件 Visual Age for Java 的下一代 IDE 开发环境，2001 年 11 月贡献给开源社区，现在它由非营利软件供应商联盟 Eclipse 基金会（Eclipse Foundation）管理。

（以上摘自 wikipedia [\[1\]](https://zh.wikipedia.org/wiki/Eclipse) ）

缺点：实测这个 IDE 打开速度比 Visual Studio 慢，而且这个 IDE 更新速度玄学，插件更新速度跟不上 IDE 的更新速度，所以对于经常更新的同学很不友好。

优点：使用体验较好，而且许多知名公司都在使用，能够快速上手，所以比较推荐 OIer 用这个 IDE。

### 安装 & 配置指南

#### 前置

您需要安装 Java 和 MinGW。

##### 下载并安装 Java

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse1-1.png)

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse1-2.png)

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse1-3.png)

##### 下载并安装 MinGW

开始安装。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse1-4.png)

选择版本。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse1-5.png)

选择安装目录。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse1-6.png)

选择镜像下载加速源，此处可以直接用 SourceForge Default。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse1-7.png)

完成安装。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse1-8.png)

#### 安装主体

##### 下载 Eclipse

进入 Eclipse 官网，

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse2.png)

点击右面相对应系统的下载链接以下载 C++ 版本，

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse3.png)

安装，然后如图填写目录信息以建造项目。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse4.png)

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse5.png)

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse6.png)

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/eclipse7.png)

### 拓展

这个软件的帮助手册很详细，建议刚接触的同学多看帮助手册，多百度，并且这个 IDE 的使用手感与 Visual Studio 相近。

如果想添加插件的话，这里推荐看一篇 CSDN 博客 [\[2\]](https://blog.csdn.net/csdnnews/article/details/78495979) 。

### 引用链接

[1]&#x3A; [Eclipse - 维基百科](https://zh.wikipedia.org/wiki/Eclipse) 

[2]&#x3A; [曾经的 Java IDE 王者 Eclipse 真的没落了？21 款插件让它强大起来！](https://blog.csdn.net/csdnnews/article/details/78495979) 

## devcpp
author: Doveqise, hsfzLZH1, wangqingshiyu, ouuan, sshwy

## 介绍

> Dev-C++ 是一套用于开发 C/C++（C++11）的自由的集成开发环境（IDE），并以 GPL 作为散布许可。使用 MinGW 及 GDB 作为编译系统与调试系统。Dev-C++ 的 IDE 是利用 Delphi 开发的。
>
> Dev-C++ 是一个 SourceForge 的项目，是由 Colin Laplace 这位程序员及其公司 Bloodshed Software 所开始的。当前 Dev-C++ 一般用于撰写运行于 Microsoft Windows 的程序。Dev-C++ 一度有移植到 Linux 的项目但当前被暂停了。
>
> Bloodshed Dev-C++ 是一款全功能的 C 和 C++ 编程语言的集成开发环境（IDE）。它使用的 GCC MinGW 或 TDM-GCC 的 64 位版本作为它的编译器。DEV-C++ 也可以使用 Cygwin 或任何其他基于 GCC 编译器组合使用。
>
> 此外，Dev-C++ 较旧的版本无法在 win8 环境下编译。
>
> 该项目已不再明显活跃，从 2005 年 2 月 22 日开始至 2011 年 6 月，Dev-C++ 的官方网站一直没有再发出新消息或是释放新版本，说明 Dev-C++ 的开发已经进入了迟滞状态。2006 年，Dev-C++ 主要开发者 Colin Laplace 曾经对此作出了解释：“因忙于现实生活的事务，没有时间继续 Dev-C++ 的开发。” [\[1\]](http://sourceforge.net/projects/dev-cpp/forums/forum/33286/topic/1334635) 

以上摘自 Wikipedia [\[2\]](https://zh.wikipedia.org/wiki/Dev-C%2B%2B) 。

不过，你在使用的版本是不是我说的这个版本呢？

没错，Dev-C++ 其实还有一个全新版本：

> Orwell Dev-C++ 是 Dev-C++ 的一个衍生版本。Orwell 鉴于 Dev-C++ 的长时间（从 2005 年 2 月 22 日起）不再更新，对 Dev-C++ 源代码进行错误修正，并更新编译器后发布的版本。

以上摘自 Wikipedia [\[3\]](https://zh.wikipedia.org/wiki/Orwell_Dev-C%2B%2B) 。

自 2011 年的 Dev-C++ 4.9.9.3 版本之后，你使用的版本均为 Orewell Dev-C++。

目前最新版本为 2015 年 4 月 27 日的 Dev-C++ 5.11 版本。

该应用界面简洁友好，安装便捷，适合初学者使用。

## 部署教程

Dev-C++ 各版本的安装步骤大同小异，下面以最新版本 5.11 演示。

 [下载链接](https://sourceforge.net/projects/orwelldevcpp/files/latest/download) 

1.  首先选择安装语言，这里选择英语，然后点击 OK。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-1.png)

2.  同意使用协议，即点击 I Agree。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-2.png)

3.  选择安装方式，此处直接点击 Next>。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-3.png)

4.  选择安装路径，按需要选择，然后点击 Install。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-4.png)

5.  安装完毕后，点击 Finish 来开始初始化 Dev-C++。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-5.png)

6.  选择语言为简体中文，然后点击 > Next。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-6.png)

7.  选择你的主题和风格，这些以后可以在编辑器选项里调整，然后点击 > Next。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-7.png)

8.  点击 OK 以完成安装。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-8.png)

## 使用教程

### 常用快捷键

#### 文件部分

-    `Ctrl + N` : 创建源代码
-    `Ctrl + O` : 打开文件
-    `Ctrl + W` : 关闭文件
-    `Ctrl + P` : 打印文件

#### 格式部分

-    `Ctrl + /` ：注释和取消注释
-    `Tab` : 缩进
-    `Shift + Tab` : 取消缩进

#### 行操作

-    `Ctrl + E` : 复制行
-    `Ctrl + D` : 删除行
-    `Ctrl + Shift + Up` : 向上移动
-    `Ctrl + Shift + Down` : 向下移动

#### 跳转部分

-    `Ctrl + F` : 搜索
-    `Ctrl + R` : 替换
-    `F3` : 搜索下一个
-    `Shift + F3` : 搜索上一个
-    `Ctrl + G` : 到指定行号
-    `Shift + Ctrl + G` : 到指定函数
-    `Ctrl +[1 ~ 9]` : 设置书签
-    `Alt +[1 ~ 9]` : 跳转书签

#### 显示部分

-    `Ctrl + 滚轮` ：字号放大或缩小
-    `Ctrl + F11` : 全屏或恢复

#### 运行部分

-    `F9` : 只编译
-    `F10` : 只运行
-    `F11` : 编译并运行
-    `F12` : 全部重新编译

#### 调试部分

-    `F2` : 转到断点
-    `F4` : 设置断点或取消
-    `F5` : 调试运行
-    `F6` : 停止
-    `F7` : 逐步调试

### 调试流程

1.  将编译器配置设定为 "TDM-GCC 4.9.2 64-bit Debug"
2.  按 `F4` 设置或取消调试断点
3.  将光标放置在变量上，按 `Alt + A` 向调试窗口添加监控变量
4.  按 `F5` 启动调试
5.  按 `F7` 或 `Alt + N` 逐步调试
6.  按 `Alt + S` 跳至下一个调试断点
7.  按 `F6` 停止调试

## 扩展

### 增加编译选项

点击工具 -> 编译选项，然后选择 "代码生成/优化" 选项卡，下面介绍我自己常用的几个编译选项。

#### 开启优化

优化代码运行时间或占用空间。

选择 "代码生成" 子选项卡中的 "优化级别（-Ox)" 选项标签。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-11.png)

#### 更换语言标准

使用新语言特性或试图让代码在旧标准中运行使用。

选择 "代码生成" 子选项卡中的 "语言标准（-std)" 选项标签。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-12.png)

#### 显示最多警告信息

查错小助手。

选择 "代码警告" 子选项卡中的 "显示最多警告信息（-Wall)" 选项标签。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-13.png)

#### 生成调试信息

当显示 "项目没有调试信息，您想打开项目调试选项并重新生成吗？" 点击后闪退或想使用调试功能时需开启此功能。

选择 "连接器" 子选项卡中的 "产生调试信息" 选项标签。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-14.png)

### 编译小 trick

点击工具 -> 编译选项，然后选择 "编译器" 选项卡，接下来介绍几个常用 trick。

#### 开大栈

防止 DFS 爆系统栈之类的情况出现。

在 "连接器命令行加入以下命令" 中加入 `-Wl,--stack=128000000` 命令。

此命令将栈开到了约 128MB 的大小，有需要可以自行增加。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-15.png)

#### 定义宏

方便本地评测使用文件输入输出或作其他用途。

在 "连接器命令行加入以下命令" 中加入 `-D[String]` 命令。

其中 `[String]` 改为你需要的宏名。

如图，当开启编译选项后便可从 `test.in` 文件读入数据并在 `test.out` 文件中输出。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-16.png)

### 美化

#### 代码格式化

点击 Astyle-> 格式化当前文件 或 按 Ctrl+Shift+A 进行代码格式化。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-17.png)

格式化后效果：

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-18.png)

#### 字体

点击工具 -> 编辑器选项，然后选择 "显示" 选项卡。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-9.png)

#### 主题

点击工具 -> 编辑器选项，然后选择 "语法" 选项卡，可以使用预设主题，也可以自行调整。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/Dev-C++-10.png)

## 引用链接

[1]&#x3A; [SourceForge 论坛的帖子](http://sourceforge.net/projects/dev-cpp/forums/forum/33286/topic/1334635) 

[2]&#x3A; [Dev-C++- 维基百科](https://zh.wikipedia.org/wiki/Dev-C%2B%2B) 

[3]&#x3A; [Orwell Dev-C++- 维基百科](https://zh.wikipedia.org/wiki/Orwell_Dev-C%2B%2B) 

## vim
author: Xeonacid, Ir1d, Enter-tainer, partychicken, ChungZH, LuoshuiTianyi, Kewth, s0cks5, Doveqise

## Vim——编辑器之神

### 历史与争端

Vim 的前身是 vi，一个简洁但是略有不足的编辑器，但是从 vi 开始，编辑器的模式区分和唯快不破的思想就已经体现的很到位了。Vim 即是 vi improved，是在 vi 原本所有的方式上进行的进一步提升，但是并不会改变 vi 的其他本质，只是增加了更多适应如今需要的一些功能。

vi 于 1976 年诞生，与 Emacs 不分先后，两者因其快捷的编辑被奉为主流的神器，甚至使用者们还有爆发过“圣战”，即是 `神的编辑器 Emacs` VS `编辑器之神 Vim` ，但是当然分不出结果，因为各有优劣。但它们共有的特点就是高度的扩展性与高度的可定制性以及快捷方便的使用。

即使很多人说它们老了，太过古老的东西应该淘汰掉。但既然能够留存至今，它们的弥坚性当然也是很客观的，也会有着某些现代编辑器无法填补的优势。

Vim 的模式区分是一个很有意思的设定，普通模式与插入模式是最主要常用的模式，普通模式下的每个键都是命令，这便是 Vim 不同于 Emacs 的地方，若是习惯了 Vim 的模式之间的切换，大部分都是单个键的命令必然比 Emacs 的无限 Ctrl 会更高效，虽然 Vim 的小容量注定比不了 Emacs“操作系统”这个东西那么万能，但是论快而言，Vim 是毫不逊色的。

Vim 有丰富的插件扩展，这点显然是比配置更迷人的存在。有这些扩展性存在，Vim 成为一个 IDE 也不会是不可能的事情。

但是，Vim 的初始学习注定是艰难的，因为其与多数主流操作不同的方式令稍懒的新手望而却步，这需要时间来适应但当度过最开始的不适应期之后，Vim 就再无难度，你会慢慢上瘾，不断优化你的配置，寻找新的更好用的插件。开始的过程就像是铸剑，之后的过程就像是与剑的更好的磨合，然后在剑中逐渐注入你的灵魂，这样它就成为了你最好的利器，令你无法割舍。乃至你会自己写适合自己的插件，就像是自创剑法，而不像是从别人那里借来剑法，杂七杂八融为一炉。

有人说了这样一句话：

Vim 是一款非常优秀的文本编辑器，但由于其陡峭的学习曲线，很多人还没开始学就放弃了，所以他们无法领悟 Vim 唯快不破的设计思想和精巧的使用体验。

附一张图，论各大编辑器的学习曲线，纵坐标代表掌握知识量及难度，横坐标代表使用的熟练程度与完成任务的效率。我们可以看到，Vim 的曲线岂止陡峭，都垂直了……但是开始过去后，是平稳的提升，只要度过开始的阶段，Vim 的学习将再无阻碍，一路直上有没有。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/horrorstories.jpg)

### 安装

一般的话，Linux 系统都是会自带 Vim 的，打开终端输入 `vim` 即可启用。

Vim 依附于终端，所以调整终端设置也可以达到美化效果。比如背景透明这种极具美感的东西。而 Gvim 则可以通过图形界面的菜单栏来调节。

Vim 确实是很方便的，而且各大系统基本上都有 Vim 版本，甚至对于许多 Linux 系统，Vim 本身就是自带的。但是自带的 Vim 很容易有功能残缺，比如不能与系统剪切板交互（将会在进阶篇讲解，当然主要是因为没安装其他东西啦），各种未开启支持。如果想要使用一些新版的功能的话（比如 Vim 内部调出终端以及自带的调试功能，当然， **如果没有相关要需要实是没有必要安装的** ，可以直接往下走），那么这时候我们就需要手动安装。第一步先是卸载系统自带的 Vim，毕竟旧的不去新的不来嘛。命令如下：

```bash
sudo apt-get remove vim
```

然后安装有两种做法。

做法一，使用命令安装，但因为系统安装的时候 Vim 就是从默认软件源安装的，所以软件源里 Vim 的版本并不是最新的。这个时候应使用第三方软件源安装，命令如下：

```bash
sudo add-apt-repository ppa:jonathonf/vim
sudo apt-get update
sudo apt-get install vim
```

静待安装完成即可

做法二，先到 [Releases - vim/vim](https://github.com/vim/vim/releases) 下载源码包，然后解压，并进入解压后的文件夹，并打开终端，cd 至文件夹路径，并依次输入如下命令：

```bash
sudo apt-get install python-dev
sudo apt-get install python3-dev
sudo apt-get install libncurses5-dev
./configure
make
sudo make install
```

make 的过程可能稍久，淡定点等。

最后在终端输入

```bash
vim
```

就跳出了那个帮帮乌干达的可怜儿童啥的，按 `a` 或 `i` 键开始编辑新文件吧。

或者要打开某个文件的话就可以在终端中

```bash
vim 文件路径
```

可以直接编辑文件。

### 编译

编译的话，先要安装 g++，命令如下：

```bash
sudo apt-get install g++
```

然后 cd 至 cpp 文件指定路径执行如下命令

```bash
g++ filename.cpp -o filename
./filename
```

第一个命令是编译，第二个则是运行。

一键编译运行的配置在配置篇给出。

### 基础篇

分模式来吧。

#### 插入模式 (insert)

插入模式的知识点其实没有太多，输入才是主职是伐。

首先，从普通模式如何进入插入模式呢？有数个命令： `i` 与 `a` 与 `A` 与 `o` 。前两个差别不大， `i` 是在光标当前位置进行写代码， `a` 是往后挪一个字符写代码。 `A` 是移动到当前行尾进行插入， `o` 是在行尾添加换行符并在下一行插入。

而如何返回普通模式？当然是<kbd>Esc</kbd>啦。但是，Vim 的插入与普通模式切换异常频繁，而<kbd>Esc</kbd>又太远了，有什么办法呢？Vim 还提供了<kbd>Ctrl</kbd>+<kbd>\[</kbd>的快捷键来返回普通模式，是否近多了呢？

虽说能够熟练了后，切换模式不再是问题，但是其实有的时候我们只是需要进入普通模式下按一次小命令，来回切换又显得浪费了一点点时间。而 Vim 又提供了插入 - 普通模式来避免这一尴尬的问题。在插入模式下，只需要按<kbd>Ctrl</kbd>+<kbd>o</kbd>即可进入此模式，当进行完一次操作后又会自动回到插入模式。这样岂不是更省时间？

#### 普通模式 (normal)

Vim 的命令大部分都是在普通模式下完成的，普通模式下可不能乱按，可以说每个键都是命令。

```vim
首先是 hjkl 四个方向键。
                                              k ^
                                           h <     > l
                                                v j
```

其实大多数编辑器都是用方向键做出移动命令，Vim 也不例外，但 `hjkl` 给了我们更好的选择，只需要一段时间的适应，你便能快速地操作它们进行移动，而且它们可没有方向键那么远，节省时间是一流的。

普通模式下最重要的命令，没有之一，那就是 `u` 。撤销命令，作用是撤销上一次对文本的更改，普通模式下的 `x` ， `d` ， `p` 命令都会被撤销，同时进入一次插入模式所编辑的文本也算一次更改， `u` 命令会删去从进入到退出插入模式所输入的所有东西。与之对应的是<kbd>Ctrl</kbd>+<kbd>r</kbd>命令，他的作用是撤销上次的撤销命令，相当于大部分 Windows 下程序中的<kbd>Ctrl</kbd>+<kbd>y</kbd>。

然后的话，就是普通模式下常用的命令。由于对行命令的使用很频繁，所以大部分的单键命令都可以通过按两次来实现对行操作。常用命令是 `x` ，用于删除光标后的一个字符。然后是 `d` 命令，也是删除，但是种类更多，这里不做赘述。同时 `d` 命令像之前说的，按两次即可删除整行，即 `dd` 。

然后是 `y` 命令，可以复制被选中的区域，这涉及到可视模式，即按 `v` 进入可视模式，多用于选中区域。进入可视模式后移动光标来确定选取范围是可以的，此时按 `o` 键即可切换活动端，省去了如果跑反方向的麻烦。当然，我相信很多人还是习惯用鼠标操作这一过程的，包括移动光标。Vim 很温馨的提供了这一配置： `set mouse=a` 。你可以将它写入你的配置文件中去。有了它之后，你将能够用鼠标选中区域并进行复制操作。当然，选中后按 `x` 或 `d` 亦可删除。同时， `y` 也符合 `d` 的性质， `yy` 将可以复制当前行。

然后就是更快的跳跃了。如果说只是使用 `hjkl` 的话，光标的移动显然不够快，而鼠标却又要伸手去拿。Vim 提供了普通模式下更快的跳跃方法， `w` 可以跳到下个单词的开头，而 `e` 可以跳到当前单词结尾， `0` 可以跳至行首， `$` 可以跳至行尾，岂不是快多了？而且 `w` ， `e` ， `0` ， `$` 还可以用于许多命令中 `de` ， `dw` ， `d0` ， `d&` 分别对应删至单词尾，删至下个单词头，删至行首，删至行尾。以及 `y` 命令亦可同理。

然后是 Vim 的可重复。在输入某个命令前，输入一个数字的话，就会重复那么多次。如在普通模式下：

```vim
asdasdasdasdasd
asdadasdddd
asdasdasd
```

光标正位于第一行，该如何删除这三行呢？普通模式下按 `3 dd` 即可。其实还有 `.` 命令也是可以做到一些重复的，这会在效率篇中提到。

然后是全文的跳跃，按 `gg` 可跳至代码的开头，按 `G` 可跳至代码最后一行，先按数字再按 `G` 可跳至指定行。

那么在文中还有极为方便的查找功能，普通模式下只需按 `/` 下方即会出现查找框框，输入需要查找的字符按回车就好啦，如果有多个查找结果，只需按 `n` 即可跳至下一个查找处，按 `N` 即可跳至上一个。

常用命令大概就这些了……

#### 命令行模式

其实这并不能称作是一个模式。

普通模式下只需要按 : 下方就会蹦出命令框框，输入相关命令即可。如 Vim 在线帮助文档，输入 `:help` 即可，如果看不懂英文……请下载 Vim 用户手册中文，或者移步插件篇。

此模式下有一些很有用的命令

 `:q` 退出， `:w` 保存， `:wq` 保存并退出， `:q/home/llj/Desktop/OI-wiki-master/docs/lang/editor/!` 不保存并退出， `:e filename` 打开当前目录下指定文件，这些是比较基础的。

然后是很强大的命令 `:x1,x2 s/A 串/B 串/` 作用是把第 `x1` 行至 `x2` 行中的所有 A 串替换成 B 串。想象一下题写完了，但是发现没开 `long long` 的时候，完全不绝望有没有，一个小命令，妙不可言。瞬间所有 `int` 变 `long long` 。

以上都是 Vim 内部的命令，但是实际上如果命令形式是 `:/home/llj/Desktop/OI-wiki-master/docs/lang/editor/! 命令` 那么就将在外部执行命令，即是以 bash 终端执行命令。既然都是外部 bash 了我就不多做介绍了，那块地不归我管……

#### 可视模式

可视模式的作用总结起来大概就是选中高亮，但是块状的可视模式可以干更多的事情，不过太麻烦了，对于新人来说大概会脑阔疼。

普通模式下按 `v` 即可进入可视模式， `hjkl` 可以移动高亮选区某一头，如果发现反了或者你进入可视模式的时候是在想要选中区域的中间位置，不用急着退出重进，更不用花时间又移回去，只需要按 `o` 即可切换活动端，操作高亮选区的另一头。或者用鼠标也不是不行啦……

用鼠标选中高亮选区当然也可以说是进入可视模式的办法之一。

然后就是 `y` 或者 `d` 操作，没了。

emm 基础应该就用到这些了吧，往后的插件，配置，更多操作在对应篇幅里。

最后其实 Vim 还有一些基础操作，它们在 Vim 自带的教程里将会讲述。打开终端输入：

```shell
vimtutor
```

即可进入教程，二三十分钟你就能掌握基础了，但应当加以练习才能彻底掌握。

### 进阶篇

这里讲的新东西不多，反而更多的是技巧与经验，Vim 虽然是一个编辑器，但要用好它学问可不小。所谓技巧，都是如何更快更高效地使用 Vim，都是逻辑思维之间的碰撞。

#### 从缩小控制区域开始

为什么 Emacs 和 Vim 这些编辑器效率高？很重要的一点在于这些编辑器可以让你切掉你的右半部分的键盘而让你的双手始终处于主键盘区域，并且让你的双手保持合作，而不会出现一只手不停的按而另一只手摊在键盘上。
所以，如果你想用好 Vim , 不要去按方向键，不要去碰鼠标，建议使用这几行丧心病狂的配置：

```vim
" 使方向键失效
imap <UP> <Nop>
imap <DOWN> <Nop>
imap <LEFT> <Nop>
imap <RIGHT> <Nop>
```

只需要最多一周的时间，你将完全适应 hjkl 的移动并感慨其效率之高。

但也许这还不够，你还可以进一步缩小你双手需要控制的区域。

-   <kbd>Backspace</kbd>（删除键）使用十分频繁，但它处在主键盘的角落，你不得不挪开手或是伸长小拇指。
    但在 Vim（甚至终端）里，你可以用 ctrl+h 来彻底代替<kbd>Backspace</kbd>。
-   回车键使用同样频繁，但同样不挪一挪手就得伸长小拇指。
    幸运的是在 Vim 和终端中，ctrl+m 完全等效与回车。
-   在绝大多数的情况下，不要去按右边的 ctrl, shift, 用左边的代替。

#### 违背常理的改变

Vim 本便是一个与寻常 IDE 不同的编辑器。那么同样你可以为它做出不寻常的改变。

如果长久使用可以发现，Esc 键太远了，小拇指都按得不顺手。那么我们该怎么处理呢？诶，我又不小心碰到大小写锁定切换键了！你会发现，<kbd>CapsLock</kbd>按键实在太没用了，不仅难用到，而且这么顺手这么近，还容易错按到，我要它何用？我为什么不吧它和<kbd>Esc</kbd>换一下呢？皆大欢喜呀。对吗？

置换方案如下：

终端运行

```bash
sudo vim /usr/share/X11/xkb/symbols/pc
```

找到 `key <ESC>` 与 `key <CAPS>` 这两行，并调换两行的中括号 `[]` 中内容并注销重新进入系统，你就会发现它们换过来了！开始可能会极度极度懵逼，不大回得过神来，但是习惯了几天后，你就会接受了，这个时候你就会进一步享受 Vim 的模式，高速切换模式不是梦。

当然，你可能要问了，如果是在考场怎么办？没有 sudo 权限改不了啊。不用担心，还有办法，但是这个办法重启就失效了，所以考场就用这个办法。在终端输入如下语句即可哦（考场亲测）：

```bash
xmodmap -e 'clear Lock' -e 'keycode x042=Escape'
```

当你能做到高速切换模式与熟练使用 hjkl 移动时，仅在想敲东西的时候进入插入模式并且敲完之后即刻推出就成了一种本能。其实你会发现<kbd>o</kbd>超级好用。现在很多时候我的换行并不是插入模式下的回车键，而是 `<ESC> o` 。而这也有另一个好处。这将会在 **分块撤销** 中得到体现。

#### 重复！效率！重复！

毫无疑问，对动作的重复是提高效率最直接的办法，也是对效率最直接的反映。接下来我将依次介绍 Vim 的<kbd>.</kbd>命令，简单的录制与重复宏与 `normal` 命令。

##### 自行车—— `.` 命令

当你使用 Vim 的时候，对于重复的文本修改其实内心是绝望的，因为 Vim 注定比其他编辑器会多出两个键的按键——<kbd>Esc</kbd>与<kbd>i</kbd>。就像走路的时候别人都是迈步子，但是你一定要跳一下再走一步，这种重复令人十分烦躁与无奈。这可以说是一个致命的缺点，但是，Vim 其实为我们提供了一台“自行车”—— `.` 命令。它令我们能直接不用迈步落步，只要往下踩就好了。

要说起这个命令，其实效果也很简单，那就是重复上次执行的命令。但是，看似简单的外表，其实却是无比的强大，重点就看你如何使用它了。这个重复上次的命令，其实可以是 `数字 + 命令` 的组合，同时， `进入插入模式 + 输入文本 + Esc` 也是一个命令的范畴。那么它的用处就大起来了

Vim 的宗旨是效率至上唯快不破，那么一切都以 `快` 来思考才是正途。那么如何使用这个自行车才是最快的呢？当然是沿着起点和终点之间的那条直线骑。同样的，<kbd>.</kbd>命令只有用到关键处才是最快的。如何使用它呢？我们来看几个例子。

    int a, b
    cin >> a >> b
    cout << a + b
    return 0

可以看见每一行末尾都少了分号。那么如何使用<kbd>.</kbd>命令来优雅地修改呢？为了省去 Vim 的缺点，我们显然可以先将光标移到第一行行尾，然后输入 `a;<Esc>` ，然后接着向下移动到每一行行尾的时候，直接使用<kbd>.</kbd>命令即可。但是这还是没有变快。那么怎么办呢？你会想起 Vim 还有个进入插入模式的命令：A。即移动到行尾插入。那么一切都鲜明起来了，命令如下即可： `A;<Esc>` ，然后你只需要不停地 `j.` 就行了，还是挺~~爽~~方便的。

那么它的用处止步于此了吗？显然远远没有。再来看如下一行代码：

```cpp
int check() {
  book[1] = 1, book[2] = 1, book[3] = 1, book[1] = 1, book[2] = 1, book[3] = 1,
  book[4] = 1, book[5] = 1;
}
```

后面五个赋值语句的数组名写错了肿么办？一个个改显然太坑了，而命令行模式的 `s` 命令又会 **全部改掉** ，那么怎么办呢？可以回忆一下我们普通模式下的 `s` 命令，它的作用是删除光标处字符并进入插入模式。那么怎么使用呢？来到第一个错误的数组名首字母处，按下 `4s` ，你会发现，数组名四个字符统统消失啦！然后输入正确的数组名再退出即可。之后？一个个把光标移过去再使用<kbd>.</kbd>就好啦。

 **但是** ，这还不够优雅，移动光标太浪费时间了！那么有什么办法嘛？答案是显然的。我们可以使用查找模式！ `/book` 再按下回车，并使用 `n` 键来到第四个数组名处，然后 `4s 新数组名 <Esc>` ，接着我们只需要重复 `n.` 就行了，是不是灰常优雅！

 **再但是** ，其实如果你开启了搜索结果高亮的选项，查找模式其实蛮难看的，这里我们引入一个新的轻便型查找命令—— `f` ！使用很简单，在一行中普通模式下， `f + 单个字符` 即可查找此行中出现的这个字符并将光标移至字符处，按 `;` 下一个， `,` 上一个。那么无需查找模式了，我们只需 `fb;;;` 之后进入插入模式修改，然后 `;.` 即可！所以这么说，对于行内移动，其实最常用的一般就几个命令： `h,l,0,$,f` ，而且 `$` 命令是可以被 `f` 替代的，那就是 `f;` 。所以<kbd>.</kbd>是不是炒鸡妙呀。

做个总结：<kbd>.</kbd>命令适用于重复的添加，修改，删除文本。就像一个自行车，踩起来蹭蹭的。

##### 飞机 -- 宏

Vim 的宏功能极度可怕，它重复的可不只是一个命令，你想要指定重复多长的命令它都可以的。那么如何使用它呢？首先我们要先“录制”——顾名思义，把一串按键操作录下来再回放，就达到了重复的效果。

录制的方法很简单，处在普通模式下先按 `q` 键，告诉 Vim 你要开始了。然后，宏的按键录制就像复制粘贴的内容一样是需要一个存放之处的，那么下一步就是为它指定存放处，你可以按下 26 个字母中的任意一个来指定，然后左下方会显示 `记录中 @你刚刚选择的字母` 然后你就可以开始快乐地录制了。同理普通模式下按 `q` 暂停录制。

那么如何调用呢？很简单，按下 `:` 进入命令行模式，命令为 `@选择的记录字母` 然后之前录制的按键就被调用了……听起来是不是麻烦没用？当然不是，你忘了<kbd>.</kbd>命令不成，执行一遍宏之后使用<kbd>.</kbd>命令不就可以不这么麻烦了？当然，如果这些所有重复技巧在一起就很强大了——录制宏 --> 调用宏 --><kbd>.</kbd>命令重复 --> 数字 +<kbd>.</kbd>命令达到无上效果。

岂不快哉？

##### normal 命令

顾名思义，自然有关 normal 模式，效果还是重复，但是——这个命令可以选择行。

如何使用呢？ `:` 进入命令行模式，命令如下：

```vim
:a,b normal 命令
```

命令作用是在 a~b 行上，normal 模式下，执行 normal 后面的那串命令。或许看起来还不是特别强大，但是作为一个可以重复<kbd>.</kbd>命令的工具以及其便于理解性，它的使用频率甚至更高于宏。

##### 数字 + . + 宏 + normal

当命令们抱团的时候，它们才是最强大的，而绝非各自为战。我们演示一个日常即可使用的方法吧。

打个比方，我下载了一本书，我需要它的每一个章节都变成 `标题` 。以方便转换成 mobi 之类的格式或者方便生成 TOC 目录跳转，怎么办呢？几千个章节哪里好处理哇。那么重复命令就大大的有用了。

1.  /正则表达式 进行查找（搜索章节名的表达式请务必上网搜一下）
2.  q 字母 开始录制宏
3.  I#<ESC>q 进行修改操作并结束宏录制
4.  normal n@字母 转到下一处并重复上一步操作
5.  数字 + .   多次重复上一步

完成了！快吗？

重复命令的介绍到此结束（甚至还超纲了）

### 插件篇

基础篇里说过，Vim 与 Emacs 之所以能成为两大巅峰的神器是因为其高度的扩展与可定制性，而最能体现这一特性的就是插件了。它们是最有魅力的一部分，是最令你无法抗拒的组成。

虽然考场上基本上不能用插件，但是日常的学习中，插件将对你的效率有很大的提高，而且一些插件的部分功能可以通过 Vim 自带实现以及配置实现。

首先，其实从前插件的安装必须下载之后丢到 .vim 文件夹中，删了又要下云云，十分麻烦。于是在使用者们的捣鼓下，一枚强大的插件管理器由此诞生——vim-plug。

当然你的配置里必须有如下两行：

```vim
set nocompatible
filetype plugin on
```

以确保你的 Vim 可以加载插件，哪怕是 Vim 原生内置的插件也需要的。

至于具体过程如下：

首先是在 home 目录下建立文件夹 .vim。然后打开终端输入以下命令：

```shell
curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
```

就安装好了。

vim-plug 可以很轻松的管理插件，只需要在配置中写一下，并在 Vim 中执行 `:PlugInstall` 命令，就可以自动从 github 上拉取插件，当然也拉取不了 github 上没有的。而如果不想用了什么插件也无须删去，在配置中注释掉那个插件的相关就行了。具体配置请移步配置篇，此处将会详细介绍我的各个插件。

#### 文件管理

使用 Vim 的时候打开文件显然毫不方便，不论是在目标文件夹下利用

```shell
vim filename
```

打开文件还是在 Vim 内使用 `:e filename` 来打开文件显然都过于麻烦。那么有没有什么更好的法子？

答案是显然的，Vim 的用户们开发了 nerdtree 这一插件。这个插件达到了一种类似于 VS Code 中的效果——工程目录树，之需在左侧目录栏选中相应文件即可打开相应文件。这在配置篇中将会有介绍。nerdtree 的开启方式是在 Vim 中输入 `:NERDTreeToggle` ，它会在左侧打开一个侧边栏窗口。我知道这显然太过麻烦，所以在配置中我给它赋予了<kbd>F10</kbd>这个快捷键。至于具体还有什么快捷键，详请参照 [此文章]([http://yang3wei.github.io/blog/2013/01/29/nerdtree-kuai-jie-jian-ji-lu/) 。

也许有人要说考场上该如何呢？没关系，Vim 自带了一个稍逊一筹的文件管理器 netrw。如果你的命令是这样的

```shell
vim 文件夹(或者说目录)路径
```

或者是在 Vim 中 `e 文件夹路径` 即可打开目录插件，你可以亲手试一试，我觉得这个还是不难琢磨的。同时在上述两个命令中可以用 `.` 来表示当前工作目录，意思是可以用

```shell
vim .
```

或者在 Vim 中使用 `e .` 来开启插件

当然，如果仅是如此还不够，使用文件管理器打开文件的话，容易使工作目录出现差错，从而导致编译的程序不存在于原文件夹中，所以你的配置文件中还需以下语句：

```vim
set autochdir
```

它的作用是会自动把工作目录移动到当前编辑文件所在目录。

#### 美化界面

首先就是那行白乎乎的状态栏，显示的信息还不够多，也不好看对吧。显示的信息是可以在配置中写的，请移步配置篇。但是不好看的问题怎么解决呢？这个时候就轮到了 airline 插件出马了，不多说，放两张图自然明白。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor/![airline1](./images/airline1.png)

/home/llj/Desktop/OI-wiki-master/docs/lang/editor/![airline2](./images/airline2.png)

那么然后呢？字体是可以在终端中设置的，Gvim 中更是有一个图形化的菜单。再就是主题了，它掌管着语法高亮的色彩，背景颜色等等。我个人推荐一个主题，那就是 onedark。附图一张。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor/![onedarktheme](./images/onedarktheme.png)

使用主题的方法呢，就是在 `.vim` 文件夹下建立 `colors` 文件夹，再将主题文件放入。其后缀名为 `.vim` ，如： `onedark.vim` 。具体配置中怎么写，请移步配置篇。

#### 启动界面

这个其实可有可无，是一个能快捷键打开历史记录的一个插件 vimplus-startify，具体可以自己尝试。（至少没有乌干达儿童了，小声）

#### 小方便性插件

commentary：快捷键 `gc` 注释选中行， `gcu` 撤销上次注释。

ale： `:w` 保存时提示语法错误，并且可以开启与 `airline` 的携同，状态栏上也会显示 `Error` 和 `Warning` 。

easymotion：快速跳转，我自己其实都不会用 233，需要可以查阅资料。

rainbow：彩虹括号，使具有包含关系的括号显现出不同的颜色，增强多括号代码的可读性。具体还需要一些东西，请上作者的 github 项目观看。

delimitMate：括号补全功能。同时考试中可用配置实现部分功能，配置篇中会讲述。

vimcdoc：汉化 Vim 在线文档。

gundo：这个插件将能够显示你的文件修改树，就像 github 上一般能够回到历史版本，时光机啊。Vim 中 `:GundoToggle` 即可在左侧打开时光机。但是需要 Vim 开启 python 支持，请自行百度。

vimim：这个的安装不在配置中 ( `* 那是之前 emm，现在 kuai 到了我自己的 github 上，可以直接拉了 *` )，相当于 Vim 自带中文输入法，需在 `.vim` 中创建文件夹 plugin 并把 [从这里](https://www.vim.org/scripts/download_script.php?src_id=23122) 下得的文件扔入此文件夹中即可。打开 Vim 并进入插入模式，按下<kbd>Ctrl</kbd>+<kbd>/</kbd>即可启用。但是使用的是云词库，若没网就会卡死。所以建议下载 [本地超大词库](https://github.com/vimim/vimim/raw/master/plugin/vimim.gbk.bsddb) ，也放入 plugin 文件夹中，与插件脚本同目录即可启用。

vim-instant-markdown：这个插件可就厉害了。Vim 用习惯了之后什么都想用 Vim 来做，比如想用 Vim 来写 Markdown 并实时预览怎么办？于是这个强大的插件就诞生了，当打开 Markdown 文件时会自动在浏览器中打开一个标签页，将能够实时预览你的 Vim 中的 markdown 内容。还有额外的需要，请至 github 首页了解详情。

一切插件的安装写法及快捷键及配置皆在配置篇中，请移步。

### 配置篇

 [我的配置](https://github.com/LuoshuiTianyi/Vim-for-OIWiki) Ps: 我的 .vimrc 时刻在改，所以这只是个副本……

结合我的配置讲一讲一些 Vim 中的小细节和快捷键以及一些……七里八里的东西？

Vim 的配置语法没那么麻烦，基本上就是 set 开启选项，call xxx() 调用函数，func 与 endfunc 定义函数，exec 执行命令，if 和 endif 描述以下条件表达式，" 表示注释，source 表示应用啥的，语法和 Vim 命令行下一模一样，只是当你把配置文件写入，Vim 开启时会自动执行配置中的每一行语句。

#### 基础设置

我必须说我的配置里其实没有背景方面的设置，因为我黑背景加个透明化很舒服了……接下来我会挑重要的配置来讲，剩下的可以结合我的配置内的注释来看

首先使用各种插件容易与 vi 的模式产生冲突，所以我们要关闭 vi 的功能，那么就有了如下配置：

```vim
set nocompatible
```

通过这个设置将关闭原有 vi 的功能以防冲突

随后，当你打开你的 cpp 文件时，你会发现及其之丑，因为没有了语法高亮，一切都是一个颜色了。那么配置中需加入如下两行

```vim
syntax enable
syntax on
```

分别是开启高亮支持与开启语法高亮

然后是状态栏， `set laststatus=2` 这行配置将会使得状态栏总是显示，而状态栏所显示的信息在配置中是可以设置的。设置如下：

```vim
set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ [%{(&fenc==\"\"?&enc:&fenc).(&bomb?\",BOM\":\"\")}]\ %c:%l/%L%)
```

这一行会使状态栏显示包括文件路径，模式，文件类型，文件编码，所在行数与列数，以及光标所在处是文件的百分之多少。加上 airline 插件，既美观又实用。

再然后，默认情况下换行符是不可被删除的，除非使用 `dd` 命令或者 `J` 命令才可做到。那么我们需要 `set backspace=indent,eol,start` 这行配置来解除这种限制。

显然还有一件事，那就是行号的问题。不管是评测文件写了多少行还是想要使用 `数字 + G` 的命令跳至指定行，没有行号的显示肯定是崩溃的。那么可以使用 `set number` 开启行号显示的功能。然后是 Vim 的自动折行功能，那就是当某一行超过了 Vim 窗口的边界，Vim 会怎么做呢？多出的部分会自动显示在下一行，而这种多出来的行前面是没有行号的，比较好辨认，这些行被称为屏幕行，而根据行号一一对应的便称作实际行。但是仅仅凭着看前面的行号来辨认某个折下来的行属于那个实际行的话，还是不够快。我们可以使用 `set cursorline` 来开启高亮显示当前行，而这个高亮也是可以设置的，我的配置里也有。

用 Vim 的一个烦恼事就是临时文件 `swap` 啥的 ...... 太烦了。以下两行配置能够禁止其生成

```vim
    set nobackup            " 设置不备份
    set noswapfile          " 禁止生成临时文件
```

至于主题……只需要如下一行

```vim
colorscheme xxx
```

xxx 就是你的主题名称（去掉 .vim 后缀名）

然后是我们在基础篇中提到过的，开启鼠标支持 `set mouse=a` ，以及插件篇中提及的 `set autochdir` 与进阶篇中有的 `set fillchars=vert:\ ,stl:\ ,stlnc:\` 这三个配置，作用各有提及。

其他的往我配置里看啦。

那个 `zsh` 是一个 shell 的相关程序，有兴趣的可以查查，特点是补全强大。 `Tab` 补全近乎完美，因为它对于文件名的补全远强于 `bash` 。

还有一件事，就是文件编码，设置如下：

```vim
set langmenu=zh_CN.UTF-8
set helplang=cn
set termencoding=utf-8
set encoding=utf8
set fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030
```

#### 快捷键设置

其实 Vim 普通模式下没有多少按键是 "自由身"，那么用户该如何定制自己的快捷键呢？Vim 为此提供了<kbd>leader</kbd>键来服务。<kbd>leader</kbd>键在配置中由自己定制，只需要短短一行

```vim
let mapleader ＝ ""
```

双引号之间就是你自己定义的<kbd>leader</kbd>键啦。

设置快捷键怎么写呢？

```vim
nnoremap 快捷键 指令
inoremap 快捷键 指令
```

两行分别代表了在普通模式下和插入模式下的快捷键执行指令。当然指令不用想多了，没有什么语法，就是相当于在键盘上按你指令中写下的键而已……

首先我的个人快捷键需求其实不是很多，我的<kbd>leader</kbd>键是<kbd>\`</kbd>，但是处于一种坐冷板凳的状态，就更新插件的时候用一用，不过还是很方便的，我的设置是：

```vim
nnoremap <leader><leader>i :PlugInstall<CR>
```

 `<CR>` 代表回车。设置之后只需要连续按<kbd> `` i</kbd>即可更新插件，很方便。

那么你有没有猜到如何利用配置写出括号补全的部分功能呢？没错，就是利用快捷键。将插入模式下的左扩号当做快捷键即可，指令就是 `()` 。如果补全后要使光标在括号里怎么办呢？如果仔细观察你就会发现每当退出插入模式，光标总是会向前跳一个字符，我们可以利用这一点，组合 `Esc + i` 不就变成了向前一个字符进行插入吗？总结下来配置如下：

```vim
inoremap (  ()<esc>i
inoremap [  []<esc>i
inoremap "  ""<esc>i
inoremap '  ''<esc>i
```

当然我的配置里没有，而且我也不用括号补全插件，其实原因是因为我希望我的撤销树会更合理与好看。你会发现，括号补全为了使光标回到括号内，已经退出了一次插入模式，那么撤销命令的效果就不完整了。而且其实插入模式下使用方向键，也相当与推出插入模式移动又重新回到插入模式，也会使撤销树不完整 = =。所以你会发现进阶篇提到的，我的配置里那个丧心病狂的东西……

还记得进阶篇里的分屏吗？显然使用鼠标点击来选择活动窗口太慢，而移动命令前加个<kbd>Ctrl</kbd>+<kbd>w</kbd>也不习惯对不对，所以我的做法是用<kbd>Ctrl</kbd>+ 移动命令来映射前面的按键组合。

```vim
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
```

应该比原来的按法好记也好按……吧……

还记得自动折行吧，我们的 `hjkl` 命令其实都是在实际行之间移动，而折下来的屏幕行实在是没法子，只能用 `l` 键不断移过去。但实际上， `g + 移动命令` 便能够使你在屏幕行间移动，因为考虑到这种移动的常用，我选择将 `g + 移动命令` 与移动命令反过来映射。

```vim
noremap j gj
noremap gj j
noremap gk k
noremap k gk
```

刚才也都说了，自由身的快捷键不多， `F1~F12` 就是方便而自由的快捷键。那用它们来干嘛呢？

<kbd>F9</kbd>一键编译

我想有了之前的编译命令，基础篇命令行模式中的介绍，你应该大概能有个思路了吧。作出的操作肯定如下：

```vim
:w   保存
:/home/llj/Desktop/OI-wiki-master/docs/lang/editor/!g++ xxx.cpp -o xxx 编译  (/home/llj/Desktop/OI-wiki-master/docs/lang/editor/! 使得命令在外部执行)
:/home/llj/Desktop/OI-wiki-master/docs/lang/editor/!./xxx 运行
```

那么如何实现呢？我倾向于写个函数：

```vim
nnoremap <F9> :call CompileRunGcc()<CR>
func/home/llj/Desktop/OI-wiki-master/docs/lang/editor/! CompileRunGcc()
    exec "w"
    exec '/home/llj/Desktop/OI-wiki-master/docs/lang/editor/!g++ % -o %<'
    exec '/home/llj/Desktop/OI-wiki-master/docs/lang/editor/!time ./%<'
    endfunc
```

第一行代表运行 `CompileRunGcc` 函数，第二行代表定义函数，三至五行代表函数运行内容，第六行代表函数结束。 `exec` 表示执行命令， `%` 表示当前文件名， `%<` 表示当前文件名去掉后缀的名字。我想你应该是看得懂函数内容的。 `time` 选项则是回显程序运行时间。

不过如果你使用得多了，就会发现当按下<kbd>F9</kbd>的时候转到另一个屏即终端进行运行，但是每运行一次都会多一些信息。如此累积的话多来几次整个终端就满了，这时可以使用 shell 下的命令

```shell
clear
```

来清屏，不过我倾向于也把它封装在一个快捷键内，按<kbd>F12</kbd>就会自动清屏了，个人觉得用着挺爽……

```vim
nnoremap <F12> :call Clss()<CR>
func/home/llj/Desktop/OI-wiki-master/docs/lang/editor/! Clss()
    exec '/home/llj/Desktop/OI-wiki-master/docs/lang/editor/!clear'
    endfunc
```

还有，在 Vim 中执行外部命令纵使有 `:/home/llj/Desktop/OI-wiki-master/docs/lang/editor/!` 的方法，其实还是不方便，要是能直接在 Vim 中再打开一个终端就好了，对吧。Vim 从 8.0 之后就增添了在内部分个屏来打开一个终端的功能，命令是 `:terminal` 。我个人也将它设置成了快捷键，作为强迫症还是装在了函数中。我想有了命令你应该自己会写了。

```vim
nnoremap <F8> :call Term()<CR>
func/home/llj/Desktop/OI-wiki-master/docs/lang/editor/! Term()
    exec 'terminal'
    endfunc
```

按<kbd>F8</kbd>就能在上面分出一个窗口打开终端了。

介于更各种 Vim 版本的压迫，Vim 作者也是奋发图强，Vim 8.1 又更新了调试程序，先用 `packadd termdebug` 开启此设置，然后在 Vim 中输入 `:Termdebug + 编译出的程序名称` 即可开始 GDB 的过程，具体详细操作可以参考 [这篇文章](https://fzheng.me/2018/05/28/termdebug/) 。这个自然也被我封装函数了 >\_&lt;。

```vim
packadd termdebug
nnoremap <F11> :call GDB()<CR>
func/home/llj/Desktop/OI-wiki-master/docs/lang/editor/! GDB()
    exec 'Termdebug %<'
    endfunc
```

#### 写代码好用的

首先是<kbd>Tab</kbd>键，我们可以用 `set tabstop=` 来定义<kbd>Tab</kbd>的长度，一般当然是 4 个空格，在等于号后面填的数字是多少那么长度就是多少空格。

然后是写代码的时候，当多个括号嵌套时用肉眼显然不好看出对应的括号，那么我们可以用 `set showmatch` 开启高亮显示匹配括号。

有的时候打开 Vim 是不是经常会提示有什么 swap 文件是否确认啥的，那个是临时缓存文件，挺烦的，我们可以使用 `set nobackup` 与 `set noswapfilei` 来禁止其生成，这样就方便舒爽多了（还是开着吧）。

最后嘛，大多数时候调试代码都会用 `freopen` 来输入输出，再利用分屏操作来打开 `.in`  `.out` 文件，就可以实时看到结果。不过每次运行程序之后你都会发现因为 `.out` 文件的修改而会弹出一个确认选项是否重新加载文件，这个也是很不爽的，我们可以开启 `set autoread` 选项以自动加载改动的文件。

#### 关于插件

插件篇中说到了强大的插件管理器 vim-plug，那么在配置中该如何写呢？框架如下：

```vim
call plug#begin('~/.vim/plugged')

call plug#end()
```

在两块之间来写需要安装的插件，格式如下：

```vim
Plug '作者 Github 上的名字/Github 上的插件仓库名'
```

写完保存后进入 Vim，使用 `:PlugInstall` 即可自动开始安装。

我的插件列表：

```vim
call plug#begin('~/.vim/plugged')

Plug 'chxuan/vimplus-startify'                 " 启动界面
Plug 'scrooloose/nerdtree'                     " 目录树
Plug 'tiagofumo/vim-nerdtree-syntax-highlight' " 目录树美化
Plug 'vim-airline/vim-airline'                 " 状态栏美化
Plug 'vim-airline/vim-airline-themes'          " 状态栏美化主题
Plug 'tpope/vim-commentary'                    " 快速注释
Plug 'scrooloose/syntastic'                    " 语法错误提示
Plug 'Lokaltog/vim-easymotion'                 " 快速跳转
Plug 'luochen1990/rainbow'                     " 彩虹括号
Plug 'yianwillis/vimcdoc'                      " HELP文档中文
Plug 'sjl/gundo.vim'                           " 撤销树
Plug 'suan/vim-instant-markdown'               " markdown 实时预览

call plug#end()
```

关于插件其实也有相关配置，但是都写在一起将会使得 `.vimrc` 十分臃肿，我们可以额外写在别的文件里，一般文件应该保存在 `home` 下，然后在配置中写下 `source $HOME/文件路径` 即可。我的 nerdtree, syntastic 和 airline 都额外写了别的文件。

同时我的配置里关于插件的快捷键如下：

```vim
F10 ：启动 nerdtree 侧边工程目录树
F7  ：启动 Gundo 时光机
```

## atom
author: ChungZH, partychicken, Xeonacid

## Atom - GitHub 家的编辑器

### 简介

Atom 是一个免费、开源、跨平台的由 GitHub 开发的程序编辑器。它是用 JavaScript 编写的，并且采用 Electron 架构。官网是 <https://atom.io/> 。它的一个较大缺点就是性能差。

## geany
# Geany

Geany 是一个轻量、便捷的编辑器，对于 Linux 环境下的初学者较为友好。

与 Dev-C++ 一样，它可以编译运行单个文件。

不过，它可以在 Linux/Windows/macOS 下运行。

其官网为： <https://geany.org/> 

## 优缺点

### 优点

1.  轻量；
2.  可以编译运行单个文件；
3.  不需要太多配置；
4.  跨平台。

### 缺点

1.  没有太多人使用；
2.  在 macOS Catalina 下有一些权限问题；
3.  新建文件时，默认不会有语法高亮，需要保存为 C++ 文件后才会有；
4.  如果从模板新建 C++ 文件，后缀名为\*.cxx，而不是我们所熟悉的\*.cpp。

## 安装

### Windows/macOS

在官网上下载安装包安装

### Linux

#### 方法一

使用 `apt` 等包管理器进行安装

#### 方法二

1.  从官网下载源码
2.  终端下运行：

```bash
    ./configure
    make
    sudo make install
```

如遇到 `No package 'gtk+-2.0' found` 可能需要安装 `libgtk2.0-dev` （使用 `apt` 等包管理器 即可）

## 常见问题

兼容深度终端：

在首选项→工具→虚拟终端，修改终端的命令为：

```bash
deepin-terminal -x "/bin/sh" %c
```

点击“应用”按钮后即可。

（来源：Deepin Wiki <https://wiki.deepin.org/> ）

## npp
author: CBW2007, partychicken, StudyingFather, Xeonacid

## 软件简介

Notepad++ 是 Windows 操作系统下的文本编辑器，支持多国语言、多种编码、多种编程语言的高亮和补全。它的 logo 也十分可爱，是一只变色龙（![npp-logo](./images/npp-logo.webp)）

其功能比其他许多编辑软件强大许多，打开大文件时更加稳定，不断撤销不会出问题。关闭时也不需要保存，它会自动为你保存在缓冲区中。（可能需要配置）而且，它十分小巧，只有 10MB+，甚至可以放在 U 盘中随身携带。

## 下载与安装

 **注意：该文章统一使用 7.7.1 版本做演示，但是最新版本与演示版本不会有太大差别，为了获得更好的使用体验，请尽量使用最新版。** 

打开 [软件官网](https://notepad-plus-plus.org/) 或 [可靠的第三方网站](https://notepad-plus.en.softonic.com/) ，去到 [Download](https://notepad-plus-plus.org/downloads) 页面并选择版本（推荐最新版），然后进入软件下载页面。 **注意选择处理器架构** （32 位或 64 位）。如果电脑是 64 位，强烈建议下载 64 位，因为大多数插件只支持 64 位；如果渴望兼容性，请下载 32 位。如果网络不好，可以选择各种软件园（有风险）。

有 3 种安装方法：

1.  installer——安装包模式，当你没有任何其他想法时的推荐模式。
2.  zip/7z package——压缩包模式，当你不想用安装包时可以直接下载 -> 解压 -> 使用。
3.  minimalist package——迷你模式，没有主题、插件和升级包，下载、安装更快捷。

这里用安装包模式做演示：

![npp-install-1](./images/npp-install-1.png)

双击安装包，进入安装界面，选择语言，接受协议，选择安装位置不在赘述，接下来选择安装内容：

![npp-install-2](./images/npp-install-2.png)

有一项是后期补的，不要在意（捂脸）。

介绍一下（按顺序）

1.  自动编译功能（？）
2.  自带插件功能
3.  自动升级插件
4.  自定义插件功能
5.  安装多国语言
6.  软件主题商店
7.  添加到右键菜单

![npp-install-3](./images/npp-install-3.png)

最后一步，两个选项。第一个是创建桌面快捷方式，第二个是“不要用 %APPDATA%”，当你想要装在 U 盘里使用时务必勾选。

最后点击“安装”开始安装。

## 更改界面语言

![npp-lang](./images/npp-lang.gif)

语言改完了，就可以随心所欲地魔改编辑器啦！

## 初级玩法

这里主要讲一些基础和特色功能。

### 查找与替换

依次单击“（菜单栏）搜索”->“查找”（快捷键 `CTRL` + `F` ）即可打开“查找”页面（如下图）。

![npp-search](./images/npp-search.png)

依次单击“（菜单栏）搜索”->“替换”（快捷键 `CTRL` + `H` ）即可打开“替换”页面（如下图）。

![npp-replace](./images/npp-replace.png)

查找、替换之间其实是一个窗口，单击上面的标签页就可以完成切换。

其功能与普通编辑器大同小异，但是支持更多，如：

1.  严格匹配或大小写匹配等
2.  跨文档匹配
3.  转义字符，如'\\r'，'\\n'。
4.  正则表达式
5.  计数

### 定期备份

![npp-settings-1](./images/npp-settings-1.png)

有了这个功能，就可以不用费心地担心意外情况代码丢失啦！

但是，这个功能只是为你的文件拍了一个快照，并没有真正保存，所以还是建议要有良好的保存习惯。或者说可以去自带插件商店安装 "Auto Save" 插件（详见 [高级玩法 -> 插件](./#_14) ，下同）

### 书签功能

在你需要的行按 `Ctrl` + `F2` 即可设放置/取消书签，放置过书签的行前段有一个蓝色圆点。

按 `F2` 可以定位到下一个书签。

如果你抱怨不方便，可以去自带插件商店安装 "Bookmarks" 插件

### 代码高亮

右击左下角的 "XXX file"，可以选择许多种语言高亮，C、C++、PASCAL、Markdown 等任你挑选。你甚至可以自己定义高亮！

如果你认为每一次打开文件都要更改高亮很麻烦，可以在“设置 -> 首选项 -> 新建 -> 默认语言”中修改默认高亮。

需要渲染 Markdown 的，可以去插件商店安装 "Markdown Viewer"，还有更多类似插件等着你！

### 显示所有字符

![npp-settings-2](./images/npp-settings-2.png)

点击红框所圈的按钮，就可以非（za）常（luan）清（wu）晰（zhang）地显示出“空格”、“TAB”、“换行”等原来不可见字符。

### 自动识别文件编码与换行符

Notepad++ 可以自动识别当前文件编码是 `UTF-8` 还是 `GB2312` 甚至其他。再也不用担心被 `锟斤拷` 抡死或被 `烫烫烫` 烫死了。

如果要使用不同的编码浏览文章，请依次单击“（菜单顶栏）编码”->“使用 XXX 编码”。如果想给文件换一个字符编码，请依次单击“（菜单顶栏）编码”->“转为 XXX 编码”。

它还可以自动识别换行符是 `CR` 、 `LF` 或 `CRLF` 。不用担心下载下来的数据被吞换行。

在底部信息栏，你可以看到 "Windows(CR LF)" 等字样，这就是当前文件的换行符。右击它，可以改变当前文件换行符。此操作配合“显示所有字符”更直观哟！

## 高级玩法

这个就适用于需求较高的用户。

### 宏

宏可以帮助你完成许多重复的工作，例如，我要将奇数行的“abcde”改为“afce”，需要两步。

#### 录制宏

![npp-macro-rec](./images/npp-macro-rec.gif)

#### 使用宏

![npp-macro-use](./images/npp-macro-use.gif)

#### 大量处理，重复使用

如果是更多行呢？操作就需要一点改变。

首先是录制，一定要先按键盘上的 `HOME` 或 `END` 键将光标移动到行首或行尾，然后用方向键调整横向位置，再进行更改。最后一定要用方向键将光标移动到下一个要处理的行。

比如刚刚的例子，可以先按 `END` 键，然后依次按 `←` ， `Backspace` , `←` , `Backspace` , `F` ，最后按两下 `↓` ，最后停止录制。

然后是重播，先定位到第一个要处理的行（第 3 行），然后点击“宏”->“重复运行宏”。在弹出窗口设置要运行的宏（刚录制的一般是第一个），设置运行次数（或者直接运行到文件尾），点确定即可。

#### 保存宏

点击“宏”->“保存录制宏”，并设置名称和快捷键，即可保存，方便后续使用。

### 插件

#### 插件管理

打开功能栏的“插件”按钮，列表中会显示所有你安装过的插件。

再选择“插件管理”选项，即可管理你的插件。

#### 安装插件（商店）

1.  打开“可用”选项卡，在列表中勾选你所要的插件
2.  点击右上角的“安装”按钮，按照提示重启软件即可。

#### 安装插件（手动）

1.  下载插件（由第三方托管的官方地址： <https://sourceforge.net/projects/npp-plugins/> ）注意一定要选择 **与安装 Notepad++ 时处理器架构相同** 的插件。
2.  找到一个名为 "XXX.dll" 的文件（通常以插件名命名）。
3.  在 Notepad++ 中的功能栏点插件，并在列表中点“打开插件文件夹”。
4.  将刚才找到的 DLL 文件放入文件夹中，重启 Notepad++。
5.  【可选】删除刚才拷贝的文件， **但不要删除生成的文件夹！** 

Tips: 如果多次不成功，可以尝试新建一个与插件名相同的文件夹在将 ".dll" 文件放入创建的文件夹中

#### 更新插件

在插件管理中，选择“更新”选项卡，并勾选要更新的插件，然后点右上角的“更新”按钮。

#### 移除插件

同样在插件管理中，选择“已安装”选项卡，并勾选要移除的插件，然后点右上角的“移除”按钮。

### 搭建开发环境

不只是编辑器！"Notepad++" 可谓神一样的存在，它可以通过傻瓜式地编译代码，甚至代替 IDE！这里以 C++ 为例

1.  安装编译器并将其必要的文件目录添加到 PATH 环境变量中。（C++ 需要添加 %APPPATH%\\bin）当你在 cmd 中输入 g++ 时不再提示'g++'不是内部或外部命令……即可（中间可能需要重启电脑）。推荐 [下载 ConsolePauser](https://sourceforge.net/projects/orwelldevcpp/files/Tools/ConsolePauser.exe/download) 然后随便放并将其目录添加到环境变量（此为 Dev-C++ 的插件，在 Dev-C++ 软件根目录也有）。

2.  在菜单栏中选择“运行”->“运行……”，打开“运行”窗口。

3.  分别输入以下命令

    ```shell
    #编译命令：
    cmd /c g++.exe -o $(CURRENT_DIRECTORY)\$(NAME_PART).exe $(FULL_CURRENT_PATH)
    #运行命令：
    cmd /c $(CURRENT_DIRECTORY)\$(NAME_PART).exe $(FULL_CURRENT_PATH) & pause
    #调试命令：
    cmd /c gdb $(CURRENT_DIRECTORY)\$(NAME_PART).exe

    #如果下载了ConsolePauser可以使用下列代码获得更好的程序运行体验！（注意添加环境变量！）

    #编译命令：
    cmd /c (start ConsolePauser "g++.exe -o $(CURRENT_DIRECTORY)\$(NAME_PART).exe $(FULL_CURRENT_PATH)")
    #运行命令：
    cmd /c (start ConsolePauser "$(CURRENT_DIRECTORY)\$(NAME_PART).exe")
    #调试命令：
    cmd /c (start ConsolePauser "gdb $(CURRENT_DIRECTORY)\$(NAME_PART).exe")
    ```


4.  单击“保存”，名字可以自己取，如 "Compile","Run" 等，然后设定好你想要的快捷键（捡好记的来，如 Dev-C++ 就分别是 `F9` 和 `F10` ）。

5.  Enjoy it!

## 小彩蛋

1.  在运行安装程序时你会在下方看到这样一句话：

    > "The best things in life are free. Notepad++ is free. So Notepad++ is the best(.)"
    >
    > （生活中最好的事情都是免费的。Notepad++ 是免费的。所以 Notepad++ 是最好的。）

    这牛吹的，不得不说，很有底气。

2.  在一个新开的页面中输入 "random" 并选中，再按 `F1` 就会得到一句很有意思的话。

## emacs
author: akakw1, Ir1d, partychicken, Xeonacid

## Emacs 入门教程

15 分钟入门 Emacs

### 简介

Emacs 是一款非常容易上手的编辑器，只需要简短的几行配置就能使用，但是想要非常熟练地使用 Emacs 进行各项工作还是需要一定的时间。

作为入门教程，这里仅介绍如何使用 Emacs 的基本功能并能够较方便地用 Emacs 编写、调试代码。

### 入门

这一部分用于介绍 Emacs 的基本功能及一些重要部分。

#### 命令

命令在 Emacs 中有很大的作用，但是由于一般用快捷键代替输入命令，所以这里只简单介绍一下。

使用右 Ctrl 左边的第一个键（不是 windows 键，在 windows 系统下需要手动设置这个键）或者快捷键 M-x（Alt+x）可以打开命令输入，输入完按下回车可以执行命令。

通常我们使用 `es` 或者 `eshell` 命令来打开 eshell（类似一个终端）。

#### 缓冲 (buffer)

缓冲即打开的文件和进程，在不保存的情况下，在缓冲中修改并不会修改到文件。

在缓冲区的底部点击缓冲的名字或者使用快捷键可以切换缓冲。

#### 编译、调试和运行

在顶部的菜单栏中有一个 Tools 点开就有编译和调试，或者你也可以输入命令或者自定义快捷键使用编译和调试功能。

运行可以使用终端或 Eshell 运行程序。

按下 Tools 中的调试 (gud-gdb) 后，输入程序名（一般会自动输好，但如果中途将程序另存为或者打开了两个需要调试的程序， **自动输好的文件名可能会有误** ）即可开始调试。

#### 分屏

这个功能便于我们查看各个缓冲的内容，而不需要来回切换缓冲，方便我们测试、调试代码。

分屏功能可以同时显示多个窗口，用鼠标拖动窗口的边缘可以缩放窗口。

几个快捷键：

-   删除分屏 "C-x 0"：将这个分屏删去
-   横向分屏 "C-x 3"：将这个分屏横向分成两半
-   纵向分屏 "C-x 2"：将这个分屏纵向分成两半

一般窗口分为四块：先横向分，调整一块的宽度约为 3/4 屏，作为编辑窗口，再将另一块横向分，一块作为调试和编译信息显示的窗口，另一块再纵向分，一块打开输入文件，一块打开输出文件。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/emacs.png)

#### 快捷键

Emacs 拥有极为丰富的快捷键，可以大幅提高写工作的效率，同时你也可以在配置中自定义快捷键或者设置快捷键的映射。

由于快捷键过多，所以 Emacs 快捷键的使用不同于我们的操作系统，一般有以下三种：

-    `F?` 、 `ESC` ：直接按下对应的功能键
-    `M-?` 、 `C-?` 、 `C-M-?` ：按下 `Alt` 或者 `Ctrl` （ `M-` 对应 `Alt` ， `C-` 对应 `Ctrl` ）的同时按下 `?` 
-    `? ?` ：先按下第一个 `?` 代表的键，松开再按下第二个 `?` 代表的键

下面是一些常用的快捷键：

-    `C-x h` ：全选
-    `C-x left` 、 `C-x right` ：切换到上/下一个缓冲
-    `C-x d` ：打开一个目录
-    `C-x C-f` ：打开一个文件（如果不存在文件则新建文件）

### 个性化

打开最初的 Emacs，非常丑，并且不好用，我们需要个性化设置。

由于配置不好记，所以部分可以直接设置的部分建议不要记配置

#### 直接设置

-   Options： `Highlight Matching Parentheses` 高亮匹配括号
-   Options： `Blink Cursor` 设置光标闪烁
-   Options Show/Hide： `Tool Bar` 显示/不显示工具栏（默认显示，建议不显示）
-   Options： `Use CUA Keys` 勾选后可以使用 Ctrl + C,Ctrl + V 等快捷键进行复制粘贴
-   Options Customize-Emacs： `Custom Theme` 选择配色方案，选择完后需要点击保存
-   Options： `Save Options`  **保存配置** 

#### 配置

在 home 目录下显示隐藏文件（Windows 系统在 **用户目录** 的 `AppData\Roaming` 目录下），".emacs" 就是配置文件（如果没有说明之前没保存），打开修改即可，如果有打开的 Emacs 需要重启 Emacs 生效。

考场必备

```text
;;设置一键编译 可以自行添加参数 难背考场不建议使用 不建议依赖一键编译
(defun compile-file ()(interactive)(compile (format "g++ -o %s %s -g -lm -Wall" (file-name-sans-extension (buffer-name))(buffer-name))))
(global-set-key [f9] 'compile-file)
;;;;设置编译快捷键（如果设置了一键编译不要与一键编译冲突）
;;(global-set-key [f9] 'compile)

(global-set-key (kbd "C-a") 'mark-whole-buffer) ;;全选快捷键
(global-set-key (kbd "C-z") 'undo) ;;撤销快捷键
(global-set-key [f10] 'gud-gdb) ;;GDB调试快捷键
(global-set-key (kbd "RET") 'newline-and-indent) ;;换行自动缩进
(global-set-key (kbd "C-s") 'save-buffer) ;;设置保存快捷键
(setq-default kill-ring-max 65535) ;;扩大可撤销记录

;;C++ 代码风格 一般控制缩进规则
;;;"bsd" 所有大括号换行
;;;"java" 所有大括号不换行。else 接在右大括号后面
;;;"awk" 只有命名空间旁、定义类、定义函数时的大括号换行。else 接在右大括号后面
;;;"linux" 只有命名空间旁、定义类、定义函数时的大括号换行。else 接在右大括号后面。一般来说，这个风格应该有 8 格的空格缩进
(setq-default c-default-style "awk")
```

??? "完整配置"
    ```text
    ;;设置一键编译
    (defun compile-file ()(interactive)(compile (format "g++ -o %s %s -g -lm -Wall" (file-name-sans-extension (buffer-name))(buffer-name))))
    (global-set-key [f9] 'compile-file)
    ;;;;设置编译快捷键（如果设置了一键编译不要与一键编译冲突）
    ;;(global-set-key [f9] 'compile)
    
    ;;考场必备
    (global-set-key (kbd "C-a") 'mark-whole-buffer) ;;全选快捷键
    (global-set-key (kbd "C-z") 'undo) ;;撤销快捷键
    (global-set-key [f10] 'gud-gdb) ;;GDB调试快捷键
    (global-set-key (kbd "RET") 'newline-and-indent) ;;换行自动缩进
    (global-set-key (kbd "C-s") 'save-buffer) ;;设置保存快捷键
    (setq-default kill-ring-max 65535) ;;扩大可撤销记录
    ;;(define-key key-translation-map [apps] (kbd "M-x")) ;; windows 系统下设置命令快捷键
    
    ;;设置缩进
    ;;;C++ 代码缩进长度。
    (setq-default c-basic-offset 4)
    ;;;使用 tab 缩进
    (setq-default indent-tabs-mode t)
    ;;;tab 的长度。务必和缩进长度一致
    (setq-default default-tab-width 4)
    (setq-default tab-width 4)
    
    ;;设置默认编码环境
    (set-language-environment "UTF-8")
    (set-default-coding-systems 'utf-8)
    
    ;;不显示欢迎页面
    (setq-default inhibit-startup-screen t)
    
    ;;设置标题
    (setq-default frame-title-format "")
    
    ;;显示行号
    (global-linum-mode t)
    
    ;;高亮
    (global-hl-line-mode 1);;高亮当前行
    (show-paren-mode t);;高亮匹配括号
    (global-font-lock-mode t);;语法高亮
    
    ;;允许emacs和外部其他程序的粘贴 好像默认允许
    (setq-default x-select-enable-clipboard t)
    
    ;;设置字体是 Ubuntu Mono 的 16 号，如果字体不存在会报错
    (set-default-font "Ubuntu Mono-16")
    ;(set-default-font "Consolas-16") ;; windows 系统请用这条
    
    ;;鼠标滚轮支持
    (mouse-wheel-mode t)
    
    ;;设置光标形状为竖线（默认为方块）
    (setq-default cursor-type 'bar)
    
    ;;回答 yes/no 改成回答 y/n
    (fset 'yes-or-no-p 'y-or-n-p)
    
    ;;透明度
    (set-frame-parameter (selected-frame) 'alpha (list 85 60))
    (add-to-list 'default-frame-alist (cons 'alpha (list 85 60)))
    
    ;;减少页面滚动的行数，防止整页地滚动
    (setq-default scroll-margin 3 scroll-conservatively 10000)
    
    ;;优化文件树结构
    (ido-mode t)
    
    ;;配色方案
    (setq default-frame-alist
             '((vertical-scroll-bars)
               (top . 25)
               (left . 45)
               (width . 120)
               (height . 40)
               (background-color . "grey15")
               (foreground-color . "grey")
               (cursor-color . "gold1")
               (mouse-color . "gold1")
               (tool-bar-lines . 0)
               (menu-bar-lines . 1)
               (scroll-bar-lines . 0)
               (right-fringe)
               (left-fringe)))
    
    (set-face-background 'highlight "gray5")
    (set-face-foreground 'region "cyan")
    (set-face-background 'region "blue")
    (set-face-foreground 'secondary-selection "skyblue")
    (set-face-background 'secondary-selection "darkblue")
    (set-cursor-color "wheat")
    (set-mouse-color "wheat")
    
    (custom-set-variables
     '(ansi-color-faces-vector
       [default default default italic underline success warning error])
    ;;启动 Ctrl-x Ctrl-c Ctrl-v = 剪切 复制 粘贴
     '(cua-mode t nil (cua-base))
     '(show-paren-mode t)
    ;;隐藏工具栏
     '(tool-bar-mode nil))
    ;;关闭光标闪烁
     '(blink-cursor-mode nil)
    (custom-set-faces)
    ```

## vscode
author: Enter-tainer, Xeonacid, ChungZH, keepthethink, abc1763613206, partychicken, Ir1d, NachtgeistW

## 简介

Visual Studio Code（以下简称 VS Code) 是一个由微软开发，同时支持 Windows、Linux 和 macOS 等操作系统且开放源代码的代码编辑器。它是用 TypeScript 编写的，并且采用 Electron 架构。官网是 <https://code.visualstudio.com/> 。它带有对 JavaScript、TypeScript 和 Node.js 的内置支持，并为其他语言（如 C++、Cype、Java、Python、PHP、Go）提供了丰富的扩展生态系统。

## 配置

### 安装语言插件

在 VS Code 中打开插件商店，然后在搜索栏中输入 `@category:"programming languages"` ，然后找到 C/C++，点击 Install 即可。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/vscode-2.png)

### 使用 Code Runner 插件

VS Code 安装并配置插件后可实现对 C/C++ 的支持，但配置过程比较复杂。一个简单的编译与运行 C++ 程序的方案是安装 Code Runner 插件。

Code Runner 是一个可以一键运行代码的插件，在工程上一般用来验证代码片段，支持 Node.js, Python, C, C++, Java, PHP, Perl, Ruby, Go 等 40 多种语言。

安装的方式是在插件商店搜索 Code Runner 并点击 Install；或者前往 [Marketplace](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) 并点击 Install，浏览器会自动打开 VS Code 并进行安装。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![](./images/vscode-1.jpg)

安装完成后，打开需要运行的文件，点击右上角的小三角图标即可运行代码；按下快捷键<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>N</kbd>（在 macOS 下是<kbd>Control</kbd>+<kbd>Option</kbd>+<kbd>N</kbd>）也可以得到同样的效果。

???+ warning
    如果安装了 VS Code 与 Code Runner 后，代码仍然无法运行，很有可能是因为系统尚未安装 C/C++ 的运行环境。

    - 在 Windows 环境下运行 C/C++ 程序，需要先安装 [MinGW](http://www.mingw.org/) 或 MinGW-w64；
    - MacOS 可运行 `xcode-select --install` 进行安装；
    - Linux 系统已经带有 C/C++ 运行环境，无需额外配置。

### 使用 C/C++ 插件编译并调试

???+ warning
    在配置前，请确保系统已经安装了 [MinGW-w64](https://mingw-w64.org/doku.php/download) 或 [Clang](https://releases.llvm.org/download.html) ，并已添加到了 `path` 中。请使用 `CMD` 或者 `PowerShell` ，而不是 `Git Bash` 作为集成终端。

#### 配置编译与调试

首先用 VS Code 打开一个空文件夹，然后按下 `F1` ，输入 `C/C++: Edit configurations (UI)` ，进入 `C/C++` 插件的设置界面。

/home/llj/Desktop/OI-wiki-master/docs/lang/editor//home/llj/Desktop/OI-wiki-master/docs/lang/editor/![vscode-1](images/vscode-3.png)

在 `Compiler path` 中选择 `G++` 或 `Clang` 的所在路径。

至此，编译的配置已经完成。按下 `F1` ，输入 `C/C++: Build and Debug Active File` ，选择用 `G++` 编译，即可查看效果。

#### 配置 IntelliSense

调整 IntelliSense mode 即可。可选的选项有 `Clang` 和 `gcc` 。

## string
author: johnvp22, lr1d

##  `string` 是什么

 `std::string` 是在标准库 `<string>` （注意不是 C 语言中的 `<string.h>` 库）中提供的一个类，本质上是 `std::basic_string<char>` 的别称。

## 为什么要使用 `string` 

在 C 语言中，提供了字符串的操作，但只能通过字符数组的方式来实现字符串。而 `string` 则是一个简单的类，使用简单，在 OI 竞赛中被广泛使用。并且相较于其他 STL 容器， `string` 的常数可以算是非常优秀的，基本与字符数组不相上下。

###  `string` 可以动态分配空间

和许多 STL 容器相同， `string` 能动态分配空间，这使得我们可以直接使用 `std::cin` 来输入，但其速度则同样较慢。这一点也同样让我们不必为内存而烦恼。

###  `string` 重载了加法运算符和比较运算符

 `string` 的加法运算符可以直接拼接两个字符串或一个字符串和一个字符。和 `std::vector` 类似， `string` 重载了比较运算符，同样是按字典序比较的，所以我们可以直接调用 `std::sort` 对若干字符串进行排序。

## 使用方法

下面介绍 `string` 的基本操作，具体可看 [C++ 文档](https://zh.cppreference.com/w/cpp/string/basic_string) 。

### 声明

```cpp
std::string s;
```

### 转 char 数组

在 C 语言里，也有很多字符串的函数，但是它们的参数都是 char 指针类型的，为了方便使用， `string` 有两个成员函数能够将自己转换为 char 指针—— `data()` / `c_str()` （它们几乎是一样的，但最好使用 `c_str()` ，因为 `c_str()` 保证末尾有空字符，而 `data()` 则不保证），如：

```cpp
printf("%s", s);          // 编译错误
printf("%s", s.data());   // 编译通过，但是是 undefined behavior
printf("%s", s.c_str());  // 一定能够正确输出
```

### 获取长度

很多函数都可以返回 string 的长度：

```cpp
printf("s 的长度为 %d", s.size());
printf("s 的长度为 %d", s.length());
printf("s 的长度为 %d", strlen(s.c_str()));
```

???+note "这些函数的复杂度"
     `strlen()` 的复杂度一定是与字符串长度线性相关的。

     `size()` 和 `length()` 的复杂度在 C++98 中没有指定，在 C++11 中被指定为常数复杂度。但在常见的编译器上，即便是 C++98，这两个函数的复杂度也是常数。

### 寻找某字符（串）第一次出现的位置

```cpp
printf("字符 a 在 s 的 %d 位置第一次出现", s.find('a'));
printf("字符串 t 在 s 的 %d 位置第一次出现", s.find(t));
printf("在 s 中自 pos 位置起字符串 t 第一次出现在 %d 位置", s.find(t, pos));
```

### 截取子串

 `substr(pos, len)` ，这个函数的参数是从 `pos` 位置开始截取最多 `len` 个字符（如果从 `pos` 开始的后缀长度不足 `len` 则截取这个后缀）。

```cpp
printf("从这个字符串的第二位开始的最多三个字符构成的子串是 %s",
       s.substr(1, 3).c_str());
```

## algorithm
STL 提供了大约 100 个实现算法的模版函数，基本都包含在 `<algorithm>` 之中，还有一部分包含在 `<numeric>` 和 `<functional>` 。完备的函数列表请 [参见参考手册](https://zh.cppreference.com/w/cpp/algorithm) ，排序相关的可以参考 [排序内容的对应页面](../../basic/stl-sort.md) 。

-    `find` ：顺序查找。 `find(v.begin(), v.end(), value)` ，其中 `value` 为需要查找的值。
-    `find_end` ：逆序查找。 `find_end(v.begin(), v.end(), value)` 。
-    `reverse` ：翻转数组、字符串。 `reverse(v.begin(), v.end())` 或 `reverse(a + begin, a + end)` 。
-    `unique` ：去除容器中相邻的重复元素。 `unique(ForwardIterator first, ForwardIterator last)` ，返回值为指向 **去重后** 容器结尾的迭代器，原容器大小不变。与 `sort` 结合使用可以实现完整容器去重。
-    `random_shuffle` ：随机地打乱数组。 `random_shuffle(v.begin(), v.end())` 或 `random_shuffle(v + begin, v + end)` 。
-    `sort` ：排序。 `sort(v.begin(), v.end(), cmp)` 或 `sort(a + begin, a + end, cmp)` ，其中 `end` 是排序的数组最后一个元素的后一位， `cmp` 为自定义的比较函数。
-    `stable_sort` ：稳定排序，用法同 `sort()` 。
-    `nth_element` ：按指定范围进行分类，即找出序列中第 $n$ 大的元素，使其左边均为小于它的数，右边均为大于它的数。 `nth_element(v.begin(), v.begin() + mid, v.end(), cmp)` 或 `nth_element(a + begin, a + begin + mid, a + end, cmp)` 。
-    `binary_search` ：二分查找。 `binary_search(v.begin(), v.end(), value)` ，其中 `value` 为需要查找的值。
-    `merge` ：将两个（已排序的）序列合并。 `merge(v1.begin(), v1.end(), v2.begin(), v2.end())` 。
-    `lower_bound` ：在一个有序序列中进行二分查找，返回指向第一个 **大于等于**  $x$ 的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。 `lower_bound(v.begin(),v.end(),x)` 。
-    `upper_bound` ：在一个有序序列中进行二分查找，返回指向第一个 **大于**  $x$ 的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。 `upper_bound(v.begin(),v.end(),x)` 。

???+warning "`lower_bound` 和 `upper_bound` 的时间复杂度"
    在一般的数组里，这两个函数的时间复杂度均为 $O(\log n)$ ，但在 `set` 等关联式容器中，直接调用 `lower_bound(s.begin(),s.end(),val)` 的时间复杂度是 $O(n)$ 的。
    
     `set` 等关联式容器中已经封装了 `lower_bound` 等函数（像 `s.lower_bound(val)` 这样），这样调用的时间复杂度是 $O(\log n)$ 的。

## associative-container
##  `set` 

 `set` 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。 `set` 内部通常采用红黑树实现。

和数学中的集合相似， `set` 中不会出现值相同的元素。

### 插入与删除操作

-    `insert(x)` 当容器中没有等价元素的时候，将元素 x 插入到 `set` 中。
-    `erase(x)` 删除值为 x 的元素，返回删除元素的个数。
-    `erase(pos)` 删除迭代器为 pos 的元素，要求迭代器必须合法。
-    `erase(first,last)` 删除迭代器在 $[first,last)$ 范围内的所有元素。
-    `clear()` 清空 `set` 。

???+note "insert 函数的返回值"
    insert 函数的返回值类型为 `pair<iterator, bool>` ，其中 iterator 是一个指向所插入元素（或者是指向等于所插入值的原本就在容器中的元素）的迭代器，而 bool 则代表元素是否插入成功，由于 `set` 中的元素具有唯一性质，所以如果在 `set` 中已有等值元素，则插入会失败，返回 false，否则插入成功，返回 true； `map` 中的 insert 也是如此。

### 迭代器

 `set` 提供了以下几种迭代器：

1.   `begin()/cbegin()`   
    返回指向首元素的迭代器，其中 `*begin = front` 。
2.   `end()/cend()`   
    返回指向数组尾端占位符的迭代器，注意是没有元素的。
3.   `rbegin()/rcbegin()`   
    返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。
4.   `rend()/rcend()`   
    返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。

以上列出的迭代器中，含有字符 `c` 的为只读迭代器，你不能通过只读迭代器去修改 `set` 中的元素的值。如果一个 `set` 本身就是只读的，那么它的一般迭代器和只读迭代器完全等价。只读迭代器自 C++11 开始支持。

### 查找操作

-    `count(x)` 返回 `set` 内键为 x 的元素数量。
-    `find(x)` 在 `set` 内存在键为 x 的元素时会返回该元素的迭代器，否则返回 `end()` 。
-    `lower_bound(x)` 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 `end()` 。
-    `upper_bound(x)` 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回 `end()` 。
-    `empty()` 返回容器是否为空。
-    `size()` 返回容器内元素个数。

???+warning "`lower_bound` 和 `upper_bound` 的时间复杂度"
     `set` 自带的 `lower_bound` 和 `upper_bound` 的时间复杂度为 $O(\log n)$ 。
    
    但使用 `algorithm` 库中的 `lower_bound` 和 `upper_bound` 函数对 `set` 中的元素进行查询，时间复杂度为 $O(n)$ 。

##  `multiset` 

 `multiset` 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。

与 `set` 不同的是， `multiset` 允许不同元素间拥有相同的值。

### 插入与删除操作

-    `insert(x)` 将元素 x 插入到 `multiset` 中。
-    `erase(x)` 删除值为 x 的 **所有** 元素，返回删除元素的个数。
-    `erase(pos)` 删除迭代器为 pos 的元素，要求迭代器必须合法。
-    `erase(first,last)` 删除迭代器在 $[first,last)$ 范围内的所有元素。
-    `clear()` 清空 `multiset` 。

### 迭代器

 `multiset` 的迭代器和 `set` 的 [迭代器](#_2) 类似，这里不再赘述。

### 查找操作

 `multiset` 的查找操作和 `set` 的 [查找操作](#_3) 类似，这里不再赘述。

##  `map` 

 `map` 是有序键值对（Attribute–value pair）容器，它的元素的键是唯一的。搜索、移除和插入操作拥有对数复杂度。 `map` 通常实现为红黑树。

你可能需要存储一些键值对，例如存储学生姓名对应的分数： `Tom 0` ， `Bob 100` ， `Alan 100` 。
但是由于数组下标只能为非负整数，所以无法用姓名作为下标来存储，这个时候最简单的办法就是使用 STL 中的 `map` 了！

 `map` 重载了 `operator[]` ，可以用任意定义了 `operator <` 的类型作为下标（在 `map` 中叫做 `key` ，也就是索引）：

```cpp
map<Key, T> yourMap;
```

其中， `Key` 是键的类型， `T` 是值的类型，下面是使用 `map` 的实例：

```cpp
map<string, int> mp;
```

### 添加元素

1.  直接赋值，例如 `mp["Tom"]=0` 
2.  通过插入一个类型为 `pair<Key, T>` 的值，例如 `mp.insert(pair<string,int>("Alan",100));` 
3.  使用 `initializer_list` ：

```cpp
map<string, int> mp = {{"Tom", 0}, {"Bob", "100"}, {"Alan", 100}};
```

### 查找、修改元素

1.  使用赋值语法： `int grade=mp["Tom"]` 。
2.  使用成员函数 `iterator find( const Key& key );` 来确定一个索引是否在 `map` 中。它会返回指向该元素的迭代器；如果索引不在 `map` 中，则会返回尾后迭代器 `mp.end()` 。
3.  如果你想获得 `map` 里全部的元素，请使用迭代器，解引用迭代器会得到一个类型为 `pair<Key, T>` 的值：

```cpp
for (iter = mp.begin(); iter != mp.end(); ++iter)
  cout << iter->first << " " << iter->second << endl;
```

其中使用 `mp.begin()` 可以得到指向 `map` 首元素的迭代器。
如果使用 C++11（及以上），还可以使用 C++11 的范围 for 循环

```cpp
for (auto &i : mp) {
  printf("Key : %d, Value : %d\n", i.first, i.second);
}
```

使用迭代器遍历大小为 $n$ 的 `map` 的时间复杂度是 $O(n)$ 。

### 删除元素

如果你想删除 `Tom` 这个元素，则可以利用 `find` 函数找到 `Tom` ，然后再 `erase` 如下

```cpp
map<string, int>::iterator it;
it = mp.find("Tom");
mp.erase(it)
```

如果你想清空所有的元素，可以直接 `mp.clear()` 

### 其他函数

-    `count` 返回匹配特定键的元素出现的次数，例如 `mp.count("Tom")` 。
-    `swap` 可以交换两个 `map` ，例如 `swap(m1,m2)` 。
-    `size` 返回 `map` 中元素的个数。
-    `empty` 如果 `map` 为空则返回 `true` ，例如 `mp.empty()` 。

##  `multimap` 

和 `map` 类似， `multimap` 是有序键值对容器，但允许多个元素拥有同一键。其搜索、插入操作拥有对数复杂度。删除单个元素在最坏情况下具有对数复杂度，均摊为常数复杂度。

!!! warning
    正是因为 multimap 允许多个元素拥有同一键的特点，multimap 并没有提供给出键访问其对应值的方法。

### 插入与删除操作

-   通过向 `multimap` 中插入一个类型为 `pair<Key, T>` 的值可以达到插入元素的目的，例如 `mp.insert(pair<string,int>("Alan",100));` ；
-    `erase(x)` : 删除键为 x 的 **所有** 元素，返回删除元素的个数。
-    `erase(pos)` : 删除迭代器为 pos 的元素，要求迭代器必须合法。
-    `erase(first,last)` : 删除迭代器在 $[first,last)$ 范围内的所有元素。
-    `clear()` : 清空容器。

### 查找操作

-    `count(x)` : 返回容器内键为 x 的元素数量。复杂度为 $O(\log(size)+ans)$ （关于容器大小对数复杂度，加上匹配个数）。
-    `find(x)` : 若容器内存在键为 x 的元素，会返回该元素的迭代器（如果有多个键为 x 的元素会返回任意一个）；否则返回 `end()` 。
-    `lower_bound(x)` : 返回指向首个不小于给定键的元素的迭代器。
-    `upper_bound(x)` : 返回指向首个大于给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 `end()` 。
-    `empty()` : 返回容器是否为空。
-    `size()` : 返回容器内元素个数。

## bitset
author: i-Yirannn, Xeonacid, ouuan

## 介绍

 `std::bitset` 是标准库中的一个存储 `0/1` 的大小不可变容器。严格来讲，它并不属于 STL。

??? "bitset 与 STL"
    > The C++ standard library provides some special container classes, the so-called container adapters (stack, queue, priority queue). In addition, a few classes provide a container-like interface (for example, strings, bitsets, and valarrays). All these classes are covered separately.1 Container adapters and bitsets are covered in Chapter 12.
    >
    > The C++ standard library provides not only the containers for the STL framework but also some containers that fit some special needs and provide simple, almost self-explanatory, interfaces. You can group these containers into either the so-called container adapters, which adapt standard STL containers to fit special needs, or a bitset, which is a containers for bits or Boolean values. There are three standard container adapters: stacks, queues, and priority queues. In priority queues, the elements are sorted automatically according to a sorting criterion. Thus, the“next”element of a priority queue is the element with the“highest”value. A bitset is a bitfield with an arbitrary but fixed number of bits. Note that the C++ standard library also provides a special container with a variable size for Boolean values: vector.

    ——摘自《The C++ Standard Library 2nd Edition》

    由此看来， `bitset` 并不属于 STL，而是一种标准库中的 "Special Container"。事实上，它作为一种容器，也并不满足 STL 容器的要求。说它是适配器，它也并不依赖于其它 STL 容器作为底层实现。

由于内存地址是按字节即 `byte` 寻址，而非比特 `bit` ，一个 `bool` 类型的变量，虽然只能表示 `0/1` , 但是也占了 1 byte 的内存。

 `bitset` 就是通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 `0/1` 。

对于一个 4 字节的 `int` 变量，在只存 `0/1` 的意义下， `bitset` 占用空间只是其 $\frac{1}{32}$ ，计算一些信息时，所需时间也是其 $\frac 1{32}$ 。

在某些情况下通过 `bitset` 可以优化程序的运行效率。至于其优化的是复杂度还是常数，要看计算复杂度的角度。一般 `bitset` 的复杂度有以下几种记法：（设原复杂度为 $O(n)$ ）

1.   $O(n)$ ，这种记法认为 `bitset` 完全没有优化复杂度。
2.   $O(\frac n{32})$ ，这种记法不太严谨（复杂度中不应出现常数），但体现了 `bitset` 能将所需时间优化至 $\frac 1{32}$ 。
3.   $O(\frac n w)$ ，其中 $w=32$ （计算机的位数），这种记法较为普遍接受。
4.   $O(\frac n {\log w})$ ，其中 $w$ 为计算机一个整型变量的大小。

当然， `vector` 的一个特化 `vector<bool>` 的储存方式同 `bitset` 一样，区别在于其支持动态开空间， `bitset` 则和我们一般的静态数组一样，是在编译时就开好了的。

然而， `bitset` 有一些好用的库函数，不仅方便，而且有时可以避免使用 for 循环而没有实质的速度优化。因此，一般不使用 `vector<bool>` 。

## 使用

### 头文件

```cpp
#include <bitset>
```

### 指定大小

```cpp
bitset<1000> bs;  // a bitset with 1000 bits
```

### 构造函数

-    `bitset()` : 每一位都是 `false` 。
-    `bitset(unsigned long val)` : 设为 `val` 的二进制形式。
-    `bitset(const string& str)` : 设为 $01$ 串 `str` 。

### 运算符

-    `operator []` : 访问其特定的一位。
-    `operator ==/!=` : 比较两个 `bitset` 内容是否完全一样。
-    `operator &/&=/|/| =/^/^=/~` : 进行按位与/或/异或/取反操作。 ** `bitset` 只能与 `bitset` 进行位运算** ，若要和整型进行位运算，要先将整型转换为 `bitset` 。
-    `operator <</>>/<<=/>>=` : 进行二进制左移/右移。
-    `operator <</>>` : 流运算符，这意味着你可以通过 `cin/cout` 进行输入输出。

### 成员函数

-    `count()` : 返回 `true` 的数量。
-    `size()` : 返回 `bitset` 的大小。
-    `test(pos)` : 它和 `vector` 中的 `at()` 的作用是一样的，和 `[]` 运算符的区别就是越界检查。
-    `any()` : 若存在某一位是 `true` 则返回 `true` ，否则返回 `false` 。
-    `none()` : 若所有位都是 `false` 则返回 `true` ，否则返回 `false` 。
-    `all()` : **C++11** ，若所有位都是 `true` 则返回 `true` ，否则返回 `false` 。
-   1.   `set()` : 将整个 `bitset` 设置成 `true` 。
    2.   `set(pos, val = true)` : 将某一位设置成 `true` / `false` 。
-   1.   `reset()` : 将整个 `bitset` 设置成 `false` 。
    2.   `reset(pos)` : 将某一位设置成 `false` 。相当于 `set(pos, false)` 。
-   1.   `flip()` : 翻转每一位。（ $0\leftrightarrow1$ ，相当于异或一个全是 $1$ 的 `bitset` ）
    2.   `flip(pos)` : 翻转某一位。
-    `to_string()` : 返回转换成的字符串表达。
-    `to_ulong()` : 返回转换成的 `unsigned long` 表达 ( `long` 在 NT 及 32 位 POSIX 系统下与 `int` 一样，在 64 位 POSIX 下与 `long long` 一样）。
-    `to_ullong()` : **C++11** ，返回转换成的 `unsigned long long` 表达。

一些文档中没有的成员函数：

-    `_Find_first()` : 返回 `bitset` 第一个 `true` 的下标，若没有 `true` 则返回 `bitset` 的大小。
-    `_Find_next(pos)` : 返回 `pos` 后面（下标严格大于 `pos` 的位置）第一个 `true` 的下标，若 `pos` 后面没有 `true` 则返回 `bitset` 的大小。

## 应用

###  [「LibreOJ β Round #2」贪心只能过样例](https://loj.ac/problem/515) 

这题可以用 dp 做，转移方程很简单：

 $f(i,j)$ 表示前 $i$ 个数的平方和能否为 $j$ ，那么 $f(i,j)=\bigvee\limits_{k=a}^bf(i-1,j-k^2)$ （或起来）。

但如果直接做的话是 $O(n^5)$ 的，（看起来）过不了。

发现可以用 `bitset` 优化，左移再或起来就好了： [std::bitset](https://loj.ac/submission/395274) 

然后发现……被加了几个剪枝的暴力艹了： [加了几个剪枝的暴力](https://loj.ac/submission/395673) 

然而，可以手写 `bitset` （只需要支持左移后或起来这一种操作）压 $64$ 位（ `unsigned long long` ）来艹掉暴力： [手写 bitset](https://loj.ac/submission/395619) 

###  [CF1097F Alex and a TV Show](https://codeforces.com/contest/1097/problem/F) 

#### 题意

给你 $n$ 个可重集，四种操作：

1.  把某个可重集设为一个数。
2.  把某个可重集设为另外两个可重集加起来。
3.  把某个可重集设为从另外两个可重集中各选一个数的 $\gcd$ 。即： $A=\{\gcd(x,y)|x\in B,y\in C\}$ 。
4.  询问某个可重集中某个数的个数， **在模 2 意义下** 。

可重集个数 $10^5$ ，操作个数 $10^6$ ，值域 $7000$ 。

#### 做法

看到“在模 $2$ 意义下”，~~而且这是篇 bitset 教程~~，可以想到用 `bitset` 维护每个可重集。

这样的话，操作 $1$ 直接设，操作 $2$ 就是异或（因为模 $2$ ），操作 $4$ 就是直接查，但 .. 操作 $3$ 怎么办？

我们可以尝试维护每个可重集的所有约数构成的可重集，这样的话，操作 $3$ 就是直接按位与。

我们可以把值域内每个数的约数构成的 `bitset` 预处理出来，这样操作 $1$ 就解决了。操作 $2$ 仍然是异或。

现在的问题是，如何通过一个可重集的约数构成的可重集得到该可重集中某个数的个数。

令原可重集为 $A$ ，其约数构成的可重集为 $A'$ ，我们要求 $A$ 中 $x$ 的个数，用 [莫比乌斯反演](../../math/mobius.md) 推一推：

$$
\begin{aligned}&\sum\limits_{i\in A}[\frac i x=1]\\=&\sum\limits_{i\in A}\sum\limits_{d|\frac i x}\mu(d)\\=&\sum\limits_{d\in A',x|d}\mu(\frac d x)\end{aligned}
$$

由于是模 $2$ 意义下， $-1$ 和 $1$ 是一样的，只用看 $\frac d x$ 有没有平方因子即可。所以，可以对值域内每个数预处理出其倍数中除以它不含平方因子的位置构成的 `bitset` ，求答案的时候先按位与再 `count()` 就好了。

这样的话，单次询问复杂度就是 $O(\frac v w)$ （ $v=7000,\,w=32$ ）。预处理可以写 $O(v\log v)$ 的，也可以写 $O(v\sqrt v)$ 的，还可以写 $O(v^2)$ 的，~~它们甚至跑的差不多快~~。

 $O(v\sqrt v)$ 或者 $O(v^2)$ 预处理比较简单， $\log$ 预处理就如下面代码所示，复杂度为调和级数，所以是 $O(v\log v)$ 。

??? "参考代码"
    ```cpp
    #include <bitset>
    #include <cctype>
    #include <cmath>
    #include <cstdio>
    #include <iostream>
    
    using namespace std;
    
    int read() {
      int out = 0;
      char c;
      while (!isdigit(c = getchar()))
        ;
      for (; isdigit(c); c = getchar()) out = out * 10 + c - '0';
      return out;
    }
    
    const int N = 100005;
    const int M = 1000005;
    const int V = 7005;
    
    bitset<V> pre[V], pre2[V], a[N], mu;
    int n, m, tot;
    char ans[M];
    
    int main() {
      int i, j, x, y, z;
    
      n = read();
      m = read();
    
      mu.set();
      for (i = 2; i * i < V; ++i) {
        for (j = 1; i * i * j < V; ++j) {
          mu[i * i * j] = 0;
        }
      }
      for (i = 1; i < V; ++i) {
        for (j = 1; i * j < V; ++j) {
          pre[i * j][i] = 1;
          pre2[i][i * j] = mu[j];
        }
      }
    
      while (m--) {
        switch (read()) {
          case 1:
            x = read();
            y = read();
            a[x] = pre[y];
            break;
          case 2:
            x = read();
            y = read();
            z = read();
            a[x] = a[y] ^ a[z];
            break;
          case 3:
            x = read();
            y = read();
            z = read();
            a[x] = a[y] & a[z];
            break;
          case 4:
            x = read();
            y = read();
            ans[tot++] = ((a[x] & pre2[y]).count() & 1) + '0';
            break;
        }
      }
    
      printf("%s", ans);
    
      return 0;
    }
    ```

### 与树分块结合

 `bitset` 与树分块结合可以解决一类求树上多条路径信息并的问题，详见 [数据结构/树分块](../../ds/tree-decompose.md) 。

### 与莫队结合

详见 [杂项/莫队配合 bitset](../../misc/mo-algo-with-bitset.md) 。

### 计算高维偏序

详见 [FHR 课件](https://github.com/OI-wiki/libs/blob/master/lang/csl/FHR-分块bitset求高维偏序.pdf) 。

## container-adapter
author: Xeonacid

## stack

STL 栈 ( `std::stack` ) 是一种后进先出 (Last In, First Out) 的容器适配器，仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。

### 头文件和命名空间

```cpp
#include <stack>
using std::stack
```

### 栈的定义

```cpp
stack<TypeName> s;  // 使用默认底层容器 deque，数据类型为 TypeName
stack<TypeName, Container> s;  // 使用 Container 作为底层容器

stack<TypeName> s2(s1);  // 以 s1 为模板定义一个栈 s2
```

### 成员函数

#### 以下所有函数均为常数复杂度

-    `top()` 访问栈顶元素（如果栈为空，此处会出错）
-    `push(x)` 向栈中插入元素 x
-    `pop()` 删除栈顶元素
-    `size()` 查询容器中的元素数量
-    `empty()` 询问容器是否为空

### 简单示例

```cpp
stack<int> s1;
s1.push(2);
s1.push(1);
stack<int> s2(s1);
s1.pop();
std::cout << s1.size() << " " << s2.size() << endl;  // 1 2
std::cout << s1.top() << " " << s2.top() << endl;    // 2 1
s1.pop();
std::cout << s1.empty() << " " << s2.empty() << endl;  // 1 0
```

## queue

STL 队列 ( `std::queue` ) 是一种先进先出 (First In, First Out) 的容器适配器，仅支持查询或删除第一个加入的元素（队首元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。

### 头文件和命名空间

```cpp
#include <queue>
using std::queue
```

### 队列的定义

```cpp
queue<TypeName> q;  // 使用默认底层容器 deque，数据类型为 TypeName
queue<TypeName, Container> q;  // 使用 Container 作为底层容器

queue<TypeName> q2(q1);  // 以 q1 为模板定义一个队列 q2
```

### 成员函数

#### 以下所有函数均为常数复杂度

-    `front()` 访问队首元素（如果队列为空，此处会出错）
-    `push(x)` 向队列中插入元素 x
-    `pop()` 删除队首元素
-    `size()` 查询容器中的元素数量
-    `empty()` 询问容器是否为空

### 简单示例

```cpp
queue<int> q1;
q1.push(2);
q1.push(1);
queue<int> q2(q1);
q1.pop();
std::cout << q1.size() << " " << q2.size() << endl;    // 1 2
std::cout << q1.front() << " " << q2.front() << endl;  // 1 2
q1.pop();
std::cout << q1.empty() << " " << q2.empty() << endl;  // 1 0
```

## priority_queue

```cpp
#include <queue>  // std::priority_queue
// 本文里的所有优先队列都会加上命名空间
// 如果不想加命名空间，需要使用：using std::priority_queue;
// 不推荐直接使用 using namespace std;
std::priority_queue<T, Container, Compare> q;
/*
 * T: 储存的元素类型
 * Container:
 * 储存的容器类型，且要求满足顺序容器的要求、具有随机访问迭代器的要求 且支持
 * front() / push_back() / pop_back() 三个函数， 标准容器中 std::vector /
 * std::deque 满足这些要求。 Compare: 默认为严格的弱序比较类型
 * priority_queue 是按照元素优先级大的在堆顶，根据 operator <
 * 的定义，默认是大根堆， 我们可以利用
 * greater<T>（若支持），或者自定义类的小于号重载实现排序。
 * 注意：只支持小于号重载而不支持其他比较符号的重载。
 */
// 构造方式 ：
std::priority_queue<int> q1;
std::priority_queue<int, vector<int>> q2;
// C++11 前，请使用 vector<int> >，空格不可省略
std::priority_queue<int, deque<int>, greater<int>> q3;
// 注意：不可跳过容器参数直接传入比较类
```

### 成员函数

1.   `top()` : 访问栈顶元素 常数复杂度
2.   `empty()` : 检查底层的容器是否为空 常数复杂度
3.   `size()` : 返回底层容器的元素数量 常数复杂度
4.   `push()` : 插入元素，并对底层容器排序 最坏 $\Theta(n)$ 均摊 $\Theta(\log(n))$ 
5.   `pop()` : 删除第一个元素 最坏 $\Theta(\log(n))$ 

由于 `std::priority_queue` 原生不支持 `modify()` / `join()` / `erase()` 故不做讲解。

### 示例

```cpp
q1.push(1);
// 堆中元素 ： [1];
for (int i = 2; i <= 5; i++) q1.push(i);
// 堆中元素 :  [1, 2, 3, 4, 5];
std::cout << q1.top() << std::endl;
// 输出结果 : 5;
q1.pop();
std::cout << q1.size() << std::endl;
// 输出结果 ：4
// 堆中元素 : [1, 2, 3, 4];
q1.push(10);
// 堆中元素 : [1, 2, 3, 4, 10];
std::cout << q1.top() << std::endl;
// 输出结果 : 10;
q1.pop();
// 堆中元素 : [1, 2, 3, 4];
```

## sequence-container
author: MingqiHuang, Xeonacid, greyqz, i-Yirannn, ChenZ01

##  `vector` 

 `std::vector` 是 STL 提供的 **内存连续的** 、 **可变长度** 的数组（亦称列表）数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。

### 为什么要使用 `vector` 

作为 OIer，对程序效率的追求远比对工程级别的稳定性要高得多，而 `vector` 由于其对内存的动态处理，时间效率在部分情况下低于静态数组，并且在 OJ 服务器不一定开全优化的情况下更加糟糕。所以在正常存储数据的时候，通常不选择 `vector` 。下面给出几个 `vector` 优秀的特性，在需要用到这些特性的情况下， `vector` 能给我们带来很大的帮助。

####  `vector` 可以动态分配内存

很多时候我们不能提前开好那么大的空间（eg：预处理 1~n 中所有数的约数）。尽管我们能知道数据总量在空间允许的级别，但是单份数据还可能非常大，这种时候我们就需要 `vector` 来把内存占用量控制在合适的范围内。 `vector` 还支持动态扩容，在内存非常紧张的时候这个特性就能派上用场了。

####  `vector` 重写了比较运算符及赋值运算符

 `vector` 重载了六个比较运算符，以字典序实现，这使得我们可以方便的判断两个容器是否相等（复杂度与容器大小成线性关系）。例如可以利用 `vector<char>` 实现字符串比较（当然，还是用 `std::string` 会更快更方便）。另外 `vector` 也重载了赋值运算符，使得数组拷贝更加方便。

####  `vector` 便利的初始化

由于 `vector` 重载了 `=` 运算符，所以我们可以方便的初始化。此外从 C++11 起 `vector` 还支持 [列表初始化](https://zh.cppreference.com/w/cpp/language/list_initialization) ，例如 `vector<int> data {1, 2, 3};` 。

###  `vector` 的使用方法

以下介绍常用用法，详细内容 [请参见 C++ 文档](https://zh.cppreference.com/w/cpp/container/vector) 。

#### 构造函数

用例参见如下代码（假设你已经 `using` 了 `std` 命名空间相关类型）：

```cpp
// 1. 创建空vector; 常数复杂度
vector<int> v0;
// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度
v0.reserve(3);
// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度
vector<int> v1(3);
// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度
vector<int> v2(3, 2);
// 4. 创建一个初始空间为3的vector，其元素的默认值是1，
// 并且使用v2的空间配置器; 线性复杂度
vector<int> v3(3, 1, v2.get_allocator());
// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度
vector<int> v4(v2);
// 6. 创建一个v4的拷贝vector v5，其内容是{v4[1], v4[2]}; 线性复杂度
vector<int> v5(v4.begin() + 1, v4.begin() + 3);
// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11
vector<int> v6(std::move(v2));  // 或者 v6 = std::move(v2);
```

??? note "测试代码"
    ```cpp
    // 以下是测试代码，有兴趣的同学可以自己编译运行一下本代码。
    cout << "v1 = ";
    copy(v1.begin(), v1.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
    cout << "v2 = ";
    copy(v2.begin(), v2.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
    cout << "v3 = ";
    copy(v3.begin(), v3.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
    cout << "v4 = ";
    copy(v4.begin(), v4.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
    cout << "v5 = ";
    copy(v5.begin(), v5.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
    cout << "v6 = ";
    copy(v6.begin(), v6.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
    ```

可以利用上述的方法构造一个 `vector` ，足够我们使用了。

#### 元素访问

 `vector` 提供了如下几种方法进行元素访问

1.   `at()` 

     `v.at(pos)` 返回容器中下标为 `pos` 的引用。如果数组越界抛出 `std::out_of_range` 类型的异常。

2.   `operator[]` 

     `v[pos]` 返回容器中下标为 `pos` 的引用。不执行越界检查。

3.   `front()` 

     `v.front()` 返回首元素的引用。

4.   `back()` 

     `v.back()` 返回末尾元素的引用。

5.   `data()` 

     `v.data()` 返回指向数组第一个元素的指针。

#### 迭代器

vector 提供了如下几种 [迭代器](./iterator.md) 

1.   `begin()/cbegin()` 

    返回指向首元素的迭代器，其中 `*begin = front` 。

2.   `end()/cend()` 

    返回指向数组尾端占位符的迭代器，注意是没有元素的。

3.   `rbegin()/rcbegin()` 

    返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。

4.   `rend()/rcend()` 

    返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。

以上列出的迭代器中，含有字符 `c` 的为只读迭代器，你不能通过只读迭代器去修改 `vector` 中的元素的值。如果一个 `vector` 本身就是只读的，那么它的一般迭代器和只读迭代器完全等价。只读迭代器自 C++11 开始支持。

#### 长度和容量

 `vector` 有以下几个与容器长度和容量相关的函数。注意， `vector` 的长度（size）指有效元素数量，而容量（capacity）指其实际分配的内存长度，相关细节请参见后文的实现细节介绍。

 **与长度相关** ：

-    `empty()` 返回一个 `bool` 值，即 `v.begin() == v.end()` ， `true` 为空， `false` 为非空。

-    `size()` 返回容器长度（元素数量），即 `std::distance(v.begin(), v.end())` 。

-    `resize()` 改变 `vector` 的长度，多退少补。补充元素可以由参数指定。

-    `max_size()` 返回容器的最大可能长度。

     **与容量相关** ：

-    `reserve()` 使得 `vector` 预留一定的内存空间，避免不必要的内存拷贝。

-    `capacity()` 返回容器的容量，即不发生拷贝的情况下容器的长度上限。

-    `shrink_to_fit()` 使得 `vector` 的容量与长度一致，多退但不会少。

### 元素增删及修改

-    `clear()` 清除所有元素
-    `insert()` 支持在某个迭代器位置插入元素、可以插入多个。 **复杂度与 `pos` 距离末尾长度成线性而非常数的** 
-    `erase()` 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 `insert` 一致。
-    `push_back()` 在末尾插入一个元素，均摊复杂度为 **常数** ，最坏为线性复杂度。
-    `pop_back()` 删除末尾元素，常数复杂度。
-    `swap()` 与另一个容器进行交换，此操作是 **常数复杂度** 而非线性的。

###  `vector` 的实现细节

 `vector` 的底层其实仍然是定长数组，它能够实现动态扩容的原因是增加了避免数量溢出的操作。首先需要指明的是 `vector` 中元素的数量（长度） $n$ 与它已分配内存最多能包含元素的数量（容量） $N$ 是不一致的， `vector` 会分开存储这两个量。当向 `vector` 中添加元素时，如发现 $n>N$ ，那么容器会分配一个尺寸为 $2N$ 的数组，然后将旧数据从原本的位置拷贝到新的数组中，再将原来的内存释放。尽管这个操作的渐进复杂度是 $O(n)$ ，但是可以证明其均摊复杂度为 $O(1)$ 。而在末尾删除元素和访问元素则都仍然是 $O(1)$ 的开销。
因此，只要对 `vector` 的尺寸估计得当并善用 `resize()` 和 `reserve()` ，就能使得 `vector` 的效率与定长数组不会有太大差距。

###  `vector<bool>` 

标准库特别提供了对 `bool` 的 `vector` 特化，每个“ `bool` ”只占 1 bit，且支持动态增长。但是其 `operator[]` 的返回值的类型不是 `bool&` 而是 `vector<bool>::reference` 。因此，使用 `vector<bool>` 使需谨慎，可以考虑使用 `deque<bool>` 或 `vector<char>` 替代。而如果你需要节省空间，请直接使用 [ `bitset` ](./bitset.md) 。

##  `array` (C++11)

 `std::array` 是 STL 提供的 **内存连续的** 、 **固定长度** 的数组数据结构。其本质是对原生数组的直接封装。

### 为什么要用 `array` 

 `array` 实际上是 STL 对数组的封装。它相比 `vector` 牺牲了动态扩容的特性，但是换来了与原生数组几乎一致的性能（在开满优化的前提下）。因此如果能使用 C++11 特性的情况下，能够使用原生数组的地方几乎都可以直接把定长数组都换成 `array` ，而动态分配的数组可以替换为 `vector` 。

### 成员函数

#### 隐式定义的成员函数

| 函数            | 作用                                  |
| ------------- | ----------------------------------- |
|  `operator=`  | 以来自另一 `array` 的每个元素重写 `array` 的对应元素 |

#### 元素访问

| 函数             | 作用                    |
| -------------- | --------------------- |
|  `at`          | 访问指定的元素，同时进行越界检查      |
|  `operator[]`  | 访问指定的元素， **不** 进行越界检查 |
|  `front`       | 访问第一个元素               |
|  `back`        | 访问最后一个元素              |
|  `data`        | 返回指向内存中数组第一个元素的指针     |

 `at` 若遇 `pos >= size()` 的情况会抛出 `std::out_of_range` 。

#### 容量

| 函数           | 作用          |
| ------------ | ----------- |
|  `empty`     | 检查容器是否为空    |
|  `size`      | 返回容纳的元素数    |
|  `max_size`  | 返回可容纳的最大元素数 |

由于每个 `array` 都是固定大小容器， `size()` 返回的值等于 `max_size()` 返回的值。

### 操作

| 函数       | 作用       |
| -------- | -------- |
|  `fill`  | 以指定值填充容器 |
|  `swap`  | 交换内容     |

 **注意，交换两个 `array` 是 $\Theta(\text{size})$ 的，而非与常规 STL 容器一样为 $O(1)$ 。** 

### 非成员函数

| 函数              | 作用                  |
| --------------- | ------------------- |
|  `operator==` 等 | 按照字典序比较 `array` 中的值 |
|  `std::get`     | 访问 `array` 的一个元素    |
|  `std::swap`    | 特化的 `std::swap` 算法  |

下面是一个 `array` 的使用示例：

```cpp
// 1. 创建空array，长度为3; 常数复杂度
std::array<int, 3> v0;
// 2. 用指定常数创建array; 常数复杂度
std::array<int, 3> v1{1, 2, 3};

v0.fill(1);  // 填充数组

// 访问数组
for (int i = 0; i != arr.size(); ++i) cout << arr[i] << " ";
```

##  `deque` 

 `std::deque` 是 STL 提供的 [双端队列](../../ds/queue.md) 数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。

###  `deque` 的使用方法

以下介绍常用用法，详细内容 [请参见 C++ 文档](https://zh.cppreference.com/w/cpp/container/deque) 。 `deque` 的迭代器函数与 `vector` 相同，因此不作详细介绍。

#### 构造函数

参见如下代码（假设你已经 `using` 了 `std` 命名空间相关类型）：

```cpp
// 1. 定义一个int类型的空双端队列 v0
deque<int> v0;
// 2. 定义一个int类型的双端队列 v1，并设置初始大小为10; 线性复杂度
deque<int> v1(10);
// 3. 定义一个int类型的双端队列 v2，并初始化为10个1; 线性复杂度
deque<int> v2(10, 1);
// 4. 复制已有的双端队列 v1; 线性复杂度
deque<int> v3(v1);
// 5. 创建一个v2的拷贝deque v4，其内容是v4[0]至v4[2]; 线性复杂度
deque<int> v4(v2.begin(), v2.begin() + 3);
// 6. 移动v2到新创建的deque v5，不发生拷贝; 常数复杂度; 需要 C++11
deque<int> v5(std::move(v2));
```

#### 元素访问

与 `vector` 一致，但无法访问底层内存。其高效的元素访问速度可参考实现细节部分。

-    `at()` 返回容器中指定位置元素的引用，执行越界检查， **常数复杂度** 。
-    `operator[]` 返回容器中指定位置元素的引用。不执行越界检查， **常数复杂度** 。
-    `front()` 返回首元素的引用。
-    `back()` 返回末尾元素的引用。

#### 迭代器

与 `vector` 一致。

#### 长度

与 `vector` 一致，但是没有 `reserve()` 和 `capacity()` 函数。（仍然有 `shrink_to_fit()` 函数）

#### 元素增删及修改

与 `vector` 一致，并额外有向队列头部增加元素的函数。

-    `clear()` 清除所有元素
-    `insert()` 支持在某个迭代器位置插入元素、可以插入多个。 **复杂度与 `pos` 与两端距离较小者成线性** 。
-    `erase()` 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 `insert` 一致。
-    `push_front()` 在头部插入一个元素， **常数复杂度** 。
-    `pop_front()` 删除头部元素， **常数复杂度** 。
-    `push_back()` 在末尾插入一个元素， **常数复杂度** 。
-    `pop_back()` 删除末尾元素， **常数复杂度** 。
-    `swap()` 与另一个容器进行交换，此操作是 **常数复杂度** 而非线性的。

###  `deque` 的实现细节

 `deque` 通常的底层实现是多个不连续的缓冲区，而缓冲区中的内存是连续的。而每个缓冲区还会记录首指针和尾指针，用来标记有效数据的区间。当一个缓冲区填满之后便会在之前或者之后分配新的缓冲区来存储更多的数据。更详细的说明可以参考 [STL 源码剖析——deque 的实现原理和使用方法详解](https://blog.csdn.net/baidu_28312631/article/details/48000123) 。

##  `list` 

 `std::list` 是 STL 提供的 [双向链表](../../ds/linked-list.md) 数据结构。能够提供线性复杂度的随机访问，以及常数复杂度的插入和删除。

###  `list` 的使用方法

 `list` 的使用方法与 `deque` 基本相同，但是增删操作和访问的复杂度不同。详细内容 [请参见 C++ 文档](https://zh.cppreference.com/w/cpp/container/list) 。 `list` 的迭代器、长度、元素增删及修改相关的函数与 `deque` 相同，因此不作详细介绍。

#### 元素访问

由于 `list` 的实现是链表，因此它不提供随机访问的接口。若需要访问中间元素，则需要使用迭代器。

-    `front()` 返回首元素的引用。
-    `back()` 返回末尾元素的引用。

#### 操作

 `list` 类型还提供了一些针对其特性实现的 STL 算法函数。由于这些算法需要 [随机访问迭代器](./iterator.md) ，因此 `list` 提供了特别的实现以便于使用。这些算法有 `splice()` 、 `remove()` 、 `sort()` 、 `unique()` 、 `merge()` 等。

##  `forward_list` （C++11）

 `std::forward_list` 是 STL 提供的 [单向链表](../../ds/linked-list.md) 数据结构，相比于 `std::list` 减小了空间开销。

###  `forward_list` 的使用方法

 `forward_list` 的使用方法与 `list` 几乎一致，但是迭代器只有单向的，因此其具体用法不作详细介绍。详细内容 [请参见 C++ 文档](https://zh.cppreference.com/w/cpp/container/forward_list) 

## index
## C++ 标准

首先需要介绍的是 C++ 本身的版本。由于 C++ 本身只是一门语言，而不同的编译器对 C++ 的实现方法各不一致，因此需要标准化来约束编译器的实现，使得 C++ 代码在不同的编译器下表现一致。C++ 自 1985 年诞生以来，一共由国际标准化组织（ISO）发布了 5 个正式的 C++ 标准，依次为 C++98、C++03、C++11（亦称 C++0x）、C++14（亦称 C++1y）、C++17（亦称 C++1z），最新的标准 C++20 仍在制定中。此外还有一些补充标准，例如 C++ TR1。

每一个版本的 C++ 标准不仅规定了 C++ 的语法、语言特性，还规定了一套 C++ 内置库的实现规范，这个库便是 C++ 标准库。C++ 标准库中包含大量常用代码的实现，如输入输出、基本数据结构、内存管理、多线程支持等。掌握 C++ 标准库是编写更现代的 C++ 代码必要的一步。C++ 标准库的详细文档在 [cppreference](https://zh.cppreference.com/) 网站上，文档对标准库中的类型函数的用法、效率、注意事项等都有介绍，请善用。

需要指出的是，不同的 OJ 平台对 C++ 版本均不相同，例如 [最新的 ICPC 比赛规则](https://icpc.baylor.edu/worldfinals/programming-environment) 支持 C++17 标准，而 [NOI 现行规则](http://www.noi.cn/newsview.html?id=559&hash=E4E249) 中指定的 g++ 4.8 [默认支持标准](https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Standards.html#Standards) 是 C++98。因此在学习 C++ 时要注意比赛支持的标准，避免在赛场上时编译报错。

## 标准模板库（STL）

STL 即标准模板库（Standard Template Library），是 C++ 标准库的一部分，里面包含了一些模板化的通用的数据结构和算法。由于其模板化的特点，它能够兼容自定义的数据类型，避免大量的造轮子工作。NOI 和 ICPC 赛事都支持 STL 库的使用，因此合理利用 STL 可以避免编写无用算法，并且充分利用编译器对模板库优化提高效率。STL 库的详细介绍请参见对应的页面： [STL 容器](./container.md) 和 [STL 算法](./algorithm.md) 。

??? note "什么是造轮子"
    造轮子（ [Reinventing_the_wheel](https://en.wikipedia.org/wiki/Reinventing_the_wheel) ）指的是重复发明已有的算法，或者重复编写现成优化过的代码。造轮子通常耗时耗力，同时效果还没有别人好。但若是为了学习或者练习，造轮子则是必要的。

## Boost 库

 [Boost](https://www.boost.org/) 是除了标准库外，另一个久副盛名的开源 C++ 工具库，其代码具有可移植、高质量、高性能、高可靠性等特点。Boost 中的模块数量非常之大，功能全面，并且拥有完备的跨平台支持，因此被看作 C++ 的准标准库。C++ 标准中的不少特性也都来自于 Boost，如智能指针、元编程、日期和时间等。尽管在 OI 中无法使用 Boost，但是 Boost 中有不少轮子可以用来验证算法或者对拍，如 Boost.Geometry 有 R 树的实现，Boost.Graph 有图的相关算法，Boost.Intrusive 则提供了一套与 STL 容器用法相似的侵入式容器。有兴趣的读者可以自行在网络搜索教程。

## 参考资料

1.   [C++ reference](https://en.cppreference.com/) 
2.   [C++ 参考手册](https://zh.cppreference.com/) 
3.   [维基百科 - C++](https://zh.wikipedia.org/wiki/C%2B%2B) 
4.   [Boost 官方网站](https://www.boost.org/) 
5.   [Boost 教程网站](https://theboostcpplibraries.com/) 

## iterator
在 STL 中，迭代器（Iterator）用来访问和检查 STL 容器中元素的对象，它的行为模式和指针类似，但是它封装了一些有效性检查，并且提供了统一的访问格式。类似的概念在其他很多高级语言中都存在，如 Python 的 `__iter__` 函数，C# 的 `IEnumerator` 。

## 基础使用

迭代器听起来比较晦涩，其实迭代器本身可以看作一个数据指针。迭代器主要支持两个运算符：自增 ( `++` ) 和解引用（单目 `*` 运算符），其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。

指向某个 [STL 容器](./container.md)  `container` 中元素的迭代器的类型一般为 `container::iterator` 。

迭代器可以用来遍历容器，例如，下面两个 for 循环的效果是一样的：

```cpp
vector<int> data(10);

for (int i = 0; i < data.size(); i++)
  cout << data[i] << endl;  // 使用下标访问元素

for (vector<int>::iterator iter = data.begin(); iter != data.end(); iter++)
  cout << *iter << endl;  // 使用迭代器访问元素
// 在C++11后可以使用 auto iter = data.begin() 来简化上述代码
```

## 分类

在 STL 的定义中，迭代器根据其支持的操作依次分为以下几类：

-   InputIterator（输入迭代器）：只要求支持拷贝、自增和解引访问。
-   OutputIterator（输出迭代器）：只要求支持拷贝、自增和解引赋值。
-   ForwardIterator（向前迭代器）：同时满足 InputIterator 和 OutputIterator 的要求。
-   BidirectionalIterator（双向迭代器）：在 ForwardIterator 的基础上支持自减（即反向访问）。
-   RandomAccessIterator（随机访问迭代器）：在 BidirectionalIterator 的基础上支持加减运算和比较运算（即随机访问）。

???+note "为什么输入迭代器叫输入迭代器？"
    “输入”指的是“可以从迭代器中获取输入”，而“输出”指的是“可以输出到迭代器”。

    “输入”和“输出”的施动者是程序的其它部分，而不是迭代器自身。

其实这个“分类”并不互斥——一个“类别”是可以包含另一个“类别”的。例如，在要求使用向前迭代器的地方，同样可以使用双向迭代器。

不同的 [STL 容器](./container.md) 支持的迭代器类型不同，在使用时需要留意。

指针满足随机访问迭代器的所有要求，可以当作随机访问迭代器使用。

## 相关函数

很多 [STL 函数](./algorithm.md) 都使用迭代器作为参数。

可以使用 `next(it)` 获取向前迭代器 `it` 的后继。

可以使用 `prev(it)` 获取双向迭代器 `it` 的前驱。

 [STL 容器](./container.md) 一般支持从一端或两端开始的访问，以及对 [const 修饰符](../const.md) 的支持。例如容器的 `begin()` 函数可以获得指向容器第一个元素的迭代器， `rbegin()` 函数可以获得指向容器最后一个元素的反向迭代器， `cbegin()` 函数可以获得指向容器第一个元素的 const 迭代器， `end()` 函数可以获得指向容器尾端（“尾端”并不是最后一个元素，可以看作是最后一个元素的后继；“尾端”的前驱是容器里的最后一个元素，其本身不指向任何一个元素）的迭代器。

## container
## 分类

/home/llj/Desktop/OI-wiki-master/docs/lang/csl/![](images/container1.png)

### 序列式容器

-    **向量** ( `vector` ) 后端可高效增加元素的顺序表。
-    **数组** ( `array` ) **C++11** ，定长的顺序表，C 风格数组的简单包装。
-    **双端队列** ( `deque` ) 双端都可高效增加元素的顺序表。
-    **列表** ( `list` ) 可以沿双向遍历的链表。
-    **单向列表** ( `forward_list` ) 只能沿一个方向遍历的链表。

### 关联式容器

-    **集合** ( `set` ) 用以有序地存储 **互异** 元素的容器。其实现是由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种比较元素大小的谓词进行排列。
-    **多重集合** ( `multiset` ) 用以有序地存储元素的容器。允许存在相等的元素。
-    **映射** ( `map` ) 由 {键，值} 对组成的集合，以某种比较键大小关系的谓词进行排列。
-    **多重映射** ( `multimap` ) 由 {键，值} 对组成的多重集合，亦即允许键有相等情况的映射。

???+note "什么是谓词 ( [ **Predicate** ](https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)) )？"
    谓词就是返回值为真或者假的函数。STL 容器中经常会使用到谓词，用于模板参数。

### 无序（关联式）容器

-    **无序（多重）集合** ( `unordered_set` / `unordered_multiset` ) **C++11** ，与 `set` / `multiset` 的区别在与元素无序，只关心”元素是否存在“，使用哈希实现。
-    **无序（多重）映射** ( `unordered_map` / `unordered_multimap` ) **C++11** ，与 `map` / `multimap` 的区别在与键 (key) 无序，只关心 "键与值的对应关系"，使用哈希实现。

### 容器适配器

容器适配器其实并不是容器。它们不具有容器的某些特点（如：有迭代器、有 `clear()` 函数……）。

> ”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。

-    **栈**  `(stack` ) 后进先出 (LIFO) 的容器。
-    **队列** ( `queue` ) 先进先出 (FIFO) 的容器。
-    **优先队列** ( `priority_queue` ) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列。

## 共同点

### 容器声明

都是 `containerName<typeName,...> name` 的形式，但模板参数（ `<>` 内的参数）的个数、形式会根据具体容器而变。

本质原因：STL 就是“标准模板库”，所以容器都是模板类。

### 迭代器

请参考 [迭代器](./iterator.md) 。

### 共有函数

 `=` ：有赋值运算符以及复制构造函数。

 `begin()` ：返回指向开头元素的迭代器。

 `end()` ：返回指向末尾的下一个元素的迭代器。 `end()` 不指向某个元素，但它是末尾元素的后继。

 `size()` ：返回容器内的元素个数。

 `max_size()` ：返回容器 **理论上** 能存储的最大元素个数。依容器类型和所存储变量的类型而变。

 `empty()` ：返回容器是否为空。

 `swap()` ：交换两个容器。

 `clear()` ：清空容器。

 `==` / `/home/llj/Desktop/OI-wiki-master/docs/lang/csl/!=` / `<` / `>` / `<=` / `>=` ：按 **字典序** 比较两个容器的大小。（比较元素大小时 `map` 的每个元素相当于 `set<pair<key, value> >` ，无序容器不支持 `<` / `>` / `<=` / `>=` 。）

## unordered-container
## 概述

自 C++11 标准起，四种基于哈希实现的无序关联式容器正式纳入了 C++ 的标准模板库中，分别是： `unordered_set` ， `unordered_multiset` ， `unordered_map` ， `unordered_multimap` 。

它们与相应的关联式容器在功能，函数等方面有诸多共同点，而最大的不同点则体现在普通的关联式容器一般采用红黑树实现，内部元素按特定顺序进行排序；而这几种无序关联式容器则采用哈希方式存储元素，内部元素不以任何特定顺序进行排序，所以访问无序关联式容器中的元素时，访问顺序也没有任何保证。

采用哈希存储的特点使得无序关联式容器 **在平均情况下** 大多数操作（包括查找，插入，删除）都能在常数时间复杂度内完成，相较于关联式容器与容器大小成对数的时间复杂度更加优秀。

!!! warning
    在最坏情况下，对无序关联式容器进行插入、删除、查找等操作的时间复杂度会 **与容器大小成线性关系** ！这一情况往往在容器内出现大量哈希冲突时产生，因此应谨慎使用无序关联式容器。

由于无序关联式容器与相应的关联式容器在用途和操作中有很多共同点，这里不再介绍无序关联式容器的各种操作，这些内容读者可以参考 [关联式容器](./associative-container.md) 。

## 制造哈希冲突

上文中提到了，在最坏情况下，对无序关联式容器进行一些操作的时间复杂度会与容器大小成线性关系。

在哈希函数确定的情况下，可以构造出数据使得容器内产生大量哈希冲突，导致复杂度达到上界。

在标准库实现里，每个元素的散列值是将值对一个质数取模得到的，更具体地说，是 [这个列表](https://github.com/gcc-mirror/gcc/blob/gcc-8_1_0-release/libstdc++-v3/src/shared/hashtable-aux.cc) 中的质数（g++ 6 及以前版本的编译器，这个质数一般是 $126271$ ，g++ 7 及之后版本的编译器，这个质数一般是 $107897$ ）。

因此可以通过向容器中插入这些模数的倍数来达到制造大量哈希冲突的目的。

## 自定义哈希函数

使用自定义哈希函数可以有效避免构造数据产生的大量哈希冲突。

要想使用自定义哈希函数，需要定义一个结构体，并在结构体中重载 `()` 运算符，像这样：

```cpp
struct my_hash {
  size_t operator()(int x) const { return x; }
};
```

当然，为了确保哈希函数不会被迅速破解（例如 Codeforces 中对使用无序关联式容器的提交进行 hack），可以试着在哈希函数中加入一些随机化函数（如时间）来增加破解的难度。

例如，在 [这篇博客](https://codeforces.com/blog/entry/62393) 中给出了如下哈希函数：

```cpp
struct my_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }

  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }
};
```

写完自定义的哈希函数后，就可以通过 `unordered_map<int, int, my_hash> my_map;` 的定义方式将自定义的哈希函数传入容器了。

# geometry
# scanning
## 简介

扫描线一般运用在图形上面，它和它的字面意思十分相似，就是一条线在整个图上扫来扫去，它一般被用来解决图形面积，周长等问题。

## Atlantis 问题

### 题意

在二维坐标系上，给出多个矩形的左下以及右上坐标，求出所有矩形构成的图形的面积。

### 解法

根据图片可知总面积可以直接暴力即可求出面积，如果数据大了怎么办？这时就需要讲到 **扫描线** 算法。

### 流程

现在假设我们有一根线，从下往上开始扫描：

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/scanning-1.png)

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/scanning-2.png)

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/scanning-3.png)

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/scanning-4.png)

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/scanning-5.png)

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/scanning-6.png)

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/scanning-7.png)

-   如图所示，我们可以把整个矩形分成如图各个颜色不同的小矩形，那么这个小矩形的高就是我们扫过的距离，那么剩下了一个变量，那就是矩形的长一直在变化。
-   我们的线段树就是为了维护矩形的长，我们给每一个矩形的上下边进行标记，下面的边标记为 1，上面的边标记为 -1，每遇到一个矩形时，我们知道了标记为 1 的边，我们就加进来这一条矩形的长，等到扫描到 -1 时，证明这一条边需要删除，就删去，利用 1 和 -1 可以轻松的到这种状态。
-   还要注意这里的线段树指的并不是线段的一个端点，而指的是一个区间，所以我们要计算的是 $r+1$ 和 $r-1$ 。
-   需要 [离散化](../misc/discrete.md) 。

### 代码

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#define maxn 300
using namespace std;

int lazy[maxn << 3];  //标记了这条线段出现的次数
double s[maxn << 3];

struct node1 {
  double l, r;
  double sum;
} cl[maxn << 3];  //线段树

struct node2 {
  double x, y1, y2;
  int flag;
} p[maxn << 3];  //坐标

//定义sort比较
bool cmp(node2 a, node2 b) { return a.x < b.x; }

//上传
void pushup(int rt) {
  if (lazy[rt] > 0)
    cl[rt].sum = cl[rt].r - cl[rt].l;
  else
    cl[rt].sum = cl[rt * 2].sum + cl[rt * 2 + 1].sum;
}

//建树
void build(int rt, int l, int r) {
  if (r - l > 1) {
    cl[rt].l = s[l];
    cl[rt].r = s[r];
    build(rt * 2, l, (l + r) / 2);
    build(rt * 2 + 1, (l + r) / 2, r);
    pushup(rt);
  } else {
    cl[rt].l = s[l];
    cl[rt].r = s[r];
    cl[rt].sum = 0;
  }
  return;
}

//更新
void update(int rt, double y1, double y2, int flag) {
  if (cl[rt].l == y1 && cl[rt].r == y2) {
    lazy[rt] += flag;
    pushup(rt);
    return;
  } else {
    if (cl[rt * 2].r > y1) update(rt * 2, y1, min(cl[rt * 2].r, y2), flag);
    if (cl[rt * 2 + 1].l < y2)
      update(rt * 2 + 1, max(cl[rt * 2 + 1].l, y1), y2, flag);
    pushup(rt);
  }
}

int main() {
  int temp = 1, n;
  double x1, y1, x2, y2, ans;
  while (scanf("%d", &n) && n) {
    ans = 0;
    for (int i = 0; i < n; i++) {
      scanf("%lf %lf %lf %lf", &x1, &y1, &x2, &y2);
      p[i].x = x1;
      p[i].y1 = y1;
      p[i].y2 = y2;
      p[i].flag = 1;
      p[i + n].x = x2;
      p[i + n].y1 = y1;
      p[i + n].y2 = y2;
      p[i + n].flag = -1;
      s[i + 1] = y1;
      s[i + n + 1] = y2;
    }
    sort(s + 1, s + (2 * n + 1));  //离散化
    sort(p, p + 2 * n, cmp);  //把矩形的边的纵坐标从小到大排序
    build(1, 1, 2 * n);       //建树
    memset(lazy, 0, sizeof(lazy));
    update(1, p[0].y1, p[0].y2, p[0].flag);
    for (int i = 1; i < 2 * n; i++) {
      ans += (p[i].x - p[i - 1].x) * cl[1].sum;
      update(1, p[i].y1, p[i].y2, p[i].flag);
    }
    printf("Test case #%d\nTotal explored area: %.2lf\n\n", temp++, ans);
  }
  return 0;
}
```

## 练习

-    [「HDU1542」Atlantis](http://acm.hdu.edu.cn/showproblem.php?pid=1542) 

-    [「HDU1828」Picture](http://acm.hdu.edu.cn/showproblem.php?pid=1828) 

-    [「HDU3265」Posters](http://acm.hdu.edu.cn/showproblem.php?pid=3265) 

## 参考资料

-    <https://www.cnblogs.com/yangsongyi/p/8378629.html> 

-    <https://blog.csdn.net/riba2534/article/details/76851233> 

-    <https://blog.csdn.net/winddreams/article/details/38495093> 

# polar-coordinate
author: Ir1d, HeRaNO, Chrogeek, abc1763613206

## 极坐标与极坐标系

（为人教版高中数学选修 4-4 内容）

> 某同学：学平面直角坐标系都学烦了，有没有其他坐标系？

我们考虑实际情况，比如航海，我们说「 $B$ 在 $A$ 的北偏东 $30^\circ$ 方向上，距离为 $100$ 米」，而不是「以 $A$ 为原点建立平面直角坐标系， $B(50,50\sqrt 3)$ 」。

这样，我们在平面上选一定点 $O$ ，称为 **极点** ，自极点引出一条射线 $Ox$ ，称为 **极轴** ，再选择一个单位长度（在数学问题中通常为 $1$ ），一个角度单位（通常为弧度）及其正方向（通常为逆时针方向），这样就建立了 **极坐标系** 。

在极坐标系下，我们怎么描述位置呢？

设 $A$ 为平面上一点，极点 $O$ 与 $A$ 之间的距离 $|OA|$ 即为 **极径** ，记为 $\rho$ ；以极轴为始边， $OA$ 为终边的角 $\angle xOA$ 为 **极角** ，记为 $\theta$ ，那么有序数对 $(\rho,\theta)$ 即为 $A$ 的 **极坐标** 。

由终边相同的角的定义可知， $(\rho,\theta)$ 与 $(\rho,\theta+2k\pi)\ (k\in \mathbb{Z})$ 其实表示的是一样的点，特别地，极点的极坐标为 $(0,\theta)\ (\theta\in \mathbb{R})$ ，于是平面内的点的极坐标表示有无数多种。

如果规定 $\rho>0,0\le \theta<2\pi​$ ，那么除极点外，其他平面内的点可以用唯一有序数对 $(\rho,\theta)​$ 表示，而极坐标 $(\rho,\theta)​$ 表示的点是唯一确定的。

当然，有时候研究极坐标系下的图形有些不方便，我们想要转到直角坐标系下研究，那么我们有互化公式。

点 $A(\rho,\theta)$ 的直角坐标 $(x,y)$ 可以如下表示：

$$
\begin{cases}
x=\rho \cos \theta\\
y=\rho \sin \theta
\end{cases}
$$

进而可知：

$$
\rho ^2=x^2+y^2\\
\tan \theta=\frac{y}{x}\ \ \ \ (x\not =0)
$$

于是，极角 $\theta=\arctan \frac{y}{x}$ ，这样就可以求出极角了。

在编程中，若要求反正切函数，尽量使用 `atan2(y, x)` ，这个函数用途比 `atan(x)` 广泛。

# distance
author: Chrogeek, frank-xjh, ChungZH, hsfzLZH1, TrisolarisHD, Planet6174, partychicken, i-Yirannn

## 欧氏距离

欧氏距离，一般也称作欧几里得距离。在平面直角坐标系中，设点 $A,B$ 的坐标分别为 $A(x_1,y_1),B(x_2,y_2)$ ，则两点间的欧氏距离为：

$$
\left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2}
$$

举个例子，若在平面直角坐标系中，有两点 $A(6,5),B(2,2)$ ，通过公式，我们很容易得到 $A,B$ 两点间的欧氏距离：

$$
\left | AB \right | = \sqrt{\left ( 2 - 6 \right )^2 + \left ( 2 - 5 \right )^2} = \sqrt{4^2+3^2} = 5
$$

除此之外， $P(x,y)$ 到原点的欧氏距离可以用公式表示为：

$$
|P| = \sqrt{x^2+y^2}
$$

那么，三维空间中两点的欧氏距离公式呢？我们来观察下图。

![dis-3-dimensional](./images/distance-0.png)

我们很容易发现，在 $\triangle ADC$ 中， $\angle ADC = 90^\circ$ ；在 $\triangle ACB$ 中， $\angle ACB = 90^\circ$ 。

$$
\begin{aligned}
\therefore ~& |AB| &=& \sqrt{|AC|^2+|BC|^2} \\
&&=& \sqrt{|AD|^2+|CD|^2+|BC|^2}
\end{aligned}
$$

由此可得，三维空间中欧氏距离的距离公式为：

$$
\begin{gathered}
\left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2 + \left ( z_2 - z_1 \right )^2} \\
|P| = \sqrt{x^2+y^2+z^2}
\end{gathered}
$$

 [NOIP2017 提高组 奶酪](https://uoj.ac/problem/332) 就运用了这一知识，可以作为欧氏距离的例题。

以此类推，我们就得到了 $n$ 维空间中欧氏距离的距离公式：对于 $\vec A(x_{11}, x_{12}, \cdots,x_{1n}) ,~ \vec B(x_{21}, x_{22}, \cdots,x_{2n})$ ，有

$$
\begin{aligned}
&\lVert\overrightarrow{AB}\rVert &=& \sqrt{\left ( x_{11} - x_{21} \right )^2 + \left ( x_{12} - x_{22} \right )^2 + \cdot \cdot \cdot +\left ( x_{1n} - x_{2n} \right )^2}\\
&&=& \sqrt{\sum_{i = 1}^{n}(x_{1i} - x_{2i})^2}
\end{aligned}
$$

欧氏距离虽然很有用，但也有明显的缺点。两个整点计算其欧氏距离时，往往答案是浮点型，会存在一定误差。

## 曼哈顿距离

在二维空间内，两个点之间的曼哈顿距离（Manhattan distance）为它们横坐标之差的绝对值与纵坐标之差的绝对值之和。设点 $A(x_1,y_1),B(x_2,y_2)$ ，则 $A,B$ 之间的曼哈顿距离用公式可以表示为：

$$
d(A,B) = |x_1 - x_2| + |y_1 - y_2|
$$

观察下图：

![manhattan-dis-diff](./images/distance-1.png)

在 $A,B$ 间，黄线、橙线都表示曼哈顿距离，而红线、蓝线表示等价的曼哈顿距离，绿线表示欧氏距离。

同样的栗子，在下图中 $A,B$ 的坐标分别为 $A(25,20),B(10,10)$ 。

![manhattan-dis](./images/distance-2.svg)

通过公式，我们很容易得到 $A,B$ 两点间的曼哈顿距离：

$$
d(A,B) = |20 - 10| + |25 - 10| = 10 + 15 = 25
$$

经过推导，我们得到 $n$ 维空间 的曼哈顿距离公式为：

$$
\begin{aligned}
&d(A,B) &=& |x_1 - y_1| + |x_2 - y_2| + \cdot \cdot \cdot + |x_n - y_n|\\
& &=& \sum_{i = 1}^{n}|x_i - y_i|
\end{aligned}
$$

除了公式之外，曼哈顿距离还具有以下数学性质：

-    **非负性** 

    曼哈顿距离是一个非负数。

     $d(i,j)\geq 0$ 

-    **统一性** 

    点到自身的曼哈顿距离为 $0$ 。

     $d(i,i) = 0$ 

-    **对称性** 

     $A$ 到 $B$ 与 $B$ 到 $A$ 的曼哈顿距离相等，且是对称函数。

     $d(i,j) = d(j,i)$ 

-    **三角不等式** 

    从点 $i$ 到 $j$ 的直接距离不会大于途经的任何其它点 $k$ 的距离。

     $d(i,j)\leq d(i,k)+d(k,j)$ 

### 例题 1

 [P5098「USACO04OPEN」Cave Cows 3](https://www.luogu.com.cn/problem/P5098) 

根据题意，对于式子 $|x_1-x_2|+|y_1-y_2|$ ，我们可以假设 $x_1 - x_2 \geq 0$ ，根据 $y_1 - y_2$ 的符号分成两种情况：

-    $(y_1 - y_2 \geq 0)\rightarrow |x_1-x_2|+|y_1-y_2|=x_1 + y_1 - (x_2 + y_2)$ 

-    $(y_1 - y_2 \lt 0)\rightarrow |x_1-x_2|+|y_1-y_2|=x_1 - y_1 - (x_2 - y_2)$ 

只要分别求出 $x+y, x-y$ 的最大值和最小值即能得出答案。

??? 参考代码 1

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    template <class T>
    inline void read(T &x) {
      x = 0;
      char c = getchar();
      bool f = 0;
      for (; !isdigit(c); c = getchar()) f ^= c == '-';
      for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
      x = f ? -x : x;
    }

    int n, x, y, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;

    int main() {
      read(n);
      for (int i = 1; i <= n; i++) {
        read(x), read(y);
        minx = min(minx, x + y), maxx = max(maxx, x + y);
        miny = min(miny, x - y), maxy = max(maxy, x - y);
      }
      printf("%d\n", max(maxx - minx, maxy - miny));
      return 0;
    }
    ```

其实还有第二种做法，那就是把曼哈顿距离转化为切比雪夫距离求解，最后部分会讲到。

## 切比雪夫距离

切比雪夫距离（Chebyshev distance）是向量空间中的一种度量，二个点之间的距离定义是其各坐标数值差绝对值的最大值。——_来源： [切比雪夫距离](https://zh.wikipedia.org/wiki/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB) - 维基百科_

在二维空间内，两个点之间的切比雪夫距离为它们横坐标之差的绝对值与纵坐标之差的绝对值的最大值。设点 $A(x_1,y_1),B(x_2,y_2)$ ，则 $A,B$ 之间的切比雪夫距离用公式可以表示为：

$$
d(A,B) = \max(|x_1 - x_2|, |y_1 - y_2|)
$$

仍然是这个栗子，下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$ 。

![Chebyshev-dis](./images/distance-2.svg)

$$
d(A,B) = \max(|20 - 10|, |25 - 10|) = \max(10, 15) = 15
$$

 $n$ 维空间中切比雪夫距离的距离公式：

$$
\begin{aligned}
&d(x,y) &=& \max\begin{Bmatrix} |x_1 - y_1|,|x_2 - y_2|,\cdot \cdot \cdot,|x_n - y_n|\end{Bmatrix} \\
&&=& \max\begin{Bmatrix} |x_i - y_i|\end{Bmatrix}(i \in [1, n])\end{aligned}
$$

## 曼哈顿距离与切比雪夫距离的相互转化

首先，我们考虑画出平面直角坐标系上所有到原点的曼哈顿距离为 $1$ 的点。

通过公式，我们很容易得到方程 $|x| + |y| = 1$ 。

将绝对值展开，得到 $4$ 个 一次函数，分别是：

$$
\begin{aligned}
&y = x + 1  &(x \geq 0, y \geq 0) \\
&y = -x + 1 &(x \leq 0, y \geq 0) \\
&y = x - 1  &(x \geq 0, y \leq 0)  \\
&y = -x - 1  &(x \leq 0, y \leq 0) \\
\end{aligned}
$$

将这 $4$ 个函数画到平面直角坐标系上，得到一个边长为 $\sqrt{2}$ 的正方形，如下图所示：

![dis-diff-square-1](./images/distance-3.svg)

正方形边界上所有的点到原点的 曼哈顿距离 都是 $1$ 。

同理，我们再考虑画出平面直角坐标系上所有到原点的 切比雪夫距离 为 $1$ 的点。

通过公式，我们知道 $\max(|x|,|y|)=1$ 。

我们将式子展开，也同样可以得到可以得到 $4$ 条 线段，分别是：

$$
\begin{aligned}
&y = 1&(-1\leq x \leq 1) \\
&y = -1&(-1\leq x \leq 1) \\
&x = 1,&(-1\leq y \leq 1) \\
&x = -1,&(-1\leq y \leq 1) \\
\end{aligned}
$$

画到平面直角坐标系上，可以得到一个边长为 $2$ 的正方形，如下图所示：

![dis-diff-square-2](./images/distance-4.svg)

正方形边界上所有的点到原点的切比雪夫距离都是 $1$ 。

将这两幅图对比，我们会神奇地发现：

这 $2$ 个正方形是相似图形。

所以，曼哈顿距离与切比雪夫距离之间会不会有联系呢？

接下来我们简略证明一下：

假设 $A(x_1,y_1),B(x_2,y_2)$ ，

我们把曼哈顿距离中的绝对值拆开，能够得到四个值，这四个值中的最大值是两个非负数之和，即曼哈顿距离。则 $A,B$ 两点的曼哈顿距离为：

$$
\begin{aligned}
d(A,B)&=|x_1 - x_2| + |y_1 - y_2|\\
&=\max\begin{Bmatrix} x_1 - x_2 + y_1 - y_2, x_1 - x_2 + y_2 - y_1,x_2 - x_1 + y_1 - y_2, x_2 - x_1 + y_2 - y_1\end{Bmatrix}\\
&= \max(|(x_1 + y_1) - (x_2 + y_2)|, |(x_1 - y_2) - (x_2 - y_2)|)
\end{aligned}
$$

我们很容易发现，这就是 $(x_1 + y_1,x_1 - y_1), (x_2 + y_2,x_2 - y_2)$ 两点之间的切比雪夫距离。

所以将每一个点 $(x,y)$ 转化为 $(x + y, x - y)$ ，新坐标系下的切比雪夫距离即为原坐标系下的曼哈顿距离。

同理， $A,B$ 两点的切比雪夫距离为：

$$
\begin{aligned}
d(A,B)&=\max\begin{Bmatrix} |x_1 - x_2|,|y_1 - y_2|\end{Bmatrix}\\
&=\max\begin{Bmatrix} \left|\dfrac{x_1 + y_1}{2}-\dfrac{x_2 + y_2}{2}\right|+\left|\dfrac{x_1 - y_1}{2}-\dfrac{x_2 - y_2}{2}\right|\end{Bmatrix}
\end{aligned}
$$

而这就是 $(\dfrac{x_1 + y_1}{2},\dfrac{x_1 - y_1}{2}), (\dfrac{x_2 + y_2}{2},\dfrac{x_2 - y_2}{2})$ 两点之间的曼哈顿距离。

所以将每一个点 $(x,y)$ 转化为 $(\dfrac{x + y}{2},\dfrac{x - y}{2})$ ，新坐标系下的曼哈顿距离即为原坐标系下的切比雪夫距离。

### 结论

-   曼哈顿坐标系是通过切比雪夫坐标系旋转 $45^\circ$ 后，再缩小到原来的一半得到的。
-   将一个点 $(x,y)$ 的坐标变为 $(x + y, x - y)$ 后，
-   原坐标系中的曼哈顿距离等于新坐标系中的切比雪夫距离
-   将一个点 $(x,y)$ 的坐标变为 $(\dfrac{x + y}{2},\dfrac{x - y}{2})$ 后，

原坐标系中的切比雪夫距离等于新坐标系中的曼哈顿距离

碰到求切比雪夫距离或曼哈顿距离的题目时，我们往往可以相互转化来求解。两种距离在不同的题目中有不同的优缺点，应该灵活运用。

### 例题 2

 [P4648「IOI2007」pairs 动物对数](https://www.luogu.com.cn/problem/P4648) （曼哈顿距离转切比雪夫距离）

 [P3964「TJOI2013」松鼠聚会](https://www.luogu.com.cn/problem/P3964) （切比雪夫距离转曼哈顿距离）

最后给出 [P5098「USACO04OPEN」Cave Cows 3](https://www.luogu.com.cn/problem/P5098) 的第二种解法：

我们考虑将题目所求的曼哈顿距离转化为切比雪夫距离，即把每个点的坐标 $(x,y)$ 变为 $(x + y, x - y)$ 。

所求的答案就变为 $\max_{i,j\in n}\begin{Bmatrix} \max\begin{Bmatrix} |x_i - x_j|,|y_i - y_j|\end{Bmatrix}\end{Bmatrix}$ 

现要使得横坐标之差和纵坐标之差最大，只需要预处理出 $x,y$ 的最大值和最小值即可。

??? 参考代码 2

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    template <class T>
    inline void read(T &x) {
      x = 0;
      char c = getchar();
      bool f = 0;
      for (; !isdigit(c); c = getchar()) f ^= c == '-';
      for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
      x = f ? -x : x;
    }

    int n, x, y, a, b, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;

    int main() {
      read(n);
      for (int i = 1; i <= n; i++) {
        read(a), read(b);
        x = a + b, y = a - b;
        minx = min(minx, x), maxx = max(maxx, x);
        miny = min(miny, y), maxy = max(maxy, y);
      }
      printf("%d\n", max(maxx - minx, maxy - miny));
      return 0;
    }
    ```

对比两份代码，我们又能够发现，两种不同的思路，写出来的代码却是完全等价的，是不是很神奇呢？当然，更高深的东西需要大家另行研究。

##  $L_m$ 距离

一般地，我们定义平面上两点 $A(x_1, y_1)$ , $B(x_2, y_2)$ 之间的 $L_m$ 距离为

 $d(L_m) = (|x_1-x_2|^m+|y1-y2|^m)^{\frac{1}{m}}$ 

特殊的， $L_2$ 距离就是欧几里得距离， $L_1$ 距离就是曼哈顿距离。

## 汉明距离

汉明距离是两个字符串之间的距离，它表示两个长度相同的字符串对应位字符不同的数量

我们可以简单的认为对两个串进行异或运算，结果为 1 的数量就是两个串的汉明距离。

部分内容搬运自 [浅谈三种常见的距离算法](https://www.luogu.org/blog/xuxing/Distance-Algorithm) ，感谢作者 xuxing 的授权。

# nearest-points
## 概述

给定 $n$ 个二维平面上的点，求一组欧几里得距离最近的点对。

下面我们介绍一种时间复杂度为 $O(n\log n)$ 的分治算法来解决这个问题。该算法在 1975 年由 [Franco P. Preparata](https://en.wikipedia.org/wiki/Franco_P._Preparata) 提出，Preparata 和 [Michael Ian Shamos](https://en.wikipedia.org/wiki/Michael_Ian_Shamos) 证明了该算法在决策树模型下是最优的。

## 算法

与常规的分治算法一样，我们将这个有 $n$ 个点的集合拆分成两个大小相同的集合 $S_1, S_2$ ，并不断递归下去。但是我们遇到了一个难题：如何合并？即如何求出一个点在 $S_1$ 中，另一个点在 $S_2$ 中的最近点对？这里我们先假设合并操作的时间复杂度为 $O(n)$ ，可知算法总复杂度为 $T(n) = 2T(\frac{n}{2}) + O(n) = O(n\log n)$ 。

我们先将所有点按照 $x_i$ 为第一关键字、 $y_i$ 为第二关键字排序，并以点 $p_m (m = \lfloor \frac{n}{2} \rfloor)$ 为分界点，拆分点集为 $A_1,A_2$ ：

$$
A_1 = \{p_i \ \big | \ i = 0 \ldots m \}\\
A_2 = \{p_i \ \big | \ i = m + 1 \ldots n-1 \}
$$

并递归下去，求出两点集各自内部的最近点对，设距离为 $h_1,h_2$ ，取较小值设为 $h$ 。

现在该合并了！我们试图找到这样的一组点对，其中一个属于 $A_1$ ，另一个属于 $A_2$ ，且二者距离小于 $h$ 。因此我们将所有横坐标与 $x_m$ 的差小于 $h$ 的点放入集合 $B$ ：

$$
B = \{ p_i \ \big | \ \lvert x_i - x_m \rvert < h \}
$$

对于 $B$ 中的每个点 $p_i$ ，我们当前目标是找到一个同样在 $B$ 中、且到其距离小于 $h$ 的点。为了避免两个点之间互相考虑，我们只考虑那些纵坐标小于 $y_i$ 的点。显然对于一个合法的点 $p_j$ ， $y_i - y_j$ 必须小于 $h$ 。于是我们获得了一个集合 $C(p_i)$ ：

$$
C(p_i) = \{ p_j\ \big |\ p_j \in B,\ y_i - h < y_j \le y_i \}
$$

如果我们将 $B$ 中的点按照 $y_i$ 排序， $C(p_i)$ 将很容易得到，即紧邻 $p_i$ 的连续几个点。

由此我们得到了合并的步骤：

1.  构建集合 $B$ 。
2.  将 $B$ 中的点按照 $y_i$ 排序。通常做法是 $O(n\log n)$ ，但是我们可以改变策略优化到 $O(n)$ （下文讲解）。
3.  对于每个 $p_i \in B$ 考虑 $p_j \in C(p_i)$ ，对于每对 $(p_i,p_j)$ 计算距离并更新答案（当前所处集合的最近点对）。

注意到我们上文提到了两次排序，因为点坐标全程不变，第一次排序可以只在分治开始前进行一次。我们令每次递归返回当前点集按 $y_i$ 排序的结果，对于第二次排序，上层直接使用下层的两个分别排序过的点集归并即可。

似乎这个算法仍然不优， $|C(p_i)|$ 将处于 $O(n)$ 数量级，导致总复杂度不对。其实不然，其最大大小为 $7$ ，我们给出它的证明：

## 复杂度证明

我们已经了解到， $C(p_i)$ 中的所有点的纵坐标都在 $(y_i-h,y_i]$ 范围内；且 $C(p_i)$ 中的所有点，和 $p_i$ 本身，横坐标都在 $(x_m-h,x_m+h)$ 范围内。这构成了一个 $2h \times h$ 的矩形。

我们再将这个矩形拆分为两个 $h \times h$ 的正方形，不考虑 $p_i$ ，其中一个正方形中的点为 $C(p_i) \cap A_1$ ，另一个为 $C(p_i) \cap A_2$ ，且两个正方形内的任意两点间距离大于 $h$ 。（因为它们来自同一下层递归）

我们将一个 $h \times h$ 的正方形拆分为四个 $\frac{h}{2} \times \frac{h}{2}$ 的小正方形。可以发现，每个小正方形中最多有 $1$ 个点：因为该小正方形中任意两点最大距离是对角线的长度，即 $\frac{h}{\sqrt 2}$ ，该数小于 $h$ 。

由此，每个正方形中最多有 $4$ 个点，矩形中最多有 $8$ 个点，去掉 $p_i$ 本身， $\max(C(p_i))=7$ 。

## 实现

我们使用一个结构体来存储点，并定义用于排序的函数对象：

```cpp
struct pt {
  int x, y, id;
};

struct cmp_x {
  bool operator()(const pt& a, const pt& b) const {
    return a.x < b.x || (a.x == b.x && a.y < b.y);
  }
};

struct cmp_y {
  bool operator()(const pt& a, const pt& b) const { return a.y < b.y; }
};

int n;
vector<pt> a;
```

为了方便实现递归，我们引入 `upd_ans()` 辅助函数来计算两点间距离并尝试更新答案：

```cpp
double mindist;
int ansa, ansb;

inline void upd_ans(const pt& a, const pt& b) {
  double dist =
      sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + .0);
  if (dist < mindist) mindist = dist, ansa = a.id, ansb = b.id;
}
```

下面是递归本身：假设在调用前 `a[]` 已按 $x_i$ 排序。如果 $r-l$ 过小，使用暴力算法计算 $h$ ，终止递归。

我们使用 `std::merge()` 来执行归并排序，并创建辅助缓冲区 `t[]` ， $B$ 存储在其中。

```cpp
void rec(int l, int r) {
  if (r - l <= 3) {
    for (int i = l; i <= r; ++i)
      for (int j = i + 1; j <= r; ++j) upd_ans(a[i], a[j]);
    sort(a + l, a + r + 1, &cmp_y);
    return;
  }

  int m = (l + r) >> 1;
  int midx = a[m].x;
  rec(l, m), rec(m + 1, r);
  static pt t[MAXN];
  merge(a + l, a + m + 1, a + m + 1, a + r + 1, t, &cmp_y);
  copy(t, t + r - l + 1, a + l);

  int tsz = 0;
  for (int i = l; i <= r; ++i)
    if (abs(a[i].x - midx) < mindist) {
      for (int j = tsz - 1; j >= 0 && a[i].y - t[j].y < mindist; --j)
        upd_ans(a[i], t[j]);
      t[tsz++] = a[i];
    }
}
```

在主函数中，这样开始递归即可：

```cpp
sort(a, a + n, &cmp_x);
mindist = 1E20;
rec(0, n - 1);
```

## 推广：平面最小周长三角形

上述算法有趣地推广到这个问题：在给定的一组点中，选择三个点，使得它们两两的距离之和最小。

算法大体保持不变，每次尝试找到一个比当前答案周长 $d$ 更小的三角形，将所有横坐标与 $x_m$ 的差小于 $\frac{d}{2}$ 的点放入集合 $B$ ，尝试更新答案。（周长为 $d$ 的三角形的最长边小于 $\frac{d}{2}$ ）

## 非分治算法

其实，除了上面提到的分治算法，还有另一种时间复杂度同样是 $O(n \log n)$ 的非分治算法。

我们可以考虑一种常见的统计序列的思想：对于每一个元素，将它和它的左边所有元素的贡献加入到答案中。平面最近点对问题同样可以使用这种思想。

具体地，我们把所有点按照 $x_i$ 为第一关键字、 $y_i$ 为第二关键字排序，并建立一个以 $y_i$ 为第一关键字、 $x_i$ 为第二关键字排序的 multiset。对于每一个位置 $i$ ，我们执行以下操作：

1.  将所有满足 $x_i - x_j >= d$ 的点从集合中删除。它们不会再对答案有贡献。
2.  对于集合内满足 $\lvert y_i - y_j \rvert < d$ 的所有点，统计它们和 $p_i$ 的距离。
3.  将 $p_i$ 插入到集合中。

由于每个点最多会被插入和删除一次，所以插入和删除点的时间复杂度为 $O(n \log n)$ ，而统计答案部分的时间复杂度证明与分治算法的时间复杂度证明方法类似，读者不妨一试。

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    #include <set>
    const int N = 200005;
    int n;
    double ans = 1e20;
    struct point {
      double x, y;
      point(double x = 0, double y = 0) : x(x), y(y) {}
    };
    
    struct cmp_x {
      bool operator()(const point &a, const point &b) const {
        return a.x < b.x || (a.x == b.x && a.y < b.y);
      }
    };
    
    struct cmp_y {
      bool operator()(const point &a, const point &b) const { return a.y < b.y; }
    };
    
    inline void upd_ans(const point &a, const point &b) {
      double dist = sqrt(pow((a.x - b.x), 2) + pow((a.y - b.y), 2));
      if (ans > dist) ans = dist;
    }
    
    point a[N];
    std::multiset<point, cmp_y> s;
    
    int main() {
      scanf("%d", &n);
      for (int i = 0; i < n; i++) scanf("%lf%lf", &a[i].x, &a[i].y);
      std::sort(a, a + n, cmp_x());
      for (int i = 0, l = 0; i < n; i++) {
        while (l < i && a[i].x - a[l].x >= ans) s.erase(s.find(a[l++]));
        for (auto it = s.lower_bound(point(a[i].x, a[i].y - ans));
             it != s.end() && it->y - a[i].y < ans; it++)
          upd_ans(*it, a[i]);
        s.insert(a[i]);
      }
      printf("%.4lf", ans);
      return 0;
    }
    ```

## 习题

-    [UVA 10245 "The Closest Pair Problem"\[难度：低\]](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1186) 
-    [SPOJ #8725 CLOPPAIR "Closest Point Pair"\[难度：低\]](https://www.spoj.com/problems/CLOPPAIR/) 
-    [CODEFORCES Team Olympiad Saratov - 2011 "Minimum amount"\[难度：中\]](http://codeforces.com/contest/120/problem/J) 
-    [Google CodeJam 2009 Final "Min Perimeter"\[难度：中\]](https://code.google.com/codejam/contest/311101/dashboard#s=a&a=1) 
-    [SPOJ #7029 CLOSEST "Closest Triple"\[难度：中\]](https://www.spoj.com/problems/CLOSEST/) 

* * *

## References

 **本页面中的分治算法部分主要译自博文 [Нахождение пары ближайших точек](http://e-maxx.ru/algo/nearest_points) 与其英文翻译版 [Finding the nearest pair of points](https://github.com/e-maxx-eng/e-maxx-eng/blob/master/src/geometry/nearest_points.md) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

 [知乎专栏：计算几何 - 最近点对问题](https://zhuanlan.zhihu.com/p/74905629) 

# convex-hull
## 二维凸包

### 凸多边形

凸多边形是指所有内角大小都在 $[0,\pi]$ 范围内的 **简单多边形** 。

### 凸包

在平面上能包含所有给定点的最小凸多边形叫做凸包。

其定义为：

> 对于给定集合 $X$ ，所有包含 $X$ 的凸集的交集 $S$ 被称为 $X$ 的 **凸包** 。

实际上可以理解为用一个橡皮筋包含住所有给定点的形态。

凸包用最小的周长围住了给定的所有点。如果一个凹多边形围住了所有的点，它的周长一定不是最小，如下图。根据三角不等式，凸多边形在周长上一定是最优的。

/home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/ch.png)

### 凸包的求法

常用的求法有 Graham 扫描法和 Andrew 算法，这里主要介绍 Andrew 算法。

#### Andrew 算法求凸包

首先把所有点以横坐标为第一关键字，纵坐标为第二关键字排序。

显然排序后最小的元素和最大的元素一定在凸包上。而且因为是凸多边形，我们如果从一个点出发逆时针走，轨迹总是“左拐”的，一旦出现右拐，就说明这一段不在凸包上。因此我们可以用一个单调栈来维护上下凸壳。

因为从左向右看，上下凸壳所旋转的方向不同，为了让单调栈起作用，我们首先 **升序枚举** 求出下凸壳，然后 **降序** 求出上凸壳。

求凸壳时，一旦发现即将进栈的点（ $P$ ）和栈顶的两个点（ $S_1,S_2$ ，其中 $S_1$ 为栈顶）行进的方向向右旋转，即叉积小于 $0$ ： $\overrightarrow{S_2S_1}\times \overrightarrow{S_1P}<0$ ，则弹出栈顶，回到上一步，继续检测，直到 $\overrightarrow{S_2S_1}\times \overrightarrow{S_1P}\ge 0$ 或者栈内仅剩一个元素为止。

通常情况下不需要保留位于凸包边上的点，因此上面一段中 $\overrightarrow{S_2S_1}\times \overrightarrow{S_1P}<0$ 这个条件中的“ $<$ ”可以视情况改为 $\le$ ，同时后面一个条件应改为 $>$ 。

##### 代码实现

```cpp
// stk[]是整型，存的是下标
// p[]存储向量或点
tp = 0;                       //初始化栈
std::sort(p + 1, p + 1 + n);  //对点进行排序
stk[++tp] = 1;
//栈内添加第一个元素，且不更新used，使得1在最后封闭凸包时也对单调栈更新
for (int i = 2; i <= n; ++i) {
  while (tp >= 2  //下一行*被重载为叉积
         && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)
    used[stk[tp--]] = 0;
  used[i] = 1;  // used表示在凸壳上
  stk[++tp] = i;
}
int tmp = tp;  // tmp表示下凸壳大小
for (int i = n - 1; i > 0; --i)
  if (/home/llj/Desktop/OI-wiki-master/docs/geometry/!used[i]) {
    //      ↓求上凸壳时不影响下凸壳
    while (tp > tmp && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)
      used[stk[tp--]] = 0;
    used[i] = 1;
    stk[++tp] = i;
  }
for (int i = 1; i <= tp; ++i)  //复制到新数组中去
  h[i] = p[stk[i]];
int ans = tp - 1;
```

根据上面的代码，最后凸包上有 $ans$ 个元素（额外存储了 $1$ 号点，因此 $h$ 数组中有 $ans+1$ 个元素），并且按逆时针方向排序。周长就是

$$
\sum_{i=1}^{ans}\left|\overrightarrow{h_ih_{i+1}}\right|
$$

### 例题

 [UVA11626 Convex Hull](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=78&page=show_problem&problem=2673) 

 [「USACO5.1」圈奶牛 Fencing the Cows](https://www.luogu.org/problemnew/show/P2742) 

 [POJ1873 The Fortified Forest](http://poj.org/problem?id=1873) 

 [POJ1113 Wall](http://poj.org/problem?id=1113) 

 [「SHOI2012」信用卡凸包](https://www.luogu.org/problemnew/show/P3829) 

# triangulation
author: xehoth

在几何中，三角剖分是指将平面对象细分为三角形，并且通过扩展将高维几何对象细分为单纯形。
对于一个给定的点集，有很多种三角剖分，如：

![三种三角剖分](./images/triangulation-0.svg)

OI 中的三角剖分主要指二维几何中的完美三角剖分（二维 Delaunay 三角剖分，简称 DT）。

## Delaunay 三角剖分

### 定义

在数学和计算几何中，对于给定的平面中的离散点集 $P$ ，其 Delaunay 三角剖分 DT( $P$ ) 满足：

1.  空圆性：DT( $P$ ) 是 **唯一** 的（任意四点不能共圆），在 DT( $P$ ) 中， **任意** 三角形的外接圆范围内不会有其它点存在。
2.  最大化最小角：在点集 $P$ 可能形成的三角剖分中，DT( $P$ ) 所形成的三角形的最小角最大。从这个意义上讲，DT( $P$ ) 是 **最接近于规则化** 的三角剖分。具体的说是在两个相邻的三角形构成凸四边形的对角线，在相互交换后，两个内角的最小角不再增大。

![一个显示了外接圆的 Delaunay 三角剖分](./images/triangulation-1.png)

### 性质

1.  最接近：以最接近的三点形成三角形，且各线段（三角形的边）皆不相交。
2.  唯一性：不论从区域何处开始构建，最终都将得到一致的结果（点集中任意四点不能共圆）。
3.  最优性：任意两个相邻三角形构成的凸四边形的对角线如果可以互换的话，那么两个三角形六个内角中最小角度不会变化。
4.  最规则：如果将三角剖分中的每个三角形的最小角进行升序排列，则 Delaunay 三角剖分的排列得到的数值最大。
5.  区域性：新增、删除、移动某一个顶点只会影响邻近的三角形。
6.  具有凸边形的外壳：三角剖分最外层的边界形成一个凸多边形的外壳。

## 构造 DT 的分治算法

DT 有很多种构造算法，在 $O(n \log n)$ 的构造算法中，分治算法是最易于理解和实现的。

分治构造 DT 的第一步是将给定点集按照 $x$ 坐标 **升序** 排列，如下图是排好序的大小为 $10$ 的点集。

![排好序的大小为 $10$ 的点集](./images/triangulation-2.svg)

一旦点集有序，我们就可以不断地将其分成两个部分（分治），直到子点集大小不超过 $3$ 。然后这些子点集可以立刻剖分为一个三角形或线段。

![分治为包含 2 或 3 个点的点集](./images/triangulation-3.svg)

然后在分治回溯的过程中，已经剖分好的左右子点集可以依次合并。合并后的剖分包含 LL-edge（左侧子点集的边）。RR-edge（右侧子点集的边），LR-edge（连接左右剖分产生的新的边），如图 LL-edge（灰色），RR-edge（红色），LR-edge（蓝色）。对于合并后的剖分，为了维持 DT 性质，我们 **可能** 需要删除部分 LL-edge 和 RR-edge，但我们在合并时 **不会** 增加 LL-edge 和 RR-edge。

![edge](./images/triangulation-4.svg)

合并左右两个剖分的第一步是插入 base LR-edge，base LR-edge 是 **最底部** 的不与 **任何** LL-edge 及 RR-edge 相交的 LR-edge。

![合并左右剖分](./images/triangulation-5.svg)

然后，我们需要确定下一条 **紧接在** base LR-edge 之上的 LR-edge。比如对于右侧点集，下一条 LR-edge 的可能端点（右端点）为与 base LR-edge 右端点相连的 RR-edge 的另一端点（ $6, 7, 9$ 号点），左端点即为 $2$ 号点。

![下一条 LR-edge](./images/triangulation-6.svg)

对于可能的端点，我们需要按以下两个标准检验：

1.  其对应 RR-edge 与 base LR-edge 的夹角小于 $180$ 度。
2.  base LR-edge 两端点和这个可能点三点构成的圆内不包含任何其它 **可能点** 。

![检验可能点](./images/triangulation-7.svg)

如上图， $6$ 号可能点所对应的绿色圆包含了 $9$ 号可能点，而 $7$ 号可能点对应的紫色圆则不包含任何其它可能点，故 $7$ 号点为下一条 LR-edge 的右端点。

对于左侧点集，我们做镜像处理即可。

![检验左侧可能点](./images/triangulation-8.svg)

当左右点集都不再含有符合标准的可能点时，合并即完成。当一个可能点符合标准，一条 LR-edge 就需要被添加，对于与需要添加的 LR-edge 相交的 LL-edge 和 RR-edge，将其删除。

当左右点集均存在可能点时，判断左边点所对应圆是否包含右边点，若包含则不符合；对于右边点也是同样的判断。一般只有一个可能点符合标准（除非四点共圆）。

![下一条 LR-edge](./images/triangulation-9.svg)

当这条 LR-edge 添加好后，将其作为 base LR-edge 重复以上步骤，继续添加下一条，直到合并完成。

![合并](./images/triangulation-10.svg)

## 代码

```cpp
#include <algorithm>
#include <cmath>
#include <cstring>
#include <list>
#include <utility>
#include <vector>

const double EPS = 1e-8;
const int MAXV = 10000;

struct Point {
  double x, y;
  int id;

  Point(double a = 0, double b = 0, int c = -1) : x(a), y(b), id(c) {}

  bool operator<(const Point &a) const {
    return x < a.x || (fabs(x - a.x) < EPS && y < a.y);
  }

  bool operator==(const Point &a) const {
    return fabs(x - a.x) < EPS && fabs(y - a.y) < EPS;
  }

  double dist2(const Point &b) {
    return (x - b.x) * (x - b.x) + (y - b.y) * (y - b.y);
  }
};

struct Point3D {
  double x, y, z;

  Point3D(double a = 0, double b = 0, double c = 0) : x(a), y(b), z(c) {}

  Point3D(const Point &p) { x = p.x, y = p.y, z = p.x * p.x + p.y * p.y; }

  Point3D operator-(const Point3D &a) const {
    return Point3D(x - a.x, y - a.y, z - a.z);
  }

  double dot(const Point3D &a) { return x * a.x + y * a.y + z * a.z; }
};

struct Edge {
  int id;
  std::list<Edge>::iterator c;
  Edge(int id = 0) { this->id = id; }
};

int cmp(double v) { return fabs(v) > EPS ? (v > 0 ? 1 : -1) : 0; }

double cross(const Point &o, const Point &a, const Point &b) {
  return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
}

Point3D cross(const Point3D &a, const Point3D &b) {
  return Point3D(a.y * b.z - a.z * b.y, -a.x * b.z + a.z * b.x,
                 a.x * b.y - a.y * b.x);
}

int inCircle(const Point &a, Point b, Point c, const Point &p) {
  if (cross(a, b, c) < 0) std::swap(b, c);
  Point3D a3(a), b3(b), c3(c), p3(p);
  b3 = b3 - a3, c3 = c3 - a3, p3 = p3 - a3;
  Point3D f = cross(b3, c3);
  return cmp(p3.dot(f));  // check same direction, in: < 0, on: = 0, out: > 0
}

int intersection(const Point &a, const Point &b, const Point &c,
                 const Point &d) {  // seg(a, b) and seg(c, d)
  return cmp(cross(a, c, b)) * cmp(cross(a, b, d)) > 0 &&
         cmp(cross(c, a, d)) * cmp(cross(c, d, b)) > 0;
}

class Delaunay {
 public:
  std::list<Edge> head[MAXV];  // graph
  Point p[MAXV];
  int n, rename[MAXV];

  void init(int n, Point p[]) {
    memcpy(this->p, p, sizeof(Point) * n);
    std::sort(this->p, this->p + n);
    for (int i = 0; i < n; i++) rename[p[i].id] = i;
    this->n = n;
    divide(0, n - 1);
  }

  void addEdge(int u, int v) {
    head[u].push_front(Edge(v));
    head[v].push_front(Edge(u));
    head[u].begin()->c = head[v].begin();
    head[v].begin()->c = head[u].begin();
  }

  void divide(int l, int r) {
    if (r - l <= 2) {  // #point <= 3
      for (int i = l; i <= r; i++)
        for (int j = i + 1; j <= r; j++) addEdge(i, j);
      return;
    }
    int mid = (l + r) / 2;
    divide(l, mid);
    divide(mid + 1, r);

    std::list<Edge>::iterator it;
    int nowl = l, nowr = r;

    for (int update = 1; update;) {
      // find left and right convex, lower common tangent
      update = 0;
      Point ptL = p[nowl], ptR = p[nowr];
      for (it = head[nowl].begin(); it != head[nowl].end(); it++) {
        Point t = p[it->id];
        double v = cross(ptR, ptL, t);
        if (cmp(v) > 0 || (cmp(v) == 0 && ptR.dist2(t) < ptR.dist2(ptL))) {
          nowl = it->id, update = 1;
          break;
        }
      }
      if (update) continue;
      for (it = head[nowr].begin(); it != head[nowr].end(); it++) {
        Point t = p[it->id];
        double v = cross(ptL, ptR, t);
        if (cmp(v) < 0 || (cmp(v) == 0 && ptL.dist2(t) < ptL.dist2(ptR))) {
          nowr = it->id, update = 1;
          break;
        }
      }
    }

    addEdge(nowl, nowr);  // add tangent

    for (int update = 1; true;) {
      update = 0;
      Point ptL = p[nowl], ptR = p[nowr];
      int ch = -1, side = 0;
      for (it = head[nowl].begin(); it != head[nowl].end(); it++) {
        if (cmp(cross(ptL, ptR, p[it->id])) > 0 &&
            (ch == -1 || inCircle(ptL, ptR, p[ch], p[it->id]) < 0)) {
          ch = it->id, side = -1;
        }
      }
      for (it = head[nowr].begin(); it != head[nowr].end(); it++) {
        if (cmp(cross(ptR, p[it->id], ptL)) > 0 &&
            (ch == -1 || inCircle(ptL, ptR, p[ch], p[it->id]) < 0)) {
          ch = it->id, side = 1;
        }
      }
      if (ch == -1) break;  // upper common tangent
      if (side == -1) {
        for (it = head[nowl].begin(); it != head[nowl].end();) {
          if (intersection(ptL, p[it->id], ptR, p[ch])) {
            head[it->id].erase(it->c);
            head[nowl].erase(it++);
          } else {
            it++;
          }
        }
        nowl = ch;
        addEdge(nowl, nowr);
      } else {
        for (it = head[nowr].begin(); it != head[nowr].end();) {
          if (intersection(ptR, p[it->id], ptL, p[ch])) {
            head[it->id].erase(it->c);
            head[nowr].erase(it++);
          } else {
            it++;
          }
        }
        nowr = ch;
        addEdge(nowl, nowr);
      }
    }
  }

  std::vector<std::pair<int, int> > getEdge() {
    std::vector<std::pair<int, int> > ret;
    ret.reserve(n);
    std::list<Edge>::iterator it;
    for (int i = 0; i < n; i++) {
      for (it = head[i].begin(); it != head[i].end(); it++) {
        if (it->id < i) continue;
        ret.push_back(std::make_pair(p[i].id, p[it->id].id));
      }
    }
    return ret;
  }
};
```

## Voronoi 图

Voronoi 图由一组由连接两邻点直线的垂直平分线组成的连续多边形组成，根据 $n$ 个在平面上不重合种子点，把平面分成 $n$ 个区域，使得每个区域内的点到它所在区域的种子点的距离比到其它区域种子点的距离近。

Voronoi 图是 Delaunay 三角剖分的对偶图，可以使用构造 Delaunay 三角剖分的分治算法求出三角网，再使用最左转线算法求出其对偶图实现在 $O(n \log n)$ 的时间复杂度下构造 Voronoi 图。

## 题目

 [SGU 383 Caravans](https://codeforces.com/problemsets/acmsguru/problem/99999/383) 三角剖分 + 倍增

 [CodeVS 2819. 无尽的毁灭](http://www.joyoi.cn/problem/codevs-2819) 三角剖分求对偶图建 Voronoi 图

## References

-   [1][Wikipedia - Triangulation (geometry)]( <https://en.wikipedia.org/wiki/Triangulation_(geometry)> )
-   [2][Wikipedia - Delaunay triangulation]( <https://en.wikipedia.org/wiki/Delaunay_triangulation> )
-   [3]Samuel Peterson - [Computing Constrained Delaunay Triangulations in 2-D (1997-98)](http://www.geom.uiuc.edu/~samuelp/del_project.html) 

# inverse
author: hyp1231

反演变换适用于题目中存在多个圆/直线之间的相切关系的情况。利用反演变换的性质，在反演空间求解问题，可以大幅简化计算。

## 定义

给定反演中心点 $O$ 和反演半径 $R$ 。若平面上点 $P$ 和 $P'$ 满足：

-   点 $P'$ 在射线 $\overrightarrow{OP}$ 上
-    $|OP| \cdot |OP'| = R^2$ 

则称点 $P$ 和点 $P'$ 互为反演点。

下图所示即为平面上一点 $P$ 的反演：

![Inv1](./images/inverse1.png)

## 性质

1.  圆 $O$ 外的点的反演点在圆 $O$ 内，反之亦然；圆 $O$ 上的点的反演点为其自身。

2.  不过点 $O$ 的圆 $A$ ，其反演图形也是不过点 $O$ 的圆。

    ![Inv2](./images/inverse2.png)

    -   记圆 $A$ 半径为 $r_1$ ，其反演图形圆 $B$ 半径为 $r_2$ ，则有：

        $$
        r_2 = \frac{1}{2}\left(\frac{1}{|OA| - r_1} - \frac{1}{|OA| + r_1}\right) R^2
        $$

         **证明：** 

        ![Inv3](./images/inverse3.png)

        根据反演变换定义：

        $$
        |OC|\cdot|OC'| = (|OA|+r_1)\cdot(|OB|-r_2) = R^2 \\ 
        |OD|\cdot|OD'| = (|OA|-r_1)\cdot(|OB|+r_2) = R^2
        $$

        消掉 $|OB|$ ，解方程即可。

    -   记点 $O$ 坐标为 $(x_0, y_0)$ ，点 $A$ 坐标为 $x_1, y_1$ ，点 $B$ 坐标为 $x_2, y_2$ ，则有：

        $$
        x_2 = x_0 + \frac{|OB|}{|OA|} (x_1 - x_0) \\ 
        y_2 = y_0 + \frac{|OB|}{|OA|} (y_1 - y_0)
        $$

        其中 $|OB|$ 可在上述求 $r_2$ 的过程中计算得到。

3.  过点 $O$ 的圆 $A$ ，其反演图形是不过点 $O$ 的直线。

    ??? note
        为什么是一条直线呢？因为圆 $A$ 上无限接近点 $O$ 的一点，其反演点离点 $O$ 无限远。

    ![Inv4](./images/inverse4.png)

4.  两个图形相切，则他们的反演图形也相切。

## 例题

###  [「ICPC 2013 杭州赛区」Problem of Apollonius](https://vjudge.net/problem/HDU-4773) 

#### 题目大意

求过两圆外一点，且与两圆相切的所有的圆。

#### 解法

首先考虑解析几何解法，似乎很难求解。

考虑以需要经过的点为反演中心进行反演（反演半径任意），所求的圆的反演图形是一条直线（应用性质 $3$ ），且与题目给出两圆的反演图形（性质 $2$ ）相切（性质 $4$ ）。

于是题目经过反演变换后转变为：求两圆的所有公切线。

求出公切线后，反演回原平面即可。

??? note "示例代码"
    ```cpp
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    #include <vector>
    using namespace std;
    
    const double EPS = 1e-8;       //精度系数
    const double PI = acos(-1.0);  //π
    const int N = 4;
    
    struct Point {
      double x, y;
      Point(double x = 0, double y = 0) : x(x), y(y) {}
      const bool operator<(Point A) const { return x == A.x ? y < A.y : x < A.x; }
    };  //点的定义
    
    typedef Point Vector;  //向量的定义
    
    Vector operator+(Vector A, Vector B) {
      return Vector(A.x + B.x, A.y + B.y);
    }  //向量加法
    Vector operator-(Vector A, Vector B) {
      return Vector(A.x - B.x, A.y - B.y);
    }  //向量减法
    Vector operator*(Vector A, double p) {
      return Vector(A.x * p, A.y * p);
    }  //向量数乘
    Vector operator/(Vector A, double p) {
      return Vector(A.x / p, A.y / p);
    }  //向量数除
    
    int dcmp(double x) {
      if (fabs(x) < EPS)
        return 0;
      else
        return x < 0 ? -1 : 1;
    }  //与0的关系
    
    double Dot(Vector A, Vector B) { return A.x * B.x + A.y * B.y; }  //向量点乘
    double Length(Vector A) { return sqrt(Dot(A, A)); }               //向量长度
    double Cross(Vector A, Vector B) { return A.x * B.y - A.y * B.x; }  //向量叉乘
    
    Point GetLineProjection(Point P, Point A, Point B) {
      Vector v = B - A;
      return A + v * (Dot(v, P - A) / Dot(v, v));
    }  //点在直线上投影
    
    struct Circle {
      Point c;
      double r;
      Circle() : c(Point(0, 0)), r(0) {}
      Circle(Point c, double r = 0) : c(c), r(r) {}
      Point point(double a) {
        return Point(c.x + cos(a) * r, c.y + sin(a) * r);
      }  //输入极角返回点坐标
    };   //圆
    
    // a[i] 和 b[i] 分别是第i条切线在圆A和圆B上的切点
    int getTangents(Circle A, Circle B, Point* a, Point* b) {
      int cnt = 0;
      if (A.r < B.r) {
        swap(A, B);
        swap(a, b);
      }
      double d2 =
          (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y);
      double rdiff = A.r - B.r;
      double rsum = A.r + B.r;
      if (dcmp(d2 - rdiff * rdiff) < 0) return 0;  //内含
    
      double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x);
      if (dcmp(d2) == 0 && dcmp(A.r - B.r) == 0) return -1;  //无限多条切线
      if (dcmp(d2 - rdiff * rdiff) == 0) {                   //内切，一条切线
        a[cnt] = A.point(base);
        b[cnt] = B.point(base);
        ++cnt;
        return 1;
      }
      //有外公切线
      double ang = acos(rdiff / sqrt(d2));
      a[cnt] = A.point(base + ang);
      b[cnt] = B.point(base + ang);
      ++cnt;
      a[cnt] = A.point(base - ang);
      b[cnt] = B.point(base - ang);
      ++cnt;
      if (dcmp(d2 - rsum * rsum) == 0) {  //一条内公切线
        a[cnt] = A.point(base);
        b[cnt] = B.point(PI + base);
        ++cnt;
      } else if (dcmp(d2 - rsum * rsum) > 0) {  //两条内公切线
        double ang = acos(rsum / sqrt(d2));
        a[cnt] = A.point(base + ang);
        b[cnt] = B.point(PI + base + ang);
        ++cnt;
        a[cnt] = A.point(base - ang);
        b[cnt] = B.point(PI + base - ang);
        ++cnt;
      }
      return cnt;
    }  // 两圆公切线 返回切线的条数，-1表示无穷多条切线
    
    Circle Inversion_C2C(Point O, double R, Circle A) {
      double OA = Length(A.c - O);
      double RB = 0.5 * ((1 / (OA - A.r)) - (1 / (OA + A.r))) * R * R;
      double OB = OA * RB / A.r;
      double Bx = O.x + (A.c.x - O.x) * OB / OA;
      double By = O.y + (A.c.y - O.y) * OB / OA;
      return Circle(Point(Bx, By), RB);
    }  // 点 O 在圆 A 外，求圆 A 的反演圆 B，R 是反演半径
    
    Circle Inversion_L2C(Point O, double R, Point A, Vector v) {
      Point P = GetLineProjection(O, A, A + v);
      double d = Length(O - P);
      double RB = R * R / (2 * d);
      Vector VB = (P - O) / d * RB;
      return Circle(O + VB, RB);
    }  // 直线反演为过 O 点的圆 B，R 是反演半径
    
    bool theSameSideOfLine(Point A, Point B, Point S, Vector v) {
      return dcmp(Cross(A - S, v)) * dcmp(Cross(B - S, v)) > 0;
    }  // 返回 true 如果 A B 两点在直线同侧
    
    int main() {
      int T;
      scanf("%d", &T);
      while (T--) {
        Circle A, B;
        Point P;
        scanf("%lf%lf%lf", &A.c.x, &A.c.y, &A.r);
        scanf("%lf%lf%lf", &B.c.x, &B.c.y, &B.r);
        scanf("%lf%lf", &P.x, &P.y);
        Circle NA = Inversion_C2C(P, 10, A);
        Circle NB = Inversion_C2C(P, 10, B);
        Point LA[N], LB[N];
        Circle ansC[N];
        int q = getTangents(NA, NB, LA, LB), ans = 0;
        for (int i = 0; i < q; ++i)
          if (theSameSideOfLine(NA.c, NB.c, LA[i], LB[i] - LA[i])) {
            if (!theSameSideOfLine(P, NA.c, LA[i], LB[i] - LA[i])) continue;
            ansC[ans++] = Inversion_L2C(P, 10, LA[i], LB[i] - LA[i]);
          }
        printf("%d\n", ans);
        for (int i = 0; i < ans; ++i) {
          printf("%.8f %.8f %.8f\n", ansC[i].c.x, ansC[i].c.y, ansC[i].r);
        }
      }
    
      return 0;
    }
    ```

## 练习

 [「ICPC 2017 南宁赛区网络赛」Finding the Radius for an Inserted Circle](https://nanti.jisuanke.com/t/A1283) 

 [「CCPC 2017 网络赛」The Designer](https://vjudge.net/problem/HDU-6158) 

## References

-    [Inversive geometry - Wikipedia](https://en.wikipedia.org/wiki/Inversive_geometry) 

-    [圆的反演变换 - ACdreamers 的博客](https://blog.csdn.net/acdreamers/article/details/16966369) 

# pick
## Pick 定理

Pick 定理：给定顶点坐标均是整点（或正方形格子点）的简单多边形，皮克定理说明了其面积 ${\displaystyle A}$ 和内部格点数目 ${\displaystyle i}$ 、边上格点数目 ${\displaystyle b}$ 的关系： ${\displaystyle A=i+{\frac {b}{2}}-1}$ 。

具体证明： [Pick's theorem](https://en.wikipedia.org/wiki/Pick%27s_theorem) 

它有以下推广：

-   取格点的组成图形的面积为一单位。在平行四边形格点，皮克定理依然成立。套用于任意三角形格点，皮克定理则是 ${\displaystyle A=2 \times i+b-2}$ 。
-   对于非简单的多边形 ${\displaystyle P}$ ，皮克定理 ${\displaystyle A=i+{\frac {b}{2}}-\chi (P)}$ ，其中 ${\displaystyle \chi (P)}$ 表示 ${\displaystyle P}$ 的 **欧拉特征数** 。
-   高维推广：Ehrhart 多项式
-   皮克定理和 **欧拉公式** （ ${\displaystyle V-E+F=2}$ ）等价。

## 一道例题 (POJ 1265)

### 题目大意

给一个平面上的简单多边形，求边上的点，多边形内的点，多边形面积。

### Solution

这道题目其实用了以下三个知识：

-   以格子点为顶点的线段，覆盖的点的个数为 $\gcd(dx,dy)$ ，其中， $dx,dy$ 分别为线段横向占的点数和纵向占的点数。如果 $dx$ 或 $dy$ 为 $0$ ，则覆盖的点数为 $dy$  **或**  $dx$ 。
-   Pick 定理：平面上以格子点为顶点的简单多边形的面积 = 边上的点数/2 + 内部的点数 + 1。
-   任意一个多边形的面积等于按顺序求相邻两个点与原点组成的向量的叉积之和（这个也可以通过顺时针定积分求得）。
     于是这题就愉快地做完了

```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
const int MAXN = 110;
struct node {
  int x, y;
} p[MAXN];
inline int gcd(int x, int y) { return y == 0 ? x : gcd(y, x % y); }
inline int area(int a, int b) { return p[a].x * p[b].y - p[a].y * p[b].x; }
int main() {
  int t, ncase = 1;
  scanf("%d", &t);
  while (t--) {
    int n, dx, dy, x, y, num = 0, sum = 0;
    scanf("%d", &n);
    p[0].x = 0, p[0].y = 0;
    for (int i = 1; i <= n; i++) {
      scanf("%d%d", &x, &y);
      p[i].x = x + p[i - 1].x, p[i].y = y + p[i - 1].y;
      dx = x, dy = y;
      if (x < 0) dx = -x;
      if (y < 0) dy = -y;
      num += gcd(dx, dy);
      sum += area(i - 1, i);
    }
    if (sum < 0) sum = -sum;
    printf("Scenario #%d:\n", ncase++);
    printf("%d %d %.1f\n\n", (sum - num + 2) >> 1, num, sum * 0.5);
  }
  return 0;
}
```

# rotating-calipers


# misc
author: Ir1d

# index
利用计算机建立数学模型解决几何问题。

# random-incremental
author: Ir1d

## 简介

随机增量算法是计算几何的一个重要算法，它对理论知识要求不高，算法时间复杂度低，应用范围广大。

增量法 (Incremental Algorithm) 的思想与第一数学归纳法类似，它的本质是将一个问题化为规模刚好小一层的子问题。解决子问题后加入当前的对象。写成递归式是：

$$
T(n)=T(n-1)+g(n)
$$

增量法形式简洁，可以应用于许多的几何题目中。

增量法往往结合随机化，可以避免最坏情况的出现。

## 最小圆覆盖问题

### 题意描述

在一个平面上有 $n$ 个点，求一个半径最小的圆，能覆盖所有的点。

### 算法

假设圆 $O$ 是前 $i-1$ 个点得最小覆盖圆，加入第 $i$ 个点，如果在圆内或边上则什么也不做。否，新得到的最小覆盖圆肯定经过第 $i$ 个点。

然后以第 $i$ 个点为基础（半径为 $0$ ），重复以上过程依次加入第 $j$ 个点，若第 $j$ 个点在圆外，则最小覆盖圆必经过第 $j$ 个点。

重复以上步骤。（因为最多需要三个点来确定这个最小覆盖圆，所以重复三次）

遍历完所有点之后，所得到的圆就是覆盖所有点得最小圆。

 **时间复杂度**  $O(n)$ 

 **空间复杂度**  $O(n)$ 

### 代码

```cpp
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>

using namespace std;

int n;
double r;

struct point {
  double x, y;
} p[100005], o;

inline double sqr(double x) { return x * x; }

inline double dis(point a, point b) {
  return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));
}

inline bool cmp(double a, double b) { return fabs(a - b) < 1e-8; }

point geto(point a, point b, point c) {
  double a1, a2, b1, b2, c1, c2;
  point ans;
  a1 = 2 * (b.x - a.x), b1 = 2 * (b.y - a.y),
  c1 = sqr(b.x) - sqr(a.x) + sqr(b.y) - sqr(a.y);
  a2 = 2 * (c.x - a.x), b2 = 2 * (c.y - a.y),
  c2 = sqr(c.x) - sqr(a.x) + sqr(c.y) - sqr(a.y);
  if (cmp(a1, 0)) {
    ans.y = c1 / b1;
    ans.x = (c2 - ans.y * b2) / a2;
  } else if (cmp(b1, 0)) {
    ans.x = c1 / a1;
    ans.y = (c2 - ans.x * a2) / b2;
  } else {
    ans.x = (c2 * b1 - c1 * b2) / (a2 * b1 - a1 * b2);
    ans.y = (c2 * a1 - c1 * a2) / (b2 * a1 - b1 * a2);
  }
  return ans;
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) scanf("%lf%lf", &p[i].x, &p[i].y);
  for (int i = 1; i <= n; i++) swap(p[rand() % n + 1], p[rand() % n + 1]);
  o = p[1];
  for (int i = 1; i <= n; i++) {
    if (dis(o, p[i]) < r || cmp(dis(o, p[i]), r)) continue;
    o.x = (p[i].x + p[1].x) / 2;
    o.y = (p[i].y + p[1].y) / 2;
    r = dis(p[i], p[1]) / 2;
    for (int j = 2; j < i; j++) {
      if (dis(o, p[j]) < r || cmp(dis(o, p[j]), r)) continue;
      o.x = (p[i].x + p[j].x) / 2;
      o.y = (p[i].y + p[j].y) / 2;
      r = dis(p[i], p[j]) / 2;
      for (int k = 1; k < j; k++) {
        if (dis(o, p[k]) < r || cmp(dis(o, p[k]), r)) continue;
        o = geto(p[i], p[j], p[k]);
        r = dis(o, p[i]);
      }
    }
  }
  printf("%.10lf\n%.10lf %.10lf", r, o.x, o.y);
  return 0;
}
```

## 练习

 [最小圆覆盖](https://www.luogu.org/problem/P1742) 

 [「HNOI2012」射箭](https://www.luogu.org/problem/P3222) 

## 参考资料

 <http://www.doc88.com/p-007257893177.html> 

 <https://www.cnblogs.com/aininot260/p/9635757.html> 

 <https://wenku.baidu.com/view/162699d63186bceb19e8bbe6.html> 

# 2d
我们将需要解决的几何问题的范围限制在二维平面内，这样就用到了二维计算几何。

要用电脑解平面几何题？数学好的同学们笑了。

> 某同学：来来来我给你们表演 $5$ 分钟算解析几何大题。

我们并不是用计算机算数学卷子上的几何题去了，而是解决一些更加复杂的几何相关问题。

为了解决复杂且抽象的问题，我们一定要选择合适的研究方法。对于计算机来说，给它看几何图形……

我们可以把要研究的图形放在平面直角坐标系或极坐标系下，这样解决问题就会方便很多。

## 前置技能

如并不了解：

-   几何基础
-   平面直角坐标系
-   向量（包括向量积）
-   极坐标与极坐标系

请先阅读 [向量](../math/vector.md) 和 [极坐标](./polar-coordinate.md) 。

## 图形的记录

### 点

在平面直角坐标系下，点用坐标表示，比如点 $(5,2)$ ，点 $(-1,0)$ 什么的。

我们记录其横纵坐标值即可。用 `pair` 或开结构体记录均可。

在极坐标系下，用极坐标表示即可。记录其极径与极角。

### 向量

由于向量的坐标表示与点相同，所以只需要像点一样存向量即可（当然点不是向量）。

在极坐标系下，与点同理。

### 线

#### 直线与射线

一般在解数学题时，我们用解析式表示一条直线。有一般式 $Ax+By+C=0$ ，还有斜截式 $y=kx+b$ ，还有截距式 $\frac{x}{a}+\frac{y}{b}=1$ ……用哪种？

这些式子最后都逃不过最后的结果——代入解方程求值。

解方程什么的最讨厌了，有什么好一点的方法吗？

考虑我们只想知道这条直线在哪，它的倾斜程度怎么样。于是用直线上的一个点先大致确定位置，用一个向量表示它的倾斜程度，好了，这条直线确定了。

因此我们记录的是：直线上一点和直线的方向向量。

#### 线段

线段很好记录：只需要记录左右端点即可。

在极坐标系下，记录线是比较麻烦的，因此大多数直线问题都在平面直角坐标系下解决。

### 多边形

开数组按一定顺序记录多边形的每个顶点即可。

特殊地，如果矩形的各边均与某坐标轴平行的话，我们只记录左下角和右上角的顶点即可。

### 曲线

一些特殊曲线，如函数图像等一般记录其解析式。对于圆，直接记录其圆心和半径即可。

## 基本公式

### 正弦定理

在三角形 $\triangle \text{ABC}$ 中，若角 $A,B,C$ 所对边分别为 $a,b,c$ ，则有：

$$
\frac{a}{\sin A}=\frac{b}{\sin B}=\frac{c}{\sin C}=2R
$$

其中， $R$ 为 $\triangle \text{ABC}$ 的外接圆半径。

### 余弦定理

在三角形 $\triangle \text{ABC}$ 中，若角 $A,B,C$ 所对边分别为 $a,b,c$ ，则有：

$$
\begin{aligned}
a^2&=b^2+c^2-2bc\cos A\\
b^2&=a^2+c^2-2ac\cos B\\
c^2&=a^2+b^2-2ab\cos C
\end{aligned}
$$

上述公式的证明略。均为人教版高中数学 A 版必修五内容。

## 基本操作

### 判断一个点在直线的哪边

> 某同学：我能看出来！

我们有直线上的一点 $P$ 的直线的方向向量 $\mathbf v$ ，想知道某个点 $Q$ 在直线的哪边。

我们利用向量积的性质，算出 $\overrightarrow {PQ}\times \mathbf v$ 。如果向量积为负，则 $Q$ 在直线上方，如果向量积为 $0$ ，则 $Q$ 在直线上，如果向量积为正，则 $Q$ 在直线下方。

可以画一下图，用右手定则感受一下。

### 快速排斥实验与跨立实验

> 某同学：捂我嘴干什么我可以……%￥\*……%

我们现在想判断两条线段是否相交。

首先特判一些特殊情况。如果两线段平行，自然不能相交。这种情况通过判断线段所在直线的斜率是否相等即可。

当然，如果两线段重合或部分重合，只需要判断是否有三点共线的情况即可。

如果两线段的交点为其中一条线段的端点，仍然判断是否有三点共线的情况即可。

还有些显然不相交的情况，我们口头上称之为「两条线段离着太远了」。可什么是「离着远」，怎么判断它呢？

规定「一条线段的区域」为以这条线段为对角线的，各边均与某一坐标轴平行的矩形所占的区域，那么可以发现，如果两条线段没有公共区域，则这两条线段一定不相交。

比如有以下两条线段：

![Seg1](./images/2d-seg1.png)

它们占用的区域是这样的：

![Seg2](./images/2d-seg2.png)

于是可以快速地判断出来这两条线段不相交。

这就是 **快速排斥实验** 。上述情况称作 **未通过快速排斥实验** 。

未通过快速排斥实验是两线段无交点的 **充分不必要条件** ，我们还需要进一步判断。

因为两线段 $a,b$ 相交， $b$ 线段的两个端点一定分布在 $a$ 线段所在直线两端；同理， $a$ 线段的两个端点一定分布在 $b$ 线段所在直线两端。我们可以直接判断一条线段的两个端点相对于另一线段所在直线的位置关系，如果不同，则两线段相交，反之则不相交。我们可以利用 3.1 中的知识帮助我们判断直线与点的位置关系。

这就是 **跨立实验** ，如果对于两线段 $a,b$ ， $b$ 线段的两个端点分布在 $a$ 线段所在直线的两侧， **且**  $a$ 线段的两个端点分布在 $b$ 线段所在直线的两侧，我们就说 $a,b$ 两线段 **通过了跨立实验** ，即两线段相交。

注意到当两条线段共线但不相交时也可以通过跨立实验，因此想要准确判断还需要与快速排斥实验结合。

### 判断一点是否在任意多边形内部

> 某同学：我还能 %$#^%\*(%&))

在计算几何中，这个问题被称为 [PIP 问题](https://en.wikipedia.org/wiki/Point_in_polygon) ，已经有一些成熟的解决方法，下面依次介绍。

#### 光线投射算法 (Ray casting algorithm)

在 [这里](https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html) 可以看到最原始的思路。

我们先特判一些特殊情况，比如「这个点离多边形太远了」。考虑一个能够完全覆盖该多边形的最小矩形，如果这个点不在这个矩形范围内，那么这个点一定不在多边形内。这样的矩形很好求，只需要知道多边形横坐标与纵坐标的最小值和最大值，坐标两两组合成四个点，就是这个矩形的四个顶点了。

还有点在多边形的某一边或某顶点上，这种情况十分容易判断（留作课后作业）。

我们考虑以该点为端点引出一条射线，如果这条射线与多边形有奇数个交点，则该点在多边形内部，否则该点在多边形外部，我们简记为 **奇内偶外** 。这个算法同样被称为奇偶规则 (Even-odd rule)。

由于 [Jordan curve theorem](https://en.wikipedia.org/wiki/Jordan_curve_theorem) ，我们知道，这条射线每次与多边形的一条边相交，就切换一次与多边形的内外关系，所以统计交点数的奇偶即可。

这样的射线怎么取？可以随机取这条射线所在直线的斜率，建议为无理数以避免出现射线与多边形某边重合的情况。

在原版代码中，使用的是记录多边形的数组中最后一个点作为射线上一点，这样统计时，如果出现射线过多边形某边或某顶点时，可以规定射线经过的点同在射线一侧，进而做跨立实验即可。

#### 回转数算法 (Winding number algorithm)

回转数是数学上的概念，是平面内闭合曲线逆时针绕过该点的总次数。很容易发现，当回转数等于 $0$ 的时候，点在曲线外部。这个算法同样被称为非零规则 (Nonzero-rule)。

如何计算呢？我们把该点与多边形的所有顶点连接起来，计算相邻两边夹角的和。注意这里的夹角是 **有方向的** 。如果夹角和为 $0$ ，则这个点在多边形外，否则在多边形内。

### 求两条直线的交点

> 某同学：这还不简单联立方程 #%$&^%)(Y(\*&rUIG))

首先，我们需要确定两条直线相交，只需判断一下两条直线的方向向量是否平行即可。如果方向向量平行，则两条直线平行，交点个数为 $0$ 。进一步地，若两条直线平行且过同一点，则两直线重合。

那么，问题简化为我们有直线 $AB,CD$ 交于一点，想求出交点 $E$ 。

如果两直线相交，则交点只有一个，我们记录了直线上的一个点和直线的方向向量，所以我们只需要知道这个点与交点的距离 $l$ ，再将这个点沿方向向量平移 $l$ 个单位长度即可。

考虑构造三角形，利用正弦定理求解 $l$ ，可以利用向量积构造出正弦定理。

![Intersection](./images/2d-intersection.png)

由上图可知， $|\mathbf a\times \mathbf b|=|\mathbf a||\mathbf b|\sin \beta$ ， $|\mathbf u\times \mathbf b|=|\mathbf u||\mathbf b|\sin \theta$ 。

作商得：

$$
T=\frac{|\mathbf u\times \mathbf b|}{|\mathbf a\times \mathbf b|}=\frac{|\mathbf u|\sin \theta}{|\mathbf a|\sin \beta}
$$

可以看出， $|\frac{|\mathbf u|\sin \theta}{\sin \beta}|=l​$ 。若绝对值内部式子取值为正，代表沿 $\mathbf a​$ 方向平移，反之则为反方向。

同时，我们将 $T$ 直接乘上 $\mathbf a$ ，就自动出现了直线的单位向量，不需要进行其他消去操作了。

于是，只需要将点 $P$ 加上 $T\mathbf a$ 即可得出交点。

### 求任意多边形的周长和面积

#### 求任意多边形的周长

直接计算即可，简洁即美德。

#### 求任意多边形的面积

考虑向量积的模的几何意义，我们可以利用向量积完成。

将多边形上的点逆时针标记为 $p_1,p_2,\cdots ,p_n$ ，再任选一个辅助点 $O$ ，记向量 $\mathbf v_i=p_i-O$ ，那么这个多边形面积 $S$ 可以表示为：

$$
S=\frac{1}{2}|\sum_{i=1}^n \mathbf v_i\times \mathbf v_{i\bmod n+1}|
$$

### 圆与直线相关

#### 求直线与圆的交点

首先判断直线与圆的位置关系。如果直线与圆相离则无交点，若相切则可以利用切线求出切点与半径所在直线，之后转化为求两直线交点。

若有两交点，则可以利用勾股定理求出两交点的中点，然后沿直线方向加上半弦长即可。

#### 求两圆交点

首先我们判断一下两个圆的位置关系，如果外离或内含则无交点，如果相切，可以算出两圆心连线的方向向量，然后利用两圆半径计算出平移距离，最后将圆心沿这个方向向量进行平移即可。

如果两圆相交，则必有两个交点，并且关于两圆心连线对称。因此下面只说明一个交点的求法，另一个交点可以用类似方法求出。

我们先将一圆圆心与交点相连，求出两圆心连线与该连线所成角。这样，将两圆心连线的方向向量旋转这个角度，就是圆心与交点相连形成的半径的方向向量了。

最后还是老套路——沿方向向量方向将圆心平移半径长度。

### 极角序

一般来说，这类题需要先枚举一个极点，然后计算出其他点的极坐标，在极坐标系下按极角的顺序解决问题。

#### 例题 [「JOI Spring Camp 2014 Day4」两个人的星座](https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d4.pdf) 

平面内有 $n$ 个点，有三种颜色，每个点的颜色是三种中的一种。求不相交的三色三角形对数。 $6\le n\le 3000$ 。

#### 题解

如果两个三角形不相交，则一定可以做出两条内公切线，如果相交或内含是做不出内公切线的。三角形的公切线可以类比圆的公切线。

先枚举一个原点，记为 $O$ ，以这个点为极点，过这个点且与 $x$ 轴平行的直线作为极轴，建立极坐标系，把剩余点按极角由小到大排序。然后统计出在极轴上方和下方的每种点的个数。

然后根据点枚举公切线，记枚举到的点为 $P$ ，初始时公切线为极轴。开始统计。那么一定存在一条公切线过点 $O$ 和点 $P$ 。因为公切线与三角形不相交，所以一方选择公切线上方的点，另一方一定选择下方的点。然后利用乘法原理统计方案数即可。

统计完后转公切线，那么点 $P$ 一定改变了相对于公切线的上下位置，而其他点不动，应该只将它的位置信息改变。

这样，可以发现，同一对三角形最终被统计了 $4$ 次，就是同一条公切线会被枚举两次，最后做出的答案应除以 $4$ 。

分析一下算法复杂度，我们枚举了一个原点，然后对于每一个原点将剩余点排序后线性统计。于是时间复杂度为 $O(n^2\log n)$ 。

## 代码编写注意事项

由于计算几何经常进行 `double` 类型的浮点数计算，因此带来了精度问题和时间问题。

有些问题，例如求点坐标均为整数的三角形面积，可以利用其特殊性进行纯整数计算，避免用浮点数影响精度。

由于浮点数计算比整数计算慢，所以需要注意程序的常数因子给时间带来的影响。

# 3d


# half-plane
author: wjy-yy, Ir1d, Xeonacid

## 定义

### 半平面

一条直线和直线的一侧。半平面是一个点集，因此是一条直线和直线的一侧构成的点集。当包含直线时，称为闭半平面；当不包含直线时，称为开半平面。

解析式一般为 $Ax+By+C\ge 0​$ 。

在计算几何中用向量表示，整个题统一以向量的左侧或右侧为半平面。

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![半平面](./images/hpi1.PNG)

### 半平面交

半平面交是指多个半平面的交集。因为半平面是点集，所以点集的交集仍然是点集。在平面直角坐标系围成一个区域。

这就很像普通的线性规划问题了，得到的半平面交就是线性规划中的可行域。一般情况下半平面交是有限的，经常考察面积等问题的解决。

它可以理解为向量集中每一个向量的右侧的交，或者是下面方程组的解。

$$
\left\{\begin{matrix}
A_1x+B_1y+C\ge 0\\ 
A_2x+B_2y+C\ge 0\\ 
\cdots
\end{matrix}\right.
$$

### 多边形的核

如果一个点集中的点与多边形上任意一点的连线与多边形没有其他交点，那么这个点集被称为多边形的核。

把多边形的每条边看成是首尾相连的向量，那么这些向量在多边形内部方向的半平面交就是多边形的核。

## 解法 - S&I 算法

### 极角排序

C 语言有一个库函数叫做 `atan2(double y,double x)` ，可以返回 $\theta\in (-\pi,\pi]$ ， $\theta =\arctan \frac{y}{x}$ 。

直接以向量为自变量，调用这个函数，以返回值为关键字排序，得到新的边（向量）集。

排序时，如果遇到共线向量（且方向相同），则取靠近可行域的一个。比如两个向量的极角相同，而我们要的是向量的左侧半平面，那么我们只需要保留左侧的向量。判断方法是取其中一个向量的起点或终点与另一个比较，检查是在左边还是在右边。

### 维护单调队列

因为半平面交是一个凸多边形，所以需要维护一个凸壳。因为后来加入的只可能会影响最开始加入的或最后加入的边（此时凸壳连通），只需要删除队首和队尾的元素，所以需要用单调队列。

我们遍历排好序了的向量，并维护另一个交点数组。当单队中元素超过 2 个时，他们之间就会产生交点。

对于当前向量，如果上一个交点在这条向量表示的半平面交的 **异侧** ，那么上一条边就没有意义了。

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![单调队列](./images/hpi2.PNG)

如上图，假设取向量左侧半平面。极角排序后，遍历顺序应该是 $\vec a\to\vec b\to\vec c$ 。当 $\vec a$ 和 $\vec b$ 入队时，在交点数组里会产生一个点 $D$ （交点数组保存队列中相同下标的向量与前一向量的交点）。

接下来枚举到 $\vec c$ 时，发现 $D$ 在 $\vec c$ 的右侧。而因为 **产生**  $D$  **的向量的极角一定比**  $\vec c$  **要小** ，所以产生 $D$ 的向量（指 $\vec b$ ）就对半平面交没有影响了。

还有一种可能的情况是快结束的时候，新加入的向量会从队首开始造成影响。

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![队首影响](./images/hpi7.PNG)

仍然假设取向量左侧半平面。加入向量 $\vec f$ 之后，第一个交点 $G$ 就在 $\vec f$ 的右侧，我们把上面的判断标准逆过来看，就知道此时应该删除向量 $\vec a$ ，也即 **队首** 的向量。

最后用队首的向量排除一下队尾多余的向量。因为队首的向量会被后面的约束，而队尾的向量不会。此时它们围成了一个环，因此队首的向量就可以约束队尾的向量。

### 得到半平面交

如果半平面交是一个凸 $n$ 边形，最后在交点数组里会得到 $n$ 个点。我们再把它们首尾相连，就是一个统一方向（顺或逆时针）的 $n$ 多边形。

此时就可以用三角剖分求面积了。（求面积是最基础的考法）

偶尔会出现半平面交不存在或面积为 0 的情况，注意考虑边界。

### 注意事项

当出现一个可以把队列里的点全部弹出去的向量（即所有队列里的点都在该向量的右侧），则我们 **必须** 先处理队尾，再处理队首。因此在循环中，我们先枚举 `--r;` 的部分，再枚举 `++l;` 的部分，才不会错。原因如下。

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/hpi4.PNG)

一般情况下，我们在队列（队列顺序为 $\left\{\vec{u},\vec{v}\right\}$ ) 后面加一条边（向量 $\vec w$ ），会产生一个交点 $N$ ，缩小 $\vec{v}$ 后面的范围。

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/hpi5.PNG)

但是毕竟每次操作都是一般的，因此可能会有把 $M$ 点“挤出去”的情况。

/home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/![](./images/hpi6.PNG)

如果此时出现了向量 $\vec a$ ，使得 $M$ 在 $\vec a$ 的右侧，那么 $M$ 就要出队了。此时如果从队首枚举 `++l` ，显然是扩大了范围。实际上 $M$ 点是由 $\vec u$ 和 $\vec v$ 共同构成的，因此需要考虑影响到现有进程的是 $\vec u$ 还是 $\vec v$ 。而因为我们在极角排序后，向量是逆时针顺序，所以 $\vec v$ 的影响要更大一些。

就如上图，如果 $M$ 确认在 $\vec a$ 的右侧，那么此时 $\vec v$ 的影响一定不会对半平面交的答案作出任何贡献。

而我们排除队首的原因是 **当前向量的限制比队首向量要大** ，这个条件的前提是队列里有不止两个线段（向量），不然就会出现上面的情况。

所以一定要先排除队尾再排除队首。

## 代码

比较部分

```cpp
friend bool operator<(seg x, seg y) {
  db t1 = atan2((x.b - x.a).y, (x.b - x.a).x);
  db t2 = atan2((y.b - y.a).y, (y.b - y.a).x);  //求极角
  if (fabs(t1 - t2) > eps)                      //如果极角不等
    return t1 < t2;
  return (y.a - x.a) * (y.b - x.a) >
         eps;  //判断向量x在y的哪边，令最靠左的排在最左边
}
```

增量部分

```cpp
// pnt its(seg a,seg b)表示求线段a,b的交点
// s[]是极角排序后的向量
// q[]是向量队列
// t[i]是s[i-1]与s[i]的交点
//【码风】队列的范围是(l,r]
//求的是向量左侧的半平面
int l = 0, r = 0;
for (int i = 1; i <= n; ++i)
  if (s[i] /home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry//home/llj/Desktop/OI-wiki-master/docs/geometry/!= s[i - 1]) {
    //注意要先检查队尾
    while (r - l > 1 && (s[i].b - t[r]) * (s[i].a - t[r]) >
                            eps)  //如果上一个交点在向量右侧则弹出队尾
      --r;
    while (r - l > 1 && (s[i].b - t[l + 2]) * (s[i].a - t[l + 2]) >
                            eps)  //如果第一个交点在向量右侧则弹出队首
      ++l;
    q[++r] = s[i];
    if (r - l > 1) t[r] = its(q[r], q[r - 1]);  //求新交点
  }
while (r - l > 1 &&
       (q[l + 1].b - t[r]) * (q[l + 1].a - t[r]) > eps)  //注意删除多余元素
  --r;
t[r + 1] = its(q[l + 1], q[r]);  //再求出新的交点
++r;
//这里不能在t里面++r需要注意一下……
```

## 练习

 [POJ 2451 Uyuw's Concert](http://poj.org/problem?id=2451) 注意边界

 [POJ 1279 Art Gallery](http://poj.org/problem?id=1279) 求多边形的核

 [「CQOI2006」凸多边形](https://www.luogu.org/problem/P4196) 

# dp
# interval
## 什么是区间 DP？

区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。令状态 $f(i,j)$ 表示将下标位置 $i$ 到 $j$ 的所有元素合并能获得的价值的最大值，那么 $f(i,j)=\max\{f(i,k)+f(k+1,j)+cost\}$ ， $cost$ 为将这两组元素合并起来的代价。

区间 DP 的特点：

 **合并** ：即将两个或多个部分进行整合，当然也可以反过来；

 **特征** ：能将问题分解为能两两合并的形式；

 **求解** ：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。

??? note " 例题[「NOI1995」石子合并](https://loj.ac/problem/10147)"
    题目大意：在一个环上有 $n$ 个数 $a_1,a_2,...,a_n$ ，进行 $n-1$ 次合并操作，每次操作将相邻的两堆合并成一堆，能获得新的一堆中的石子数量的和的得分。你需要最大化你的得分。

考虑不在环上，而在一条链上的情况。

令 $f(i,j)$ 表示将区间 $[i,j]$ 内的所有石子合并到一起的最大得分。

写出 **状态转移方程** ： $f(i,j)=max\{f(i,k)+f(k+1,j)+\sum_{t=i}^{j} a_t \}~(i\le k<j)$ 

令 $sum_i$ 表示 $a$ 数组的前缀和，状态转移方程变形为 $f(i,j)=max\{f(i,k)+f(k+1,j)+sum_j-sum_{i-1} \}$ 。

## 怎样进行状态转移

由于计算 $f(i,j)$ 的值时需要知道所有 $f(i,k)$ 和 $f(k+1,j)$ 的值，而这两个中包含的元素的数量都小于 $f(i,j)$ ，所以我们以 $len=j-i+1$ 作为 DP 的阶段。首先从小到大枚举 $len$ ，然后枚举 $i$ 的值，根据 $len$ 和 $i$ 用公式计算出 $j$ 的值，然后枚举 $k$ ，时间复杂度为 $O(n^3)$ 

## 怎样处理环

题目中石子围成一个环，而不是一条链，怎么办呢？

 **方法一** ：由于石子围成一个环，我们可以枚举分开的位置，将这个环转化成一个链，由于要枚举 $n$ 次，最终的时间复杂度为 $O(n^4)$ 。

 **方法二** ：我们将这条链延长两倍，变成 $2\times n$ 堆，其中第 $i$ 堆与第 $n+i$ 堆相同，用动态规划求解后，取 $f(1,n),f(2,n+1),...,f(i,n+i-1)$ 中的最优值，即为最后的答案。时间复杂度 $O(n^3)$ 。

## 核心代码

```cpp
for (len = 1; len <= n; len++)
  for (i = 1; i <= 2 * n - 1; i++) {
    int j = len + i - 1;
    for (k = i; k < j && k <= 2 * n - 1; k++)
      f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + sum[j] - sum[i - 1]);
  }
```

## 几道练习题

 [NOIP 2006 能量项链](https://vijos.org/p/1312) 

 [NOIP 2007 矩阵取数游戏](https://vijos.org/p/1378) 

 [「IOI2000」邮局](https://www.luogu.org/problemnew/show/P4767) 

# dag
DAG 即 [有向无环图](../graph/dag.md) ，一些实际问题中的二元关系都可使用 DAG 来建模。

## 例子

以这道题为例子，来分析一下 DAG 建模的过程。

??? note " 例题[UVa 437 巴比伦塔 The Tower of Babylon](https://cn.vjudge.net/problem/UVA-437)"
    有 $n (n\leqslant 30)$ 种砖块，已知三条边长，每种都有无穷多个。要求选一些立方体摞成一根尽量高的柱子（每个砖块可以自行选择一条边作为高），使得每个砖块的底面长宽分别严格小于它下方砖块的底面长宽，求塔的最大高度。

### 建立 DAG

由于每个砖块的底面长宽分别严格小于它下方砖块的底面长宽，因此不难将这样一种关系作为建图的依据，而本题也就转化为最长路问题。

也就是说如果砖块 $j$ 能放在砖块 $i$ 上，那么 $i$ 和 $j$ 之间存在一条边 $(i, j)$ ，且边权就是砖块 $j$ 所选取的高。

本题的另一个问题在于每个砖块的高有三种选法，怎样建图更合适呢？

不妨将每个砖块拆解为三种堆叠方式，即将一个砖块分解为三个砖块，每一个拆解得到的砖块都选取不同的高。

初始的起点是大地，大地的底面是无穷大的，则大地可达任意砖块，当然我们写程序时不必特意写上无穷大。

假设有两个砖块，三条边分别为 $31, 41, 59$ 和 $33, 83, 27$ ，那么整张 DAG 应该如下图所示。/home/llj/Desktop/OI-wiki-master/docs/dp/![](./images/dag-babylon.png)

图中蓝实框所表示的是一个砖块拆解得到的一组砖块，之所以用 $\{\}$ 表示底面边长，是因为砖块一旦选取了高，底面边长就是无序的。

图中黄虚框表示的是重复计算部分，为下文做铺垫。

### 转移

题目要求的是塔的最大高度，已经转化为最长路问题，其起点上文已指出是大地，那么终点呢？

显然终点已经自然确定，那就是某砖块上不能再搭别的砖块的时候。

之前在图上标记的黄虚框表明有重复计算，下面我们开始考虑转移方程。

显然，砖块一旦选取了高，那么这块砖块上最大能放的高度是确定的。

某个砖块 $i$ 有三种堆叠方式分别记为 $0, 1, 2$ ，那么对于砖块 $i$ 和其堆叠方式 $r$ 来说则有如下转移方程

 $d(i, r) = \max\left\{d(j, r') + h'\right\}$ 

其中 $j$ 是所有那些在砖块 $i$ 以 $r$ 方式堆叠时可放上的砖块， $r'$ 对应 $j$ 此时的摆放方式，也就确定了此时唯一的高度 $h'$ 。

在实际编写时，将所有 $d(i, r)$ 都初始化为 $-1$ ，表示未计算过。

在试图计算前，如果发现已经计算过，直接返回保存的值；否则就按步计算，并保存。

最终答案是所有 $d(i, r)$ 的最大值。

### 题解

```cpp
#include <cstring>
#include <iostream>
#define MAXN (30 + 5)
#define MAXV (500 + 5)
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
int d[MAXN][3];
int x[MAXN], y[MAXN], z[MAXN];
int babylon_sub(int c, int rot, int n) {
  if (d[c][rot] /home/llj/Desktop/OI-wiki-master/docs/dp/!= -1) {
    return d[c][rot];
  }
  d[c][rot] = 0;
  int base1, base2;
  if (rot == 0) {
    base1 = x[c];
    base2 = y[c];
  }
  if (rot == 1) {
    base1 = y[c];
    base2 = z[c];
  }
  if (rot == 2) {
    base1 = x[c];
    base2 = z[c];
  }
  for (int i = 0; i < n; i++) {
    if ((x[i] < base1 && y[i] < base2) || (y[i] < base1 && x[i] < base2))
      d[c][rot] = MAX(d[c][rot], babylon_sub(i, 0, n) + z[i]);
    if ((y[i] < base1 && z[i] < base2) || (z[i] < base1 && y[i] < base2))
      d[c][rot] = MAX(d[c][rot], babylon_sub(i, 1, n) + x[i]);
    if ((x[i] < base1 && z[i] < base2) || (z[i] < base1 && x[i] < base2))
      d[c][rot] = MAX(d[c][rot], babylon_sub(i, 2, n) + y[i]);
  }
  return d[c][rot];
}
int babylon(int n) {
  for (int i = 0; i < n; i++) {
    d[i][0] = -1;
    d[i][1] = -1;
    d[i][2] = -1;
  }
  int r = 0;
  for (int i = 0; i < n; i++) {
    r = MAX(r, babylon_sub(i, 0, n) + z[i]);
    r = MAX(r, babylon_sub(i, 1, n) + x[i]);
    r = MAX(r, babylon_sub(i, 2, n) + y[i]);
  }
  return r;
}
int main() {
  int t = 0;
  while (true) {
    int n;
    std::cin >> n;
    if (n == 0) break;
    t++;
    for (int i = 0; i < n; i++) {
      std::cin >> x[i] >> y[i] >> z[i];
    }
    std::cout << "Case " << t << ":"
              << " maximum height = " << babylon(n);
    std::cout << std::endl;
  }
  return 0;
}
```

# knapsack
author: hydingsy, Link-cute, Ir1d, greyqz, LuoshuiTianyi, Odeinjul

在学习本章前请确认你已经学习了 [动态规划部分简介](./index.md) 

在具体讲何为“背包 dp”前，先来看如下的例题：

??? note "[「USACO07 DEC」Charm Bracelet](https://www.luogu.org/problemnew/show/P2871)"
    题意概要：有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

在上述例题中，由于每个物体只有 $2$ 种可能的状态（取与不取），正如二进制中的 $0$ 和 $1$ ，这类问题便被称为“0-1 背包问题”。

## 0-1 背包

例题中已知条件有第 $i$ 个物品的重量 $w_{i}$ ，价值 $v_{i}$ ，以及背包的总容量 $W$ 。

设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。

考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$ ；当其放入背包时，背包的剩余容量会减小 $w_{i}$ ，背包中物品的总价值会增大 $v_{i}$ ，故这种情况的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$ 。

由此可以得出状态转移方程：

$$
f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})
$$

这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用滚动数组的形式来优化。

由于对 $f_i$ 有影响的只有 $f_{i-1}$ ，可以去掉第一维，直接用 $f_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：

$$
f_j=\max \left(f_j,f_{j-w_i}+v_i\right)
$$

 **务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的。** 

还有一点需要注意的是，很容易写出这样的错误核心代码：

```cpp
for (int i = 1; i <= n; i++)
  for (int l = 0; l <= W - w[i]; l++)
    f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
// 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]],f[i - 1][l] + w[i]),f[i][l +
// w[i]]); 简化而来
```

这段代码哪里错了呢？枚举顺序错了。

仔细观察代码可以发现：对于当前处理的物品 $i$ 和当前状态 $f_{i,j}$ ，在 $j\geqslant w_{i}$ 时， $f_{i,j}$ 是会被 $f_{i,j-w_{i}}$ 所影响的。这就相当于物品 $i$ 可以多次被放入背包，与题意不符。（事实上，这正是完全背包问题的解法）

为了避免这种情况发生，我们可以改变枚举的顺序，从 $W$ 枚举到 $w_{i}$ ，这样就不会出现上述的错误，因为 $f_{i,j}$ 总是在 $f_{i,j-w_{i}}$ 前被更新。

因此实际核心代码为

```cpp
for (int i = 1; i <= n; i++)
  for (int l = W; l >= w[i]; l--) f[l] = max(f[l], f[l - w[i]] + v[i]);
```

??? 例题代码
    ```cpp
    #include <iostream>
    const int maxn = 13010;
    int n, W, w[maxn], v[maxn], f[maxn];
    int main() {
      std::cin >> n >> W;
      for (int i = 1; i <= n; i++) std::cin >> w[i] >> v[i];
      for (int i = 1; i <= n; i++)
        for (int l = W; l >= w[i]; l--)
          if (f[l - w[i]] + v[i] > f[l]) f[l] = f[l - w[i]] + v[i];
      std::cout << f[W];
      return 0;
    }
    ```

## 完全背包

完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

我们可以借鉴 0-1 背包的思路，进行状态定义：设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。

需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。

可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n^3)$ 的。

状态转移方程如下：

$$
f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)
$$

考虑做一个简单的优化。可以发现，对于 $f_{i,j}$ ，只要通过 $f_{i,j-w_i}$ 转移就可以了。因此状态转移方程为：

$$
f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)
$$

理由是当我们这样转移时， $f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。

与 0-1 背包相同地，我们可以将第一维去掉来优化空间复杂度。如果理解了 0-1 背包的优化方式，就不难明白压缩后的循环是正向的（也就是上文中提到的错误优化）。

??? note "[「Luogu P1616」疯狂的采药](https://www.luogu.org/problemnew/show/P1616)"
    题意概要：有 $n$ 种物品和一个容量为 $W$ 的背包，每种物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干个物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

??? 例题代码
    ```cpp
    #include <iostream>
    const int maxn = 1e5 + 10;
    int n, W, w[maxn], v[maxn], f[maxn];
    int main() {
      std::cin >> W >> n;
      for (int i = 1; i <= n; i++) std::cin >> w[i] >> v[i];
      for (int i = 1; i <= n; i++)
        for (int l = w[i]; l <= W; l++)
          if (f[l - w[i]] + v[i] > f[l]) f[l] = f[l - w[i]] + v[i];
      std::cout << f[W];
      return 0;
    }
    ```

## 多重背包

多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品 y 有 $k_i$ 个，而非 $1$ 个。

一个很朴素的想法就是：把“每种物品选 $k_i$ 次”等价转换为“有 $k_i$ 个相同的物品，每个物品选一次”。这样就转换成了一个 0-1 背包模型，套用上文所述的方法就可已解决。状态转移方程如下：

$$
f_{i,j}=\max_{k=0}^{k_i}(f_{i-1,j-k\times w_i}+v_i\times k)
$$

时间复杂度 $O(nW\sum k_i)$ 。

### 二进制分组优化

考虑优化。我们仍考虑把多重背包转化成 0-1 背包模型来求解。

显然，复杂度中的 $O(nW)$ 部分无法再优化了，我们只能从 $O(\sum k_i)$ 处入手。为了表述方便，我们用 $A_{i,j}$ 代表第 $i$ 种物品拆分出的第 $j$ 个物品。

在朴素的做法中， $\forall j\le k_i$ ， $A_{i,j}$ 均表示相同物品。那么我们效率低的原因主要在于我们进行了大量重复性的工作。举例来说，我们考虑了“同时选 $A_{i,1},A_{i,2}$ ”与“同时选 $A_{i,2},A_{i,3}$ ”这两个完全等效的情况。这样的重复性工作我们进行了许多次。那么优化拆分方式就成为了解决问题的突破口。

我们可以通过“二进制分组”的方式使拆分方式更加优美。

具体地说就是令 $A_{i,j}\left(j\in\left[0,\lfloor \log_2(k_i+1)\rfloor-1\right]\right)$ 分别表示由 $2^{j}$ 个单个物品“捆绑”而成的大物品。特殊地，若 $k_i+1$ 不是 $2$ 的整数次幂，则需要在最后添加一个由 $k_i-2^{\lfloor \log_2(k_i+1)\rfloor-1}$ 个单个物品“捆绑”而成的大物品用于补足。

举几个例子：

-    $6=1+2+3$ 
-    $8=1+2+4+1$ 
-    $18=1+2+4+8+3$ 
-    $31=1+2+4+8+16$ 

显然，通过上述拆分方式，可以表示任意 $\le k_i$ 个物品的等效选择方式。将每种物品按照上述方式拆分后，使用 0-1 背包的方法解决即可。

时间复杂度 $O(W\sum_{i=1}^n\log_2k_i)$ 

??? 二进制分组代码
    ```cpp
    index = 0;
    for (int i = 1; i <= m; i++) {
      int c = 1, p, h, k;
      cin >> p >> h >> k;
      while (k - c > 0) {
        k -= c;
        list[++index].w = c * p;
        list[index].v = c * h;
        c *= 2;
      }
      list[++index].w = p * k;
      list[index].v = h * k;
    }
    ```

### 单调队列优化

见 [单调队列/单调栈优化](opt/monotonous-queue-stack.md) 。

习题： [「Luogu P1776」宝物筛选\_NOI 导刊 2010 提高（02）](https://www.luogu.org/problemnew/show/P1776) 

## 混合背包

混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取 $k$ 次。

这种题目看起来很吓人，可是只要领悟了前面几种背包的中心思想，并将其合并在一起就可以了。下面给出伪代码：

```cpp
for (循环物品种类) {
  if (是 0 - 1 背包)
    套用 0 - 1 背包代码;
  else if (是完全背包)
    套用完全背包代码;
  else if (是多重背包)
    套用多重背包代码;
}
```

??? note "[「Luogu P1833」樱花](https://www.luogu.org/problemnew/show/P1833)"
    题意概要：有 $n$ 种樱花树和长度为 $T$ 的时间，有的樱花树只能看一遍，有的樱花树最多看 $A{i}$ 遍，有的樱花树可以看无数遍。每棵樱花树都有一个美学值 $C{i}$ ，求在 $T$ 的时间内看哪些樱花树能使美学值最高。

## 二维费用背包

先来一道例题： [「Luogu P1855」榨取 kkksc03](https://www.luogu.org/problemnew/show/P1855) 。

这道题是很明显的 0-1 背包问题，可是不同的是选一个物品会消耗两种价值（经费、时间）。这种问题其实很简单：方程基本不用变，只需再开一维数组，同时转移两个价值就行了！（完全、多重背包同理）

这时候就要注意，再开一维存放物品编号就不合适了，因为容易 MLE。

例题核心代码：

```cpp
for (int k = 1; k <= n; k++) {
  for (int i = m; i >= mi; i--)    //对经费进行一层枚举
    for (int j = t; j >= ti; j--)  //对时间进行一层枚举
      dp[i][j] = max(dp[i][j], dp[i - mi][j - ti] + 1);
}
```

## 分组背包

再看一道例题： [「Luogu P1757」通天之分组背包](https://www.luogu.org/problemnew/show/P1757) 。

所谓分组背包，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。

这种题怎么想呢？其实是从“在所有物品中选择一件”变成了“从当前组中选择一件”，于是就对每一组进行一次 0-1 背包就可以了。

再说一说如何进行存储。我们可以将 $t_{k,i}$ 表示第 $k$ 组的第 $i$ 件物品的编号是多少，再用 $cnt_k$ 表示第 $k$ 组物品有多少个。

例题核心代码：

```cpp
for (int k = 1; k <= ts; k++)          //循环每一组
  for (int i = m; i >= 0; i--)         //循环背包容量
    for (int j = 1; j <= cnt[k]; j++)  //循环该组的每一个物品
      if (i >= w[t[k][j]])
        dp[i] = max(dp[i],
                    dp[i - w[t[k][j]]] + c[t[k][j]]);  //像0-1背包一样状态转移
```

这里要注意： **一定不能搞错循环顺序** ，这样才能保证正确性。

## 有依赖的背包

一道例题： [「Luogu P1064」金明的预算方案](https://www.luogu.org/problemnew/show/P1064) 。

这种背包问题其实就是如果选第 $i$ 件物品，就必须选第 $j$ 件物品，保证不会循环引用，一部分题目甚至会出现多叉树的引用形式。为了方便，就称不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。

对于包含一个主件和若干个附件的集合有以下可能性：仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……需要将以上可能性的容量和价值转换成一件件物品。因为这几种可能性只能选一种，所以可以将这看成分组背包。

如果是多叉树的集合，则要先算子节点的集合，最后算父节点的集合。

## 泛化物品的背包

这种背包，没有固定的费用和价值，它的价值是随着分配给它的费用而定。在背包容量为 $V$ 的背包问题中，当分配给它的费用为 $v_i$ 时，能得到的价值就是 $h\left(v_i\right)$ 。这时，将固定的价值换成函数的引用即可。

## 杂项

### 小优化

根据贪心原理，当费用相同时，只需保留价值最高的；当价值一定时，只需保留费用最低的；当有两件物品 $i,j$ 且 $i$ 的价值大于 $j$ 的价值并且 $i$ 的费用小于 $j$ 的费用是，只需保留 $j$ 。

### 背包问题变种

#### 输出方案

输出方案其实就是记录下来背包中的某一个状态是怎么推出来的。我们可以用 $g_{i,v}$ 表示第 $i$ 件物品占用空间为 $v$ 的时候是否选择了此物品。然后在转移时记录是选用了哪一种策略（选或不选）。输出时的伪代码：

```cpp
int v = V;  //记录当前的存储空间
for (
    从最后一件循环至第一件)  //因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环
{
  if (g[i][v]) {
    选了第 i 项物品;
    v -= 第 i 项物品的价值;
  } else
    未选第 i 项物品;
}
```

#### 求方案数

对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。

这种问题就是把求最大值换成求和即可。

例如 0-1 背包问题的转移方程就变成了：

$$
dp_i=\sum(dp_i,dp_{i-c_i})
$$

初始条件： $dp_0=1$ 

因为当容量为 $0$ 时也有一个方案：什么都不装！

#### 求最优方案总数

#### 求第 k 优解

### 参考资料

dd 大牛（崔添翼）的背包九讲，GitHub 仓库链接： [tianyicui/pack: 背包问题九讲](https://github.com/tianyicui/pack) 。

# memo
## 记忆化搜索是啥

以 [NOIP 2005 采药](https://vijos.org/p/1104) 为例：

> 山洞里有 M 株不同的草药，采每一株都需要一些时间 $t_i$ ，每一株也有它自身的价值 $v_i$ 。我会给你一段时间 T，在这段时间里，你可以采到一些草药。让采到的草药的总价值最大。

我不会动态规划，只会搜索，我就会直接写一个粗暴的 [DFS](../search/dfs.md) :

-   注：为了方便食用，本文中所有代码省略头文件

```cpp
int n, t;
int tcost[103], mget[103];
int ans = 0;
void dfs(int pos, int tleft, int tans) {
  if (tleft < 0) return;
  if (pos == n + 1) {
    ans = max(ans, tans);
    return;
  }
  dfs(pos + 1, tleft, tans);
  dfs(pos + 1, tleft - tcost[pos], tans + mget[pos]);
}
int main() {
  cin >> t >> n;
  for (int i = 1; i <= n; i++) cin >> tcost[i] >> mget[i];
  dfs(1, t, 0);
  cout << ans << endl;
  return 0;
}
```

这就是个十分智障的大暴搜是吧 ......

emmmmmm....... $30$ 分

然后我心血来潮，想不借助任何 "外部变量"（就是 dfs 函数外且 **值随 dfs 运行而改变的变量** ), 比如 ans

把 ans 删了之后就有一个问题：我们拿什么来记录答案？

答案很简单：

 **返回值！** 

此时 $dfs(pos,tleft)$ 返回在时间 $tleft$ 内采集 **后**  $pos$ 个草药，能获得的最大收益

不理解就看看代码吧：

```cpp
int n, time;
int tcost[103], mget[103];
int dfs(int pos, int tleft) {
  if (pos == n + 1) return 0;
  int dfs1, dfs2 = -INF;
  dfs1 = dfs(pos + 1, tleft);
  if (tleft >= tcost[pos]) dfs2 = dfs(pos + 1, tleft - tcost[pos]) + mget[pos];
  return max(dfs1, dfs2);
}
int main() {
  cin >> time >> n;
  for (int i = 1; i <= n; i++) cin >> tcost[i] >> mget[i];
  cout << dfs(1, time) << endl;
  return 0;
}
```

~~emmmmmm....... 还是 ${30}$ 分~~

但这个时候，我们的程序已经不依赖任何外部变量了。

然后我非常无聊，将所有 dfs 的返回值都记录下来，竟然发现……

 **震惊，对于相同的 pos 和 tleft,dfs 的返回值总是相同的！** 

想一想也不奇怪，因为我们的 dfs 没有依赖任何外部变量。

旁白：像 $tcost[103]$ , $mget[103]$ 这种东西不算是外部变量，因为它们的值在 dfs 过程中不会被改变。

然后？

开个数组 $mem$ , 记录下来每个 $dfs(pos,tleft)$ 的返回值。刚开始把 $mem$ 中每个值都设成 $-1$ （代表没访问过）。每次刚刚进入一个 dfs 前（我们的 dfs 是递归调用的嘛），都检测 $mem[pos][tleft]$ 是否为 $-1$ , 如果是就正常执行并把答案记录到 $mem$ 中，否则？

 **直接返回 $mem$ 中的值！** 

```cpp
int n, t;
int tcost[103], mget[103];
int mem[103][1003];
int dfs(int pos, int tleft) {
  if (mem[pos][tleft] != -1) return mem[pos][tleft];
  if (pos == n + 1) return mem[pos][tleft] = 0;
  int dfs1, dfs2 = -INF;
  dfs1 = dfs(pos + 1, tleft);
  if (tleft >= tcost[pos]) dfs2 = dfs(pos + 1, tleft - tcost[pos]) + mget[pos];
  return mem[pos][tleft] = max(dfs1, dfs2);
}
int main() {
  memset(mem, -1, sizeof(mem));
  cin >> t >> n;
  for (int i = 1; i <= n; i++) cin >> tcost[i] >> mget[i];
  cout << dfs(1, t) << endl;
  return 0;
}
```

此时 $mem$ 的意义与 dfs 相同：

> 在时间 $tleft$ 内采集 **后**  $pos$ 个草药，能获得的最大收益

这能 ac ?

能。 **这就是 "采药" 那题的 AC 代码** 

好我们 yy 出了记忆化搜索

#### 总结一下记忆化搜索是啥：

-   不依赖任何 **外部变量** 
-   答案以返回值的形式存在，而不能以参数的形式存在（就是不能将 dfs 定义成 $dfs(pos ,tleft , nowans )$ , 这里面的 nowans 不符合要求）。
-   对于相同一组参数，dfs 返回值总是相同的

* * *

## 记忆化搜索与动态规划的关系：

有人会问：记忆化搜索难道不是搜索？

是搜索。但个人认为她更像 dp :

不信你看 $mem$ 的意义：

> 在时间 $tleft$ 内采集 **后**  $pos$ 个草药，能获得的最大收益

这不就是 dp 的状态？

由上面的代码中可以看出：

>  $mem[pos][tleft] = max(mem[pos+1][tleft-tcost[pos]]+mget[pos]\ ,\ mem[pos+1][tleft])$ 

这不就是 dp 的状态转移？

个人认为：

> 记忆化搜索约等于动态规划， **（印象中）任何一个 dp 方程都能转为记忆化搜索** 

大部分记忆化搜索的状态/转移方程与 dp 都一样，时间复杂度/空间复杂度与 **不加优化的** dp 完全相同

比如：

 $dp[i][j][k] = dp[i+1][j+1][k-a[j]] + dp[i+1][j][k]$ 

转为

```cpp
int dfs(int i, int j, int k) {
  // 判断边界条件
  if (mem[i][j][k] != -1) return mem[i][j][k];
  return mem[i][j][k] = dfs(i + 1, j + 1, k - a[j]) + dfs(i + 1, j, k);
}
int main() {
  memset(mem, -1, sizeof(mem));
  // 读入部分略去
  cout << dfs(1, 0, 0) << endl;
}
```

* * *

## 如何写记忆化搜索

### 方法 I

1.  把这道题的 dp 状态和方程写出来
2.  根据他们写出 dfs 函数
3.  添加记忆化数组

举例：

 $dp_{i} = max\{dp_{j}+1\}\quad 1 \leq j < i and a_{j}<a_{i}$ （最长上升子序列）

转为

```cpp
int dfs(int i) {
  if (mem[i] != -1) return mem[i];
  int ret = 1;
  for (int j = 1; j < i; j++)
    if (a[j] < a[i]) ret = max(ret, dfs(j) + 1);
  return mem[i] = ret;
}
int main() {
  memset(mem, -1, sizeof(mem));
  // 读入部分略去
  cout << dfs(n) << endl;
}
```

### 方法 II

1.  写出这道题的暴搜程序（最好是 [dfs](../search/dfs.md) )
2.  将这个 dfs 改成 "无需外部变量" 的 dfs
3.  添加记忆化数组

举例：本文最开始介绍 "什么是记忆化搜索" 时举的 "采药" 那题的例子

* * *

## 记忆化搜索的优缺点

优点：

-   记忆化搜索可以避免搜到无用状态，特别是在有状态压缩时

举例：给你一个有向图（注意不是完全图），经过每条边都有花费，求从点 1 出发，经过每个点 **恰好一次** 后的最小花费（最后不用回到起点），保证路径存在。

dp 状态很显然：

设 $dp_{pos,mask}$ 表示身处在 $pos$ 处，走过 $mask$ (mask 为一个二进制数）中的顶点后的最小花费

常规 $dp$ 的状态数为 $O(n\cdot 2^n)$ , 转移复杂度（所有的加在一起）为 $O(m)$ 

但是！如果我们用记忆化搜索，就可以避免到很多无用的状态，比如 $pos$ 为起点却已经经过了 $>1$ 个点的情况。

-   不需要注意转移顺序（这里的 "转移顺序" 指正常 dp 中 for 循环的嵌套顺序以及循环变量是递增还是递减）

举例：用常规 dp 写 "合并石子" 需要先枚举区间长度然后枚举起点，但记忆化搜索直接枚举断点（就是枚举当前区间由哪两个区间合并而成）然后递归下去就行

-   边界情况非常好处理，且能有效防止数组访问越界
-   有些 dp（如区间 dp) 用记忆化搜索写很简单但正常 dp 很难
-   记忆化搜索天生携带搜索天赋，可以使用技能 "剪枝"!

缺点：

-   致命伤：不能滚动数组！
-   有些优化比较难加
-   由于递归，有时效率较低但不至于 TLE（状压 dp 除外）

* * *

## 记忆化搜索的注意事项

-   千万别忘了加记忆化！（别笑，认真的
-   边界条件要加在检查当前数组值是否为非法数值（防止越界）
-   数组不要开小了（逃

## 模板

```cpp
int g[MAXN];
int f(传入数值) {
  if (g[规模] != 无效数值) return g[规模];
  if (终止条件) return 最小子问题解;
  g[规模] = f(缩小规模);
  return g[规模];
}
int main() {
  ... memset(g, 无效数值, sizeof(g));
  ...
}
```

# misc


# index
动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

严格意义上，动态规划只能用来解决最优化问题，但在 OI 中，计数等非最优化问题的递推解法也常被不规范地称作 DP。事实上，动态规划与其它类型的递推的确有很多相似之处，学习时可以注意它们之间的异同。

参考资料： <https://zh.wikipedia.org/wiki/动态规划> 

# tree
在学习本章前请确认你已经学习了 [动态规划基础](./basic.md) 

树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。

## 例题

以下面这道题为例，介绍一下树形 DP 的一般过程。

??? note " 例题[洛谷 P1352 没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)"
    某大学有 $n$ 个职员，编号为 $1\text{~} N$ 。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $a_i$ ，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

我们可以定义 $f(i,0/1)$ 代表以 $i$ 为根的子树的最优解（第二维的值为 0 代表 $i$ 不参加舞会的情况，1 代表 $i$ 参加舞会的情况）。

显然，我们可以推出下面两个状态转移方程（其中下面的 $x$ 都是 $i$ 的儿子）：

-    $f(i,0) = \sum\max \{f(x,1),f(x,0)\}$ （上司不参加舞会时，下属可以参加，也可以不参加）
-    $f(i,1) = \sum{f(x,0)} + a_i$ （上司参加舞会时，下属都不会参加）

我们可以通过 DFS，在返回上一层时更新当前节点的最优解。

代码：

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
struct edge {
  int v, next;
} e[6005];
int head[6005], n, cnt, f[6005][2], ans, is_h[6005], vis[6005];
void addedge(int u, int v) {
  e[++cnt].v = v;
  e[cnt].next = head[u];
  head[u] = cnt;
}
void calc(int k) {
  vis[k] = 1;
  for (int i = head[k]; i; i = e[i].next)  //枚举该节点的每个子节点
  {
    if (vis[e[i].v]) continue;
    calc(e[i].v);
    f[k][1] += f[e[i].v][0];
    f[k][0] += max(f[e[i].v][0], f[e[i].v][1]);
  }
  return;
}
int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) scanf("%d", &f[i][1]);
  for (int i = 1; i < n; i++) {
    int l, k;
    scanf("%d%d", &l, &k);
    is_h[l] = 1;
    addedge(k, l);
  }
  for (int i = 1; i <= n; i++)
    if (!is_h[i])  //从根节点开始DFS
    {
      calc(i);
      printf("%d", max(f[i][1], f[i][0]));
      return 0;
    }
}
```

## 习题

 [HDU 2196 Computer](http://acm.hdu.edu.cn/showproblem.php?pid=2196) 

 [POJ 1463 Strategic game](http://poj.org/problem?id=1463) 

 [POJ 3585 Accumulation Degree](http://poj.org/problem?id=3585) 

# number
## 经典题型

数位 DP 问题往往都是这样的题型，给定一个闭区间 $[l,r]$ ，让你求这个区间中满足 **某种条件** 的数的总数。

??? note " 例题[SCOI2009 windy 数](https://loj.ac/problem/10165)"
    题目大意：给定一个区间 $[l,r]$ ，求其中满足条件 **不含前导 $0$ 且相邻两个数字相差至少为 $2$ ** 的数字个数。

首先我们将问题转化成更加简单的形式。设 $ans_i$ 表示在区间 $[1,i]$ 中满足条件的数的数量，那么所求的答案就是 $ans_r-ans_{l-1}$ 。

分开求解这两个问题。

对于一个小于 $n$ 的数，它从高到低肯定出现某一位，使得这一位上的数值小于 $n$ 这一位上对应的数值。而之前的所有位都和 $n$ 上的位相等。

有了这个性质，我们可以定义 $f(i,st,op)$ 表示当前将要考虑的是从高到低的第 $i$ 位，当前该前缀的状态为 $st$ 且前缀和当前求解的数字的大小关系是 $op$ （ $op=1$ 表示等于， $op=0$ 表示小于）时的数字个数。在本题中，这个前缀的状态就是上一位的值，因为当前将要确定的位不能取哪些数只和上一位有关。在其他题目中，这个值可以是：前缀的数字和，前缀所有数字的 $\gcd$ ，该前缀取模某个数的余数，也有两种或多种合用的情况。

写出 **状态转移方程** ： $f(i,st,op)=\sum_{k=1}^{maxx} f(i+1,k,op=1~ \operatorname{and}~ k=maxx )\quad (|st-k|\ge 2)$ 

这里的 $k$ 就是当前枚举的下一位的值，而 $maxx$ 就是当前能取到的最高位。因为如果 $op=1$ ，那么你在这一位上取的值一定不能大于求解的数字上该位的值，否则则没有限制。

我们发现，尽管前缀所选择的状态不同，而 $f$ 的三个参数相同，答案就是一样的。为了防止这个答案被计算多次，可以使用记忆化搜索的方式实现。

核心代码：

```cpp
int dfs(int x, int st, int op)  // op=1 =;op=0 <
{
  if (!x) return 1;
  if (!op && ~f[x][st]) return f[x][st];
  int maxx = op ? dim[x] : 9, ret = 0;
  for (int i = 0; i <= maxx; i++) {
    if (abs(st - i) < 2) continue;
    if (st == 11 && i == 0)
      ret += dfs(x - 1, 11, op & (i == maxx));
    else
      ret += dfs(x - 1, i, op & (i == maxx));
  }
  if (!op) f[x][st] = ret;
  return ret;
}
int solve(int x) {
  memset(f, -1, sizeof f);
  dim.clear();
  dim.push_back(-1);
  int t = x;
  while (x) {
    dim.push_back(x % 10);
    x /= 10;
  }
  return dfs(dim.size() - 1, 11, 1);
}
```

## 几道练习题

 [BZOJ 3679 数字之积](https://www.lydsy.com/JudgeOnline/problem.php?id=3679) 

 [ZJOI2010 count 数字计数](https://loj.ac/problem/10169) 

 [Ahoi2009 self 同类分布](https://www.luogu.org/problem/P4127) 

 [洛谷  P3413 SAC#1 - 萌数](https://www.luogu.org/problemnew/show/P3413) 

 [HDU 6148 Valley Number](http://acm.hdu.edu.cn/showproblem.php?pid=6148) 

 [CF55D Beautiful numbers](http://codeforces.com/problemset/problem/55/D) 

 [CF628D Magic Numbers](http://codeforces.com/problemset/problem/628/D) 

 [CF401D Roman and Numbers](http://codeforces.com/problemset/problem/401/D) 

# basic
author: Ir1d, CBW2007, ChungZH, xhn16729, Xeonacid, tptpp, hsfzLZH1, ouuan, TrisolarisHD, HeRaNO, greyqz, Chrogeek, partychicken

动态规划应用于子问题重叠的情况：

1.  要去刻画最优解的结构特征；
2.  尝试递归地定义最优解的值（就是我们常说的考虑从 $i - 1$ 转移到 $i$ ）；
3.  计算最优解；
4.  利用计算出的信息构造一个最优解。

## 钢条切割

给定一段钢条，和不同长度的价格，问如何切割使得总价格最大。

为了求解规模为 $n$ 的原问题，我们先求解形式完全一样，但规模更小的子问题。
即当完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例。
我们通过组合相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。

> 最优子结构：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。

动态规划的两种实现方法：

-   带备忘的自顶向下法（记忆化搜索）；
-   自底向上法（将子问题按规模排序，类似于递推）。

算导用子问题图上按照逆拓扑序求解问题，引出记忆化搜索。

重构解（输出方案）：转移的时候记录最优子结构的位置。

## 矩阵链乘法

给出 $n$ 个矩阵的序列，希望计算他们的乘积，问最少需要多少次乘法运算？

（认为 $p \times q$ 的矩阵与 $q\times r$ 的矩阵相乘代价是 $p\times q\times r$ 。）

完全括号化方案是指要给出谁先和谁乘。

## 动态规划原理

两个要素：

### 最优子结构

具有最优子结构也可能是适合用贪心的方法求解。

注意要确保我们考察了最优解中用到的所有子问题。

1.  证明问题最优解的第一个组成部分是做出一个选择；
2.  对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
3.  给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
4.  证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

要保持子问题空间尽量简单，只在必要时扩展。

最优子结构的不同体现在两个方面：

1.  原问题的最优解中涉及多少个子问题；
2.  确定最优解使用哪些子问题时，需要考察多少种选择。

子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

 **经典问题：** 

-    **无权最短路径：** 具有最优子结构性质。
-    **无权最长（简单）路径：** 此问题不具有，是 NPC 的。区别在于，要保证子问题无关，即同一个原问题的一个子问题的解不影响另一个子问题的解。相关：求解一个子问题时用到了某些资源，导致这些资源在求解其他子问题时不可用。

### 子问题重叠

子问题空间要足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。

### 重构最优解

存表记录最优分割的位置，就不用重新按照代价来重构。

## 最长公共子序列

子序列允许不连续。

每个 $c[i][j]$ 只依赖于 $c[i - 1][j]$ 、 $c[i][j - 1]$ 和 $c[i - 1][j - 1]$ 。

记录最优方案的时候可以不需要额外建表（优化空间），因为重新选择一遍（转移过程）也是 $O(1)$ 的。

## 最优二叉搜索树

给二叉搜索树的每个节点定义一个权值，问如何安排使得权值和深度的乘积最小。

考虑当一棵子树成为了一个节点的子树时，答案（期望搜索代价）有何变化？

由于每个节点的深度都增加了 1，这棵子树的期望搜索代价的增加值应为所有概率之和。

> tD/eD 动态规划：
> 状态空间是 $O(n^t)$ 的，每一项依赖其他 $O(n^e)$ 项。

## 最长连续不下降子序列

对 n 个数求它的最长不下降子序列，也就是求最长的上升（一个数比一个数大）子序列有多长。

因为是连续的，所以只要与上一个元素进行比较即可。

```cpp
int a[MAXN];
int dp() {
  int now = 1, ans = 1;
  for (int i = 2; i <= n; i++) {
    if (a[i] > a[i - 1])
      now++;
    else
      now = 1;
    ans = max(now, ans);
  }
  return ans;
}
```

## 最长不下降子序列

对 n 个数求它的最长不下降子序列，也就是求最长的上升（一个数比一个数大）子序列有多长。与最长连续不下降子序列不同的是，不需要这个子序列是连续的了。

求最长子序列的方法有两种。

### 最简单的第一种

 $O\left(n^2\right)$ 的算法。每一次从头扫描找出最佳答案。

```cpp
int a[MAXN], d[MAXN];
int dp() {
  d[1] = 1;
  int ans = 1;
  for (int i = 2; i <= n; i++) {
    for (int j = 1; j < i; j++)
      if (a[j] < a[i]) {
        d[i] = max(d[i], d[j] + 1);
        ans = max(ans, d[i]);
      }
  }
  return ans;
}
```

### 稍复杂的第二种

 $O\left(n \log n\right)$ 的算法，参考了这篇文章 <https://www.cnblogs.com/itlqs/p/5743114.html> 。

首先，定义 $a_1 \dots a_n$ 为原始序列， $d$ 为当前的不下降子序列， $len$ 为子序列的长度，那么 $d_{len}$ 就是长度为 $len$ 的不下降子序列末尾元素。

初始化： $d_1=a_1,len=1$ 。

现在我们已知最长的不下降子序列长度为 1，那么我们让 $i$ 从 2 到 $n$ 循环，依次求出前 $i$ 个元素的最长不下降子序列的长度，循环的时候我们只需要维护好 $d$ 这个数组还有 $len$ 就可以了。 **关键在于如何维护。** 

考虑进来一个元素 $a_i$ ：

1.  元素大于 $d_{len}$ ，直接 $d_{++len}=a_i$ 即可，这个比较好理解。
2.  元素等于 $d_{len}$ ，因为前面的元素都小于它，所以这个元素可以直接抛弃。
3.  元素小于 $d_{len}$ ，找到 **第一个** 大于它的元素，插入进去，其他小于它的元素不要。

那么代码如下：

```cpp
for (int i = 0; i < n; ++i) scanf("%d", a + i);
memset(dp, 0x1f, sizeof dp);
mx = dp[0];
for (int i = 0; i < n; ++i) {
  *std::lower_bound(dp, dp + n, a[i]) = a[i];
}
ans = 0;
while (dp[ans] != mx) ++ans;
```

## 经典问题（来自习题）

### DAG 中的最长简单路径

 $dp[i] = \max(dp[j] + 1), ((j, i) \in E)$ 

### 最长回文子序列

$$
dp[i][i + len] =
\begin{cases}
dp[i + 1][i + len - 1] + 2,  & \text{if $s[i] = s[i + len]$} \\[2ex]
\max(dp[i + 1][i + len], dp[i][i + len - 1]), & \text{else}
\end{cases}
$$

边界： $dp[i][i] = 1$ 。

注意： $dp[i][j]$ 表示的是闭区间。

也可以转化为 LCS 问题，只需要把 $a$ 串反转当做 $b$ ，对 $a$ 和 $b$ 求 LCS 即可。

证明在 [这里](https://www.zhihu.com/question/34580085/answer/59539708) 。

注意区分子串（要求连续）的问题。

### 最长回文子串

 $O(n^2)$ ： $dp[i] = \max(dp[j] + 1), s(j + 1 \cdots i)$ 是回文

 $O(n)$ ：Manacher

 $p[i]$ 表示从 $i$ 向两侧延伸（当然要保证两侧对应位置相等）的最大长度。

为了处理方便，我们把原串每两个字符之间加一个（不包含在原串中的） `#` ，开头加一个 `$` 。

这样得到的回文串长度就保证是奇数了

考虑如果按顺序得到了 $p[1 \cdots i - 1]$ ，如何计算 $p[i]$ 的值？

如果之前有一个位置比如说是 $id$ ，有 $p[id] + id > i$ 那么 $i$ 这个位置是被覆盖了的，根据 $id$ 处的对称性，我们找 $p[id \times 2 - i]$ 延伸的部分被 $p[id]$ 延伸的部分所覆盖的那段，显然这段对称回去之后是可以从 $i$ 处延伸出去的长度。

如果找不到呢？就先让 $p[i] = 1$ 吧。

之后再暴力延伸一下。

可以证明是 $O(n)$ 的。

至于如何找是否有这么一个 $id$ 呢？递推的时候存一个 $max$ 就好了。

代码在： <https://github.com/Ir1d/Fantasy/blob/master/HDU/3068.cpp> 

### 双调欧几里得旅行商问题

好像出成了某一年程设期末。

upd：其实是 [程设期末推荐练习](https://ir1d.cf/2018/06/23/cssx/程设期末推荐练习/) 里面的。

书上的提示是：从左到右扫描，对巡游路线的两个部分分别维护可能的最优解。

说的就是把回路给拆开吧。

#### 思路一

 $dp[i][j]$ 表示 $1 \cdots i$ 和 $1 \cdots j$ 两条路径。

我们可以人为要求 $1 \cdots i$ 是更快的那一条路径。

这样考虑第 $i$ 个点分给谁。

如果是分给快的那条：

 $dp[i][j] = \min(dp[i - 1][j] + dis[i - 1][i]),\ j = 1 \cdots i$ 

如果是慢的，原来是慢的那条就变成了快的，所以另一条是到 $i - 1$ 那个点：

 $dp[i][j] = \min(dp[i - 1][j] + dis[j][i]),\ j = 1 \cdots i$ 

答案是 $\min(dp[n][i] + dis[n][i])$ 。
（从一开始编号，终点是 $n$ ）

代码： <https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/2018rec/11.cpp> 

#### 思路二

把 $dp[i][j]$ 定义反过来，不是 $1 \cdots i$ 和 $1 \cdots j$ 。

改成是 $i..n$ 和 $j \cdots n$ ，不要求哪个更快。

这样的转移更好写：

我们记 $k = \max(i, j) + 1$ 

 $k$ 这个点肯定在两条路中的一个上， $dp[i][j]$ 取两种情况的最小值即可。

 $dp[i][j] = \min(dp[i][k] + dis[k][j], dp[k][j] + dis[i][k])$ 

边界是： $dp[i][n] = dp[n][i] = dis[n][i]$ 。

答案是 $dp[1][1]$ 。

### 整齐打印

希望最小化所有行的额外空格数的立方之和。

注意到实际问题要求单词不能打乱顺序，所以就好做了起来。 **不要把题目看复杂。** 

 $dp[i] = \min(dp[j] + cost[j][i])$ 

不知道这样可不可做：有 $n$ 个单词，可以不按顺序打印，问怎么安排，使得把他们打印成 $m$ 行之后，每行的空格之和最小。

### 编辑距离

变换操作有 $6$ 种，复制、替换、删除、插入、旋转、终止（结束转换过程）。

### 最优对齐问题

把空格符插入到字符串里，使得相似度最大。

定义了按字符比较的相似度。

然后发现最优对齐问题可以转换为编辑距离问题。

相当于仅有三个操作的带权编辑距离。

```text
copy    :  1
replace : -1
insert  : -2
```

### 公司聚会计划

没有上司的舞会。

 $dp[x][0]$ 是没去， $dp[x][1]$ 是去了。

 $dp[u][0] = \max(dp[v][0], dp[v][1]), v \in son(u)$ 

 $dp[u][1] = w[u] + dp[v][0], v \in son(u)$ 

### 译码算法

 [Viterbi algorithm](https://en.wikipedia.org/wiki/Viterbi_algorithm) 之前写词性标注的时候有用到，好像用在输入法里面也是类似的。

本题中用来实现语音识别，其实就是找一条对应的概率最大的路径。

ref： <https://segmentfault.com/a/1190000008720143> 

### 基于接缝裁剪的图像压缩

玩过 opencv 的应该有印象，seam carving 就是在做 dp。

题中要求每一行删除一个像，每个像素都有代价，要求总代价最小。

限制：要求相邻两行中删除的像素必须位于同一列或相邻列。

 $dp[i][j] = \min(dp[i - 1][j], dp[i - 1][j - 1], dp[i - 1][j + 1]) + cost[i][j]$ 

边界： $dp[1][i] = cost[1][i]$ 。

### 字符串拆分

相当于问怎么按顺序拼起来使得总代价最小。

等价于之前那个最优二叉搜索树。

 $dp[i][j] = \min(dp[i][k] + dp[k][j]) + l[j] - l[i] + 1,\ k = i + 1 \cdots j - 1$ 

注意 $l[i]$ 表示的是第 i 个切分点的位置。

边界： $dp[i][i] = 0$ 。

就按照区间 dp 的姿势来写就好了。

### 投资策略规划

> 引理：存在最优投资策略，每年都将所有钱投入到单一投资中。

这是个很有趣的结论，dp 问题中很常见。

 <https://fogsail.github.io/2017/05/08/20170508/> 

剩下的就是个二维 dp，想成从 $(1, i)$ 走到 $(n, m)$ 的路径的问题，然后收益和代价就是边权，网格图只能往右下方走。

### 库存规划

生产多了少了都有额外的成本，问怎么安排生产策略使得额外的成本尽可能地少。

 $cost[i][j]$ 表示剩下 $i$ 个月，开始的时候有 $j$ 台库存的最小成本。

 <https://walkccc.github.io/CLRS/Chap15/Problems/15-11/> 

### 签约棒球自由球员

 $v[i][j]$ 是考虑 $i$ 之后的位置，总费用为 $x$ 的最大收益。

 <https://walkccc.github.io/CLRS/Chap15/Problems/15-12/> 

类似于背包问题。

* * *

当选取的状态难以进行递推时（分解出的子问题和原问题形式不一样），考虑将问题状态分类细化，增加维度。

# state
学习状压 dp 之前，请确认你已经完成了 [动态规划基础](./basic.md) 部分内容的学习。

（同时建议学习 [位运算](../math/bit.md) 部分的内容）

## 状压 DP 简介

状压 dp 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。

## 例题

??? note "[「SCOI2005」互不侵犯](https://loj.ac/problem/2153)"
    在 $N\times N$ 的棋盘里面放 $K$ 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 $8$ 个格子。

我们用 $f(i,j,l)$ 表示前 $i$ 行，当前状态为 $j$ ，且已经放置 $l$ 个国王时的方案数。

其中 $j$ 这一维状态我们用一个二进制整数表示（ $j$ 的某个二进制位为 0 代表对应的列不放国王，否则代表对应的列放国王）。

我们需要在刚开始的时候预处理出一行的所有合法状态 $sta(x)$ （排除同一行内两个国王相邻的不合法情况），在转移的时候枚举这些可能状态进行转移。

设当前行的状态为 $j$ ，上一行的状态为 $x$ ，可以得到下面的转移方程： $f(i,j,l) = \sum f(i-1,x,l-sta(x))$ 。

需要注意在转移时排除相邻两行国王互相攻击的不合法情况。

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <iostream>
    using namespace std;
    long long sta[2005], sit[2005], f[15][2005][105];
    int n, k, cnt;
    void dfs(int x, int num, int cur) {
      if (cur >= n)  //有新的合法状态
      {
        sit[++cnt] = x;
        sta[cnt] = num;
        return;
      }
      dfs(x, num, cur + 1);  // cur位置不放国王
      dfs(x + (1 << cur), num + 1,
          cur + 2);  // cur位置放国王，与它相邻的位置不能再放国王
    }
    int main() {
      cin >> n >> k;
      dfs(0, 0, 0);  //先预处理一行的所有合法状态
      for (int i = 1; i <= cnt; i++) f[1][i][sta[i]] = 1;
      for (int i = 2; i <= n; i++)
        for (int j = 1; j <= cnt; j++)
          for (int l = 1; l <= cnt; l++) {
            if (sit[j] & sit[l]) continue;
            if ((sit[j] << 1) & sit[l]) continue;
            if (sit[j] & (sit[l] << 1)) continue;
            //排除不合法转移
            for (int p = sta[j]; p <= k; p++) f[i][j][p] += f[i - 1][l][p - sta[j]];
          }
      long long ans = 0;
      for (int i = 1; i <= cnt; i++) ans += f[n][i][k];  //累加答案
      cout << ans << endl;
      return 0;
    }
    ```

## 几道练习题

 [NOI2001 炮兵阵地](https://loj.ac/problem/10173) 

 [「USACO06NOV」玉米田 Corn Fields](https://www.luogu.org/problemnew/show/P1879) 

 [AHOI2009 中国象棋](https://www.luogu.org/problem/P2051) 

 [九省联考 2018 一双木棋](https://loj.ac/problem/2471) 

# dynamic
在学习本章前请确认你已经学习了 [矩阵](../math/matrix.md)  [树链剖分](../graph/hld.md) 。

动态 DP 问题是猫锟在 WC2018 讲的黑科技，一般用来解决树上的 DP 问题，同时支持点权（边权）修改操作。

在 NOIP2018D2T3 考察后风靡 OI 圈。

## 例子

以这道模板题为例子讲解一下动态 DP 的过程。

??? note " 例题[洛谷 P4719 【模板】动态 DP](https://www.luogu.org/problem/P4719) "
    给定一棵 $n$ 个点的树，点带点权。有 $m$ 次操作，每次操作给定 $x,y$ 表示修改点 $x$ 的权值为 $y$ 。你需要在每次操作之后求出这棵树的最大权独立集的权值大小。

#### 广义矩阵乘法

定义广义矩阵乘法 $A\times B=C$ 为：

$$
C_{i,j}=\max_{k=1}^{n}(A_{i,k}+B_{k,j})
$$

相当于将普通的矩阵乘法中的乘变为加，加变为 $\max$ 操作。

同时广义矩阵乘法满足结合律，所以可以使用矩阵快速幂。

#### 不带修改操作

令 $f_{i,0}$ 表示不选择 $i$ 的最大答案， $f_{i,1}$ 表示选择 $i$ 的最大答案。

则有 DP 方程：

$$
\begin{cases}f_{i,0}=\sum_{son}\max(f_{son,0},f_{son,1})\\f_{i,1}=w_i+\sum_{son}f_{son,0}\end{cases}
$$

答案就是 $\max(f_{root,0},f_{root,1})$ .

#### 带修改操作

首先将这棵树进行树链剖分，假设有这样一条重链：

/home/llj/Desktop/OI-wiki-master/docs/dp/![](./images/dynamic.png)

设 $g_{i,0}$ 表示不选择 $i$ 且只允许选择 $i$ 的轻儿子所在子树的最大答案， $g_{i,1}$ 表示选择 $i$ 的最大答案， $son_i$ 表示 $i$ 的重儿子。

假设我们已知 $g_{i,0/1}$ 那么有 DP 方程：

$$
\begin{cases}f_{i,0}=g_{i,0}+\max(f_{son_i,0},f_{son_i,1})\\f_{i,1}=g_{i,1}+f_{son_i,0}\end{cases}
$$

答案是 $\max(f_{root,0},f_{root,1})$ .

可以构造出矩阵：

$$
\begin{bmatrix}
g_{i,0} & g_{i,0}\\
g_{i,1} & -\infty
\end{bmatrix}\times 
\begin{bmatrix}
f_{son_i,0}\\f_{son_i,1}
\end{bmatrix}=
\begin{bmatrix}
f_{i,0}\\f_{i,1}
\end{bmatrix}
$$

注意，我们这里使用的是广义乘法规则。

可以发现，修改操作时只需要修改 $g_{i,1}$ 和每条往上的重链即可。

#### 具体思路

1.  DFS 预处理求出 $f_{i,0/1}$ 和 $g_{i,0/1}$ .

2.  对这棵树进行树剖（注意，因为我们对一个点进行询问需要计算从该点到该点所在的重链末尾的区间矩阵乘，所以对于每一个点记录 $End_i$ 表示 $i$ 所在的重链末尾节点编号），每一条重链建立线段树，线段树维护 $g$ 矩阵和 $g$ 矩阵区间乘积。

3.  修改时首先修改 $g_{i,1}$ 和线段树中 $i$ 节点的矩阵，计算 $top_i$ 矩阵的变化量，修改到 $fa_{top_i}$ 矩阵。

4.  查询时就是 1 到其所在的重链末尾的区间乘，最后取一个 $\max$ 即可。

??? note "代码实现"
    ```c++
    #include <bits/stdc++.h>
    
    using namespace std;
    
    #define REP(i, a, b) for (int i = (a), _end_ = (b); i <= _end_; ++i)
    #define mem(a) memset((a), 0, sizeof(a))
    #define str(a) strlen(a)
    #define lson root << 1
    #define rson root << 1 | 1
    typedef long long LL;
    
    const int maxn = 500010;
    const int INF = 0x3f3f3f3f;
    
    int Begin[maxn], Next[maxn], To[maxn], e, n, m;
    int size[maxn], son[maxn], top[maxn], fa[maxn], dis[maxn], p[maxn], id[maxn],
        End[maxn];
    // p[i]表示i树剖后的编号，id[p[i]] = i
    int cnt, tot, a[maxn], f[maxn][2];
    
    struct matrix {
      int g[2][2];
      matrix() { memset(g, 0, sizeof(g)); }
      matrix operator*(const matrix &b) const  // 重载矩阵乘
      {
        matrix c;
        REP(i, 0, 1)
        REP(j, 0, 1) REP(k, 0, 1) c.g[i][j] = max(c.g[i][j], g[i][k] + b.g[k][j]);
        return c;
      }
    } Tree[maxn], g[maxn];  // Tree[]是建出来的线段树，g[]是维护的每个点的矩阵
    
    inline void PushUp(int root) { Tree[root] = Tree[lson] * Tree[rson]; }
    
    inline void Build(int root, int l, int r) {
      if (l == r) {
        Tree[root] = g[id[l]];
        return;
      }
      int Mid = l + r >> 1;
      Build(lson, l, Mid);
      Build(rson, Mid + 1, r);
      PushUp(root);
    }
    
    inline matrix Query(int root, int l, int r, int L, int R) {
      if (L <= l && r <= R) return Tree[root];
      int Mid = l + r >> 1;
      if (R <= Mid) return Query(lson, l, Mid, L, R);
      if (Mid < L) return Query(rson, Mid + 1, r, L, R);
      return Query(lson, l, Mid, L, R) * Query(rson, Mid + 1, r, L, R);
      // 注意查询操作的书写
    }
    
    inline void Modify(int root, int l, int r, int pos) {
      if (l == r) {
        Tree[root] = g[id[l]];
        return;
      }
      int Mid = l + r >> 1;
      if (pos <= Mid)
        Modify(lson, l, Mid, pos);
      else
        Modify(rson, Mid + 1, r, pos);
      PushUp(root);
    }
    
    inline void Update(int x, int val) {
      g[x].g[1][0] += val - a[x];
      a[x] = val;
      // 首先修改x的g矩阵
      while (x) {
        matrix last = Query(1, 1, n, p[top[x]], End[top[x]]);
        // 查询top[x]的原本g矩阵
        Modify(1, 1, n,
               p[x]);  // 进行修改(x点的g矩阵已经进行修改但线段树上的未进行修改)
        matrix now = Query(1, 1, n, p[top[x]], End[top[x]]);
        // 查询top[x]的新g矩阵
        x = fa[top[x]];
        g[x].g[0][0] +=
            max(now.g[0][0], now.g[1][0]) - max(last.g[0][0], last.g[1][0]);
        g[x].g[0][1] = g[x].g[0][0];
        g[x].g[1][0] += now.g[0][0] - last.g[0][0];
        // 根据变化量修改fa[top[x]]的g矩阵
      }
    }
    
    inline void add(int u, int v) {
      To[++e] = v;
      Next[e] = Begin[u];
      Begin[u] = e;
    }
    
    inline void DFS1(int u) {
      size[u] = 1;
      int Max = 0;
      f[u][1] = a[u];
      for (int i = Begin[u]; i; i = Next[i]) {
        int v = To[i];
        if (v == fa[u]) continue;
        dis[v] = dis[u] + 1;
        fa[v] = u;
        DFS1(v);
        size[u] += size[v];
        if (size[v] > Max) {
          Max = size[v];
          son[u] = v;
        }
        f[u][1] += f[v][0];
        f[u][0] += max(f[v][0], f[v][1]);
        // DFS1过程中同时求出f[i][0/1]
      }
    }
    
    inline void DFS2(int u, int t) {
      top[u] = t;
      p[u] = ++cnt;
      id[cnt] = u;
      End[t] = cnt;
      g[u].g[1][0] = a[u];
      g[u].g[1][1] = -INF;
      if (/home/llj/Desktop/OI-wiki-master/docs/dp/!son[u]) return;
      DFS2(son[u], t);
      for (int i = Begin[u]; i; i = Next[i]) {
        int v = To[i];
        if (v == fa[u] || v == son[u]) continue;
        DFS2(v, v);
        g[u].g[0][0] += max(f[v][0], f[v][1]);
        g[u].g[1][0] += f[v][0];
        // g矩阵根据f[i][0/1]求出
      }
      g[u].g[0][1] = g[u].g[0][0];
    }
    
    int main() {
    #ifndef ONLINE_JUDGE
      freopen("input.txt", "r", stdin);
      freopen("output.txt", "w", stdout);
    #endif
      scanf("%d%d", &n, &m);
      REP(i, 1, n) scanf("%d", &a[i]);
      REP(i, 1, n - 1) {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v);
        add(v, u);
      }
      dis[1] = 1;
      DFS1(1);
      DFS2(1, 1);
      Build(1, 1, n);
      REP(i, 1, m) {
        int x, val;
        scanf("%d%d", &x, &val);
        Update(x, val);
        matrix ans = Query(1, 1, n, 1, End[1]);  // 查询1所在重链的矩阵乘
        printf("%d\n", max(ans.g[0][0], ans.g[1][0]));
      }
      return 0;
    }
    ```

# plug
有些 [状压 DP](./state.md) 问题要求我们记录状态的连通性信息，这类问题一般被形象的称为插头 DP 或连通性状态压缩 DP。例如格点图的哈密顿路径计数，求棋盘的黑白染色方案满足相同颜色之间形成一个连通块的方案数，以及特定图的生成树计数等等。这些问题通常需要我们对状态的连通性进行编码，讨论状态转移过程中连通性的变化。

## 骨牌覆盖与轮廓线 DP

温故而知新，在开始学习插头 DP 之前，不妨先让我们回顾一个经典问题。

??? note " 例题[「HDU 1400」Mondriaan’s Dream](https://vjudge.net/problem/HDU-1400)"
    题目大意：在  N×M 的棋盘内铺满 1×2 或 2×1 的多米诺骨牌，求方案数。

当 n 或 m 规模不大的时候，这类问题可以使用 [状压 DP](./state.md) 解决。逐行划分阶段，状态 `dp[i][s]` 表示当前已考虑过前 `i` 行，且第 `i` 行的状态为 `s` 的方案数。这里的状态 s 的每一位可以表示这个这个位置是否已被上一行覆盖。

![domino](./images/domino.png)（Credits: 图片来自 [这里](https://blog.csdn.net/u014634338/article/details/50015825) 。）

另一种划分阶段的方法是逐格 DP，或者称之为轮廓线 DP。 `dp[i][j][s]` 表示已经考虑到第 `i` 行第 `j` 列，且当前轮廓线上的状态为 `s` 的方案数。

虽然逐格 DP 中我们的状态增加了一个维度，但是转移的时间复杂度减少为 `O(1)` ，所以时间复杂度未变。我们用 `f0` 表示当前阶段的状态，用 `f1` 表示下一阶段的状态， `u = f0[s]` 表示当前枚举的函数值，那么有如下的状态转移方程：

```cpp
if (s >> j & 1) {       // 如果已被覆盖
  f1[s ^ 1 << j] += u;  // 不放
} else {                // 如果未被覆盖
  if (j != m - 1 && (!(s >> j + 1 & 1))) f1[s ^ 1 << j + 1] += u;  // 横放
  f1[s ^ 1 << j] += u;                                             // 竖放
}
```

观察到这里不放和竖放的方程可以合并。

??? 例题代码
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 11;
    long long f[2][1 << N], *f0, *f1;
    int n, m;
    int main() {
      while (cin >> n >> m && n) {
        f0 = f[0];
        f1 = f[1];
        fill(f1, f1 + (1 << m), 0);
        f1[0] = 1;
        for (int i = 0; i < n; ++i) {
          for (int j = 0; j < m; ++j) {
            swap(f0, f1);
            fill(f1, f1 + (1 << m), 0);
    #define u f0[s]
            for (int s = 0; s < 1 << m; ++s)
              if (u) {
                if (j != m - 1 && (!(s >> j & 3))) f1[s ^ 1 << j + 1] += u;  // 横放
                f1[s ^ 1 << j] += u;  // 竖放或不放
              }
          }
        }
        cout << f1[0] << endl;
      }
    }
    ```

??? note " 习题[「SRM 671. Div 1 900」BearDestroys](https://competitiveprogramming.info/topcoder/srm/round/16551/div/1)"
    题目大意：给定 `n*m` 的矩阵，每个格子有 `E` 或 `S` 。
    对于一个矩阵，有一个计分方案。按照行优先的规则扫描每个格子，如果这个格子之前被骨牌占据，则 skip。
    否则尝试放多米诺骨牌。如果放骨牌的方向在矩阵外或被其他骨牌占据，则放置失败，切换另一种方案或 skip。
    如果是 `E` 则优先放一个 `1*2` 的骨牌，
    如果是 `S` 则优先放一个 `2*1` 的骨牌。
    一个矩阵的得分为最后放的骨牌数。
    问所有 `2^(n*m)` 种矩阵的得分的和。

### 术语

阶段：动态规划执行的顺序，后续阶段的结果只与前序阶段的结果有关（无后效性）。很多 DP 问题可以有多种划分阶段的方式。例如在背包问题中，我们通常既可以按照物品划分阶段，也可以按照背包容量划分阶段（外层循环先枚举什么）。而在多米诺骨牌问题中，我们可以按照行、列、格子以及对角线等特征划分阶段。

轮廓线：已决策状态和未决策状态的分界线。

![contour line](./images/contour_line.png)

插头：一个格子某个方向的插头存在，表示这个格子在这个方向与相邻格子相连。

![contour line](./images/plug.png)

## 路径模型

### 多条回路

??? note " 例题[「HDU 1693」Eat the Trees](https://vjudge.net/problem/HDU-1693)"
    题目大意：求用若干条回路覆盖 N×M 棋盘的方案数，有些位置有障碍。

严格来说，多条回路问题并不属于插头 DP，因为我们只需要和上面的骨牌覆盖问题一样，记录插头是否存在，然后成对的合并和生成插头就可以了。

注意对于一个宽度为 `m` 的棋盘，轮廓线的宽度为 `m+1` ，因为包含 `m` 个上插头，和 `1` 个左插头。注意，当一行迭代完成之后，最右边的左插头通常是不合法的状态，同时我们需要补上下一行第一个左插头，这需要我们调整当前轮廓线的状态，通常是所有状态进行左移，我们把这个操作称为滚动 `roll()` 。

??? 例题代码
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 11;
    long long f[2][1 << (N + 1)], *f0, *f1;
    int n, m;
    int main() {
      int T;
      cin >> T;
      for (int Case = 1; Case <= T; ++Case) {
        cin >> n >> m;
        f0 = f[0];
        f1 = f[1];
        fill(f1, f1 + (1 << m + 1), 0);
        f1[0] = 1;
        for (int i = 0; i < n; ++i) {
          for (int j = 0; j < m; ++j) {
            bool bad;
            cin >> bad;
            bad ^= 1;
            swap(f0, f1);
            fill(f1, f1 + (1 << m + 1), 0);
    #define u f0[s]
            for (int s = 0; s < 1 << m + 1; ++s)
              if (u) {
                bool lt = s >> j & 1, up = s >> j + 1 & 1;
                if (bad) {
                  if (!lt && !up) f1[s] += u;
                } else {
                  f1[s ^ 3 << j] += u;
                  if (lt != up) f1[s] += u;
                }
              }
          }
          swap(f0, f1);
          fill(f1, f1 + (1 << m + 1), 0);
          for (int s = 0; s < 1 << m; ++s) f1[s << 1] = u;
        }
        printf("Case %d: There are %lld ways to eat the trees.\n", Case, f1[0]);
      }
    }
    ```

??? note " 习题[「ZJU 4231」The Hive II](https://vjudge.net/problem/ZOJ-3466)"
    题目大意：同上题，但格子变成了六边形。

### 一条回路

#### 例题「Andrew Stankevich Contest 16 - Problem F」Pipe Layout

??? note " 例题[「Andrew Stankevich Contest 16 - Problem F」Pipe Layout](https://codeforces.com/gym/100220)"
    题目大意：求用一条回路覆盖 `N×M` 棋盘的方案数。

在上面的状态表示中我们每合并一组连通的插头，就会生成一条独立的回路，因而在本题中，我们还需要区分插头之间的连通性（出现了！）。这需要我们对状态进行额外的编码。

#### 状态编码

通常的编码方案有括号表示和最小表示，这里着重介绍泛用性更好的最小表示。我们用长度 `m+1` 的整形数组，记录轮廓线上每个插头的状态， `0` 表示没有插头，并约定连通的插头用相同的数字进行标记。

那么下面两组编码方式表示的是相同的状态：

-    `0 3 1 0 1 3` 
-    `0 1 2 0 2 1` 

我们将相同的状态都映射成字典序最小表示，例如在上例中的 `0 1 2 0 2 1` 就是一组最小表示。

我们用 `b[]` 数组表示轮廓线上插头的状态。 `bb[]` 表示在最小表示的编码的过程中，每个数字被映射到的最小数字。注意 `0` 表示插头不存在，不能被映射成其他值。

```cpp
int b[M + 1], bb[M + 1];
int encode() {
  int s = 0;
  memset(bb, -1, sizeof(bb));
  int bn = 1;
  bb[0] = 0;
  for (int i = m; i >= 0; --i) {
#define bi bb[b[i]]
    if (!~bi) bi = bn++;
    s <<= offset;
    s |= bi;
  }
  return s;
}
void decode(int s) {
  REP(i, m + 1) {
    b[i] = s & mask;
    s >>= offset;
  }
}
```

我们注意到插头总是成对出现，成对消失的。因而 `0 1 2 0 1 2` 这样的状态是不合法的。合法的状态构成一组括号序列，实际中合法状态可能是非常稀疏的。

#### 手写哈希

在一些 [状压 DP](./state.md) 的问题中，合法的状态可能是稀疏的（例如本题），为了优化时空复杂度，我们可以使用哈希表存储合法的 `DP` 状态。对于 `cpp` 选手，我们可以使用 [std::unordered_map](http://www.cplusplus.com/reference/unordered_map/unordered_map/) ，当然也可以直接手写，这样可以灵活的将状态转移函数也封装于其中。

```cpp
const int MaxSZ = 16796, Prime = 9973;
struct hashTable {
  int head[Prime], next[MaxSZ], sz;
  int state[MaxSZ];
  long long key[MaxSZ];
  inline void clear() {
    sz = 0;
    memset(head, -1, sizeof(head));
  }
  inline void push(int s) {
    int x = s % Prime;
    for (int i = head[x]; ~i; i = next[i]) {
      if (state[i] == s) {
        key[i] += d;
        return;
      }
    }
    state[sz] = s, key[sz] = d;
    next[sz] = head[x];
    head[x] = sz++;
  }
  void roll() { REP(i, sz) state[i] <<= offset; }
} H[2], *H0, *H1;
```

上面的代码中：

-    `MaxSZ` 表示合法状态的上界，可以估计，也可以预处理出较为精确的值。
-    `Prime` 一个小于 `MaxSZ` 的大素数。
-    `head[]` 表头节点的指针。
-    `next[]` 后续状态的指针。
-    `state[]` 节点的状态。
-    `key[]` 节点的关键字，在本题中是方案数。
-    `clear()` 初始化函数，和手写邻接表类似，我们只需要初始化表头节点的指针。
-    `push()` 状态转移函数，其中 `d` 是一个全局变量（偷懒），表示每次状态转移所带来的增量。如果找到的话就 `+=` ，否则就创建一个状态为 `s` ，关键字为 `d` 的新节点。
-    `roll()` 迭代完一整行之后，滚动轮廓线。

关于哈希表的复杂度分析，以及开哈希和闭哈希的不同，可以参见 [《算法导论》](https://oi-wiki.org/intro/resources/#_5) 中关于散列表的相关章节。

#### 状态转移讨论

```cpp
REP(ii, H0->sz) {
  decode(H0->state[ii]);                  // 取出状态，并解码
  d = H0->key[ii];                        // 得到增量 delta
  int lt = b[j], up = b[j + 1];           // 左插头，上插头
  bool dn = i != n - 1, rt = j != m - 1;  // 下插头，右插头
  if (lt && up) {                         // 如果左、上均有插头
    if (lt == up) {                       // 来自同一个连通块
      if (i == n - 1 &&
          j == m - 1) {  // 只有在最后一个格子时，才能合并，封闭回路。
        push(j, 0, 0);
      }
    } else {  // 否则，必须合并这两个连通块，因为本题中需要回路覆盖
      REP(i, m + 1) if (b[i] == lt) b[i] = up;
      push(j, 0, 0);
    }
  } else if (lt || up) {  // 如果左、上之中有一个插头
    int t = lt | up;      // 得到这个插头
    if (dn) {             // 如果可以向下延伸
      push(j, t, 0);
    }
    if (rt) {  // 如果可以向右延伸
      push(j, 0, t);
    }
  } else {           // 如果左、上均没有插头
    if (dn && rt) {  // 生成一对新插头
      push(j, m, m);
    }
  }
}
```

??? 例题代码
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    #define REP(i, n) for (int i = 0; i < n; ++i)
    const int M = 10;
    const int offset = 3, mask = (1 << offset) - 1;
    int n, m;
    long long ans, d;
    const int MaxSZ = 16796, Prime = 9973;
    struct hashTable {
      int head[Prime], next[MaxSZ], sz;
      int state[MaxSZ];
      long long key[MaxSZ];
      inline void clear() {
        sz = 0;
        memset(head, -1, sizeof(head));
      }
      inline void push(int s) {
        int x = s % Prime;
        for (int i = head[x]; ~i; i = next[i]) {
          if (state[i] == s) {
            key[i] += d;
            return;
          }
        }
        state[sz] = s, key[sz] = d;
        next[sz] = head[x];
        head[x] = sz++;
      }
      void roll() { REP(i, sz) state[i] <<= offset; }
    } H[2], *H0, *H1;
    int b[M + 1], bb[M + 1];
    int encode() {
      int s = 0;
      memset(bb, -1, sizeof(bb));
      int bn = 1;
      bb[0] = 0;
      for (int i = m; i >= 0; --i) {
    #define bi bb[b[i]]
        if (!~bi) bi = bn++;
        s <<= offset;
        s |= bi;
      }
      return s;
    }
    void decode(int s) {
      REP(i, m + 1) {
        b[i] = s & mask;
        s >>= offset;
      }
    }
    void push(int j, int dn, int rt) {
      b[j] = dn;
      b[j + 1] = rt;
      H1->push(encode());
    }
    int main() {
    #ifdef ONLINE_JUDGE
      freopen("pipe.in", "r", stdin);
      freopen("pipe.out", "w", stdout);
    #endif
      cin >> n >> m;
      if (m > n) swap(n, m);
      H0 = H, H1 = H + 1;
      H1->clear();
      d = 1;
      H1->push(0);
      REP(i, n) {
        REP(j, m) {
          swap(H0, H1);
          H1->clear();
          REP(ii, H0->sz) {
            decode(H0->state[ii]);
            d = H0->key[ii];
            int lt = b[j], up = b[j + 1];
            bool dn = i != n - 1, rt = j != m - 1;
            if (lt && up) {
              if (lt == up) {
                if (i == n - 1 && j == m - 1) {
                  push(j, 0, 0);
                }
              } else {
                REP(i, m + 1) if (b[i] == lt) b[i] = up;
                push(j, 0, 0);
              }
            } else if (lt || up) {
              int t = lt | up;
              if (dn) {
                push(j, t, 0);
              }
              if (rt) {
                push(j, 0, t);
              }
            } else {
              if (dn && rt) {
                push(j, m, m);
              }
            }
          }
        }
        H1->roll();
      }
      assert(H1->sz <= 1);
      cout << (H1->sz == 1 ? H1->key[0] : 0) << endl;
    }
    ```

#### 习题

??? note " 习题[「Ural 1519」Formula 1](https://acm.timus.ru/problem.aspx?space=1&num=1519)"
    题目大意：有障碍。

??? note " 习题[「USACO 5.4.4」Betsy's Tours](http://oj.jzxx.net/problem.php?id=1695)"
    题目大意：一个 N\*N 的方阵（N&lt;=7），求从左上角出发到左下角结束经过每个格子的路径总数。虽然是一条路径，但因为起点和终点固定，可以转化为一条回路问题。

??? note " 习题[「POJ 1739」Tony's Tour](http://poj.org/problem?id=1739)"
    题目大意：著名的男人八题系列之一。解法同上。

??? note " 习题[「USACO 6.1.1」Postal Vans](https://vjudge.net/problem/UVALive-2738)"
    题目大意：n&lt;= 1000，m = 4，每个回路需要统计两次（逆时针和顺时针），需要高精度。

??? note " 习题[「ProjectEuler 393」Migrating ants](https://projecteuler.net/problem=393)"
    题目大意：对于每一个有 `m` 条回路的方案，对答案的贡献是 `2^m` ，求所有方案的贡献和。

### 一条路径

#### 例题「ZOJ 3213」Beautiful Meadow

??? note " 例题[「ZOJ 3213」Beautiful Meadow](https://vjudge.net/problem/ZOJ-3213)"
    题目大意：一个 N\*M 的方阵（N, M&lt;=8），每个格点有一个权值，求一段路径，最大化路径覆盖的格点的权值和。

本题是标准的一条路径问题，在一条路径问题中，编码的状态中还会存在不能配对的独立插头。需要在状态转移函数中，额外讨论独立插头的生成、合并与消失的情况。独立插头的生成和消失对应着路径的一端，因而这类事件不会发生超过两次（一次生成一次消失，或者两次生成一次合并），否则最终结果一定会出现多个连通块。

我们需要在状态中额外记录这类事件发生的总次数，可以将这个信息编码进状态里（注意，类似这样的额外信息在调整轮廓线的时候，不需要跟着滚动），当然也可以在 `hashTable` 数组的外面加维。下面的范例程序中我们选择后者。

#### 状态转移

```cpp
REP(i, n) {
  REP(j, m) {
    checkMax(ans, A[i][j]);  // 需要单独处理一个格子的情况
    if (!A[i][j]) continue;  // 如果有障碍，则跳过，注意这时状态数组不需要滚动
    swap(H0, H1);
    REP(c, 3)
    H1[c].clear();  // c 表示生成和消失事件发生的总次数，最多不超过 2 次
    REP(c, 3) REP(ii, H0[c].sz) {
      decode(H0[c].state[ii]);
      d = H0[c].key[ii] + A[i][j];
      int lt = b[j], up = b[j + 1];
      bool dn = A[i + 1][j], rt = A[i][j + 1];
      if (lt && up) {
        if (lt == up) {  // 在一条路径问题中，我们不能合并相同的插头。
          // Cannot deploy here...
        } else {  // 有可能参与合并的两者中有独立插头，但是也可以用同样的代码片段处理
          REP(i, m + 1) if (b[i] == lt) b[i] = up;
          push(c, j, 0, 0);
        }
      } else if (lt || up) {
        int t = lt | up;
        if (dn) {
          push(c, j, t, 0);
        }
        if (rt) {
          push(c, j, 0, t);
        }
        // 一个插头消失的情况，如果是独立插头则意味着消失，如果是成对出现的插头则相当于生成了一个独立插头，
        // 无论哪一类事件都需要将 c + 1。
        if (c < 2) {
          push(c + 1, j, 0, 0);
        }
      } else {
        d -= A[i][j];
        H1[c].push(H0[c].state[ii]);
        d += A[i][j];    // 跳过插头生成，本题中不要求全部覆盖
        if (dn && rt) {  // 生成一对插头
          push(c, j, m, m);
        }
        if (c < 2) {  // 生成一个独立插头
          if (dn) {
            push(c + 1, j, m, 0);
          }
          if (rt) {
            push(c + 1, j, 0, m);
          }
        }
      }
    }
  }
  REP(c, 3) H1[c].roll();  // 一行结束，调整轮廓线
}
```

??? 例题代码
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    #define REP(i, n) for (int i = 0; i < n; ++i)
    template <class T>
    inline bool checkMax(T &a, const T b) {
      return a < b ? a = b, 1 : 0;
    }
    const int N = 8, M = 8;
    const int offset = 3, mask = (1 << offset) - 1;
    int A[N + 1][M + 1];
    int n, m;
    int ans, d;
    const int MaxSZ = 16796, Prime = 9973;
    struct hashTable {
      int head[Prime], next[MaxSZ], sz;
      int state[MaxSZ];
      int key[MaxSZ];
      inline void clear() {
        sz = 0;
        memset(head, -1, sizeof(head));
      }
      inline void push(int s) {
        int x = s % Prime;
        for (int i = head[x]; ~i; i = next[i]) {
          if (state[i] == s) {
            checkMax(key[i], d);
            return;
          }
        }
        state[sz] = s, key[sz] = d;
        next[sz] = head[x];
        head[x] = sz++;
      }
      void roll() { REP(i, sz) state[i] <<= offset; }
    } H[2][3], *H0, *H1;
    int b[M + 1], bb[M + 1];
    int encode() {
      int s = 0;
      memset(bb, -1, sizeof(bb));
      int bn = 1;
      bb[0] = 0;
      for (int i = m; i >= 0; --i) {
    #define bi bb[b[i]]
        if (!~bi) bi = bn++;
        s <<= offset;
        s |= bi;
      }
      return s;
    }
    void decode(int s) {
      REP(i, m + 1) {
        b[i] = s & mask;
        s >>= offset;
      }
    }
    void push(int c, int j, int dn, int rt) {
      b[j] = dn;
      b[j + 1] = rt;
      H1[c].push(encode());
    }
    void init() {
      cin >> n >> m;
      H0 = H[0], H1 = H[1];
      REP(c, 3) H1[c].clear();
      d = 0;
      H1[0].push(0);
      memset(A, 0, sizeof(A));
      REP(i, n) REP(j, m) cin >> A[i][j];
    }
    void solve() {
      ans = 0;
      REP(i, n) {
        REP(j, m) {
          checkMax(ans, A[i][j]);
          if (!A[i][j]) continue;
          swap(H0, H1);
          REP(c, 3) H1[c].clear();
          REP(c, 3) REP(ii, H0[c].sz) {
            decode(H0[c].state[ii]);
            d = H0[c].key[ii] + A[i][j];
            int lt = b[j], up = b[j + 1];
            bool dn = A[i + 1][j], rt = A[i][j + 1];
            if (lt && up) {
              if (lt == up) {
                // Cannot deploy here...
              } else {
                REP(i, m + 1) if (b[i] == lt) b[i] = up;
                push(c, j, 0, 0);
              }
            } else if (lt || up) {
              int t = lt | up;
              if (dn) {
                push(c, j, t, 0);
              }
              if (rt) {
                push(c, j, 0, t);
              }
              if (c < 2) {
                push(c + 1, j, 0, 0);
              }
            } else {
              d -= A[i][j];
              H1[c].push(H0[c].state[ii]);
              d += A[i][j];  // skip
              if (dn && rt) {
                push(c, j, m, m);
              }
              if (c < 2) {
                if (dn) {
                  push(c + 1, j, m, 0);
                }
                if (rt) {
                  push(c + 1, j, 0, m);
                }
              }
            }
          }
        }
        REP(c, 3) H1[c].roll();
      }
      REP(ii, H1[2].sz) checkMax(ans, H1[2].key[ii]);
      cout << ans << endl;
    }
    int main() {
    #ifndef ONLINE_JUDGE
      freopen("in.txt", "r", stdin);
    #endif
      int T;
      cin >> T;
      while (T--) {
        init();
        solve();
      }
    }
    ```

#### 习题

??? note " 习题[「NOI 2010 Day2」旅行路线](https://www.luogu.com.cn/problem/P1933)"
    题目大意：n × m 的棋盘，棋盘的每个格子有一个 01 权值 T[x][y]，要求寻找一个路径覆盖，满足：
    
    -   第 i 个参观的格点 (x, y)，满足 T[x][y]= L[i]
    -   路径的一端在棋盘的边界上

    求可行的方案数 mod 11192869。

## 染色模型

除了路径模型之外，还有一类常见的模型，需要我们对棋盘进行染色，相邻的相同颜色节点被视为连通。在路径类问题中，状态转移的时候我们枚举当前路径的方向，而在染色类问题中，我们枚举当前节点染何种颜色。在染色模型中，状态中处在相同连通性的节点可能不止两个。但总体来说依然大同小异。我们不妨来看一个经典的例题。

### 例题「UVA 10572」Black & White

??? note " 例题[「UVA 10572」Black & White](https://vjudge.net/problem/UVA-10572)"
    题目大意：在 N×M 的棋盘内对未染色的格点进行黑白染色，要求所有黑色区域和白色区域连通，且任意一个 2x2 的子矩形内的颜色不能完全相同（例如下图中的情况非法），求合法的方案数，并构造一组合法的方案。

    ![black_and_white1](./images/black_and_white1.png)

#### 状态编码

我们先考虑状态编码。不考虑连通性，那么就是 [SGU 197. Nice Patterns Strike Back](https://codeforces.com/problemsets/acmsguru/problem/99999/197) ，不难用 [状压 DP](./state.md) 直接解决。现在我们需要在状态中同时体现颜色和连通性的信息，考察轮廓线上每个位置的状态，二进制的每 `Offset` 位描述轮廓线上的一个位置，因为只有黑白两种颜色，我们用最低位的奇偶性表示颜色，其余部分示连通性。

考虑第一行上面的节点，和第一列左侧节点，如果要避免特判的话，可以考虑引入第三种颜色区分它们，这里我们观察到这些边界状态的连通性信息一定为 0，所以不需要对第三种颜色再进行额外编码。

在路径问题中我们的轮廓线是由 `m` 个上插头与 `1` 个左插头组成的。本题中，由于我们还需要判断当前格点为右下角的 `2x2` 子矩形是否合法，所以需要记录左上角格子的颜色，因此轮廓线的长度依然是 `m+1` 。

这样的编码方案中依然保留了很多冗余信息，（连通的区域颜色一定相同，且左上角的格子只需要颜色信息不需要连通性），但是因为已经用了哈希表和最小表示，对时间复杂度的影响不大，为了降低编程压力，就不再细化了。

在最多情况下（例如第一行黑白相间），每个插头的连通性信息都不一样，因此我们需要 `4` 位二进制位记录连通性，再加上颜色信息，本题的 `Offset` 为 `5` 位。

```cpp
const int Offset = 5, Mask = (1 << Offset) - 1;
int c[N + 2];
int b[N + 2], bb[N + 3];
T_state encode() {
  T_state s = 0;
  memset(bb, -1, sizeof(bb));
  int bn = 1;
  bb[0] = 0;
  for (int i = m; i >= 0; --i) {
#define bi bb[b[i]]
    if (!~bi) bi = bn++;
    s <<= Offset;
    s |= (bi << 1) | c[i];
  }
  return s;
}
void decode(T_state s) {
  REP(i, m + 1) {
    b[i] = s & Mask;
    c[i] = b[i] & 1;
    b[i] >>= 1;
    s >>= Offset;
  }
}
```

#### 手写哈希

因为需要构造任意一组方案，这里的哈希表我们需要添加一组域 `pre[]` 来记录每个状态在上一阶段的任意一个前驱。

```cpp
const int Prime = 9979, MaxSZ = 1 << 20;
template <class T_state, class T_key>
struct hashTable {
  int head[Prime];
  int next[MaxSZ], sz;
  T_state state[MaxSZ];
  T_key key[MaxSZ];
  int pre[MaxSZ];
  void clear() {
    sz = 0;
    memset(head, -1, sizeof(head));
  }
  void push(T_state s, T_key d, T_state u) {
    int x = s % Prime;
    for (int i = head[x]; ~i; i = next[i]) {
      if (state[i] == s) {
        key[i] += d;
        return;
      }
    }
    state[sz] = s, key[sz] = d, pre[sz] = u;
    next[sz] = head[x], head[x] = sz++;
  }
  void roll() { REP(ii, sz) state[ii] <<= Offset; }
};
hashTable<T_state, T_key> _H, H[N][N], *H0, *H1;
```

#### 方案构造

有了上面的信息，我们就可以容易的构造方案了。首先遍历当前哈希表中的状态，如果连通块数目不超过 `2` ，那么统计进方案数。如果方案数不为 `0` ，我们倒序用 `pre` 数组构造出方案，注意每一行的末尾因为我们执行了 `Roll()` 操作，颜色需要取 `c[j+1]` 。

```cpp
void print() {
  T_key z = 0;
  int u;
  REP(i, H1->sz) {
    decode(H1->state[i]);
    if (*max_element(b + 1, b + m + 1) <= 2) {
      z += H1->key[i];
      u = i;
    }
  }
  cout << z << endl;
  if (z) {
    DWN(i, n, 0) {
      B[i][m] = 0;
      DWN(j, m, 0) {
        decode(H[i][j].state[u]);
        int cc = j == m - 1 ? c[j + 1] : c[j];
        B[i][j] = cc ? 'o' : '#';
        u = H[i][j].pre[u];
      }
    }
    REP(i, n) puts(B[i]);
  }
  puts("");
}
```

#### 状态转移

我们记：

-    `cc` 当前正在染色的格子的颜色
-    `lf` 左边格子的颜色
-    `up` 上边格子的颜色
-    `lu` 左上格子的颜色

我们用 `-1` 表示颜色不存在。接下来讨论状态转移，一共有三种情况，合并，继承与生成：

```cpp
void trans(int i, int j, int u, int cc) {
  decode(H0->state[u]);
  int lf = j ? c[j - 1] : -1, lu = b[j] ? c[j] : -1,
      up = b[j + 1] ? c[j + 1] : -1;  // 没有颜色也是颜色的一种！
  if (lf == cc && up == cc) {         // 合并
    if (lu == cc) return;             // 2x2 子矩形相同的情况
    int lf_b = b[j - 1], up_b = b[j + 1];
    REP(i, m + 1) if (b[i] == up_b) { b[i] = lf_b; }
    b[j] = lf_b;
  } else if (lf == cc || up == cc) {  // 继承
    if (lf == cc)
      b[j] = b[j - 1];
    else
      b[j] = b[j + 1];
  } else {                                             // 生成
    if (i == n - 1 && j == m - 1 && lu == cc) return;  // 特判
    b[j] = m + 2;
  }
  c[j] = cc;
  if (!ok(i, j, cc)) return;  // 判断是否会因生成封闭的连通块导致不合法
  H1->push(encode(), H0->key[u], u);
}
```

对于最后一种情况需要注意的是，如果已经生成了一个封闭的连通区域，那么我们不能再使用她的颜色染色，否则这种颜色会出现两个连通块。我们似乎需要额度记录这种事件，可以参考 [「ZOJ 3213」Beautiful Meadow](#zoj-3213beautiful-meadow) 中的做法，再开一维记录这个事件。不过利用本题的特殊性，我们也可以特判掉。

```cpp
bool ok(int i, int j, int cc) {
  if (cc == c[j + 1]) return true;
  int up = b[j + 1];
  if (!up) return true;
  int c1 = 0, c2 = 0;
  REP(i, m + 1) if (i != j + 1) {
    if (b[i] == b[j + 1]) {  // 连通性相同，颜色一定相同
      assert(c[i] == c[j + 1]);
    }
    if (c[i] == c[j + 1] && b[i] == b[j + 1]) ++c1;
    if (c[i] == c[j + 1]) ++c2;
  }
  if (!c1) {               // 如果会生成新的封闭连通块
    if (c2) return false;  // 如果轮廓线上还有相同的颜色
    if (i < n - 1 || j < m - 2) return false;
  }
  return true;
}
```

进一步讨论连通块消失的情况。每当我们对一个格子进行染色后，如果没有其他格子与其上侧的格子连通，那么会形成一个封闭的连通块。这个事件仅在最后一行的最后两列时可以发生，否则后续为了不出现 `2x2` 的同色连通块，这个颜色一定会再次出现，除了下面的情况：

    2 2
    o#
    #o

我们特判掉这种，这样在本题中，就可以偷懒不用记录之前是否已经生成了封闭的连通块了。

??? 例题代码
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    #define REP(i, n) for (int i = 0; i < n; ++i)
    #define DWN(i, b, a) for (int i = b - 1; i >= a; --i)
    typedef long long T_state;
    typedef int T_key;
    const int N = 8;
    int n, m;
    char A[N + 1][N + 1], B[N + 1][N + 1];
    const int Offset = 5, Mask = (1 << Offset) - 1;
    int c[N + 2];
    int b[N + 2], bb[N + 3];
    T_state encode() {
      T_state s = 0;
      memset(bb, -1, sizeof(bb));
      int bn = 1;
      bb[0] = 0;
      for (int i = m; i >= 0; --i) {
    #define bi bb[b[i]]
        if (!~bi) bi = bn++;
        s <<= Offset;
        s |= (bi << 1) | c[i];
      }
      return s;
    }
    void decode(T_state s) {
      REP(i, m + 1) {
        b[i] = s & Mask;
        c[i] = b[i] & 1;
        b[i] >>= 1;
        s >>= Offset;
      }
    }
    const int Prime = 9979, MaxSZ = 1 << 20;
    template <class T_state, class T_key>
    struct hashTable {
      int head[Prime];
      int next[MaxSZ], sz;
      T_state state[MaxSZ];
      T_key key[MaxSZ];
      int pre[MaxSZ];
      void clear() {
        sz = 0;
        memset(head, -1, sizeof(head));
      }
      void push(T_state s, T_key d, T_state u) {
        int x = s % Prime;
        for (int i = head[x]; ~i; i = next[i]) {
          if (state[i] == s) {
            key[i] += d;
            return;
          }
        }
        state[sz] = s, key[sz] = d, pre[sz] = u;
        next[sz] = head[x], head[x] = sz++;
      }
      void roll() { REP(ii, sz) state[ii] <<= Offset; }
    };
    hashTable<T_state, T_key> _H, H[N][N], *H0, *H1;
    bool ok(int i, int j, int cc) {
      if (cc == c[j + 1]) return true;
      int up = b[j + 1];
      if (!up) return true;
      int c1 = 0, c2 = 0;
      REP(i, m + 1) if (i != j + 1) {
        if (b[i] == b[j + 1]) {
          assert(c[i] == c[j + 1]);
        }
        if (c[i] == c[j + 1] && b[i] == b[j + 1]) ++c1;
        if (c[i] == c[j + 1]) ++c2;
      }
      if (!c1) {               // 如果会生成新的封闭连通块
        if (c2) return false;  // 如果轮廓线上还有相同的颜色
        if (i < n - 1 || j < m - 2) return false;
      }
      return true;
    }
    void trans(int i, int j, int u, int cc) {
      decode(H0->state[u]);
      int lf = j ? c[j - 1] : -1, lu = b[j] ? c[j] : -1,
          up = b[j + 1] ? c[j + 1] : -1;
      if (lf == cc && up == cc) {
        if (lu == cc) return;
        int lf_b = b[j - 1], up_b = b[j + 1];
        REP(i, m + 1) if (b[i] == up_b) { b[i] = lf_b; }
        b[j] = lf_b;
      } else if (lf == cc || up == cc) {
        if (lf == cc)
          b[j] = b[j - 1];
        else
          b[j] = b[j + 1];
      } else {
        if (i == n - 1 && j == m - 1 && lu == cc) return;
        b[j] = m + 2;
      }
      c[j] = cc;
      if (!ok(i, j, cc)) return;
      H1->push(encode(), H0->key[u], u);
    }
    void init() {
      cin >> n >> m;
      REP(i, n) scanf("%s", A[i]);
    }
    void solve() {
      H1 = &_H, H1->clear(), H1->push(0, 1, 0);
      REP(i, n) {
        REP(j, m) {
          H0 = H1, H1 = &H[i][j], H1->clear();
          REP(u, H0->sz) {
            if (A[i][j] == '.' || A[i][j] == '#') trans(i, j, u, 0);
            if (A[i][j] == '.' || A[i][j] == 'o') trans(i, j, u, 1);
          }
        }
        H1->roll();
      }
    }
    void print() {
      T_key z = 0;
      int u;
      REP(i, H1->sz) {
        decode(H1->state[i]);
        if (*max_element(b + 1, b + m + 1) <= 2) {
          z += H1->key[i];
          u = i;
        }
      }
      cout << z << endl;
      if (z) {
        DWN(i, n, 0) {
          B[i][m] = 0;
          DWN(j, m, 0) {
            decode(H[i][j].state[u]);
            int cc = j == m - 1 ? c[j + 1] : c[j];
            B[i][j] = cc ? 'o' : '#';
            u = H[i][j].pre[u];
          }
        }
        REP(i, n) puts(B[i]);
      }
      puts("");
    }
    int main() {
    #ifndef ONLINE_JUDGE
      freopen("in.txt", "r", stdin);
    #endif
      int T;
      cin >> T;
      while (T--) {
        init();
        solve();
        print();
      }
    }
    ```

??? note " 习题[「Topcoder SRM 312. Div1 Hard」CheapestIsland](https://competitiveprogramming.info/topcoder/srm/round/9992/div/1)"
    题目大意：给一个棋盘图，每个格子有权值，求权值之和最小的连通块。

??? note " 习题[「JLOI 2009」神秘的生物](https://www.luogu.com.cn/problem/P3886)"
    题目大意：给一个棋盘图，每个格子有权值，求权值之和最大的连通块。

## 图论模型

??? note " 例题[「NOI 2007 Day2」生成树计数](https://www.luogu.com.cn/problem/P2109)"
    题目大意：某类特殊图的生成树计数，每个节点恰好与其前 k 个节点之间有边相连。

??? note " 例题[「2015 ACM-ICPC Asia Shenyang Regional Contest - Problem E」Efficient Tree](https://vjudge.net/problem/HDU-5513)"
    题目大意：给出一个 N×M 的网格图，以及相邻四联通格子之间的边权。
    对于一颗生成树，每个节点的得分为 1+[有一条连向上的边]+[有一条连向左的边]。
    生成树的得分为所有节点的得分之积。
    
    要求：
    最小生成树的边权和
    所有最小生成树的得分之和。
    （n&lt;=800, m&lt;7）

## 实战篇

### 例题「HDU 4113」Construct the Great Wall

??? note " 例题[「HDU 4113」Construct the Great Wall](https://vjudge.net/problem/HDU-4113)"
    题目大意：在 N×M 的棋盘内构造一组回路，分割所有的 `x` 和 `o` 。

有一类插头 DP 问题要求我们在棋盘上构造一组墙，以分割棋盘上的某些元素。不妨称之为修墙问题，这类问题既可视作染色模型，也可视作路径模型。

![greatwall](./images/greatwall.jpg)

在本题中，如果视作染色模型的话，不仅需要额外讨论染色区域的周长，还要判断在角上触碰而导致不合法的情况（图 2）。另外与 [「UVA 10572」Black & White](https://vjudge.net/problem/UVA-10572) 不同的是，本题中要求围墙为简单多边形，因而对于下面的回字形的情况，在本题中是不合法的。

    3 3
    ooo
    oxo
    ooo

因而我们使用路径模型，转化为 [一条回路](#一条回路) 来处理。

我们沿着棋盘的交叉点进行 DP（因而长宽需要增加 1），每次转移时，需要保证所有的 `x` 在回路之外， `o` 在回路之内。因此我们还需要维护当前位置是否在回路内部。对于这个信息我们可以加维，也可以直接统计轮廓线上到这个位置之前出现下插头次数的奇偶性（射线法）。

??? 例题代码
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    #define REP(i, n) for (int i = 0; i < n; ++i)
    template <class T>
    inline bool checkMin(T &a, const T b) {
      return b < a ? a = b, 1 : 0;
    }
    const int N = 10, M = N;
    const int offset = 3, mask = (1 << offset) - 1;
    int n, m;
    int d;
    const int INF = 0x3f3f3f3f;
    int b[M + 1], bb[M + 1];
    int encode() {
      int s = 0;
      memset(bb, -1, sizeof(bb));
      int bn = 1;
      bb[0] = 0;
      for (int i = m; i >= 0; --i) {
    #define bi bb[b[i]]
        if (!~bi) bi = bn++;
        s <<= offset;
        s |= bi;
      }
      return s;
    }
    void decode(int s) {
      REP(i, m + 1) {
        b[i] = s & mask;
        s >>= offset;
      }
    }
    const int MaxSZ = 16796, Prime = 9973;
    struct hashTable {
      int head[Prime], next[MaxSZ], sz;
      int state[MaxSZ];
      int key[MaxSZ];
      inline void clear() {
        sz = 0;
        memset(head, -1, sizeof(head));
      }
      inline void push(int s) {
        int x = s % Prime;
        for (int i = head[x]; ~i; i = next[i]) {
          if (state[i] == s) {
            checkMin(key[i], d);
            return;
          }
        }
        state[sz] = s, key[sz] = d;
        next[sz] = head[x];
        head[x] = sz++;
      }
      void roll() { REP(i, sz) state[i] <<= offset; }
    } H[2], *H0, *H1;
    char A[N + 1][M + 1];
    void push(int i, int j, int dn, int rt) {
      b[j] = dn;
      b[j + 1] = rt;
      if (A[i][j] != '.') {
        bool bad = A[i][j] == 'o';
        REP(jj, j + 1) if (b[jj]) bad ^= 1;
        if (bad) return;
      }
      H1->push(encode());
    }
    int solve() {
      cin >> n >> m;
      int ti, tj;
      REP(i, n) {
        scanf("%s", A[i]);
        REP(j, m) if (A[i][j] == 'o') ti = i, tj = j;
        A[i][m] = '.';
      }
      REP(j, m + 1) A[n][j] = '.';
      ++n, ++m, ++ti, ++tj;
      H0 = H, H1 = H + 1;
      H1->clear();
      d = 0;
      H1->push(0);
      int z = INF;
      REP(i, n) {
        REP(j, m) {
          swap(H0, H1);
          H1->clear();
          REP(ii, H0->sz) {
            decode(H0->state[ii]);
            d = H0->key[ii] + 1;
            int lt = b[j], up = b[j + 1];
            bool dn = i != n - 1, rt = j != m - 1;
            if (lt && up) {
              if (lt == up) {
                int cnt = 0;
                REP(i, m + 1) if (b[i])++ cnt;
                if (cnt == 2 && i == ti && j == tj) {
                  checkMin(z, d);
                }
              } else {
                REP(i, m + 1) if (b[i] == lt) b[i] = up;
                push(i, j, 0, 0);
              }
            } else if (lt || up) {
              int t = lt | up;
              if (dn) {
                push(i, j, t, 0);
              }
              if (rt) {
                push(i, j, 0, t);
              }
            } else {
              --d;
              push(i, j, 0, 0);
              ++d;
              if (dn && rt) {
                push(i, j, m, m);
              }
            }
          }
        }
        H1->roll();
      }
      if (z == INF) z = -1;
      return z;
    }
    int main() {
    #ifndef ONLINE_JUDGE
      freopen("in.txt", "r", stdin);
    #endif
      int T;
      cin >> T;
      for (int Case = 1; Case <= T; ++Case) {
        printf("Case #%d: %d\n", Case, solve());
      }
    }
    ```

??? note " 习题[「HDU 4796」Winter's Coming](https://vjudge.net/problem/HDU-4796)"
    题目大意：在 N×M 的棋盘内对未染色的格点进行黑白灰染色，要求所有黑色区域和白色区域连通，且黑色区域与白色区域分别与棋盘的上下边界连通，且其中黑色区域与白色区域不能相邻。每个格子有对应的代价，求一组染色方案，最小化灰色区域的代价。

    ![4796](./images/4796.jpg)

??? note " 习题[「ZOJ 2125」Rocket Mania](https://vjudge.net/problem/ZOJ-2125)"

??? note " 习题[「ZOJ 2126」Rocket Mania Plus](https://vjudge.net/problem/ZOJ-2126)"

??? note " 习题[「World Finals 2009/2010 Harbin」Channel](https://vjudge.net/problem/UVALive-4789)"
    题目大意：。

??? note " 习题[「HDU 3958」Tower Defence](https://vjudge.net/problem/HDU-3958)"
    题目大意：。

??? note " 习题[「UVA 10531」Maze Statistics](https://vjudge.net/problem/UVA-10531)"
    题目大意：。

??? note " 习题[「AIZU 2452」Pipeline Plans](https://vjudge.net/problem/Aizu-2452)"
    题目大意：。

??? note " 习题[「SDOI 2014」电路板](https://www.luogu.com.cn/problem/P3314)"
    题目大意：。

??? note " 习题[「SPOJ CAKE3」Delicious Cake](https://vjudge.net/problem/SPOJ-CAKE3)"
    题目大意：。

.

## 本章注记

插头 DP 问题通常编码难度较大，讨论复杂，因而属于 OI/ACM 中相对较为 [偏门的领域](https://github.com/OI-wiki/libs/blob/master/topic/7-%E7%8E%8B%E5%A4%A9%E6%87%BF-%E8%AE%BA%E5%81%8F%E9%A2%98%E7%9A%84%E5%8D%B1%E5%AE%B3.ppt) 。这方面最为经典的资料，当属 2008 年 [陈丹琦](https://www.cs.princeton.edu/~danqic/) 的集训队论文—— [基于连通性状态压缩的动态规划问题](https://github.com/AngelKitty/review_the_national_post-graduate_entrance_examination/tree/master/books_and_notes/professional_courses/data_structures_and_algorithms/sources/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E8%AE%BA%E6%96%87/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2008%E8%AE%BA%E6%96%87%E9%9B%86/%E9%99%88%E4%B8%B9%E7%90%A6%E3%80%8A%E5%9F%BA%E4%BA%8E%E8%BF%9E%E9%80%9A%E6%80%A7%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E3%80%8B) 。其次，HDU 的 notonlysuccess 2011 年曾经在博客中连续写过两篇由浅入深的专题，也是不可多得的好资料，不过现在需要在 Web Archive 里考古。

-    [notonlysuccess，【专辑】插头 DP](https://web.archive.org/web/20110815044829/http://www.notonlysuccess.com/?p=625) 
-    [notonlysuccess，【完全版】插头 DP](https://web.archive.org/web/20111007185146/http://www.notonlysuccess.com/?p=931) 

### 多米诺骨牌覆盖

 [「HDU 1400」Mondriaan’s Dream](https://vjudge.net/problem/HDU-1400) 也出现在 [《算法竞赛入门经典训练指南》](https://oi-wiki.org/intro/resources/#_5) 中，并作为《轮廓线上的动态规划》一节的例题。 [多米诺骨牌覆盖（Domino tiling）](https://en.wikipedia.org/wiki/Domino_tiling) 是一组非常经典的数学问题，稍微修改其数据范围就可以得到不同难度，需要应用不同的算法解决的子问题。

当限定 `m = 2` 时，多米诺骨牌覆盖等价于斐波那契数列。 [《具体数学》](https://www.csie.ntu.edu.tw/~r97002/temp/Concrete%20Mathematics%202e.pdf) 中使用了该问题以引出斐波那契数列，并使用了多种方法得到其解析解。

当 `m <= 10, n <= 1e9` 时，可以将转移方程预处理成矩阵形式，并使用 [矩阵乘法进行加速](http://www.matrix67.com/blog/archives/276) 。

![domino_v2_transform_matrix](./images/domino_v2_transform_matrix.gif)

当 `n, m <= 100` ，可以用 [FKT Algorithm](https://en.wikipedia.org/wiki/FKT_algorithm) 计算其所对应平面图的完美匹配数。

-    [「51nod 1031」骨牌覆盖](http://www.51nod.com/Challenge/Problem.html#problemId=1031) 
-    [「51nod 1033」骨牌覆盖 V2](http://www.51nod.com/Challenge/Problem.html#problemId=1033) \| [「Vijos 1194」Domino](https://vijos.org/p/1194) 
-    [「51nod 1034」骨牌覆盖 V3](http://www.51nod.com/Challenge/Problem.html#problemId=1034) \| [「Ural 1594」Aztec Treasure](https://acm.timus.ru/problem.aspx?space=1&num=1594) 
-    [Wolfram MathWorld, Chebyshev Polynomial of the Second Kind](https://mathworld.wolfram.com/ChebyshevPolynomialoftheSecondKind.html) 

### 一条路径

「一条路径」是 [哈密度路径（Hamiltonian Path）]((https://en.wikipedia.org/wiki/Hamiltonian_path)) 问题在 [格点图（Grid Graph）](https://mathworld.wolfram.com/GridGraph.html) 中的一种特殊情况。哈密顿路径的判定性问题是 [NP-complete](https://en.wikipedia.org/wiki/NP-completeness) 家族中的重要成员。Niconico 上有一个『フカシギの数え方』おねえさんといっしょ！みんなで数えてみよう（和大姐姐一起学习计算系列）的科普向视频，就使用这个问题作为例子，来说明 NPC 问题的计算时间如何随着问题的规模的线性增长而指数增长。

![sm18847458](./images/sm18847458.png)

-    [【动画】从方格这头走向那头有多少种走法呢～【结尾迷之感动】](https://www.bilibili.com/video/BV1Cx411D74e) \| [Youtube](https://www.youtube.com/watch?v=Q4gTV4r0zRs) \| [Niconico](<>) 

# count


## quadrangle
author: TrisolarisHD, zyf0726, hsfzLZH1, MingqiHuang, Ir1d, greyqz, billchenchina, Chrogeek, StudyingFather

## 区间类（2D1D）动态规划中的应用

在区间类动态规划（如石子合并问题）中，我们经常遇到以下形式的 2D1D 状态转移方程：

$$
f_{l,r} = \min_{k=l}^{r-1}\{f_{l,k}+f_{k+1,r}\} + w(l,r)\qquad\left(1 \leq l \leq r \leq n\right)
$$

直接简单实现状态转移，总时间复杂度将会达到 $O(n^3)$ ，但当函数 $w(l,r)$ 满足一些特殊的性质时，我们可以利用决策的单调性进行优化。

-    **区间包含单调性** ：如果对于任意 $l \leq l' \leq r' \leq r$ ，均有 $w(l',r') \leq w(l,r)$ 成立，则称函数 $w$ 对于区间包含关系具有单调性。
-    **四边形不等式** ：如果对于任意 $l_1\leq l_2 \leq r_1 \leq r_2$ ，均有 $w(l_1,r_1)+w(l_2,r_2) \leq w(l_1,r_2) + w(l_2,r_1)$ 成立，则称函数 $w$ 满足四边形不等式（简记为“交叉小于包含”）。若等号永远成立，则称函数 $w$ 满足 **四边形恒等式** 。

>  **引理 1** 若满足关于区间包含的单调性的函数 $w(l, r)$ 满足四边形不等式，则状态 $f_{l,r}$ 也满足四边形不等式。

考虑对区间长度使用数学归纳法。

定义 $g_{k,l,r}=f_{l,k}+f_{k+1,r}+w(l,r)$ 表示当决策为 $k$ 时的状态值，任取 $l_1\leq l_2\leq r_1\leq r_2$ ，记 $u=\mathop{\arg\min}\limits_{l_1\leq k < r_2}g_{k,l_1,r_2},v=\mathop{\arg\min}\limits_{l_2\leq k < r_1}g_{k,l_2,r_1}$ 分别表示状态 $f_{l_1,r_2}$ 和 $f_{l_2,r_1}$ 的最优决策点。

1.  若 $u\leq v$ ，则 $l_1\leq u< r_1,\ l_2\leq v< r_2$ ，因此

    $$
    \begin{aligned}
    	f_{l_1,r_1} \leq g_{u,l_1,r_1} &= f_{l_1,u} + f_{u+1,r_1} + w(l_1,r_1) \\
    	f_{l_2,r_2} \leq g_{v,l_2,r_2} &= f_{l_2,v} + f_{v+1,r_2} + w(l_2,r_2)
    \end{aligned}
    $$

    再由 $u+1 \leq v+1 \leq r_1 \leq v_2$ 和归纳假设知

    $$
    f_{u+1,r_1} + f_{v+1,r_2} \leq f_{u+1,r_2} + f_{v+1,r_1}
    $$

    将前两个不等式累加，并将第三个不等式代入，可得

    $$
    \begin{aligned}
    	f_{l_1,r_1} + f_{l_2,r_2} & \leq f_{l_1,u} + f_{l_2,v} + f_{u+1,r_2} + f_{v+1,r_1} + w(l_1,r_2) + w(l_2,r_1) \\
    	& \leq g_{u,l_1,r_2} + g_{v,l_2,r_1} = f_{l_1,r_2} + f_{l_2,r_1}
    \end{aligned}
    $$


2.  若 $v< u$ ，则 $l_1\leq v<r_1,l_2\leq u<r_2$ ，因此

    $$
    \begin{aligned}
    f_{l_1,r_1} \leq g_{v,l_1,r_1} &= f_{l_1,v} + f_{v+1,r_1} + w(l_1,r_1) \\
    f_{l_2,r_2} \leq g_{u,l_2,r_2} &= f_{l_2,u} + f_{u+1,r_2} + w(l_2,r_2)
    \end{aligned}
    $$

    再由 $l_1 \leq l_2 \leq v \leq u$ 和归纳假设知

    $$
    f_{l_1,v} + f_{l_2,u} \leq f_{l_1,u} + f_{l_2,v}
    $$

    将前两个不等式累加，并将第三个不等式代入，可得

    $$
    \begin{aligned}
    f_{l_1,r_1} + f_{l_2,r_2} & \leq f_{l_1,u} + f_{l_2,v} + f_{v+1,r_1} + f_{u+1,r_2} + w(l_1,r_2) + w(l_2,r_1) \\
    & \leq g_{u,l_1,r_2} + g_{v,l_2,r_1} = f_{l_1,r_2} + f_{l_2,r_1}
    \end{aligned}
    $$

综上所述，两种情况均有 $f_{l_1,r_1} + f_{l_2,r_2} \leq f_{l_1,r_2} + f_{l_2,r_1}$ ，即四边形不等式成立。

>  **定理 1** 若状态 $f$ 满足四边形不等式，记 $m_{l,r}=\min\{k:f_{l,r} = g_{k,l,r}\}$ 表示最优决策点，则有
>
> $$
> m_{l,r-1} \leq m_{l,r} \leq m_{l+1,r}
> $$

记 $u = m_{l,r},\ k_1=m_{l,r-1},\ k_2=m_{l+1,r}$ ，分情况讨论：

1.  若 $k_1>u$ ，则 $u+1 \leq k_1+1 \leq r-1 \leq r$ ，因此根据四边形不等式有

    $$
    f_{u+1,r-1} + f_{k_1+1,r} \leq f_{u+1,r} + f_{k_1+1,r-1}
    $$

    再根据 $u$ 是状态 $f_{l,r}$ 的最优决策点可知

    $$
    f_{l,u} + f_{u+1,r} \leq f_{l,k_1} + f_{k_1+1, r}
    $$

    将以上两个不等式相加，得

    $$
    f_{l,u} + f_{u+1,r-1} \leq f_{l,k_1}+f_{k_1+1,r-1}
    $$

    即 $g_{u,l,r-1} \leq g_{k_1,l,r-1}$ ，但这与 $k_1$ 是最小的最优决策点矛盾，因此 $k_1\leq u$ 。

2.  若 $u>k_2$ ，则 $l\leq l+1 \leq k_2\leq u$ ，根据四边形不等式可得

    $$
    f_{l,k_2} + f_{l+1,u} \leq f_{l,u} + f_{l+1, k_2}
    $$

    再根据 $k_2$ 是状态 $f_{l+1, r}$ 的最优决策点可知

    $$
    f_{l+1,k_2} + f_{k_2+1, r} \leq f_{l+1,u} + f_{u+1,r}
    $$

    将以上两个不等式相加，得

    $$
    f_{l,k_2}+f_{k_2+1,r} \leq f_{l,u} + f_{u+1,r}
    $$

    即 $g_{k_2,l,r} \leq g_{u,l,r}$ ，但这与 $u$ 是最小的最优决策点矛盾，因此 $u \leq k_2$ 。

因此，如果在计算状态 $f_{l,r}$ 的同时将其最优决策点 $m_{l,r}$ 记录下来，那么我们对决策点 $k$ 的总枚举量将降为

$$
\sum_{1\leq l<r\leq n} m_{l+1,r} - m_{l,r-1} = \sum_{i=1}^n m_{i,n} - m_{1,i}\leq n^2
$$

核心代码如下：

```cpp
for (int len = 2; len <= n; ++len)  // 枚举区间长度
  for (int l = 1, r = len; r <= n; ++l, ++r) {
    // 枚举长度为len的所有区间
    f[l][r] = INF;
    for (int k = m[l][r - 1]; k <= m[l + 1][r]; ++k)
      if (f[l][r] > f[l][k] + f[k + 1][r] + w(l, r)) {
        f[l][r] = f[l][k] + f[k + 1][r] + w(l, r);  // 更新状态值
        m[l][r] = k;  // 更新（最小）最优决策点
      }
  }
```

## 1D1D 动态规划中的应用

除了经典的石子合并问题外，四边形不等式的性质在一类 1D1D 动态规划中也能得出决策单调性，从而优化状态转移的复杂度。考虑以下状态转移方程：

$$
f_{r} = \min_{l=1}^{r-1}\{f_{l}+w(l,r)\}\qquad\left(1 \leq r \leq n\right)
$$

>  **定理 2** 若函数 $w(l,r)$ 满足四边形不等式，记 $h_{l,r}=f_l+w(l,r)$ 表示从 $l$ 转移过来的状态 $r$ , $k_{r}=\min\{l|f_{r}=h_{l,r}\}$ 表示最优决策点，则有
>
> $$
> \forall r_1 \leq r_2:k_{r_1} \leq k_{r_2}
> $$

记 $l_1=k_{r_1},\ l_2=k_{r_2}$ ，若 $l_1>l_2$ ，则 $l_2<l_1<r_1\leq r_2​$ ，根据四边形不等式有

$$
w(l_2,r_1) + w(l_1,r_2) \leq w(l_1,r_1) + w(l_2,r_2)
$$

又由于 $l_2$ 是最优决策点，因此 $h_{l_2,r_2} \leq h_{l_1,r_2}$ ，即

$$
f_{l_2}+w(l_2,r_2) \leq f_{l_1}+w(l_1,r_2)
$$

将以上两个不等式相加，可得

$$
f_{l_2}+w(l_2,r_1) \leq f_{l_1}+w(l_1,r_1)
$$

即 $h_{l_2,r_1} \leq h_{l_1,r_1}$ ，但这与 $l_1$ 是最小最优决策点矛盾，因此必有 $l_1 \leq l_2$ 。

但与 2D1D 动态规划中的情形不同，在这里我们根据决策单调性只能得出每次枚举 $l$ 时的下界，而无法确定其上界。因此，简单实现该状态转移方程仍然无法优化最坏时间复杂度。

先考虑一种简单的情况，转移函数的值在动态规划前就已完全确定。即如下所示状态转移方程：

$$
f_{r} = \min_{l=1}^{r-1}w(l,r) \qquad\left(1 \leq r \leq n\right)
$$

在这种情况下，我们定义过程 $\textsf{DP}(l, r, k_l, k_r)$ 表示求解 $f_{l}\sim f_{r}$ 的状态值，并且已知这些状态的最优决策点必定位于 $[k_l, k_r]$ 中，然后使用分治算法如下：

```cpp
void DP(int l, int r, int k_l, int k_r) {
  int mid = (l + r) / 2, k = k_l;
  // 求状态f[mid]的最优决策点
  for (int i = k_l; i <= min(k_r, mid - 1); ++i)
    if (w(i, mid) < w(k, mid)) i = k;
  f[mid] = w(k, mid);
  // 根据决策单调性得出左右两部分的决策区间，递归处理
  if (l < mid) DP(l, mid - 1, k_l, k);
  if (r > mid) DP(mid + 1, r, k, k_r);
}
```

使用递归树的方法，容易分析出该分治算法的复杂度为 $O(n\log n)$ ，因为递归树每一层的决策区间总长度不超过 $2n$ ，而递归层数显然为 $O(\log n)$ 级别。

### 例题 1. [「loj2157」「POI2011」Lightning Conductor](https://loj.ac/problem/2157) 

题目大意：给定一个长度为 $n\leq 500000$ 的序列 $a_1, a_2, \cdots, a_n$ ，要求对于每一个 $1 \leq r \leq n$ ，找到最小的非负整数 $f_{r}$ 满足

$$
\forall l\in\left[1,n\right]:a_l \leq a_r + f_{r} - \sqrt{|r-l|}
$$

显然，经过不等式变形，我们可以得到待求整数 $f_{r} = \max\limits_{l=1}^{n}\{a_l+\sqrt{r-l}-a_r\}$ 。不妨先考虑 $l < r$ 的情况（另外一种情况类似），此时我们可以得到状态转移方程：

$$
f_{r} = \min_{l=1}^{r-1}\{\ -a_l-\sqrt{r-l}+a_r\}
$$

根据 $-\sqrt{x}$ 的凸性，我们很容易得出（后文将详细描述）函数 $w(l, r) = -a_l - \sqrt{r-l} + a_r$ 满足四边形不等式，因此套用上述的分治算法便可在 $O(n\log n)$ 的时间内解决此题了。

现在处理一般情况，即转移函数的值是在动态规划的过程中按照一定的拓扑序逐步确定的。此时我们需要改变思维方式，由“确定一个状态的最优决策”转化为“确定一个决策是哪些状态的最优决策“。具体可见上文的「单调栈优化 DP」。

## 满足四边形不等式的函数类

为了更方便地证明一个函数满足四边形不等式，我们有以下几条性质：

 **性质 1.** 若函数 $w_1(l,r),w_2(l,r)$ 均满足四边形不等式（或区间包含单调性），则对于任意 $c_1,c_2\geq 0$ ，函数 $c_1w_1+c_2w_2$ 也满足四边形不等式（或区间包含单调性）。

 **性质 2.** 若存在函数 $f(x),g(x)$ 使得 $w(l,r) = f(r)-g(l)$ ，则函数 $w$ 满足四边形恒等式。当函数 $f,g$ 单调增加时，函数 $w$ 还满足区间包含单调性。

 **性质 3.** 设 $h(x)$ 是一个单调增加的凸函数，若函数 $w(l,r)$ 满足四边形不等式并且对区间包含关系具有单调性，则复合函数 $h(w(l,r))$ 也满足四边形不等式和区间包含单调性。

 **性质 4** .  设 $h(x)$ 是一个凸函数，若函数 $w(l,r)$ 满足四边形恒等式并且对区间包含关系具有单调性，则复合函数 $h(w(l,r))$ 也满足四边形不等式。

首先需要澄清一点，凸函数（Convex Function）的定义在国内教材中有分歧，此处的凸函数指的是（可微的）下凸函数，即一阶导数单调增加的函数。

前两条性质根据定义很容易证明，下面证明第三条性质，性质四的证明过程类似。

任取 $l \leq l' \leq r' \leq r$ ，根据函数 $w$ 对区间包含关系的单调性有 $w(l',r')\leq w(l,r)$ 成立。又因为 $h(x)$ 单调增加，故 $h(w(l',r')) \leq h(w(l,r))$ ，即复合函数 $h\circ w$ 满足区间包含单调性。

任取 $l_1\leq l_2\leq r_1\leq r_2$ ，根据函数 $w$ 满足四边形不等式，有

$$
w(l_1,r_1) + w(l_2,r_2) \leq w(l_1,r_2) + w(l_2,r_1)
$$

移项，并根据 $w$ 对区间包含满足单调性，可得

$$
0 \leq w(l_1,r_1) - w(l_2,r_1) \leq w(l_1,r_2) - w(l_2,r_2)
$$

记 $t = w(l_1,r_2) - w(l_2,r_2)\geq 0$ ，则 $w(l_1,r_1)\leq w(l_2,r_1)+t,\ w(l_1,r_2)= w(l_2,r_2)+t$ ，故根据函数 $h$ 的单调性可知（如果是证明性质四则第一个不等式变为等式，无需用到单调性）

$$
\begin{aligned}
	h(w(l_1,r_1)) - h(w(l_2,r_1)) & \leq  h(w(l_2,r_1)+t) - h(w(l_2,r_1)) \\
	h(w(l_1,r_2)) - h(w(l_2,r_2)) & = h(w(l_2,r_2)+t) - h(w(l_2,r_2))
\end{aligned}
$$

设 $\Delta h(x) = h(x+t)-h(x)$ ，则 $\Delta h'(x) = h'(x+t)-h'(x)$ 。由于 $h(x)$ 是一个凸函数，故导函数 $h'(x)$ 单调增加，因此函数 $\Delta h$ 也单调增加，此时有

$$
\begin{aligned}
h(w(l_1,r_1)) - h(w(l_2,r_1)) & \leq \Delta h(w(l_2,r_1)) \\
	& \leq \Delta h(w(l_2,r_2)) = h(w(l_1,r_2)) - h(w(l_2,r_2))
\end{aligned}
$$

即 $h(w(l_1,r_1)) + h(w(l_2,r_2)) \leq h(w(l_1,r_2)) + h(w(l_2,r_1))$ ，说明 $h\circ w$ 也满足四边形不等式。

回顾例题 1 中的 $w(l, r) = -a_l - \sqrt{r-l} + a_r$ ，由性质 2 可知 $-a_l+a_r$ 满足四边形不等式，而 $r-l$ 满足四边形恒等式和区间包含单调性。再根据 $-\sqrt{x}$ 的凸性以及性质 4 可知 $-\sqrt{r-l}$ 也满足四边形不等式，最终利用性质 1，即可得出 $w(l, r)$ 满足四边形不等式性质了。

### 例题 2. [「HNOI2008」玩具装箱 toy](https://loj.ac/problem/10188) 

题目大意：有 $n$ 个玩具需要装箱，要求每个箱子中的玩具编号必须是连续的。每个玩具有一个长度 $C_i$ ，如果一个箱子中有多个玩具，那么每两个玩具之间要加入一个单位长度的分隔物。形式化地说，如果将编号在 $[l,r]$ 间的玩具装在一个箱子里，那么这个箱子的长度为 $r-l+\sum_{k=l}^r C_k$ 。现在需要制定一个装箱方案，使得所有容器的长度与 $K$ 差值的平方之和最小。

设 $f_{r}$ 表示将前 $r$ 个玩具装箱的最小代价，则枚举第 $r$ 个玩具与哪些玩具放在一个箱子中，可以得到状态转移方程为

$$
f_{r} = \min_{l=1}^{r-1}\{f_{l} + \left(r-l-1-K+\sum_{k=l+1}^r C_k\right)^2\}
$$

记 $s(r) = r+\sum_{k=1}^r C_k$ ，则有 $w(l, r) = (s(r) - s(l) - 1 - K)^2$ 。显然 $s(r)$ 单调增加，因此根据性质 1 和性质 2 可知 $s(r) - s(l) - 1 - K$ 满足区间包含单调性和四边形不等式。再根据 $x^2$ 的单调性和凸性以及性质 3 可知， $w(l, r)$ 也满足四边形不等式，此时使用单调栈优化即可。

## 习题

 [「IOI2000」邮局](https://www.luogu.org/problemnew/show/P4767) 

## 参考资料

 [noiau 的 CSDN 博客](https://blog.csdn.net/noiau/article/details/72514812) 

## slope
author: TrisolarisHD, hsfzLZH1, abc1763613206, greyqz, Ir1d, billchenchina, Chrogeek, Enter-tainer, StudyingFather, MrFoodinChina, luoguyuntianming

## 例题选讲

??? note " 例题[「HNOI2008」玩具装箱 TOY](https://loj.ac/problem/10188)"
    令 $f_i$ 表示前 $i$ 个物品，随意分组装在任意多个容器里所能得到的最小费用。

写出 **状态转移方程** ： $f_i=\min\{f_j+(pre_i-pre_j+i-j-1-L)^2\}$ ，其中 $pre_i$ 表示前 $i$ 个数的前缀和。

换元试图简化状态转移方程式：令 $s_i=pre_i+i,L'=L+1$ ，则 $f_i=f_j+(s_i-s_j-L')^2$ ，展开，移项得

 $f_i=f_j+(s_i-s_j-L')^2$ 

 $f_i+2\times s_i\times (s_j+L')=f_j+s_i^2+(s_j+L')^2$ 

我们观察到，式子的右端的所有项都只和 $i$ 有关或只和 $j$ 有关，式子左端的第一项是我们要求的目标值，式子左端的其余项都同时和 $i$ 和 $j$ 有关。我们将这个式子看作一条直线的函数解析式，形如 $b+k\times x=y$ ，和上式一一对应。我们发现如果我们要最小化 $f_i$ ，也就是说要最小化这个直线的截距，而对于每个确定的 $i$ ，这个直线的斜率 $s_i$ 都是确定的。

/home/llj/Desktop/OI-wiki-master/docs/dp/opt/![](../images/optimization.svg)

如图，我们将这个斜率固定的直线从下往上平移，直到有一个点在这条直线上，然后将新的点加入点集，这样肯定能保证所有的直线的斜率都是单调递升的（因为如果新的直线斜率小于斜率最大的直线，那么其一定不成被选择成为新的决策），所以我们相当于维护了一个下凸包。（如果求的是 $\max$ 那么就要维护一个 **上凸包** 。这种东西要具体情况具体分析，如果直线的斜率不满足单调性，那就要维护整个凸包/二分等奇技淫巧。）

可以用单调队列维护下凸包。

## 习题

 [「SDOI2016」征途](https://loj.ac/problem/2035) 

 [「ZJOI2007」仓库建设](https://loj.ac/problem/10189) 

 [「APIO2010」特别行动队](https://loj.ac/problem/10190) 

 [「JSOI2011」柠檬](https://www.luogu.org/problem/P5504) 

 [「Codeforces 311B」Cats Transport](http://codeforces.com/problemset/problem/311/B) 

 [「NOI2007」货币兑换](https://loj.ac/problem/2353) 

 [「NOI2019」回家路线](https://loj.ac/problem/3156) 

 [「NOI2016」国王饮水记](https://uoj.ac/problem/223) 

 [「NOI2014」购票](https://uoj.ac/problem/7) 

## state
author: TrisolarisHD, partychicken, Xeonacid

## 概述

优化 dp 时，不止可以从转移过程入手，加速转移。有时，也可以从状态定义入手，通过改变设计状态的方式实现复杂度上的优化。

令人比较头疼的是，这类优化大多不具有通用性，即不能很套路地应用于多个题目中。因此，下文将从具体例题出发，力求提供思路上的启发，希望可以对读者有一定帮助。

## Example I

### Problem

给定两个长度分别为 $n,m$ 且仅由小写字母构成的字符串 $A,B$ , 求 $A,B$ 的最长公共子序列。 $(n\le 10^6,m\le 10^3)$ 

### Naive solution

您一眼秒了它，这不是板子吗？

定义状态 $f_{i,j}$ 为 $A$ 的前 $i$ 位与 $B$ 的前 $j$ 位最长公共子串，则有

$$
f_{i,j}=
\begin{cases}
\max(f_{i-1,j},f_{i,j-1}) & ,A_i \neq B_j \\
f_{i-1,j-1}+1 & ,A_i = B_j 
\end{cases}
$$

上述做法的时间复杂度 $O(nm)$ ，无法通过本题。

### Better solution

我们仔细一想，发现了一个性质：最终答案不会超过 $m$ 。

我们又仔细一想，发现 LCS 满足贪心的性质。

更改状态定义 $f_{i,j}$ 为与 $B$ 前 $i$ 位的最长公共子序列长度为 $j$ 的 $A$ 的最短前缀长度（即将朴素做法的答案与第一维状态对调）

可以通过预处理 $A$ 的每一位的下一个 $a,b,\cdots,z$ 的出现位置进行 $O(1)$ 的顺推转移。

复杂度 $O(m^2+26n)$ ，可以通过本题。

## Example II

### Problem

给定一个 $n$ 个点的无权有向图，判断该图是否存在哈密顿回路。 $(2\le n\le 20)$ 

### Naive solution

看到数据范围，我们考虑状压。

设 $f_{s,i}$ 表示从点 $1$ 出发，仅经过点集 $s$ 中的点能否到达点 $i$ 。记 $g$ 为原图的邻接矩阵。则有

$$
f_{s, i} = \bigcap_{j\in s, j\neq i}f_{s - \left\{i\right\}, j}\cap g_{j, i} \left(i\in s\right)
$$

时间复杂度 $O(n^2 \times 2^n)$ ，写得好看或许能过，但是并不优美。

### Better solution

上面的状态设计中，每个 $dp$ 值只代表一个 `bool` 值，这让我们觉得有些浪费。

我们可以考虑对于每个状态 $s$ 将 $f_{s,1},f_{s,2},\dots,f_{s,n}$ 压成一个 `int` ，发现我们可以将邻接矩阵同样压缩后进行 $O(1)$ 转移。

时间复杂度 $O(n\times 2^n)$ , 可以通过这道题。

## monotonous-queue-stack
author: TrisolarisHD, hsfzLZH1, Ir1d, greyqz, Anguei, billchenchina, Chrogeek, ChungZH

## 介绍

学习本节前，请务必先学习 [单调队列](../../ds/monotonous-queue.md) 及 [单调栈](../../ds/monotonous-stack.md) 部分。

??? note " 例题[CF372C Watching Fireworks is Fun](http://codeforces.com/problemset/problem/372/C)"
    题目大意：城镇中有 $n$ 个位置，有 $m$ 个烟花要放。第 $i$ 个烟花放出的时间记为 $t_i$ ，放出的位置记为 $a_i$ 。如果烟花放出的时候，你处在位置 $x$ ，那么你将收获 $b_i-|a_i-x|$ 点快乐值。

    初始你可在任意位置，你每个单位时间可以移动不大于 $d$ 个单位距离。现在你需要最大化你能获得的快乐值。

设 $f_{i,j}$ 表示在放第 $i$ 个烟花时，你的位置在 $j$ 所能获得的最大快乐值。

写出 **状态转移方程** ： $f_{i,j}=\max\{f_{i-1,k}+b_i-|a_i-j|\}$ 

这里的 $k$ 是有范围的， $j-(t_{i+1}-t_i)\times d\le k\le j+(t_{i+1}-t_i)\times d$ 。

我们尝试将状态转移方程进行变形：

由于 $\max$ 里出现了一个确定的常量 $b_i$ ，我们可以将它提到外面去。

 $f_{i,j}=\max\{f_{i-1,k}+b_i+|a_i-j|\}=\max\{f_{i-1,k}-|a_i-j|\}+b_i$ 

如果确定了 $i$ 和 $j$ 的值，那么 $|a_i-j|$ 的值也是确定的，也可以将这一部分提到外面去。

最后，式子变成了这个样子： $f_{i,j}=\max\{f_{i-1,k}-|a_i-j|\}+b_i=\max\{f_{i-1,k}\}-|a_i-j|+b_i$ 

看到这一熟悉的形式，我们想到了什么？ **单调队列优化** 。由于最终式子中的 $\max$ 只和上一状态中连续的一段的最大值有关，所以我们在计算一个新的 $i$ 的状态值时候只需将原来的 $f_{i-1}$ 构造成一个单调队列，并维护单调队列，使得其能在均摊 $O(1)$ 的时间复杂度内计算出 $\max\{f_{i-1,k}\}$ 的值，从而根据公式计算出 $f_{i,j}$ 的值。

总的时间复杂度为 $O(nm)$ 。

讲完了，让我们归纳一下单调队列优化动态规划问题的基本形态：当前状态的所有值可以从上一个状态的某个连续的段的值得到，要对这个连续的段进行 RMQ 操作，相邻状态的段的左右区间满足非降的关系。

## 单调队列优化多重背包

???+note "问题描述"
    你有 $n$ 个物品，每个物品重量为 $w_i$ ，价值为 $v_i$ ，数量为 $k_i$ 。你有一个承重上限为 $m$ 的背包，现在要求你在不超过重量上限的情况下选取价值和尽可能大的物品放入背包。求最大价值。

不了解背包 DP 的请先阅读 [背包 DP](../knapsack.md) 。设 $f_{i,j}$ 表示前 $i$ 个物品装入承重为 $j$ 的背包的最大价值，朴素的转移方程为

$$
f_{i,j}=\max_{k=0}^{k_i}(f_{i-1,j-k\times w_i}+v_i\times k)
$$

时间复杂度 $O(nW\sum k_i)$ 。

考虑优化 $f_i$ 的转移。为方便表述，设 $g_{x,y}=f_{i,x\times w_i+y},g'_{x,y}=f_{i-1,x\times w_i+y}$ ，则转移方程可以表示为：

$$
g_{x,y}=\max_{k=0}^{k_i}(g'_{x-k,y}+v_i\times k)
$$

设 $G_{x,y}=g'_{x,y}-v_i\times x$ 。则方程可以表示为：

$$
g_{x,y}=\max_{k=0}^{k_i}(G_{x-k,y})+v_i\times x
$$

这样就转化为一个经典的单调队列优化形式了。 $G_{x,y}$ 可以 $O(1)$ 计算，因此对于固定的 $y$ ，我们可以在 $O\left( \left\lfloor \dfrac{W}{w_i} \right\rfloor \right)$ 的时间内计算出 $g_{x,y}$ 。因此求出所有 $g_{x,y}$ 的复杂度为 $O\left( \left\lfloor \dfrac{W}{w_i} \right\rfloor \right)\times O(w_i)=O(W)$ 。这样转移的总复杂度就降为 $O(nW)$ 。

## 习题

 [「Luogu P1886」滑动窗口](https://loj.ac/problem/10175) 

 [「NOI2005」瑰丽华尔兹](https://www.luogu.org/problem/P2254) 

 [「SCOI2010」股票交易](https://loj.ac/problem/10183) 

# search
# bidirectional
author: FFjet, ChungZH, frank-xjh, hsfzLZH1, Xarfa, AndrewWayne

### 双向同时搜索

从状态图上起点和终点同时开始进行宽度/深度优先搜索，如果发现相遇了，那么可以认为是获得了可行解。

双向广搜的步骤：

```text
开始结点 和 目标结点 入队列 q
标记开始结点为 1
标记目标结点为 2
while(队列q不为空)
{
  从 q.front() 扩展出新的s个结点
  
  如果 新扩展出的结点已经被其他数字标记过
    那么 表示搜索的两端碰撞
    那么 循环结束
  
  如果 新的s个结点是从开始结点扩展来的
    那么 将这个s个结点标记为1 并且入队q 
    
  如果 新的s个结点是从目标结点扩展来的
    那么 将这个s个结点标记为2 并且入队q
}
```

### 折半搜索

也称 meet in the middle，主要思想是将整个搜索过程分成两半，分别搜索，最后将两半的结果合并。由于搜索的复杂度往往是指数级的，而折半搜索可以使指数减半，也就能使复杂度开方。

???+note "例题 [「USACO09NOV」灯 Lights](https://www.luogu.org/problemnew/show/P2962)"

    有 $n$ 盏灯，每盏灯与若干盏灯相连，每盏灯上都有一个开关，如果按下一盏灯上的开关，这盏灯以及与之相连的所有灯的开关状态都会改变。一开始所有灯都是关着的，你需要将所有灯打开，求最小的按开关次数。

    $1\le n\le 35$。

如果这道题暴力 DFS 找开关灯的状态，时间复杂度就是 $O(2^{n})$ , 显然超时。不过，如果我们用 **meet-in-middle** 的话，时间复杂度可以优化至 $O(n2^{n/2})$ 。 **meet-in-middle** 就是让我们先找一半的状态，也就是找出只使用编号为 $1$ 到 $\mathrm{mid}$ 的开关能够到达的状态，再找出只使用另一半开关能到达的状态。如果前半段和后半段开启的灯互补，将这两段合并起来就得到了一种将所有灯打开的方案。具体实现时，可以把前半段的状态以及达到每种状态的最少按开关次数存储在 `map` 里面，搜索后半段时，每搜出一种方案，就把它与互补的第一段方案合并来更新答案。

??? note "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <iostream>
    #include <map>
    
    using namespace std;
    
    typedef long long ll;
    
    int n, m, ans = 0x7fffffff;
    map<ll, int> f;
    ll a[40];
    
    int main() {
      cin >> n >> m;
    
      for (int i = 0; i < n; ++i) a[i] = (1ll << i);
    
      for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        --u;
        --v;
        a[u] |= (1ll << v);
        a[v] |= (1ll << u);
      }
    
      for (int i = 0; i < (1 << (n / 2)); ++i) {
        ll t = 0;
        int cnt = 0;
        for (int j = 0; j < n / 2; ++j) {
          if ((i >> j) & 1) {
            t ^= a[j];
            ++cnt;
          }
        }
        if (!f.count(t))
          f[t] = cnt;
        else
          f[t] = min(f[t], cnt);
      }
    
      for (int i = 0; i < (1 << (n - n / 2)); ++i) {
        ll t = 0;
        int cnt = 0;
        for (int j = 0; j < (n - n / 2); ++j) {
          if ((i >> j) & 1) {
            t ^= a[n / 2 + j];
            ++cnt;
          }
        }
        if (f.count(((1ll << n) - 1) ^ t))
          ans = min(ans, cnt + f[((1ll << n) - 1) ^ t]);
      }
    
      cout << ans;
    
      return 0;
    }
    ```

# dlx
author: LeverImmy

## 精确覆盖问题

### 定义

精确覆盖问题 (Exact Cover Problem) 是指给定许多集合 $S_i (1 \le i \le n)$ 以及一个集合 $X$ ，求满足以下条件的无序多元组 $(T_1, T_2, \cdots , T_m)$ ：

(1) $\forall i, j \in [1, m],T_i\bigcap T_j = \varnothing (i \neq j)$ 

(2) $X = \bigcup\limits_{i = 1}^{m}T_i$ 

(3) $\forall i \in[1, m], T_i \in \{S_1, S_2, \cdots, S_n\}$ 

例如，若给出

$$
\begin{aligned}
  & S_1 = \{5, 9, 17\} \\
  & S_2 = \{1, 8, 119\} \\
  & S_3 = \{3, 5, 17\} \\
  & S_4 = \{1, 8\} \\
  & S_5 = \{3, 119\} \\
  & S_6 = \{8, 9, 119\} \\
  & X = \{1, 3, 5, 8, 9, 17, 119\}
\end{aligned}
$$

则 $(S_1, S_4, S_5)$ 为一组合法解。

### 问题转化

我们将 $\bigcup\limits_{i = 1}^{n}S_i$ 中的所有数离散化，那么可以得到这么一个模型：

> 给定一个 01 矩阵，你可以选择一些行，使得最终每列都恰好有一个 1。
> 举个例子，我们对上文中的例子进行建模，可以得到这么一个矩阵：

$$
\begin{pmatrix}
  0 & 0 & 1 & 0 & 1 & 1 & 0 \\
  1 & 0 & 0 & 1 & 0 & 0 & 1 \\
  0 & 1 & 1 & 0 & 0 & 1 & 0 \\
  1 & 0 & 0 & 1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 & 0 & 0 & 1 \\
  0 & 0 & 0 & 1 & 1 & 0 & 1
\end{pmatrix}
$$

其中第 $i$ 行表示着 $S_i$ ，而这一行的每个数依次表示 $[1 \in S_i],[3 \in S_i],[5 \in S_i],\cdots,[119 \in S_i]$ 。

### 暴力 1

我们可以枚举选择哪些行，最后检查这个方案是否合法。

因为每一行都有选或者不选两种状态，所以枚举行的时间复杂度是 $O(2^n)$ 的；

而每次检查都需要 $O(nm)$ 的时间复杂度。所以总的复杂度是 $O(nm\cdot2^n)$ 。

??? note "代码实现"

    ```cpp
    int ok = 0;
    for(int state = 0; state < 1 << n; ++state) { // 枚举每行是否被选
      for(int i = 1; i <= n; ++i) if((1 << i - 1) & state)
        for(int j = 1; j <= m; ++j)
          a[i][j] = 1;
      int flag = 1;
      for(int j = 1; j <= m; ++j) for(int i = 1, bo = 0; i <= n; ++i)
        if(a[i][j]) {
          if(bo) flag = 0;
          else bo = 1;
        }
      if(!flag) continue;
      else {
        ok = 1;
        for(int i = 1; i <= n; ++i) if((1 << i - 1) & state)
            printf("%d ", i);
        puts("");
      }
      memset(a, 0, sizeof(a));
    }
    if(!ok) puts("No solution.");
    ```

### 暴力 2

考虑到 01 矩阵的特殊性质，我们可以把每一行都看做成一个 $m$ 位二进制数。

因此被转化为了

> 给你 $n$ 个 $m$ 位二进制数，要求选择一些数，使得任意两个数的与都为 0，且所有数的或为 $2^m - 1$ 。 `tmp` 表示的是截至目前的所有被选择了的 $m$ 位二进制数的或。

因为每一行都有选或者不选两种状态，所以枚举行的时间复杂度为 $O(2^n)$ ；

而每次计算 `tmp` 都需要 $O(n)$ 的时间复杂度。所以总的复杂度为 $O(n\cdot2^n)$ 。

??? note "代码实现"

    ```cpp
    int ok = 0;
    for(int i = 1; i <= n; ++i)
      for(int j = m; j >= 1; --j)
        num[i] = num[i] << 1 | a[i][j];
    for(int state = 0; state < 1 << n; ++state) {
      int tmp = 0;
      for(int i = 1; i <= n; ++i)  if((1 << i - 1) & state) {
        if(tmp & num[i]) break;
        tmp |= num[i];
      }
      if(tmp == (1 << m) - 1) {
        ok = 1;
        for(int i = 1; i <= n; ++i) if((1 << i - 1) & state)
          printf("%d ", i);
          puts("");
      }
    }
    if(!ok) puts("No solution.");
    ```

## X 算法

Donald E. Knuth 提出了 X 算法 (Algorithm X)，其思想与刚才的暴力差不多，但是方便优化。

继续以上文中中提到的例子为载体，我们得到的是一个这样的 01 矩阵：

$$
\begin{pmatrix}
  0 & 0 & 1 & 0 & 1 & 1 & 0 \\
  1 & 0 & 0 & 1 & 0 & 0 & 1 \\
  0 & 1 & 1 & 0 & 0 & 1 & 0 \\
  1 & 0 & 0 & 1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 & 0 & 0 & 1 \\
  0 & 0 & 0 & 1 & 1 & 0 & 1
\end{pmatrix}
$$

Donald E. Knuth 提出了一个叫做 X 算法 (Algorithm X) 的东西，其思想与刚才的暴力差不多，但是方便优化。

继续以上文中提到的例子为载体，我们得到的是一个这样的 01 矩阵：

$$
\begin{pmatrix}
  0 & 0 & 1 & 0 & 1 & 1 & 0 \\
  1 & 0 & 0 & 1 & 0 & 0 & 1 \\
  0 & 1 & 1 & 0 & 0 & 1 & 0 \\
  1 & 0 & 0 & 1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 & 0 & 0 & 1 \\
  0 & 0 & 0 & 1 & 1 & 0 & 1
\end{pmatrix}
$$

1.  此时第一行有 $3$ 个 $1$ ，第二行有 $3$ 个 $1$ ，第三行有 $3$ 个 $1$ ，第四行有 $2$ 个 $1$ ，第五行有 $2$ 个 $1$ ，第六行有 $3$ 个 $1$ 。选择第一行，将它删除，并将所有 $1$ 所在的列打上标记；

$$
\begin{pmatrix}
  \color{Blue}0 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 & \color{Blue}0 \\
  1 & 0 & \color{Red}0 & 1 & \color{Red}0 & \color{Red}0 & 1 \\
  0 & 1 & \color{Red}1 & 0 & \color{Red}0 & \color{Red}1 & 0 \\
  1 & 0 & \color{Red}0 & 1 & \color{Red}0 & \color{Red}0 & 0 \\
  0 & 1 & \color{Red}0 & 0 & \color{Red}0 & \color{Red}0 & 1 \\
  0 & 0 & \color{Red}0 & 1 & \color{Red}1 & \color{Red}0 & 1
  \end{pmatrix}
$$

2.  选择所有被标记的列，将它们删除，并将这些列中含 $1$ 的行打上标记；

$$
\begin{pmatrix}
  \color{Blue}0 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 & \color{Blue}0 \\
  1 & 0 & \color{Blue}0 & 1 & \color{Blue}0 & \color{Blue}0 & 1 \\
  \color{Red}0 & \color{Red}1 & \color{Blue}1 & \color{Red}0 & \color{Blue}0 & \color{Blue}1 & \color{Red}0 \\
  1 & 0 & \color{Blue}0 & 1 & \color{Blue}0 & \color{Blue}0 & 0 \\
  0 & 1 & \color{Blue}0 & 0 & \color{Blue}0 & \color{Blue}0 & 1 \\
  \color{Red}0 & \color{Red}0 & \color{Blue}0 & \color{Red}1 & \color{Blue}1 & \color{Blue}0 & \color{Red}1
\end{pmatrix}
$$

3.  选择所有被标记的行，将它们删除；

$$
\begin{pmatrix}
  \color{Blue}0 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 & \color{Blue}0 \\
  1 & 0 & \color{Blue}0 & 1 & \color{Blue}0 & \color{Blue}0 & 1 \\
  \color{Blue}0 & \color{Blue}1 & \color{Blue}1 & \color{Blue}0 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 \\
  1 & 0 & \color{Blue}0 & 1 & \color{Blue}0 & \color{Blue}0 & 0 \\
  0 & 1 & \color{Blue}0 & 0 & \color{Blue}0 & \color{Blue}0 & 1 \\
  \color{Blue}0 & \color{Blue}0 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 & \color{Blue}0 & \color{Blue}1
\end{pmatrix}
$$

 **这表示表示我们选择了一行，且这一行的所有 $1$ 所在的列不能有其他 $1$ 了** 。

于是我们得到了这样的一个新的小 01 矩阵：

$$
\begin{pmatrix}
  1 & 0 & 1 & 1 \\
  1 & 0 & 1 & 0 \\
  0 & 1 & 0 & 1
\end{pmatrix}
$$

4.  此时第一行（原来的第二行）有 $3$ 个 $1$ ，第二行（原来的第四行）有 $2$ 个 $1$ ，第三行（原来的第五行）有 $2$ 个 $1$ 。选择第一行（原来的第二行），将它删除，并将所有 $1$ 所在的列打上标记；

$$
\begin{pmatrix}
  \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 \\
  \color{Red}1 & 0 & \color{Red}1 & \color{Red}0 \\
  \color{Red}0 & 1 & \color{Red}0 & \color{Red}1
\end{pmatrix}
$$

5.  选择所有被标记的列，将它们删除，并将这些列中含 $1$ 的行打上标记；

$$
\begin{pmatrix}
  \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 \\
  \color{Blue}1 & \color{Red}0 & \color{Blue}1 & \color{Blue}0 \\
  \color{Blue}0 & \color{Red}1 & \color{Blue}0 & \color{Blue}1
\end{pmatrix}
$$

6.  选择所有被标记的行，将它们删除；

$$
\begin{pmatrix}
  \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 \\
  \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 \\
  \color{Blue}0 & \color{Blue}1 & \color{Blue}0 & \color{Blue}1
\end{pmatrix}
$$

于是我们得到了一个空矩阵。但是上次删除的行 "1 0 1 1" 不是全 $1$ 的，说明选择有误；

$$
\begin{pmatrix}
\end{pmatrix}
$$

7.  回溯到步骤 $4$ ，我们考虑选择第二行（原来的第四行），将它删除，并将所有 $1$ 所在的列打上标记；

$$
\begin{pmatrix}
  \color{Red}1 & 0 & \color{Red}1 & 1 \\
  \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 \\
  \color{Red}0 & 1 & \color{Red}0 & 1
\end{pmatrix}
$$

8.  选择所有被标记的列，将它们删除，并将这些列中含 $1$ 的行打上标记；

$$
\begin{pmatrix}
  \color{Blue}1 & \color{Red}0 & \color{Blue}1 & \color{Red}1 \\
  \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 \\
  \color{Blue}0 & 1 & \color{Blue}0 & 1
\end{pmatrix}
$$

9.  选择所有被标记的行，将它们删除；

$$
\begin{pmatrix}
  \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 \\
  \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 \\
  \color{Blue}0 & 1 & \color{Blue}0 & 1
  \end{pmatrix}
$$

于是我们得到了这样的一个矩阵：

$$
\begin{pmatrix}
  1 & 1
\end{pmatrix}
$$

10. 此时第一行（原来的第五行）有 $2$ 个 $1$ ，将它们全部删除，我们得到了一个空矩阵：

$$
\begin{pmatrix}
\end{pmatrix}
$$

11. 上一次删除的时候，删除的是全 $1$ 的行，因此成功，算法结束。

    答案即为我们删除的三行： $1, 4, 5$ 。

-    **强烈建议自己模拟一遍矩阵删除、还原与回溯的过程后再接着阅读下文。** 

我们可以概括出 X 算法的过程：

1.  对于现在的矩阵 $M$ ，选择并标记一列 $r$ ，将 $r$ 添加至 $S$ 中；

2.  如果尝试了所有的 $r$ 却无解，则算法结束，输出无解。

3.  标记与 $r$ 相关的行 $r_i$ 和 $c_i$ ；

4.  删除所有标记的行和列，得到新矩阵 $M'$ ；

5.  如果 $M'$ 为空，且 $r$ 为全 $1$ 的，则算法结束，输出被删除的行组成的集合 $S$ ；

    如果 $M'$ 为空，且 $r$ 不为全 $1$ 的，则恢复与 $r$ 相关的行 $r_i$ 以及列 $c_i$ ，跳转至步骤 $1$ ；

    如果 $M'$ 不为空，则跳转至步骤 $1$ ；

不难看出，X 算法需要大量的“删除行”、“删除列”和“恢复行”、“恢复列”的操作。

Donald E. Knuth 想到了用双向十字链表来维护这些操作。

而在双向十字链表上不断跳跃的过程被形象地比喻成“跳跃”，因此被用来优化 X 算法的双向十字链表也被称为“Dancing Links”。

## Dancing Links 优化的 X 算法

### 预编译命令

```cpp
#define IT(i, A, x) for (i = A[x]; i != x; i = A[i])
```

### 定义

既然是双向十字链表，那么一定是有四个指针域的：一个指上方的元素，一个指下方的元素，一个指左边的元素，一个指右边的元素。而每个元素 $i$ 在整个双向十字链表系中都对应着一个格子，因此还要表示 $i$ 所在的列和所在的这样：

![dlx-1](./images/dlx-1.png)

是不是非常简单？

而其实大型双向链表其实是长这样的：

![dlx-2](./images/dlx-2.png)

每一行都有一个行首指示，每一列都有一个列指示。

行首指示为 `first[]` ，列指示是我们虚拟出的 $c + 1$ 个结点。

同时，每一列都有一个 `siz[]` 表示这一列的元素个数。

特殊地， $0$ 号结点无右结点等价于这个 Dancing Links 为空。

```cpp
static const int MS = 1e5 + 5;
int n, m, idx, first[MS], siz[MS];
int L[MS], R[MS], U[MS], D[MS];
int col[MS], row[MS];
```

### remove 操作

 $\text{remove(c)}$ 表示在 Dancing Links 中删除第 $c$ 列以及与其相关的行和列。

我们先将 $c$ 删除，此时：

(1) $c$ 左侧的结点的右结点应为 $c$ 的右结点；

(2) $c$ 右侧的结点的左结点应为 $c$ 的左结点。

即 `L[R[c]] = L[c], R[L[c]] = R[c];` 。

![dlx-3.png](./images/dlx-3.png)

然后我们要顺着这一列往下走，把走过的每一行都删掉。

如何删掉每一行呢？枚举当前行的指针 $j$ ，此时：

(1) $j$ 上方的结点的下结点应为 $j$ 的下结点；

(2) $j$ 下方的结点的上结点应为 $j$ 的上结点。

注意要修改每一列的元素个数。

即 `U[D[j]] = U[j], D[U[j]] = D[j], --siz[col[j]];` 。

![dlx-4.png](./images/dlx-4.png)

因此 $\text{remove(c)}$ 的代码实现就非常简单了：

其中第一个 `IT(i, D, c)` 等价于 `for(i = D[c]; i != c; i = D[i])` ，即在顺着这一列从上往下遍历；

第二个 `IT(j, R, i)` 等价于 `for(j = R[i]; j != i; j = R[j])` ，即在顺着这一行从左往右遍历。

```cpp
void remove(const int &c) {
  int i, j;
  L[R[c]] = L[c], R[L[c]] = R[c];
  IT(i, D, c) IT(j, R, i) U[D[j]] = U[j], D[U[j]] = D[j], --siz[col[j]];
}
```

### recover 操作

 $\text{recover(c)}$ 表示在 Dancing Links 中还原第 $c$ 列以及与其相关的行和列。

 $\text{recover(c)}$ 即 $\text{remove(c)}$ 的逆操作，在这里就不多赘述了。

 **值得注意的是，**  $\text{recover(c)}$  **的所有操作的顺序与**  $\text{remove(c)}$  **的操作恰好相反。** 

在这里给出 $\text{recover(c)}$ 的代码实现：

```cpp
void recover(const int &c) {
  int i, j;
  IT(i, U, c) IT(j, L, i) U[D[j]] = D[U[j]] = j, ++siz[col[j]];
  L[R[c]] = R[L[c]] = c;
}
```

### build 操作

 $\text{build(r, c)}$ 表示新建一个大小为 $r \times c$ ，即有 $r$ 行， $c$ 列的 Dancing Links。

我们新建 $c + 1$ 个结点，为列指示。

第 $i$ 个点的左结点为 $i - 1$ ，右结点为 $i + 1$ ，上结点为 $i$ ，下结点为 $i$ 。

特殊地， $0$ 结点的左结点为 $c$ ， $c$ 结点的右结点为 $0$ 。

于是我们得到了一条链：

![dlx-5.png](./images/dlx-5.png)

```cpp
void build(const int &r, const int &c) {
  n = r, m = c;
  for (int i = 0; i <= c; ++i) {
    L[i] = i - 1, R[i] = i + 1;
    U[i] = D[i] = i;
  }
  L[0] = c, R[c] = 0, idx = c;
  memset(first, 0, sizeof(first));
  memset(siz, 0, sizeof(siz));
}
```

这样就初始化了一个 Dancing Links。

### insert 操作

 $\text{insert(r, c)}$ 表示在第 $r$ 行，第 $c$ 列插入一个结点。

我们分两种情况来操作：

(1) 如果第 $r$ 行没有元素，那么直接插入一个元素，并使 $first(r)$ 指向这个元素；

(2) 如果第 $r$ 行有元素，那么将这个新元素 **用一种奇异的方式** 与 $c$ 和 $first(r)$ 连接起来。

对于 (1)，我们可以通过 `first[r] = L[idx] = R[idx] = idx;` 来实现；

对于 (2)，（我们称这个新元素为 $idx$ ）：

-   我们把 $idx$ 插入到 $c$ 的正下方，此时：

    (1) $idx$ 下方的结点为原来 $c$ 的下结点；

    (2) $idx$ 下方的结点（即原来 $c$ 的下结点）的上结点为 $idx$ ;

    (3) $idx$ 的上结点为 $c$ ；

    (4) $c$ 的下结点为 $idx$ 。

    注意记录 $idx$ 的所在列和所在行，以及更新这一列的元素个数。

    ```cpp
    col[++idx] = c, row[idx] = r, ++siz[c];
    U[idx] = c, D[idx] = D[c], U[D[c]] = idx, D[c] = idx;
    ```

     **强烈建议读者完全掌握这几步的顺序后再继续阅读本文。** 

-   我们把 $idx$ 插入到 $first(r)$ 的正右方，此时：

    (1) $idx$ 右侧的结点为原来 $first(r)$ 的右结点；

    (2) 原来 $first(r)$ 右侧的结点的左结点为 $idx$ ；

    (3) $idx$ 的左结点为 $first(r)$ ；

    (4) $first(r)$ 的右结点为 $idx$ 。

    ```cpp
    L[idx] = first[r], R[idx] = R[first[r]];
    R[first[r]] = idx, L[R[first[r]]] = idx;
    ```

     **强烈建议读者完全掌握这几步的顺序后再继续阅读本文。** 

对于 $\text{insert(r, c)}$ 这个操作，我们可以画图来辅助理解：

![dlx-6.png](./images/dlx-6.png)

留心曲线箭头的方向。

在这里给出 $\text{insert(r, c)}$ 的代码：

```cpp
void insert(const int &r, const int &c) {
  row[++idx] = r, col[idx] = c, ++siz[c];
  U[idx] = D[idx] = c, U[D[c]] = idx, D[c] = idx;
  if (!first[r])
    first[r] = L[idx] = R[idx] = idx;
  else {
    L[idx] = first[r], R[idx] = R[first[r]];
    L[R[first[r]]] = idx, R[first[r]] = idx;
  }
}
```

### dance 操作

 $\text{dance()}$ 即为递归地删除以及还原各个行列的过程。

(1) 如果 $0$ 号结点没有右结点，那么矩阵为空，记录答案并返回；

(2) 选择列元素个数最少的一列，并删掉这一列；

(3) 遍历这一列所有有 $1$ 的行，枚举它是否被选择；

(4) 递归调用 $\text{dance()}$ ，如果可行，则返回；如果不可行，则恢复被选择的行；

(5) 如果无解，则返回；

在这里给出 $\text{dance()}$ 的代码实现：

```cpp
bool dance(int dep) {
  int i, j, c = R[0];
  if (!R[0]) {
    ans = dep;
    return 1;
  }
  IT(i, R, 0) if (siz[i] < siz[c]) c = i;
  remove(c);
  IT(i, D, c) {
    stk[dep] = row[i];
    IT(j, R, i) remove(col[j]);
    if (dance(dep + 1)) return 1;
    IT(j, L, i) recover(col[j]);
  }
  recover(c);
  return 0;
}
```

其中 `stk[]` 用来记录答案。

注意我们每次优先选择列元素个数最少的一列进行删除，这样能保证程序具有一定的启发性，使搜索树分支最少。

## 模板

 [【模板】舞蹈链（DLX）](https://www.luogu.com.cn/problem/P4929) 

??? note "模板代码"

    ```cpp
    #include <bits/stdc++.h>
    #define ll long long
    #define rgi register int
    #define rgl register ll
    #define il inline
    const int N = 500 + 10;
    int n, m, idx, ans;
    int first[N], siz[N], stk[N];
    struct DLXNODE {
      int lc, rc, up, dn, r, c;
    };
    il int read() {
      rgi x = 0, f = 0, ch;
      while(!isdigit(ch = getchar())) f |= ch == '-';
      while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
      return f ? -x : x;
    }
    struct DLX {
      static const int MAXSIZE = 1e5 + 10;
    #define IT(i, A, x) for(i = A[x]; i != x; i = A[i])
      int n, m, tot, first[MAXSIZE + 10], siz[MAXSIZE + 10];
      int L[MAXSIZE + 10], R[MAXSIZE + 10], U[MAXSIZE + 10], D[MAXSIZE + 10];
      int col[MAXSIZE + 10], row[MAXSIZE + 10];
      void build(const int &r, const int &c) {
        n = r, m = c;
        for(rgi i = 0; i <= c; ++i) {
          L[i] = i - 1, R[i] = i + 1;
          U[i] = D[i] = i;
        }
        L[0] = c, R[c] = 0, tot = c;
        memset(first, 0, sizeof(first));
        memset(siz, 0, sizeof(siz));
      }
      void insert(const int &r, const int &c) {
        col[++tot] = c, row[tot] = r, ++siz[c];
        D[tot] = D[c], U[D[c]] = tot, U[tot] = c, D[c] = tot;
        if(!first[r]) first[r] = L[tot] = R[tot] = tot;
        else {
          R[tot] = R[first[r]], L[R[first[r]]] = tot;
          L[tot] = first[r], R[first[r]] = tot;
        }
      }
      void remove(const int &c) {
        rgi i, j;
        L[R[c]] = L[c], R[L[c]] = R[c];
        IT(i, D, c) IT(j, R, i)
        U[D[j]] = U[j], D[U[j]] = D[j], --siz[col[j]];
      }
      void recover(const int &c) {
        rgi i, j;
        IT(i, U, c) IT(j, L, i)
        U[D[j]] = D[U[j]] = j, ++siz[col[j]];
        L[R[c]] = R[L[c]] = c;
      }
      bool dance(int dep) {
        if(!R[0]) { ans = dep; return 1; }
        rgi i, j, c = R[0];
        IT(i, R, 0) if(siz[i] < siz[c]) c = i;
        remove(c);
        IT(i, D, c) {
          stk[dep] = row[i];
          IT(j, R, i) remove(col[j]);
          if(dance(dep + 1)) return 1;
          IT(j, L, i) recover(col[j]);
        }
        recover(c);
        return 0;
      }
    #undef IT
    } solver;
    int main() {
      n = read(), m = read();
      solver.build(n, m);
      for(rgi i = 1; i <= n; ++i) for(rgi j = 1; j <= m; ++j) {
        int x = read();
        if(x) solver.insert(i, j);
      } solver.dance(1);
      if(ans)
        for(rgi i = 1; i < ans; ++i) printf("%d ", stk[i]);
      else
        puts("No Solution!");
      return 0;
    }
    ```

## 时间复杂度分析

DLX 的时间复杂度是 **指数级** 的，它递归及回溯的次数与矩阵中 $1$ 的个数有关，与矩阵的 $r, c$ 等参数无关。

因此理论复杂度大概在 $O(c^n)$ 左右，其中 $c$ 为某个非常接近于 $1$ 的常数， $n$ 为矩阵中 $1$ 的个数。

但实际情况下 DLX 表现良好，一般能解决大部分的问题。

## 如何建模

DLX 的难点，不全在于链表的建立，而在于建模。

 **请确保已经完全掌握 DLX 模板后再继续阅读本文。** 

我们每拿到一个题，应该考虑行和列所表示的意义：

-   行表示_决策_，因为每行对应着一个集合，也就对应着选/不选；

-   列表示_状态_，因为第 $i$ 列对应着某个条件 $P_i$ 。

对于某一行而言，由于不同的列的值不尽相同，我们 **由不同的状态，定义了一个决策** 。

1.   [数独](https://www.luogu.com.cn/problem/P1784) 

    ??? note "解题思路"

        先考虑决策是什么。

        在这一题中，每一个决策可以用形如 $(r, c, w)$ 的有序三元组表示。

        注意到 “宫” 并不是决策的参数，因为它 **可以被每个确定的 $(r, c)$ 表示**。

        因此有 $9 \times 9 \times 9 = 729$ 行。

        再考虑状态是什么。

        我们思考一下 $(r, c, w)$ 这个决将会造成什么影响。记 $(r, c)$ 所在的宫为 $b$。

        (1) 第 $r$ 行用了一个 $w$（用 $9 \times 9 = 81$ 列表示）；

        (2) 第 $c$ 列用了一个 $w$（用 $9 \times 9 = 81$ 列表示）；

        (3) 第 $b$ 宫用了一个 $w$（用 $9 \times 9 = 81$ 列表示）；

        (4) $(r, c)$ 中填入了一个数（用 $9 \times 9 = 81$ 列表示）。

        因此有 $81 \times 4 = 324$ 列，共 $729 \times 4 = 2916$ 个 $1$。

        至此，我们成功地将 $9 \times 9$ 的数独问题转化成了一个**有 $729$ 行，$324$ 列，共 $2916$ 个 $1$** 的精确覆盖问题。

    ??? note "参考代码"

        ```cpp
        #include <bits/stdc++.h>
        #define LL long long
        #define rgi register int
        #define il inline
        const int N = 1e6 + 10;
        #define JUDGE 0
        #define DEBUG 0
        int ans[10][10], stk[N];
        il int read() {
          rgi x = 0, f = 0, ch;
          while(!isdigit(ch = getchar())) f |= ch == '-';
          while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
          return f ? -x : x;
        }
        struct DLX {
          static const int MAXSIZE = 1e5 + 10;
        #define IT(i, A, x) for(i = A[x]; i != x; i = A[i])
          int n, m, tot, first[MAXSIZE + 10], siz[MAXSIZE + 10];
          int L[MAXSIZE + 10], R[MAXSIZE + 10], U[MAXSIZE + 10], D[MAXSIZE + 10];
          int col[MAXSIZE + 10], row[MAXSIZE + 10];
          void build(const int &r, const int &c) {
            n = r, m = c;
            for(rgi i = 0; i <= c; ++i) {
              L[i] = i - 1, R[i] = i + 1;
              U[i] = D[i] = i;
            }
            L[0] = c, R[c] = 0, tot = c;
            memset(first, 0, sizeof(first));
            memset(siz, 0, sizeof(siz));
          }
          void insert(const int &r, const int &c) {
            col[++tot] = c, row[tot] = r, ++siz[c];
            D[tot] = D[c], U[D[c]] = tot, U[tot] = c, D[c] = tot;
            if(!first[r]) first[r] = L[tot] = R[tot] = tot;
            else {
              R[tot] = R[first[r]], L[R[first[r]]] = tot;
              L[tot] = first[r], R[first[r]] = tot;
            }
          }
          void remove(const int &c) {
            rgi i, j;
            L[R[c]] = L[c], R[L[c]] = R[c];
            IT(i, D, c) IT(j, R, i)
            U[D[j]] = U[j], D[U[j]] = D[j], --siz[col[j]];
          }
          void recover(const int &c) {
            rgi i, j;
            IT(i, U, c) IT(j, L, i)
            U[D[j]] = D[U[j]] = j, ++siz[col[j]];
            L[R[c]] = R[L[c]] = c;
          }
          bool dance(int dep) {
            rgi i, j, c = R[0];
            if(!R[0]) {
              for(i = 1; i < dep; ++i) {
                int x = (stk[i] - 1) / 9 / 9 + 1;
                int y = (stk[i] - 1) / 9 % 9 + 1;
                int v = (stk[i] - 1) % 9 + 1;
                ans[x][y] = v;
              }
              return 1;
            }
            IT(i, R, 0) if(siz[i] < siz[c]) c = i;
            remove(c);
            IT(i, D, c) {
              stk[dep] = row[i];
              IT(j, R, i) remove(col[j]);
              if(dance(dep + 1)) return 1;
              IT(j, L, i) recover(col[j]);
            }
            recover(c);
            return 0;
          }
        } solver;
        int GetId(int row, int col, int num) { return (row - 1) * 9 * 9 + (col - 1) * 9 + num; }
        void Insert(int row, int col, int num) {
          int dx = (row - 1) / 3 + 1;
          int dy = (col - 1) / 3 + 1;
          int room = (dx - 1) * 3 + dy;
          int id = GetId(row, col, num);
          int f1 = (row - 1) * 9 + num; // task 1
          int f2 = 81 + (col - 1) * 9 + num; // task 2
          int f3 = 81 * 2 + (room - 1) * 9 + num; // task 3
          int f4 = 81 * 3 + (row - 1) * 9 + col; // task 4
          solver.insert(id, f1);
          solver.insert(id, f2);
          solver.insert(id, f3);
          solver.insert(id, f4);
        }
        int main() {
        #if JUDGE
          freopen(".in", "r", stdin);
          freopen(".out", "w", stdout);
        #endif
          solver.build(729, 324);
          for(rgi i = 1; i <= 9; ++i) for(rgi j = 1; j <= 9; ++j) {
            ans[i][j] = read();
            for(rgi v = 1; v <= 9; ++v) {
              if(ans[i][j] && ans[i][j] != v) continue;
              Insert(i, j, v);
            }
          } solver.dance(1);
          for(rgi i = 1; i <= 9; ++i, putchar('\n')) for(rgi j = 1; j <= 9; ++j, putchar(' '))
            printf("%d", ans[i][j]);
          return 0;
        }
        ```

2.   [靶形数独](https://www.luogu.com.cn/problem/P1074) 

    ??? note "解题思路"

        这一题与 [数独](https://www.luogu.com.cn/problem/P1784) 的模型构建 **一模一样**，主要区别在于答案的更新。

        这一题可以开一个权值数组，每次找到一组数独的解时，

        每个位置上的数乘上对应的权值计入答案即可。

    ??? note "参考代码"

        ```cpp
        #include <bits/stdc++.h>
        #define LL long long
        #define il inline
        const int oo = 0x3f3f3f3f;
        const int N = 1e5 + 10;
        const int e[] = { 6, 6, 6, 6, 6, 6, 6, 6, 6,
                          6, 7, 7, 7, 7, 7, 7, 7, 6,
                          6, 7, 8, 8, 8, 8, 8, 7, 6,
                          6, 7, 8, 9, 9, 9, 8, 7, 6,
                          6, 7, 8, 9, 10, 9, 8, 7, 6,
                          6, 7, 8, 9, 9, 9, 8, 7, 6,
                          6, 7, 8, 8, 8, 8, 8, 7, 6,
                          6, 7, 7, 7, 7, 7, 7, 7, 6,
                          6, 6, 6, 6, 6, 6, 6, 6, 6
                        };
        int ans = -oo, a[10][10], stk[N];
        il int read() {
          int x = 0, f = 0, ch;
          while(!isdigit(ch = getchar())) f |= ch == '-';
          while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
          return f ? -x : x;
        }
        int GetWeight(int row, int col, int num) { return num * e[(row - 1) * 9 + (col - 1)]; }
        struct DLX {
          static const int MAXSIZE = 1e5 + 10;
        #define IT(i, A, x) for(i = A[x]; i != x; i = A[i])
          int n, m, tot, first[MAXSIZE + 10], siz[MAXSIZE + 10];
          int L[MAXSIZE + 10], R[MAXSIZE + 10], U[MAXSIZE + 10], D[MAXSIZE + 10];
          int col[MAXSIZE + 10], row[MAXSIZE + 10];
          void build(const int &r, const int &c) {
            n = r, m = c;
            for(int i = 0; i <= c; ++i) {
              L[i] = i - 1, R[i] = i + 1;
              U[i] = D[i] = i;
            }
            L[0] = c, R[c] = 0, tot = c;
            memset(first, 0, sizeof(first));
            memset(siz, 0, sizeof(siz));
          }
          void insert(const int &r, const int &c) {
            col[++tot] = c, row[tot] = r, ++siz[c];
            D[tot] = D[c], U[D[c]] = tot, U[tot] = c, D[c] = tot;
            if(!first[r]) first[r] = L[tot] = R[tot] = tot;
            else {
              R[tot] = R[first[r]], L[R[first[r]]] = tot;
              L[tot] = first[r], R[first[r]] = tot;
            }
          }
          void remove(const int &c) {
            int i, j;
            L[R[c]] = L[c], R[L[c]] = R[c];
            IT(i, D, c) IT(j, R, i)
            U[D[j]] = U[j], D[U[j]] = D[j], --siz[col[j]];
          }
          void recover(const int &c) {
            int i, j;
            IT(i, U, c) IT(j, L, i)
            U[D[j]] = D[U[j]] = j, ++siz[col[j]];
            L[R[c]] = R[L[c]] = c;
          }
          void dance(int dep) {
            int i, j, c = R[0];
            if(!R[0]) {
              int cur_ans = 0;
              for(i = 1; i < dep; ++i) {
                int cur_row = (stk[i] - 1) / 9 / 9 + 1;
                int cur_col = (stk[i] - 1) / 9 % 9 + 1;
                int cur_num = (stk[i] - 1) % 9 + 1;
                cur_ans += GetWeight(cur_row, cur_col, cur_num);
              }
              ans = std::max(ans, cur_ans);
              return;
            }
            IT(i, R, 0) if(siz[i] < siz[c]) c = i;
            remove(c);
            IT(i, D, c) {
              stk[dep] = row[i];
              IT(j, R, i) remove(col[j]);
              dance(dep + 1);
              IT(j, L, i) recover(col[j]);
            }
            recover(c);
          }
        } solver;
        int GetId(int row, int col, int num) { return (row - 1) * 9 * 9 + (col - 1) * 9 + num; }
        void Insert(int row, int col, int num) {
          int dx = (row - 1) / 3 + 1; // r
          int dy = (col - 1) / 3 + 1; // c
          int room = (dx - 1) * 3 + dy; // room
          int id = GetId(row, col, num);
          int f1 = (row - 1) * 9 + num; // task 1
          int f2 = 81 + (col - 1) * 9 + num; // task 2
          int f3 = 81 * 2 + (room - 1) * 9 + num; // task 3
          int f4 = 81 * 3 + (row - 1) * 9 + col; // task 4
          solver.insert(id, f1);
          solver.insert(id, f2);
          solver.insert(id, f3);
          solver.insert(id, f4);
        }
        int main() {
          solver.build(729, 324);
          for(int i = 1; i <= 9; ++i) for(int j = 1; j <= 9; ++j) {
            a[i][j] = read();
            for(int v = 1; v <= 9; ++v) {
              if(a[i][j] && v != a[i][j]) continue;
              Insert(i, j, v);
            }
          } solver.dance(1);
          printf("%d", ans == -oo ? -1 : ans);
          return 0;
        }
        ```

3.   [「NOI2005」智慧珠游戏](https://www.luogu.com.cn/problem/P4205) 

    ??? note "解题思路"

        定义：题中给我们的智慧珠的形态，称为这个智慧珠的 *标准形态*。

        显然，我们可以通过改变两个参数 $d$（表示顺时针旋转 $90^{\circ}$ 的次数）和 $f$（是否水平翻转）来改变这个智慧珠的形态。

        仍然，我们先考虑决策是什么。

        在这一题中，每一个决策可以用形如 $(v, d, f, i)$ 的有序五元组表示。

        表示第 $i$ 个智慧珠的 *标准形态* 的左上角的位置，序号为 $v$，经过了 $d$ 次顺时针转 $90^{\circ}$。

        巧合的是，我们可以令 $f = 1$ 时不水平翻转，$f = -1$ 时水平翻转，从而达到简化代码的目的。

        因此有 $55 \times 4 \times 2 \times 12 = 5280$ 行。

        需要注意的是，因为一些不合法的填充，如 $(1, 0, 1, 4)$，

        所以**在实际操作中，空的智慧珠棋盘也只需要建出 $2730$ 行。**

        再考虑状态是什么。

        这一题的状态比较简单。

        我们思考一下，$(v, d, f, i)$ 这个决策会造成什么影响。

        (1) 某些格子被占了（用 $55$ 列表示）；

        (2) 第 $i$ 个智慧珠被用了（用 $12$ 列表示）。

        因此有 $55 + 12 = 67$ 列，共 $5280 \times (5 + 1) = 31680$ 个 $1$。

        至此，我们成功地将智慧珠游戏转化成了一个**有 $5280$ 行，$67$ 列，共 $31680$ 个 $1$** 的精确覆盖问题。

    ??? note "参考代码"

        ```cpp
        #include <bits/stdc++.h>
        #define LL long long
        int numcol, numrow;
        int dfn[3000], tx[2], nxt[2], num[50][50], vis[50];
        char ans[50][50];
        const int f[2] = { -1, 1 };
        const int table[12][5][2] = {
          // directions of shapes
          { { 0, 0 }, { 1, 0 }, { 0, 1 } },                       // A
          { { 0, 0 }, { 0, 1 }, { 0, 2 }, { 0, 3 } },             // B
          { { 0, 0 }, { 1, 0 }, { 0, 1 }, { 0, 2 } },             // C
          { { 0, 0 }, { 1, 0 }, { 0, 1 }, { 1, 1 } },             // D
          { { 0, 0 }, { 1, 0 }, { 2, 0 }, { 2, 1 }, { 2, 2 } },   // E
          { { 0, 0 }, { 0, 1 }, { 1, 1 }, { 0, 2 }, { 0, 3 } },   // F
          { { 0, 0 }, { 1, 0 }, { 0, 1 }, { 0, 2 }, { 1, 2 } },   // G
          { { 0, 0 }, { 1, 0 }, { 0, 1 }, { 1, 1 }, { 0, 2 } },   // H
          { { 0, 0 }, { 0, 1 }, { 0, 2 }, { 1, 2 }, { 1, 3 } },   // I
          { { 0, 0 }, { -1, 1 }, { 0, 1 }, { 1, 1 }, { 0, 2 } },  // J
          { { 0, 0 }, { 1, 0 }, { 1, 1 }, { 2, 1 }, { 2, 2 } },   // K
          { { 0, 0 }, { 1, 0 }, { 0, 1 }, { 0, 2 }, { 0, 3 } },   // L
        };
        const int len[12] = { 3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5 };
        const int getx[] = { 0,  1,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,
                             6,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,
                             9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11,
                             11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13,
                             13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14
                           };
        const int gety[] = { 0,  1, 1, 2,  1, 2, 3, 1, 2, 3, 4,  1,  2,  3,  4,  5, 1, 2, 3, 4, 5, 6, 1, 2, 3,  4,
                             5,  6, 7, 1,  2, 3, 4, 5, 6, 7, 8,  1,  2,  3,  4,  5, 6, 7, 8, 9, 1, 2, 3, 4, 5,  6,
                             7,  8, 9, 10, 1, 2, 3, 4, 5, 6, 7,  8,  9,  10, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
                             12, 1, 2, 3,  4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1,  2, 3, 4, 5, 6, 7, 8, 9
                           };
        struct DLX {
          static const int MS = 1e5 + 10;
        #define IT(i, A, x) for (i = A[x]; i != x; i = A[i])
          int n, m, tot, first[MS], siz[MS];
          int L[MS], R[MS], U[MS], D[MS];
          int col[MS], row[MS];
          void build(const int &r, const int &c) {
            n = r, m = c;
            for (rgi i = 0; i <= c; ++i) {
              L[i] = i - 1, R[i] = i + 1;
              U[i] = D[i] = i;
            }
            L[0] = c, R[c] = 0, tot = c;
            memset(first, 0, sizeof(first));
            memset(siz, 0, sizeof(siz));
          }
          void insert(const int &r, const int &c) {
            col[++tot] = c, row[tot] = r, ++siz[c];
            D[tot] = D[c], U[D[c]] = tot, U[tot] = c, D[c] = tot;
            if (!first[r])
              first[r] = L[tot] = R[tot] = tot;
            else
              R[tot] = R[first[r]], L[R[first[r]]] = tot, L[tot] = first[r], R[first[r]] = tot;  // !
          }
          void remove(const int &c) {
            rgi i, j;
            L[R[c]] = L[c], R[L[c]] = R[c];
            IT(i, D, c) IT(j, R, i) U[D[j]] = U[j], D[U[j]] = D[j], --siz[col[j]];
          }
          void recover(const int &c) {
            rgi i, j;
            IT(i, U, c) IT(j, L, i) U[D[j]] = D[U[j]] = j, ++siz[col[j]];
            L[R[c]] = R[L[c]] = c;
          }
          bool dance() {
            if (!R[0])
              return 1;
            rgi i, j, c = R[0];
            IT(i, R, 0) if (siz[i] < siz[c]) c = i;
            remove(c);
            IT(i, D, c) {
              if (col[i] <= 55)
                ans[getx[col[i]]][gety[col[i]]] = dfn[row[i]] + 'A';
              IT(j, R, i) {
                remove(col[j]);
                if (col[j] <= 55)
                  ans[getx[col[j]]][gety[col[j]]] = dfn[row[j]] + 'A';
              }
              if (dance())
                return 1;
              IT(j, L, i) recover(col[j]);
            }
            recover(c);
            return 0;
          }
        #undef IT
        } solver;
        int main() {
          for (rgi i = 1; i <= 10; ++i) scanf("%s", ans[i] + 1);
          for (rgi i = 1; i <= 10; ++i)
            for (rgi j = 1; j <= i; ++j) {
              if (ans[i][j] != '.')
                vis[ans[i][j] - 'A'] = 1;
              num[i][j] = ++numcol;
            }
          solver.build(2730, numcol + 12);
          /*******build*******/
          for (rgi id = 0, op; id < 12; ++id) {  // every block
            for (++numcol, op = 0; op <= 1; ++op) {
              for (rgi dx = 0; dx <= 1; ++dx) {
                for (rgi dy = 0; dy <= 1; ++dy) {
                  for (tx[0] = 1; tx[0] <= 10; ++tx[0]) {
                    for (tx[1] = 1; tx[1] <= tx[0]; ++tx[1]) {
                      bool flag = 1;
                      for (rgi k = 0; k < len[id]; ++k) {
                        nxt[op] = tx[op] + f[dx] * table[id][k][0];
                        nxt[op ^ 1] = tx[op ^ 1] + f[dy] * table[id][k][1];
                        if (vis[id]) {
                          if (ans[nxt[0]][nxt[1]] != id + 'A') {
                            flag = 0;
                            break;
                          }
                        } else if (ans[nxt[0]][nxt[1]] != '.') {
                          flag = 0;
                          break;
                        }
                      }
                      if (!flag)
                        continue;
                      dfn[++numrow] = id;
                      solver.insert(numrow, numcol);
                      for (rgi k = 0; k < len[id]; ++k) {
                        nxt[op] = tx[op] + f[dx] * table[id][k][0];
                        nxt[op ^ 1] = tx[op ^ 1] + f[dy] * table[id][k][1];
                        solver.insert(numrow, num[nxt[0]][nxt[1]]);
                      }
                    }
                  }
                }
              }
            }
          }
          /********end********/
          if (!solver.dance())
            puts("No solution");
          else
            for (rgi i = 1; i <= 10; ++i, puts(""))
              for (rgi j = 1; j <= i; ++j) putchar(ans[i][j]);
          return 0;
        }
        ```

## 练习

1.   [SUDOKU - Sudoku](https://www.spoj.com/problems/SUDOKU/) 
2.   [「kuangbin 带你飞」专题三 Dancing Links](https://vjudge.net/contest/65998#overview) 

## 总结

DLX 能用来解决精确覆盖问题，适当地建立起模型后能解决一些大模拟。

## References

-   [1]英雄哪里出来 的 [《夜深人静写算法（九）- Dancing Links X（跳舞链）》](https://blog.csdn.net/whereisherofrom/article/details/79220897) 
-   [2]万仓一黍 的 [《跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题》](https://www.cnblogs.com/grenet/p/3145800.html) 
-   [3]zhangjianjunab 的 [《DLX 算法一览》](https://blog.csdn.net/zhangjianjunab/article/details/83688681) 
-   [4]静听风吟。的 [《搜索：DLX 算法》](https://www.cnblogs.com/aininot260/p/9629926.html) 
-   [5]刘汝佳，陈锋 的 [《算法竞赛进阶指南》](https://item.jd.com/11111050.html) 

# iterative
## 简介

迭代加深是一种 **每次限制搜索深度的** 深度优先搜索。

它的本质还是深度优先搜索，只不过在搜索的同时带上了一个深度 $d$ ，当 $d$ 达到设定的深度时就返回，一般用于找最优解。如果一次搜索没有找到合法的解，就让设定的深度 $+1$ ，重新从根开始。

既然是为了找最优解，为什么不用 BFS 呢？我们知道 BFS 的基础是一个队列，队列的空间复杂度很大，当状态比较多或者单个状态比较大时，使用队列的 BFS 就显出了劣势。事实上，迭代加深就类似于用 DFS 方式实现的 BFS，它的空间复杂度相对较小。

当搜索树的分支比较多时，每增加一层的搜索复杂度会出现指数级爆炸式增长，这时前面重复进行的部分所带来的复杂度几乎可以忽略，这也就是为什么迭代加深是可以近似看成 BFS 的。

## 步骤

首先设定一个较小的深度作为全局变量，进行 DFS。每进入一次 DFS，将当前深度 $d++$ ，当发现 $d$ 大于设定的深度就返回。如果在搜索的途中发现了答案就可以回溯，同时在回溯的过程中可以记录路径。如果没有发现答案，就返回到函数入口，增加设定深度，继续搜索。

## 代码结构

```text
IDDFS(u,d)
    if d>设定深度
        return
    else
        for each edge (u,v)
            IDDFS(v,d+1)
	return
```

## 注意事项

在大多数的题目中，广度优先搜索还是比较方便的，而且容易判重。当发现广度优先搜索在空间上不够优秀，而且要找最优解的问题时，就应该考虑迭代加深。

# idastar
学习 IDA\*之前，请确保您已经学完了 [A\*](./astar.md) 算法和 [迭代加深搜索](./iterative.md) 。

## IDA\*简介

IDA\*，即采用迭代加深的 A\*算法。相对于 A\*算法，由于 IDA\*改成了深度优先的方式，所以 IDA\*更实用：

1.  不需要判重，不需要排序；
2.  空间需求减少。

     **大致框架** （伪代码）：

```text
Procedure IDA_STAR(StartState)
Begin
  PathLimit := H(StartState) - 1;
  Succes := False;
  Repeat
    inc(PathLimit);
    StartState.g = 0;
    Push(OpenStack, StartState);
    Repeat
      CurrentState := Pop(OpenStack);
      If Solution(CurrentState) then
        Success = True
      Elseif PathLimit >= CurrentState.g + H(CurrentState) then
        For each Child(CurrentState) do
          Push(OpenStack, Child(CurrentState));
    until Success or empty(OpenStack);
  until Success or ResourceLimtsReached;
end;
```

### 优点

1.  空间开销小，每个深度下实际上是一个深度优先搜索，不过深度有限制，而 DFS 的空间消耗小是众所周知的；
2.  利于深度剪枝。

### 缺点

重复搜索：回溯过程中每次 depth 变大都要再次从头搜索。

> 其实，前一次搜索跟后一次相差是微不足道的。

## 例题

??? note "埃及分数"
     **题目描述** 

    在古埃及，人们使用单位分数的和（即 $\frac{1}{a}$ ， $a$ 是自然数）表示一切有理数。例如， $\frac{2}{3}=\frac{1}{2}+\frac{1}{6}$ ，但不允许 $\frac{2}{3}=\frac{1}{3}+\frac{1}{3}$ ，因为在加数中不允许有相同的。

    对于一个分数 $\frac{a}{b}$ ，表示方法有很多种，其中加数少的比加数多的好，如果加数个数相同，则最小的分数越大越好。例如， $\frac{19}{45}=\frac{1}{5}+\frac{1}{6}+\frac{1}{18}$ 是最优方案。

    输入整数 $a,b$ （ $0<a<b<500$ ），试编程计算最佳表达式。

    输入样例：

    ```text
    495 499
    ```

    输出样例：

    ```text
    Case 1: 495/499=1/2+1/5+1/6+1/8+1/3992+1/14970
    ```

 **分析** 

这道题目理论上可以用回溯法求解，但是 **解答树** 会非常“恐怖”—不仅深度没有明显的上界，而且加数的选择理论上也是无限的。换句话说，如果用宽度优先遍历，连一层都扩展不完，因为每一层都是 **无限大** 的。

解决方案是采用迭代加深搜索：从小到大枚举深度上限 $maxd$ ，每次执行只考虑深度不超过 $maxd$ 的节点。这样，只要解的深度优先，则一定可以在有限时间内枚举到。

深度上限 $maxd$ 还可以用来 **剪枝** 。按照分母递增的顺序来进行扩展，如果扩展到 i 层时，前 $i$ 个分数之和为 $\frac{c}{d}$ ，而第 $i$ 个分数为 $\frac{1}{e}$ ，则接下来至少还需要 $\frac{\frac{a}{b}-\frac{c}{d}}{\frac{1}{e}}$ 个分数，总和才能达到 $\frac{a}{b}$ 。例如，当前搜索到 $\frac{19}{45}=\frac{1}{5}+\frac{1}{100}+\cdots$ ，则后面的分数每个最大为 $\frac{1}{101}$ ，至少需要 $\frac{\frac{19}{45}-\frac{1}{5}}{\frac{1}{101}}=23$ 项总和才能达到 $\frac{19}{45}$ ，因此前 $22$ 次迭代是根本不会考虑这棵子树的。这里的关键在于：可以估计至少还要多少步才能出解。

注意，这里的估计都是乐观的，因为用了 **至少** 这个词。说得学术一点，设深度上限为 $maxd$ ，当前结点 $n$ 的深度为 $g(n)$ ，乐观估价函数为 $h(n)$ ，则当 $g(n)+h(n)>maxd$ 时应该剪枝。这样的算法就是 IDA\*。当然，在实战中不需要严格地在代码里写出 $g(n)$ 和 $h(n)$ ，只需要像刚才那样设计出乐观估价函数，想清楚在什么情况下不可能在当前的深度限制下出解即可。

> 如果可以设计出一个乐观估价函数，预测从当前结点至少还需要扩展几层结点才有可能得到解，则迭代加深搜索变成了 IDA\*算法。

 **代码** 

```cpp
// 埃及分数问题
#include <algorithm>
#include <cassert>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

int a, b, maxd;

typedef long long LL;

LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b); }

// 返回满足1/c <= a/b的最小c
inline int get_first(LL a, LL b) { return b / a + 1; }

const int maxn = 100 + 5;

LL v[maxn], ans[maxn];

// 如果当前解v比目前最优解ans更优，更新ans
bool better(int d) {
  for (int i = d; i >= 0; i--)
    if (v[i] != ans[i]) {
      return ans[i] == -1 || v[i] < ans[i];
    }
  return false;
}

// 当前深度为d，分母不能小于from，分数之和恰好为aa/bb
bool dfs(int d, int from, LL aa, LL bb) {
  if (d == maxd) {
    if (bb % aa) return false;  // aa/bb必须是埃及分数
    v[d] = bb / aa;
    if (better(d)) memcpy(ans, v, sizeof(LL) * (d + 1));
    return true;
  }
  bool ok = false;
  from = max(from, get_first(aa, bb));  // 枚举的起点
  for (int i = from;; i++) {
    // 剪枝：如果剩下的maxd+1-d个分数全部都是1/i，加起来仍然不超过aa/bb，则无解
    if (bb * (maxd + 1 - d) <= i * aa) break;
    v[d] = i;
    // 计算aa/bb - 1/i，设结果为a2/b2
    LL b2 = bb * i;
    LL a2 = aa * i - bb;
    LL g = gcd(a2, b2);  // 以便约分
    if (dfs(d + 1, i + 1, a2 / g, b2 / g)) ok = true;
  }
  return ok;
}

int main() {
  int kase = 0;
  while (cin >> a >> b) {
    int ok = 0;
    for (maxd = 1; maxd <= 100; maxd++) {
      memset(ans, -1, sizeof(ans));
      if (dfs(0, get_first(a, b), a, b)) {
        ok = 1;
        break;
      }
    }
    cout << "Case " << ++kase << ": ";
    if (ok) {
      cout << a << "/" << b << "=";
      for (int i = 0; i < maxd; i++) cout << "1/" << ans[i] << "+";
      cout << "1/" << ans[maxd] << "\n";
    } else
      cout << "No solution.\n";
  }
  return 0;
}
```

## 练习题

 [旋转游戏 UVa1343](https://www.luogu.org/problem/UVA1343) 

# backtracking
## 概念表述

回溯法是一种经常被用在深度深度优先搜索（DFS）和广度优先搜索（BFS）的技巧。

其本质是：走不通就回头。

## 实现过程

1.  构造空间树。

2.  进行遍历。

3.  如遇到边界条件，即不再向下搜索，转而搜索另一条链。

4.  达到目标条件，输出结果。

## 经典例题：

### DFS 实现

八皇后问题（USACO 版本）的回溯代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int ans[14], check[3][28] = {0}, sum = 0, n;
void eq(int line) {
  if (line > n) {
    sum++;
    if (sum > 3)
      return;
    else {
      for (int i = 1; i <= n; i++) printf("%d ", ans[i]);
      printf("\n");
      return;
    }
  }
  for (int i = 1; i <= n; i++) {
    if ((!check[0][i]) && (!check[1][line + i]) && (!check[2][line - i + n])) {
      ans[line] = i;
      check[0][i] = 1;
      check[1][line + i] = 1;
      check[2][line - i + n] = 1;
      eq(line + 1);
      check[0][i] = 0;
      check[1][line + i] = 0;
      check[2][line - i + n] = 0;
    }
  }
}
int main() {
  scanf("%d", &n);
  eq(1);
  printf("%d", sum);
  return 0;
}
```

### BFS 实现

迷宫问题（USACO 版本）的回溯代码：

```cpp
using namespace std;
int n, m, k, x, y, a, b, ans;
int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
bool vis[6][6];
struct oo {
  int x, y, used[6][6];
};

oo sa;

void bfs() {
  queue<oo> q;
  sa.x = x;
  sa.y = y;
  sa.used[x][y] = 1;
  q.push(sa);
  while (!q.empty()) {
    oo now = q.front();
    q.pop();
    for (int i = 0; i < 4; i++) {
      int sx = now.x + dx[i];
      int sy = now.y + dy[i];
      if (now.used[sx][sy] || vis[sx][sy] || sx == 0 || sy == 0 || sx > n ||
          sy > m)
        continue;
      if (sx == a && sy == b) {
        ans++;
        continue;
      }
      sa.x = sx;
      sa.y = sy;
      memcpy(sa.used, now.used, sizeof(now.used));
      sa.used[sx][sy] = 1;
      q.push(sa);
    }
  }
}

int main() {
  scanf("%d%d%d", &n, &m, &k);
  scanf("%d%d%d%d", &x, &y, &a, &b);
  for (int i = 1, aa, bb; i <= k; i++) {
    scanf("%d%d", &aa, &bb);
    vis[aa][bb] = 1;
  }
  bfs();
  printf("%d", ans);
  return 0;
}
```

# opt
author: CBW2007, ChungZH, TrisolarisHD, abc1763613206, Ir1d

## 前言

DFS（深度优先搜索）是一种常见的算法，大部分的题目都可以用 DFS 解决，但是大部分情况下，这都是骗分算法，很少会有爆搜为正解的题目。因为 DFS 的时间复杂度特别高。（没学过 DFS 的请自行补上这一课）

既然不能成为正解，那就多骗一点分吧。那么这一篇文章将介绍一些实用的优化算法（俗称“剪枝”）。

先来一段深搜模板，之后的模板将在此基础上进行修改。

```cpp
int ans = 最坏情况, now;  // now为当前答案
void dfs(传入数值) {
  if (到达目的地) ans = 从当前解与已有解中选最优;
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
```

其中的 ans 可以是解的记录，那么从当前解与已有解中选最优就变成了输出解。

## 剪枝方法

最常用的剪枝有三种，记忆化搜索、最优性剪枝、可行性剪枝。

### 记忆化搜索

因为在搜索中，相同的传入值往往会带来相同的解，那我们就可以用数组来记忆，详见 [记忆化搜索](../dp/memo.md) 。

 **模板：** 

```cpp
int g[MAXN];  //定义记忆化数组
int ans = 最坏情况, now;
void dfs f(传入数值) {
  if (g[规模] != 无效数值) return;  //或记录解，视情况而定
  if (到达目的地) ans = 从当前解与已有解中选最优;  //输出解，视情况而定
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
int main() {
  ... memset(g, 无效数值, sizeof(g));  //初始化记忆化数组
  ...
}
```

### 最优性剪枝

在搜索中导致运行慢的原因还有一种，就是在当前解已经比已有解差时仍然在搜索，那么我们只需要判断一下当前解是否已经差于已有解。

 **模板：** 

```cpp
int ans = 最坏情况, now;
void dfs(传入数值) {
  if (now比ans的答案还要差) return;
  if (到达目的地) ans = 从当前解与已有解中选最优;
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
```

### 可行性剪枝

 **模板：** 

在搜索中如果当前解已经不可用了还运行，也是在搜索中导致运行慢的原因。

```cpp
int ans = 最坏情况, now;
void dfs(传入数值) {
  if (当前解已不可用) return;
  if (到达目的地) ans = 从当前解与已有解中选最优;
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
```

## 剪枝思路

剪枝思路有很多种，大多需要对于具体问题来分析，在此简要介绍几种常见的剪枝思路。

-   极端法：考虑极端情况，如果最极端（最理想）的情况都无法满足，那么肯定实际情况搜出来的结果不会更优了。

-   调整法：通过对子树的比较剪掉重复子树和明显不是最有“前途”的子树。

-   数学方法：比如在图论中借助连通分量，数论中借助模方程的分析，借助不等式的放缩来估计下界等等。

## 例题

???+note "工作分配问题"
     **题目描述** 

    有 $n$ 份工作要分配给 $n$ 个人来完成，每个人完成一份。第 $i$ 个人完成第 $k$ 份工作所用的时间为一个正整数 $t_{i,k}$，其中 $1 \leq i, k \leq n$。试确定一个分配方案，使得完成这 $n$ 份工作的时间总和最小。

    输入包含 $n + 1$ 行。

    第 1 行为一个正整数 $n$。

    第 2 行到第 $n + 1$ 行中每行都包含 $n$ 个正整数，形成了一个 $n \times n$ 的矩阵。在该矩阵中，第 $i$ 行第 $k$ 列元素 $t_{i,k}$ 表示第 $i$ 个人完成第 $k$ 件工作所要用的时间。

    输出包含一个正整数，表示所有分配方案中最小的时间总和。

    **数据范围**

    $1 \leq n \leq  15$

    $1 \leq t_{i,k} \leq 10^4$

    **输入样例**

    ```text
    5
    9 2 9 1 9
    1 9 8 9 6
    9 9 9 9 1
    8 8 1 8 4
    9 1 7 8 9
    ```

    **输出样例**

    ```text
    5
    ```

由于每个人都必须分配到工作，在这里可以建一个二维数组 `time[i][j]` ，用以表示 $i$ 个人完成 $j$ 号工作所花费的时间。给定一个循环，从第 1 个人开始循环分配工作，直到所有人都分配到。为第 $i$ 个人分配工作时，再循环检查每个工作是否已被分配，没有则分配给 $i$ 个人，否则检查下一个工作。可以用一个一维数组 `is_working[j]` 来表示第 $j$ 号工作是否已被分配，未分配则 `is_working[j]=0` ，否则 `is_working[j]=1` 。利用回溯思想，在工人循环结束后回到上一工人，取消此次分配的工作，而去分配下一工作直到可以分配为止。这样，一直回溯到第 1 个工人后，就能得到所有的可行解。

检查工作分配，其实就是判断取得可行解时的二维数组的第一维下标各不相同并且第二维下标各不相同。而我们是要得到完成这 $n$ 份工作的最小时间总和，即可行解中时间总和最小的一个，故需要再定义一个全局变量 `cost_time_total_min` 表示目前找到的解中最小的时间总和，初始 `cost_time_total_min` 为 `time[i][i]` 之和，即对角线工作时间相加之和。在所有人分配完工作时，比较 `count` 与 `cost_time_total_min` 的大小，如果 `count` 小于 `cost_time_total_min` ，说明找到了一个最优解，此时就把 `count` 赋给 `cost_time_total_min` 。

但考虑到算法的效率，这里还有一个剪枝优化的工作可以做。就是在每次计算局部费用变量 `count​` 的值时，如果判断 `count` 已经大于 `cost_time_total_min` ，就没必要再往下分配了，因为这时得到的解必然不是最优解。

??? note "参考代码"
    ```C++
    #include <cstdio>
    #define N 16
    int is_working[N] = {0};  // 某项工作是否被分配
    int time[N][N];           // 完成某项工作所需的时间
    int cost_time_total_min;  // 完成 n 份工作的最小时间总和
    // i 表示第几个人，count 表示工作费用总和
    void work(int i, int count, int n) {
      // 如果 i 超出了所能分配的最大工作件数，表示分配完成，并且 count 比原来
      // cost_time_total_min 花费少，则更新 cost_time_total_min 的值
      if (i > n && count < cost_time_total_min) {
        cost_time_total_min = count;
        return;
      }
      // 回溯思想
      if (count < cost_time_total_min) {
        // j 表示第几件工作
        for (int j = 1; j <= n; j++) {
          // 如果工作未被分配 is_working = 0
          if (is_working[j] == 0) {
            // 分配工作 is_working = 1
            is_working[j] = 1;
            // 工作交给第 i + 1 个人
            work(i + 1, count + time[i][j], n);
            // 在一轮迭代完成之后，返回到上一个人，要对此次的工作进行重新分配
            // 将 is_working[j] 重设为 0
            is_working[j] = 0;
          }
        }
      }
    }
    int main() {
      int n;
      scanf("%d", &n);
      for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
          scanf("%d", &time[i][j]);
        }
        cost_time_total_min += time[i][i];
      }
      work(1, 0, n);
      printf("%d\n", cost_time_total_min);
      return 0;
    }
    ```

# heuristic
## 概念

简单来说，启发式搜索就是对取和不取都做分析，从中选取更优解（或删去无效解）

由于概念过于抽象，我们使用例题讲解。

??? note " 例题[「NOIP2005 普及组」采药](https://www.luogu.org/problemnew/show/P1048)"
    题目大意：有 $N$ 种物品和一个容量为 $W$ 的背包，每种物品有重量 $wi$ 和价值 $vi$ 两种属性，要求选若干个物品（每种物品只能选一次）放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

## 代码构造

我们写一个估价函数 f，可以剪掉所有无效的 0 枝条（就是剪去大量无用不选枝条）。

估价函数 f 的运行过程如下：

我们在取的时候判断一下是不是超过了规定体积（可行性剪枝）。

在不取的时候判断一下不取这个时，剩下的药所有的价值 + 现有的价值是否大于目前找到的最优解（最优性剪枝）。

## 例题代码

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
const int N = 105;
int n, m, ans;
struct Node {
  int a, b;  // a代表时间，b代表价值
  double f;
} node[N];

bool operator<(Node p, Node q) { return p.f > q.f; }

int f(int t, int v) {
  int tot = 0;
  for (int i = 1; t + i <= n; i++)
    if (v >= node[t + i].a) {
      v -= node[t + i].a;
      tot += node[t + i].b;
    } else
      return (int)(tot + v * node[t + i].f);
  return tot;
}

void work(int t, int p, int v) {
  ans = max(ans, v);
  if (t > n) return;
  if (f(t, p) + v > ans) work(t + 1, p, v);
  if (node[t].a <= p) work(t + 1, p - node[t].a, v + node[t].b);
}

int main() {
  scanf("%d %d", &m, &n);
  for (int i = 1; i <= n; i++) {
    scanf("%d %d", &node[i].a, &node[i].b);
    node[i].f = 1.0 * node[i].b / node[i].a;
  }
  sort(node + 1, node + n + 1);
  work(1, m, 0);
  printf("%d\n", ans);
  return 0;
}
```

# index
搜索，也就是对状态空间进行枚举。通过穷尽所有的可能，来找到最优解，或者统计合法解的个数。

搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。

搜索是一些高级算法的基础，在 OI 中，纯粹的搜索往往也是得到部分分的手段，但可以通过纯粹的搜索拿到满分的题目非常少。

## 经典题目

-    [「kuangbin 带你飞」专题一 简单搜索](https://vjudge.net/contest/65959) 
-    [「kuangbin 带你飞」专题二 搜索进阶](https://vjudge.net/contest/65997) 

# bfs
BFS 是图论中的一种遍历算法，详见 [BFS](../graph/bfs.md) .

BFS 在搜索中也很常用，将每个状态对应为图中的一个点即可。

# astar
A\*算法是 [BFS](./bfs.md) 的一种改进。

定义起点 $s$ ，终点 $t$ 。

从起点（初始状态）开始的距离函数 $g(x)$ 。

到终点（最终状态）的距离函数 $h(x), h*(x)$ 。

定义每个点的估价函数 $f(x)=g(x)+h(x)$ 。

A\*算法每次从 **优先队列** 中取出一个 $f$ 最小的，然后更新相邻的状态。

如果 $h\leq h*$ ，则 A\*算法能找到最优解。

上述条件下，如果 $h$  **满足三角形不等式，则 A\*算法不会将重复结点加入队列** 。

其实…… $h=0$ 时就是 [DFS](./dfs.md) 算法， $h=0$ 并且边权为 $1$ 时就是 [BFS](./bfs.md) 。

## 例题 [八数码](https://www.luogu.org/problemnew/show/P1379) 

题目大意：在 $3\times 3$ 的棋盘上，摆有八个棋子，每个棋子上标有 1 至 8 的某一数字。棋盘中留有一个空格，空格用 0 来表示。空格周围的棋子可以移到空格中，这样原来的位置就会变成空格。给出一种初始布局和目标布局（为了使题目简单，设目标状态为

    123
    804
    765

），找到一种从初始布局到目标布局最少步骤的移动方法。

 $h$ 函数可以定义为，不在应该在的位置的数字个数。

容易发现 $h$ 满足以上两个性质，此题可以使用 A\*算法求解。

代码实现：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
#include <set>
using namespace std;
const int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};
int fx, fy;
char ch;
struct matrix {
  int a[5][5];
  bool operator<(matrix x) const {
    for (int i = 1; i <= 3; i++)
      for (int j = 1; j <= 3; j++)
        if (a[i][j] != x.a[i][j]) return a[i][j] < x.a[i][j];
    return false;
  }
} f, st;
int h(matrix a) {
  int ret = 0;
  for (int i = 1; i <= 3; i++)
    for (int j = 1; j <= 3; j++)
      if (a.a[i][j] != st.a[i][j]) ret++;
  return ret;
}
struct node {
  matrix a;
  int t;
  bool operator<(node x) const { return t + h(a) > x.t + h(x.a); }
} x;
priority_queue<node> q;
set<matrix> s;
int main() {
  st.a[1][1] = 1;
  st.a[1][2] = 2;
  st.a[1][3] = 3;
  st.a[2][1] = 8;
  st.a[2][2] = 0;
  st.a[2][3] = 4;
  st.a[3][1] = 7;
  st.a[3][2] = 6;
  st.a[3][3] = 5;
  for (int i = 1; i <= 3; i++)
    for (int j = 1; j <= 3; j++) {
      scanf(" %c", &ch);
      f.a[i][j] = ch - '0';
    }
  q.push({f, 0});
  while (!q.empty()) {
    x = q.top();
    q.pop();
    if (!h(x.a)) {
      printf("%d\n", x.t);
      return 0;
    }
    for (int i = 1; i <= 3; i++)
      for (int j = 1; j <= 3; j++)
        if (!x.a.a[i][j]) fx = i, fy = j;
    for (int i = 0; i < 4; i++) {
      int xx = fx + dx[i], yy = fy + dy[i];
      if (1 <= xx && xx <= 3 && 1 <= yy && yy <= 3) {
        swap(x.a.a[fx][fy], x.a.a[xx][yy]);
        if (!s.count(x.a)) s.insert(x.a), q.push({x.a, x.t + 1});
        swap(x.a.a[fx][fy], x.a.a[xx][yy]);
      }
    }
  }
  return 0;
}
```

## 例题 [k 短路](https://www.luogu.org/problemnew/show/P2483) 

题目大意：按顺序求一个有向图上从结点 $s$ 到结点 $t$ 的所有路径最小的前任意多（不妨设为 $k$ ）个。

很容易发现，这个问题很容易转化成用 A\*算法解决问题的标准程式。

初始状态为处于结点 $s$ ，最终状态为处于结点 $t$ ，距离函数为从 $s$ 到当前结点已经走过的距离，估价函数为从当前结点到结点 $t$ 至少要走过的距离，也就是当前结点到结点 $t$ 的最短路。

就这样，我们在预处理的时候反向建图，计算出结点 $t$ 到所有点的最短路，然后将初始状态塞入优先队列，每次取出 $f(x)=g(x)+h(x)$ 最小的一项，计算出其所连结点的信息并将其也塞入队列。当你第 $k$ 次走到结点 $t$ 时，也就算出了结点 $s$ 到结点 $t$ 的 $k$ 短路。

由于设计的距离函数和估价函数，每个状态需要存储两个参数，当前结点 $x$ 和已经走过的距离 $v$ 。

我们可以在此基础上加一点小优化：由于只需要求出第 $k$ 短路，所以当我们第 $k+1$ 次或以上走到该结点时，直接跳过该状态。因为前面的 $k$ 次走到这个点的时候肯定能因此构造出 $k$ 条路径，所以之后在加边更无必要。

代码实现：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 5010;
const int maxm = 400010;
const double inf = 2e9;
int n, m, k, u, v, cur, h[maxn], nxt[maxm], p[maxm], cnt[maxn], ans;
int cur1, h1[maxn], nxt1[maxm], p1[maxm];
double e, ww, w[maxm], f[maxn];
double w1[maxm];
bool tf[maxn];
void add_edge(int x, int y, double z) {
  cur++;
  nxt[cur] = h[x];
  h[x] = cur;
  p[cur] = y;
  w[cur] = z;
}
void add_edge1(int x, int y, double z) {
  cur1++;
  nxt1[cur1] = h1[x];
  h1[x] = cur1;
  p1[cur1] = y;
  w1[cur1] = z;
}
struct node {
  int x;
  double v;
  bool operator<(node a) const { return v + f[x] > a.v + f[a.x]; }
};
priority_queue<node> q;
struct node2 {
  int x;
  double v;
  bool operator<(node2 a) const { return v > a.v; }
} x;
priority_queue<node2> Q;
int main() {
  scanf("%d%d%lf", &n, &m, &e);
  while (m--) {
    scanf("%d%d%lf", &u, &v, &ww);
    add_edge(u, v, ww);
    add_edge1(v, u, ww);
  }
  for (int i = 1; i < n; i++) f[i] = inf;
  Q.push({n, 0});
  while (!Q.empty()) {
    x = Q.top();
    Q.pop();
    if (tf[x.x]) continue;
    tf[x.x] = true;
    f[x.x] = x.v;
    for (int j = h1[x.x]; j; j = nxt1[j]) Q.push({p1[j], x.v + w1[j]});
  }
  k = (int)e / f[1];
  q.push({1, 0});
  while (!q.empty()) {
    node x = q.top();
    q.pop();
    cnt[x.x]++;
    if (x.x == n) {
      e -= x.v;
      if (e < 0) {
        printf("%d\n", ans);
        return 0;
      }
      ans++;
    }
    for (int j = h[x.x]; j; j = nxt[j])
      if (cnt[p[j]] <= k && x.v + w[j] <= e) q.push({p[j], x.v + w[j]});
  }
  printf("%d\n", ans);
  return 0;
}
```

# dfs
DFS 为图论中的概念，详见 [DFS（图论）](../graph/dfs.md) 页面。在 **搜索算法** 中，该词常常指利用递归函数方便地实现暴力枚举的算法，与图论中的 DFS 算法有一定相似之处，但并不完全相同。

考虑这个例子：

???+note "例题"
    把正整数 n 分解为 3 个不同的正整数，如 6=1+2+3，排在后面的数必须大于等于前面的数，输出所有方案。

对于这个问题，如果不知道搜索，应该怎么办呢？

当然是 3 重循环，参考代码如下：

```cpp
for (int i = 1; i <= n; ++i)
  for (int j = i; j <= n; ++j)
    for (int k = j; k <= n; ++k)
      if (i + j + k == n) printf("%d=%d+%d+%d\n", n, i, j, k);
```

那如果是分解成四个整数呢？再加一重循环？

那分解成小于等于 m 个整数呢？

这时候就需要用到递归搜索了。

该类搜索算法的特点在于，将要搜索的目标分成若干“层”，每层基于前几层的状态进行决策，直到达到目标状态。

考虑上述问题，即将正整数 n 分解成小于等于 m 个正整数之和，且排在后面的数必须大于等于前面的数，并输出所有方案。

设一组方案将正整数 n 分解成 k 个正整数之和，k 个正整数为 $a_1, a_2, \ldots, a_k$ .

我们将问题分层，第 $i$ 层决定 $a_i$ 。则为了进行第 $i$ 层决策，我们需要记录三个状态变量： $n-\sum_{j=1}^i{a_j}$ ，表示后面所有正整数的和；以及 $a_{i-1}$ ，表示前一层的正整数，以确保正整数递增；以及 $i$ ，确保我们最多输出 $m$ 个正整数。

为了记录方案，我们用 arr 数组，第 i 项表示 $a_i$ . 注意到 arr 实际上是一个长度为 $i$ 的栈。

代码如下：

```cpp
int m, arr[103];  // arr 用于记录方案
void dfs(int n, int i, int a) {
  if (n == 0) {
    for (int j = 1; j <= i - 1; ++j) printf("%d ", arr[j]);
    printf("\n");
  }
  if (i < m) {
    for (int j = a; j <= n; ++j) {
      arr[i] = j;
      dfs(n - j, i + 1, j);  // 请仔细思考该行含义。
    }
  }
}
// 主函数
scanf("%d%d", &n, &m);
dfs(n, 1, 1);
```

## 例题

 [Luogu P1706 全排列问题](https://www.luogu.org/problemnew/show/P1706) 

C++ 代码：

```cpp
bool vis[N];  //访问标记数组
int a[N];     //排列数组，按顺序储存当前搜索结果

void dfs(int step) {
  if (step == n + 1)  //边界
  {
    for (int i = 1; i <= n; i++) {
      cout << setw(5) << a[i];
    }
    cout << endl;
    return;
  }
  for (int i = 1; i <= n; i++) {
    if (vis[i] == 0) {
      vis[i] = 1;
      a[step] = i;
      dfs(step + 1);
      vis[i] = 0;
    }
  }
  return;
}
```

# string
# match
## 字符串匹配问题

### 单串匹配

一个模式串 (pattern)，一个待匹配串，找出前者在后者中的所有出现位置

### 多串匹配

多个模式串，一个待匹配串（多个待匹配串可以直接连起来）。

直接当做单串匹配肯定是可以的，但是效率不够高。

### 匹配一个串的任意后缀

### 匹配多个串的任意后缀

## 暴力做法

对于每个位置，尝试对模式串和待匹配串进行比对。

参考代码：

（伪代码）

```cpp
std::vector<int> match(char *a, char *b, int n, int m) {
  std::vector<int> ans;
  for (i = 0; i < n - m + 1; i++) {
    for (j = 0; j < m; j++) {
      if (a[i + j] != b[j]) break;
    }
    if (j == m) ans.push_back(i);
  }
  return ans;
}
```

时间复杂度分析：

最坏时间复杂度是 $O(nm)$ 的，

最好是 $O(n)$ 的。

如果字符集的大小大于 1（有至少两个不同的字符），平均时间复杂度是 $O(n)$ 的。但是在 OI 题目中，给出的字符串一般都不是纯随机的。

## Hash 的方法

参见 [Hash](./hash.md) 

## KMP 算法

参见 [KMP](./kmp.md) 

# kmp
author: Ir1d, LeoJacob, Xeonacid, greyqz, StudyingFather, TrisolarisHD

## 前缀函数定义

给定一个长度为 $n$ 的字符串 $s$ ，其 **前缀函数** 被定义为一个长度为 $n$ 的数组 $\pi$ 。其中 $\pi[i]$ 为既是子串 $s[0\dots i]$ 的前缀同时也是该子串的后缀的最长真前缀（proper prefix）长度。一个字符串的真前缀是其前缀但不等于该字符串自身。根据定义， $\pi[0] = 0$ 。

前缀函数的定义可用数学语言描述如下：

$$
\pi[i] = \max_{k = 0 \dots i}\{k: s[0 \dots k - 1] = s[i - (k - 1) \dots i]\}
$$

举例来说，字符串 `abcabcd` 的前缀函数为 $[0, 0, 0, 1, 2, 3, 0]$ ，字符串 `aabaaab` 的前缀函数为 $[0, 1, 0, 1, 2, 2, 3]$ 。

## 朴素算法

一个直接按照定义计算前缀函数的算法如下：

```cpp
vector<int> prefix_function(string s) {
  int n = (int)s.length();
  vector<int> pi(n);
  for (int i = 0; i < n; i++)
    for (int k = 0; k <= i; k++)
      if (s.substr(0, k) == s.substr(i - k + 1, k)) pi[i] = k;
  return pi;
}
```

显见该算法的时间复杂度为 $O(n^3)$ ，具有很大的改进空间。

## 高效算法

该算法由 Knuth 和 Pratt 在 1977 年提出，同年 Morris 也独立的提出该算法。该算法被用作一个子串搜索算法的核心函数。

### 第一个优化

第一个重要的观察是相邻的前缀函数值至多增加 $1$ 。

实际上，如不然，即 $\pi[i + 1] > \pi[i] + 1$ ，考察长度为 $\pi[i + 1]$ 的 $s[0 \dots i + 1]$ 的后缀可引出矛盾。该后缀去掉最后一个字符后，我们得到一个长度为 $\pi[i + 1] - 1$ 的 $s[0 \dots i]$ 的后缀。该后缀比 $\pi[i]$ 描述的后缀更优，同其定义矛盾。

下述图例展示了这个矛盾。假定位于位置 $i$ 和 $i + 1$ 的既是后缀同时也是前缀的最长真后缀的长度分别为 $2$ 和 $4$ 。则字符串 $s_0 s_1 s_2 s_3$ 与字符串 $s_{i - 2} s_{i - 1} s_i s_{i + 1}$ 相同，这意味着 $s_0 s_1 s_2$ 与字符串 $s_{i - 2} s_{i - 1} s_i$ 相同，因此 $\pi[i]$ 至少为 $3$ 。

$$
\underbrace{\overbrace{s_0 ~ s_1}^{\pi[i] = 2} ~ s_2 ~ s_3}_{\pi[i+1] = 4} ~ \dots ~ \underbrace{s_{i-2} ~ \overbrace{s_{i-1} ~ s_{i}}^{\pi[i] = 2} ~ s_{i+1}}_{\pi[i+1] = 4}
$$

所以当移动到下一个位置时，前缀函数的值要么增加一，要么维持不变，要么减少。实际上，该事实已经允许我们将算法时间复杂度减少至 $O(n^2)$ 。因为每步中前缀函数至多增加 $1$ ，因此在总的运行过程中，前缀函数至多增加 $n$ ，同时也至多减小 $n$ 。这意味着我们仅需要进行 $O(n)$ 次字符串比较，所以总复杂度为 $O(n^2)$ 。

### 第二个优化

让我们走的更远一点：尝试摆脱掉字符串比较。为了达成这一点，我们必须用到先前计算的所有信息。

现在考虑计算位置 $i + 1$ 的前缀函数 $\pi$ 的值。如果 $s[i + 1] = s[\pi[i]]$ ，那么我们可以断言 $\pi[i + 1] = \pi[i] + 1$ ，因为我们已经知道位于位置 $i$ 的长度为 $\pi[i]$ 的后缀同长度为 $\pi[i]$ 的前缀相等。参照下述图例：

$$
\underbrace{\overbrace{s_0 ~ s_1 ~ s_2}^{\pi[i]} ~ \overbrace{s_3}^{s_3 = s_{i+1}}}_{\pi[i+1] = \pi[i] + 1} ~ \dots ~ \underbrace{\overbrace{s_{i-2} ~ s_{i-1} ~ s_{i}}^{\pi[i]} ~ \overbrace{s_{i+1}}^{s_3 = s_{i + 1}}}_{\pi[i+1] = \pi[i] + 1}
$$

如果不是上述情况，即 $s[i + 1] \neq s[\pi[i]]$ ，那么我们需要尝试更短的字符串。为了加速，我们希望直接移动到最长的长度 $j < \pi[i]$ ，使得在位置 $i$ 的前缀性质仍得以保持，也即 $s[0 \dots j - 1] = s[i - j + 1 \dots i]$ ：

$$
\overbrace{\underbrace{s_0 ~ s_1}_j ~ s_2 ~ s_3}^{\pi[i]} ~ \dots ~ \overbrace{s_{i-3} ~ s_{i-2} ~ \underbrace{s_{i-1} ~ s_{i}}_j}^{\pi[i]} ~ s_{i+1}
$$

实际上，如果我们找到了这样的长度 $j$ ，那么我们仅需要再次比较 $s[i + 1]$ 和 $s[j]$ 。如果他们相等，那么我们置 $\pi[i + 1] = j + 1$ 。否则，我们需要找到小于 $j$ 的最大值使得前缀性质得以保持，如此反复。这个过程会一直持续，直到 $j = 0$ 。如果 $s[i + 1] = s[0]$ ，那么我们置 $\pi[i + 1] = 1$ ，否则 $\pi[i + 1] = 0$ 。

所以我们已经有了这个算法的一个大概雏形。现在仅剩的问题是对于 $j$ ，如何快速找到这样的长度。让我们重新叙述一遍：对于当前在位置 $i$ 使得前缀性质得以保持的长度 $j$ ，也即 $s[0 \dots j - 1] = s[i - j + 1 \dots i]$ ，我们希望找到最大的 $k < j$ ，使得前缀性质仍得以保持。

$$
\overbrace{\underbrace{s_0 ~ s_1}_k ~ s_2 ~ s_3}^j ~ \dots ~ \overbrace{s_{i-3} ~ s_{i-2} ~ \underbrace{s_{i-1} ~ s_{i}}_k}^j ~s_{i+1}
$$

上图显示出 $k$ 必定为 $\pi[j - 1]$ ，而该值我们之前已经计算过了。

### 最终算法

所以最终我们可以构建一个不需要进行任何字符串比较，并且只进行 $O(n)$ 次操作的算法。

以下是最终的流程：

-   在一个循环中以 $i = 1$ 到 $i = n - 1$ 的顺序计算前缀函数 $\pi[i]$ 的值（ $\pi[0]$ 被赋值为 $0$ ）。
-   为了计算当前的前缀函数值 $\pi[i]$ ，我们令变量 $j$ 表示右端点位于 $i - 1$ 的最好的后缀的长度。初始时 $j = \pi[i - 1]$ 。
-   通过比较 $s[j]$ 和 $s[i]$ 来检查长度为 $j + 1$ 的后缀是否同时也是一个前缀。如果二者相等，那么我们置 $\pi[i] = j + 1$ ，否则我们减少 $j$ 至 $\pi[j - 1]$ 并且重复该过程。
-   如果 $j = 0$ 并且仍没有任何一次匹配，则置 $\pi[i] = 0$ 并移至下一个下标 $i + 1$ 。

### 实现

该算法的实现出人意料的短且直观。

```cpp
vector<int> prefix_function(string s) {
  int n = (int)s.length();
  vector<int> pi(n);
  for (int i = 1; i < n; i++) {
    int j = pi[i - 1];
    while (j > 0 && s[i] != s[j]) j = pi[j - 1];
    if (s[i] == s[j]) j++;
    pi[i] = j;
  }
  return pi;
}
```

这是一个 **在线** 算法，即其当数据到达时处理它——举例来说，你可以一个字符一个字符的读取字符串，立即处理它们以计算出每个字符的前缀函数值。该算法仍然需要存储字符串本身以及先前计算过的前缀函数值，但如果我们已经预先知道该字符串前缀函数的最大可能取值 $M$ ，那么我们仅需要存储该字符串的前 $M + 1$ 个字符以及对应的前缀函数值。

## 应用

### 在字符串中查找子串：Knuth-Morris-Pratt 算法

该任务是前缀函数的一个典型应用。

给定一个文本 $t$ 和一个字符串 $s$ ，我们尝试找到并展示 $s$ 在 $t$ 中的所有出现（occurrence）。

为了简便起见，我们用 $n$ 表示字符串 $s$ 的长度，用 $m$ 表示文本 $t$ 的长度。

我们构造一个字符串 $s + \# + t$ ，其中 $\#$ 为一个既不出现在 $s$ 中也不出现在 $t$ 中的分隔符。接下来计算该字符串的前缀函数。现在考虑该前缀函数除去最开始 $n + 1$ 个值（即属于字符串 $s$ 和分隔符的函数值）后其余函数值的意义。根据定义， $\pi[i]$ 为右端点在 $i$ 且同时为一个前缀的最长真子串的长度，具体到我们的这种情况下，其值为与 $s$ 的前缀相同且右端点位于 $i$ 的最长子串的长度。由于分隔符的存在，该长度不可能超过 $n$ 。而如果等式 $\pi[i] = n$ 成立，则意味着 $s$ 完整出现在该位置（即其右端点位于位置 $i$ ）。注意该位置的下标是对字符串 $s + \# + t$ 而言的。

因此如果在某一位置 $i$ 有 $\pi[i] = n$ 成立，则字符串 $s$ 在字符串 $t$ 的 $i - (n - 1) - (n + 1) = i - 2n$ 处出现。

正如在前缀函数的计算中已经提到的那样，如果我们知道前缀函数的值永远不超过一特定值，那么我们不需要存储整个字符串以及整个前缀函数，而只需要二者开头的一部分。在我们这种情况下这意味着只需要存储字符串 $s + \#$ 以及相应的前缀函数值即可。我们可以一次读入字符串 $t$ 的一个字符并计算当前位置的前缀函数值。

因此 Knuth-Morris-Pratt 算法（简称 KMP 算法）用 $O(n + m)$ 的时间以及 $O(n)$ 的内存解决了该问题。

### 统计每个前缀的出现次数

在该节我们将同时讨论两个问题。给定一个长度为 $n$ 的字符串 $s$ ，在问题的第一个变种中我们希望统计每个前缀 $s[0 \dots i]$ 在同一个字符串的出现次数，在问题的第二个变种中我们希望统计每个前缀 $s[0 \dots i]$ 在另一个给定字符串 $t$ 中的出现次数。

首先让我们来解决第一个问题。考虑位置 $i$ 的前缀函数值 $\pi[i]$ 。根据定义，其意味着字符串 $s$ 一个长度为 $\pi[i]$ 的前缀在位置 $i$ 出现并以 $i$ 为右端点，同时不存在一个更长的前缀满足前述定义。与此同时，更短的前缀可能以该位置为右端点。容易看出，我们遇到了在计算前缀函数时已经回答过的问题：给定一个长度为 $j$ 的前缀，同时其也是一个右端点位于 $i$ 的后缀，下一个更小的前缀长度 $k < j$ 是多少？该长度的前缀需同时也是一个右端点为 $i$ 的后缀。因此以位置 $i$ 为右端点，有长度为 $\pi[i]$ 的前缀，有长度为 $\pi[\pi[i] - 1]$ 的前缀，有长度为 $\pi[\pi[\pi[i] - 1] - 1]$ 的前缀，等等，直到长度变为 $0$ 。故而我们可以通过下述方式计算答案。

```cpp
vector<int> ans(n + 1);
for (int i = 0; i < n; i++) ans[pi[i]]++;
for (int i = n - 1; i > 0; i--) ans[pi[i - 1]] += ans[i];
for (int i = 0; i <= n; i++) ans[i]++;
```

在上述代码中我们首先统计每个前缀函数值在数组 $\pi$ 中出现了多少次，然后再计算最后答案：如果我们知道长度为 $i$ 的前缀出现了恰好 $\text{ans}[i]$ 次，那么该值必须被叠加至其最长的既是后缀也是前缀的子串的出现次数中。在最后，为了统计原始的前缀，我们对每个结果加 $1$ 。

现在考虑第二个问题。我们应用来自 Knuth-Morris-Pratt 的技巧：构造一个字符串 $s + \# + t$ 并计算其前缀函数。与第一个问题唯一的不同之处在于，我们只关心与字符串 $t$ 相关的前缀函数值，即 $i \ge n + 1$ 的 $\pi[i]$ 。有了这些值之后，我们可以同样应用在第一个问题中的算法来解决该问题。

### 一个字符串中本质不同子串的数目

给定一个长度为 $n$ 的字符串 $s$ ，我们希望计算其本质不同子串的数目。

我们将迭代的解决该问题。换句话说，在知道了当前的本质不同子串的数目的情况下，我们要找出一种在 $s$ 末尾添加一个字符后重新计算该数目的方法。

令 $k$ 为当前 $s$ 的本质不同子串数量。我们添加一个新的字符 $c$ 至 $s$ 。显然，会有一些新的子串以字符 $c$ 结尾。我们希望对这些以该字符结尾且我们之前未曾遇到的子串计数。

构造字符串 $t = s + c$ 并将其反转得到字符串 $t^{\sim}$ 。现在我们的任务变为计算有多少 $t^{\sim}$ 的前缀未在 $t^{\sim}$ 的其余任何地方出现。如果我们计算了 $t^{\sim}$ 的前缀函数最大值 $\pi_{\max}$ ，那么最长的出现在 $s$ 中的前缀其长度为 $\pi_{\max}$ 。自然的，所有更短的前缀也出现了。

因此，当添加了一个新字符后新出现的子串数目为 $|s| + 1 - \pi_{\max}$ 。

所以对于每个添加的字符，我们可以在 $O(n)$ 的时间内计算新子串的数目，故最终复杂度为 $O(n^2)$ 。

值得注意的是，我们也可以重新计算在头部添加一个字符，或者从尾或者头移除一个字符时的本质不同子串数目。

### 字符串压缩

给定一个长度为 $n$ 的字符串 $s$ ，我们希望找到其最短的“压缩”表示，也即我们希望寻找一个最短的字符串 $t$ ，使得 $s$ 可以被 $t$ 的一份或多份拷贝的拼接表示。

显然，我们只需要找到 $t$ 的长度即可。知道了该长度，该问题的答案即为长度为该值的 $s$ 的前缀。

让我们计算 $s$ 的前缀函数。通过使用该函数的最后一个值 $\pi[n - 1]$ ，我们定义值 $k = n - \pi[n - 1]$ 。我们将证明，如果 $k$ 整除 $n$ ，那么 $k$ 就是答案，否则不存在一个有效的压缩，故答案为 $n$ 。

假定 $n$ 可被 $k$ 整除。那么字符串可被划分为长度为 $k$ 的若干块。根据前缀函数的定义，该字符串长度为 $n - k$ 的前缀等于其后缀。但是这意味着最后一个块同倒数第二个块相等，并且倒数第二个块同倒数第三个块相等，等等。作为其结果，所有块都是相等的，因此我们可以将字符串 $s$ 压缩至长度 $k$ 。

诚然，我们仍需证明该值为最优解。实际上，如果有一个比 $k$ 更小的压缩表示，那么前缀函数的最后一个值 $\pi[n - 1]$ 必定比 $n - k$ 要大。因此 $k$ 就是答案。

现在假设 $n$ 不可以被 $k$ 整除，我们将通过反证法证明这意味着答案为 $n$ [^1]。假设其最小压缩表示 $r$ 的长度为 $p$ （ $p$ 整除 $n$ ），字符串 $s$ 被划分为 $n / p \ge 2$ 块。那么前缀函数的最后一个值 $\pi[n - 1]$ 必定大于 $n - p$ （如果等于则 $n$ 可被 $k$ 整除），也即其所表示的后缀将部分的覆盖第一个块。现在考虑字符串的第二个块。该块有两种解释：第一种为 $r_0 r_1 \dots r_{p - 1}$ ，另一种为 $r_{p - k} r_{p - k + 1} \dots r_{p - 1} r_0 r_1 \dots r_{p - k - 1}$ 。由于两种解释对应同一个字符串，因此可得到 $p$ 个方程组成的方程组，该方程组可简写为 $r_{(i + k) \bmod p} = r_{i \bmod p}$ ，其中 $\cdot \bmod p$ 表示模 $p$ 意义下的最小非负剩余。

$$
\begin{gathered}
\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 ~ r_5}^p ~ \overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 r_5}^p \\
r_0 ~ r_1 ~ r_2 ~ r_3 ~ \underbrace{\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 ~ r_5}^p ~ r_0 ~ r_1}_{\pi[11] = 8}
\end{gathered}
$$

根据扩展欧几里得算法我们可以得到一组 $x$ 和 $y$ 使得 $xk + yp = \gcd(k, p)$ 。通过与等式 $pk - kp = 0$ 适当叠加我们可以得到一组 $x' > 0$ 和 $y' < 0$ 使得 $x'k + y'p = \gcd(k, p)$ 。这意味着通过不断应用前述方程组中的方程我们可以得到新的方程组 $r_{(i + \gcd(k, p)) \bmod p} = r_{i \bmod p}$ 。

由于 $\gcd(k, p)$ 整除 $p$ ，这意味着 $\gcd(k, p)$ 是 $r$ 的一个周期。又因为 $\pi[n - 1] > n - p$ ，故有 $n - \pi[n - 1] = k < p$ ，所以 $\gcd(k, p)$ 是一个比 $p$ 更小的 $r$ 的周期。因此字符串 $s$ 有一个长度为 $\gcd(k, p) < p$ 的压缩表示，同 $p$ 的最小性矛盾。

综上所述，不存在一个长度小于 $n$ 的压缩表示，因此答案为 $n$ 。

[^1]: 在俄文版及英文版中该部分证明均疑似有误。本文章中的该部分证明由作者自行添加。

### 根据前缀函数构建一个自动机

让我们重新回到通过一个分隔符将两个字符串拼接的新字符串。对于字符串 $s$ 和 $t$ 我们计算 $s + \# + t$ 的前缀函数。显然，因为 $\#$ 是一个分隔符，前缀函数值永远不会超过 $|s|$ 。因此我们只需要存储字符串 $s + \#$ 和其对应的前缀函数值，之后就可以动态计算对于之后所有字符的前缀函数值：

$$
\underbrace{s_0 ~ s_1 ~ \dots ~ s_{n-1} ~ \#}_{\text{need to store}} ~ \underbrace{t_0 ~ t_1 ~ \dots ~ t_{m-1}}_{\text{do not need to store}}
$$

实际上在这种情况下，知道 $t$ 的下一个字符 $c$ 以及之前位置的前缀函数值便足以计算下一个位置的前缀函数值，而不需要用到任何其它 $t$ 的字符和对应的前缀函数值。

换句话说，我们可以构造一个 **自动机** （一个有限状态机）：其状态为当前的前缀函数值，而从一个状态到另一个状态的转移则由下一个字符确定。

因此，即使没有字符串 $t$ ，我们同样可以应用构造转移表的算法构造一个转移表 $( \text { old } \pi , c ) \rightarrow \text { new } _ { - } \pi$ ：

```cpp
void compute_automaton(string s, vector<vector<int>>& aut) {
  s += '#';
  int n = s.size();
  vector<int> pi = prefix_function(s);
  aut.assign(n, vector<int>(26));
  for (int i = 0; i < n; i++) {
    for (int c = 0; c < 26; c++) {
      int j = i;
      while (j > 0 && 'a' + c != s[j]) j = pi[j - 1];
      if ('a' + c == s[j]) j++;
      aut[i][c] = j;
    }
  }
}
```

然而在这种形式下，对于小写字母表，算法的时间复杂度为 $O(|\Sigma|n^2)$ 。注意到我们可以应用动态规划来利用表中已计算过的部分。只要我们从值 $j$ 变化到 $\pi[j - 1]$ ，那么我们实际上在说转移 $(j, c)$ 所到达的状态同转移 $(\pi[j - 1], c)$ 一样，但该答案我们之前已经精确计算过了。

```cpp
void compute_automaton(string s, vector<vector<int>>& aut) {
  s += '#';
  int n = s.size();
  vector<int> pi = prefix_function(s);
  aut.assign(n, vector<int>(26));
  for (int i = 0; i < n; i++) {
    for (int c = 0; c < 26; c++) {
      if (i > 0 && 'a' + c != s[i])
        aut[i][c] = aut[pi[i - 1]][c];
      else
        aut[i][c] = i + ('a' + c == s[i]);
    }
  }
}
```

最终我们可在 $O(|\Sigma|n)$ 的时间复杂度内构造该自动机。

该自动机在什么时候有用呢？首先，记得大部分时候我们为了一个目的使用字符串 $s + \# + t$ 的前缀函数：寻找字符串 $s$ 在字符串 $t$ 中的所有出现。

因此使用该自动机的最直接的好处是 **加速计算字符串 $s + \# + t$ 的前缀函数** 。

通过构建 $s + \#$ 的自动机，我们不再需要存储字符串 $s$ 以及其对应的前缀函数值。所有转移已经在表中计算过了。

但除此以外，还有第二个不那么直接的应用。我们可以在字符串 $t$ 是 **某些通过一些规则构造的巨型字符串** 时，使用该自动机加速计算。Gray 字符串，或者一个由一些短的输入串的递归组合所构造的字符串都是这种例子。

出于完整性考虑，我们来解决这样一个问题：给定一个数 $k \le 10^5$ ，以及一个长度 $\le 10^5$ 的字符串 $s$ ，我们需要计算 $s$ 在第 $k$ 个 Gray 字符串中的出现次数。回想起 Gray 字符串以下述方式定义：

$$
\begin{aligned}
g_1 &= \mathtt{a}\\
g_2 &= \mathtt{aba}\\
g_3 &= \mathtt{abacaba}\\
g_4 &= \mathtt{abacabadabacaba}
\end{aligned}
$$

由于其天文数字般的长度，在这种情况下即使构造字符串 $t$ 都是不可能的：第 $k$ 个 Gray 字符串有 $2^k - 1$ 个字符。然而我们可以在仅仅知道开头若干前缀函数值的情况下，有效计算该字符串末尾的前缀函数值。

除了自动机之外，我们同时需要计算值 $G[i][j]$ ：在从状态 $j$ 开始处理 $g_i$ 后的自动机的状态，以及值 $K[i][j]$ ：当从状态 $j$ 开始处理 $g_i$ 后， $s$ 在 $g_i$ 中的出现次数。实际上 $K[i][j]$ 为在执行操作时前缀函数取值为 $|s|$ 的次数。易得问题的答案为 $K[k][0]$ 。

我们该如何计算这些值呢？首先根据定义，初始条件为 $G[0][j] = j$ 以及 $K[0][j] = 0$ 。之后所有值可以通过先前的值以及使用自动机计算得到。为了对某个 $i$ 计算相应值，回想起字符串 $g_i$ 由 $g_{i - 1}$ ，字母表中第 $i$ 个字符，以及 $g_{i - 1}$ 三者拼接而成。因此自动机会途径下列状态：

$$
\begin{gathered}
\text{mid} = \text{aut}[G[i - 1][j]][i] \\
G[i][j] = G[i - 1][\text{mid}]
\end{gathered}
$$

 $K[i][j]$ 的值同样可被简单计算。

$$
K[i][j] = K[i - 1][j] + [\text{mid} == |s|] + K[i - 1][\text{mid}]
$$

其中 $[\cdot]$ 当其中表达式取值为真时值为 $1$ ，否则为 $0$ 。综上，我们已经可以解决关于 Gray 字符串的问题，以及一大类与之类似的问题。举例来说，应用同样的方法可以解决下列问题：给定一个字符串 $s$ 以及一些模式 $t_i$ ，其中每个模式以下列方式给出：该模式由普通字符组成，当中可能以 $t_{k}^{\text{cnt}}$ 的形式递归插入先前的字符串，也即在该位置我们必须插入字符串 $t_k$  $\text{cnt}$ 次。以下是这些模式的一个例子：

$$
\begin{aligned}
t_1 &= \mathtt{abdeca} \\
t_2 &= \mathtt{abc} + t_1^{30} + \mathtt{abd} \\
t_3 &= t_2^{50} + t_1^{100} \\
t_4 &= t_2^{10} + t_3^{100}
\end{aligned}
$$

递归代入会使字符串长度爆炸式增长，他们的长度甚至可以达到 $100^{100}$ 的数量级。而我们必须找到字符串 $s$ 在每个字符串中的出现次数。

该问题同样可通过构造前缀函数的自动机解决。同之前一样，我们利用先前计算过的结果对每个模式计算其转移然后相应统计答案即可。

## 练习题目

-    [UVA 455 "Periodic Strings"](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=396) 
-    [UVA 11022 "String Factoring"](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1963) 
-    [UVA 11452 "Dancing the Cheeky-Cheeky"](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2447) 
-    [UVA 12604 - Caesar Cipher](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4282) 
-    [UVA 12467 - Secret Word](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3911) 
-    [UVA 11019 - Matrix Matcher](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1960) 
-    [SPOJ - Pattern Find](http://www.spoj.com/problems/NAJPF/) 
-    [Codeforces - Anthem of Berland](http://codeforces.com/contest/808/problem/G) 
-    [Codeforces - MUH and Cube Walls](http://codeforces.com/problemset/problem/471/D) 

* * *

 **本页面主要译自博文 [Префикс-функция. Алгоритм Кнута-Морриса-Пратта](http://e-maxx.ru/algo/prefix_function) 与其英文翻译版 [Prefix function. Knuth–Morris–Pratt algorithm](https://cp-algorithms.com/string/prefix-function.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# seq-automaton
在阅读本文之前，请先阅读 [自动机](./automaton.md) 。

## 定义

序列自动机是接受且仅接受一个字符串的子序列的自动机。

本文中用 $s$ 代指这个字符串。

### 状态

若 $s$ 包含 $n$ 个字符，那么序列自动机包含 $n+1$ 个状态。

令 $t$ 是 $s$ 的一个子序列，那么 $\delta(start, t)$ 是 $t$ 在 $s$ 中第一次出现时末端的位置。

也就是说，一个状态 $i$ 表示前缀 $s[1..i]$ 的子序列与前缀 $s[1..i-1]$ 的子序列的差集。

序列自动机上的所有状态都是接受状态。

### 转移

由状态定义可以得到， $\delta(u, c)=\min\{i|i>u,s[i]=c\}$ ，也就是字符 $c$ 下一次出现的位置。

为什么是“下一次”出现的位置呢？因为若 $i>j$ ，后缀 $s[i..|s|]$ 的子序列是后缀 $s[j..|s|]$ 的子序列的子集，一定是选尽量靠前的最优。

## 构建

从后向前扫描，过程中维护每个字符最前的出现位置：

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{A string } S\\
2 & \textbf{Output. } \text{The state transition of the sequence automaton of }S \\
3 & \textbf{Method. }  \\
4 & \textbf{for }c\in\Sigma\\
5 & \qquad next[c]\gets null\\
6 & \textbf{for }i\gets|S|\textbf{ downto }1\\
7 & \qquad next[S[i]]\gets i\\
8 & \qquad \textbf{for }c\in\Sigma\\
9 & \qquad\qquad \delta(i-1,c)\gets next[c]\\
10 & \textbf{return }\delta
\end{array}
$$

这样构建的复杂度是 $O(n|\Sigma|)$ 。

## 例题

???+note "[「HEOI2015」最短不公共子串](https://loj.ac/problem/2123)"

    给你两个由小写英文字母组成的串 $A$ 和 $B$，求：

    1. $A$ 的一个最短的子串，它不是 $B$ 的子串；
    2. $A$ 的一个最短的子串，它不是 $B$ 的子序列；
    3. $A$ 的一个最短的子序列，它不是 $B$ 的子串；
    4. $A$ 的一个最短的子序列，它不是 $B$ 的子序列。

    $1\le |A|, |B|\le 2000$。

    ??? mdui-shadow-6 "题解"
        这题的 (1) 和 (3) 两问需要后缀自动机，而且做法类似，在这里只讲解 (2) 和 (4) 两问。

        (2) 比较简单，枚举 A 的子串输入进 B 的序列自动机，若不接受则计入答案。

        (4) 需要 DP。令 $f(i, j)$ 表示在 A 的序列自动机中处于状态 $i$ ，在 B 的序列自动机中处于状态 $j$ ，需要再添加多少个字符能够不是公共子序列。

        $f(i, null)=0$ 

        $f(i, j)=\min\limits_{\delta_A(i,c)\ne null}f(\delta_A(i, c), \delta_B(j, c))+1$ 

    ??? mdui-shadow-6 "参考代码"
        ```cpp
        #include <algorithm>
        #include <cstdio>
        #include <cstring>
        #include <iostream>
        
        using namespace std;
        
        const int N = 2005;
        
        char s[N], t[N];
        int na[N][26], nb[N][26], nxt[26];
        int n, m, a[N], b[N], tot = 1, p = 1, f[N][N << 1];
        
        struct SAM {
          int par, ch[26], len;
        } sam[N << 1];
        
        void insert(int x) {
          int np = ++tot;
          sam[np].len = sam[p].len + 1;
          while (p && !sam[p].ch[x]) {
            sam[p].ch[x] = np;
            p = sam[p].par;
          }
          if (p == 0)
            sam[np].par = 1;
          else {
            int q = sam[p].ch[x];
            if (sam[q].len == sam[p].len + 1)
              sam[np].par = q;
            else {
              int nq = ++tot;
              sam[nq].len = sam[p].len + 1;
              memcpy(sam[nq].ch, sam[q].ch, sizeof(sam[q].ch));
              sam[nq].par = sam[q].par;
              sam[q].par = sam[np].par = nq;
              while (p && sam[p].ch[x] == q) {
                sam[p].ch[x] = nq;
                p = sam[p].par;
              }
            }
          }
          p = np;
        }
        
        int main() {
          scanf("%s%s", s + 1, t + 1);
        
          n = strlen(s + 1);
          m = strlen(t + 1);
        
          for (int i = 1; i <= n; ++i) a[i] = s[i] - 'a';
          for (int i = 1; i <= m; ++i) b[i] = t[i] - 'a';
        
          for (int i = 1; i <= m; ++i) insert(b[i]);
        
          for (int i = 0; i < 26; ++i) nxt[i] = n + 1;
          for (int i = n; i >= 0; --i) {
            memcpy(na[i], nxt, sizeof(nxt));
            nxt[a[i]] = i;
          }
        
          for (int i = 0; i < 26; ++i) nxt[i] = m + 1;
          for (int i = m; i >= 0; --i) {
            memcpy(nb[i], nxt, sizeof(nxt));
            nxt[b[i]] = i;
          }
        
          int ans = N;
        
          for (int l = 1; l <= n; ++l) {
            for (int r = l, u = 1; r <= n; ++r) {
              u = sam[u].ch[a[r]];
              if (!u) {
                ans = min(ans, r - l + 1);
                break;
              }
            }
          }
        
          printf("%d\n", ans == N ? -1 : ans);
        
          ans = N;
        
          for (int l = 1; l <= n; ++l) {
            for (int r = l, u = 0; r <= n; ++r) {
              u = nb[u][a[r]];
              if (u == m + 1) {
                ans = min(ans, r - l + 1);
                break;
              }
            }
          }
        
          printf("%d\n", ans == N ? -1 : ans);
        
          for (int i = n; i >= 0; --i) {
            for (int j = 1; j <= tot; ++j) {
              f[i][j] = N;
              for (int c = 0; c < 26; ++c) {
                int u = na[i][c];
                int v = sam[j].ch[c];
                if (u <= n) f[i][j] = min(f[i][j], f[u][v] + 1);
              }
            }
          }
        
          printf("%d\n", f[0][1] == N ? -1 : f[0][1]);
        
          memset(f, 0, sizeof(f));
        
          for (int i = n; i >= 0; --i) {
            for (int j = 0; j <= m; ++j) {
              f[i][j] = N;
              for (int c = 0; c < 26; ++c) {
                int u = na[i][c];
                int v = nb[j][c];
                if (u <= n) f[i][j] = min(f[i][j], f[u][v] + 1);
              }
            }
          }
        
          printf("%d\n", f[0][0] == N ? -1 : f[0][0]);
        
          return 0;
        }
        ```

# lyndon
author: sshwy, StudyingFather, orzAtalod

## Lyndon 分解

首先我们介绍 Lyndon 分解的概念。

Lyndon 串：对于字符串 $s$ ，如果 $s$ 的字典序严格小于 $s$ 的所有后缀的字典序，我们称 $s$ 是简单串，或者 **Lyndon 串** 。举一些例子， $a$ , $b$ , $ab$ , $aab$ , $abb$ , $ababb$ , $abcd$ 都是 Lyndon 串。如果 $s$ 是 Lyndon 串，当且仅当 $s$ 的字典序严格小于它的所有非平凡的循环同构串。

Lyndon 分解：串 $s$ 的 Lyndon 分解记为 $s=w_1w_2\cdots w_k$ ，其中所有 $w_i$ 为简单串，并且他们的字典序按照非严格单减排序，即 $w_1\ge w_2\ge\cdots\ge w_k$ 。可以发现，这样的分解存在且唯一。

## Duval 算法

Duval 可以在 $O(n)$ 的时间内求出一个串的 Lyndon 分解。

首先我们介绍另外一个概念：如果一个字符串 $t$ 能够分解为 $t=ww\cdots\overline{w}$ 的形式，其中 $w$ 是一个 Lyndon 串，而 $\overline{w}$ 是 $w$ 的前缀（ $\overline{w}$ 可能是空串），那么称 $t$ 是近似简单串（pre-simple），或者近似 Lyndon 串。一个 Lyndon 串也是近似 Lyndon 串。

Duval 算法运用了贪心的思想。算法过程中我们把串 $s$ 分成三个部分 $s=s_1s_2s_3$ ，其中 $s_1$ 是一个 Lyndon 串，它的 Lyndon 分解已经记录； $s_2$ 是一个近似 Lyndon 串； $s_3$ 是未处理的部分。

整体描述一下，该算法每一次尝试将 $s_3$ 的首字符添加到 $s_2$ 的末尾。如果 $s_2$ 不再是近似 Lyndon 串，那么我们就可以将 $s_2$ 截出一部分前缀（即 Lyndon 分解）接在 $s_1$ 末尾。

我们来更详细地解释一下算法的过程。定义一个指针 $i$ 指向 $s_2$ 的首字符，则 $i$ 从 $1$ 遍历到 $n$ （字符串长度）。在循环的过程中我们定义另一个指针 $j$ 指向 $s_3$ 的首字符，指针 $k$ 指向 $s_2$ 中我们当前考虑的字符（意义是 $j$ 在 $s_2$ 的上一个循环节中对应的字符）。我们的目标是将 $s[j]$ 添加到 $s_2$ 的末尾，这就需要将 $s[j]$ 与 $s[k]$ 做比较：

1.  如果 $s[j]=s[k]$ ，则将 $s[j]$ 添加到 $s_2$ 末尾不会影响它的近似简单性。于是我们只需要让指针 $j,k$ 自增（移向下一位）即可。
2.  如果 $s[j]>s[k]$ ，那么 $s_2s[j]$ 就变成了一个 Lyndon 串，于是我们将指针 $j$ 自増，而让 $k$ 指向 $s_2$ 的首字符，这样 $s_2$ 就变成了一个循环次数为 1 的新 Lyndon 串了。
3.  如果 $s[j]<s[k]$ ，则 $s_2s[j]$ 就不是一个近似简单串了，那么我们就要把 $s_2$ 分解出它的一个 Lyndon 子串，这个 Lyndon 子串的长度将是 $j-k$ ，即它的一个循环节。然后把 $s_2$ 变成分解完以后剩下的部分，继续循环下去（注意，这个情况下我们没有改变指针 $j,k$ ），直到循环节被截完。对于剩余部分，我们只需要将进度“回退”到剩余部分的开头即可。

### 代码实现

下面的代码返回串 $s$ 的 Lyndon 分解方案。

```cpp
// duval_algorithm
vector<string> duval(string const& s) {
  int n = s.size(), i = 0;
  vector<string> factorization;
  while (i < n) {
    int j = i + 1, k = i;
    while (j < n && s[k] <= s[j]) {
      if (s[k] < s[j])
        k = i;
      else
        k++;
      j++;
    }
    while (i <= k) {
      factorization.push_back(s.substr(i, j - k));
      i += j - k;
    }
  }
  return factorization;
}
```

### 复杂度分析

接下来我们证明一下这个算法的复杂度。

外层的循环次数不超过 $n$ ，因为每一次 $i$ 都会增加。第二个内层循环也是 $O(n)$ 的，因为它只记录 Lyndon 分解的方案。接下来我们分析一下内层循环。很容易发现，每一次在外层循环中找到的 Lyndon 串是比我们所比较过的剩余的串要长的，因此剩余的串的长度和要小于 $n$ ，于是我们最多在内层循环 $O(n)$ 次。事实上循环的总次数不超过 $4n-3$ ，时间复杂度为 $O(n)$ 。

## 最小表示法（Finding the smallest cyclic shift）

对于长度为 $n$ 的串 $s$ ，我们可以通过上述算法寻找该串的最小表示法。

我们构建串 $ss$ 的 Lyndon 分解，然后寻找这个分解中的一个 Lyndon 串 $t$ ，使得它的起点小于 $n$ 且终点大于等于 $n$ 。可以很容易地使用 Lyndon 分解的性质证明，子串 $t$ 的首字符就是 $s$ 的最小表示法的首字符，即我们沿着 $t$ 的开头往后 $n$ 个字符组成的串就是 $s$ 的最小表示法。

于是我们在分解的过程中记录每一次的近似 Lyndon 串的开头即可。

```cpp
// smallest_cyclic_string
string min_cyclic_string(string s) {
  s += s;
  int n = s.size();
  int i = 0, ans = 0;
  while (i < n / 2) {
    ans = i;
    int j = i + 1, k = i;
    while (j < n && s[k] <= s[j]) {
      if (s[k] < s[j])
        k = i;
      else
        k++;
      j++;
    }
    while (i <= k) i += j - k;
  }
  return s.substr(ans, n / 2);
}
```

## 习题

-    [UVA #719 - Glass Beads](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=660) 

     **本页面主要译自博文 [Декомпозиция Линдона. Алгоритм Дюваля. Нахождение наименьшего циклического сдвига](http://e-maxx.ru/algo/duval_algorithm) 与其英文翻译版 [Lyndon factorization](https://cp-algorithms.com/string/lyndon_factorization.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# manacher
## 描述

给定一个长度为 $n$ 的字符串 $s$ ，请找到所有对 $(i, j)$ 使得子串 $s[i \dots j]$ 为一个回文串。当 $t = t_{\text{rev}}$ 时，字符串 $t$ 是一个回文串（ $t_{\text{rev}}$ 是 $t$ 的反转字符串）。

## 更进一步的描述

显然在最坏情况下可能有 $O(n^2)$ 个回文串，因此似乎一眼看过去该问题并没有线性算法。

但是关于回文串的信息可用 **一种更紧凑的方式** 表达：对于每个位置 $i = 0 \dots n - 1$ ，我们找出值 $d_1[i]$ 和 $d_2[i]$ 。二者分别表示以位置 $i$ 为中心的长度为奇数和长度为偶数的回文串个数。

举例来说，字符串 $s = \mathtt{abababc}$ 以 $s[3] = b$ 为中心有三个奇数长度的回文串，也即 $d_1[3] = 3$ ：

$$
a\ \overbrace{b\ a\ \underset{s_3}{b}\ a\ b}^{d_1[3]=3}\ c
$$

字符串 $s = \mathtt{cbaabd}$ 以 $s[3] = a$ 为中心有两个偶数长度的回文串，也即 $d_2[3] = 2$ ：

$$
c\ \overbrace{b\ a\ \underset{s_3}{a}\ b}^{d_2[3]=2}\ d
$$

因此关键思路是，如果以某个位置 $i$ 为中心，我们有一个长度为 $l$ 的回文串，那么我们有以 $i$ 为中心的长度为 $l - 2$ ， $l - 4$ ，等等的回文串。所以 $d_1[i]$ 和 $d_2[i]$ 两个数组已经足够表示字符串中所有子回文串的信息。

一个令人惊讶的事实是，存在一个复杂度为线性并且足够简单的算法计算上述两个“回文性质数组” $d_1[]$ 和 $d_2[]$ 。在这篇文章中我们将详细的描述该算法。

## 解法

总的来说，该问题具有多种解法：应用字符串哈希，该问题可在 $O(n \log n)$ 时间内解决，而使用后缀数组和快速 LCA 该问题可在 $O(n)$ 时间内解决。

但是这里描述的算法 **压倒性** 的简单，并且在时间和空间复杂度上具有更小的常数。该算法由 **Glenn K. Manacher** 在 1975 年提出。

## 朴素算法

为了避免在之后的叙述中出现歧义，这里我们指出什么是“朴素算法”。

该算法通过下述方式工作：对每个中心位置 $i$ ，在比较一对对应字符后，只要可能，该算法便尝试将答案加 $1$ 。

该算法是比较慢的：它只能在 $O(n^2)$ 的时间内计算答案。

该朴素算法的实现如下：

```cpp
vector<int> d1(n), d2(n);
for (int i = 0; i < n; i++) {
  d1[i] = 1;
  while (0 <= i - d1[i] && i + d1[i] < n && s[i - d1[i]] == s[i + d1[i]]) {
    d1[i]++;
  }

  d2[i] = 0;
  while (0 <= i - d2[i] - 1 && i + d2[i] < n &&
         s[i - d2[i] - 1] == s[i + d2[i]]) {
    d2[i]++;
  }
}
```

## Manacher 算法

这里我们将只描述算法中寻找所有奇数长度子回文串的情况，即只计算 $d_1[]$ ；寻找所有偶数长度子回文串的算法（即计算数组 $d_2[]$ ）将只需对奇数情况下的算法进行一些小修改。

为了快速计算，我们维护已找到的子回文串的最靠右的 **边界 $(l, r)$ ** （即具有最大 $r$ 值的回文串）。初始时，我们置 $l = 0$ 和 $r = -1$ 。

现在假设我们要对下一个 $i$ 计算 $d_1[i]$ ，而之前所有 $d_1[]$ 中的值已计算完毕。我们将通过下列方式计算：

-   如果 $i$ 位于当前子回文串之外，即 $i > r$ ，那么我们调用朴素算法。

    因此我们将连续地增加 $d_1[i]$ ，同时在每一步中检查当前的子串 $[i - d_1[i] \dots i + d_1[i]]$ 是否为一个回文串。如果我们找到了第一处对应字符不同，又或者碰到了 $s$ 的边界，则算法停止。在两种情况下我们均已计算完 $d_1[i]$ 。此后，仍需记得更新 $(l, r)$ 。

-   现在考虑 $i \le r$ 的情况。我们将尝试从已计算过的 $d_1[]$ 的值中获取一些信息。首先在子回文串 $(l, r)$ 中反转位置 $i$ ，即我们得到 $j = l + (r - i)$ 。现在来考察值 $d_1[j]$ 。因为位置 $j$ 同位置 $i$ 对称，我们 **几乎总是** 可以置 $d_1[i] = d_1[j]$ 。该想法的图示如下（可认为以 $j$ 为中心的回文串被“拷贝”至以 $i$ 为中心的位置上）：

    $$
    \ldots\
    \overbrace{
        s_l\ \ldots\
        \underbrace{
            s_{j-d_1[j]+1}\ \ldots\ s_j\ \ldots\ s_{j+d_1[j]-1}
        }_\text{palindrome}\
        \ldots\
        \underbrace{
            s_{i-d_1[j]+1}\ \ldots\ s_i\ \ldots\ s_{i+d_1[j]-1}
        }_\text{palindrome}\
        \ldots\ s_r
    }^\text{palindrome}\
    \ldots
    $$

    然而有一个 **棘手的情况** 需要被正确处理：当“内部”的回文串到达“外部”回文串的边界时，即 $j - d_1[j] + 1 \le l$ （或者等价的说， $i + d_1[j] - 1 \ge r$ ）。因为在“外部”回文串范围以外的对称性没有保证，因此直接置 $d_1[i] = d_1[j]$ 将是不正确的：我们没有足够的信息来断言在位置 $i$ 的回文串具有同样的长度。

    实际上，为了正确处理这种情况，我们应该“截断”回文串的长度，即置 $d_1[i] = r - i$ 。之后我们将运行朴素算法以尝试尽可能增加 $d_1[i]$ 的值。

    该种情况的图示如下（以 $j$ 为中心的回文串已经被截断以落在“外部”回文串内）：

    $$
    \ldots\
    \overbrace{
        \underbrace{
            s_l\ \ldots\ s_j\ \ldots\ s_{j+(j-l)}
        }_\text{palindrome}\
        \ldots\
        \underbrace{
            s_{i-(r-i)}\ \ldots\ s_i\ \ldots\ s_r
        }_\text{palindrome}
    }^\text{palindrome}\
    \underbrace{
        \ldots \ldots \ldots \ldots \ldots
    }_\text{try moving here}
    $$

    该图示显示出，尽管以 $j$ 为中心的回文串可能更长，以致于超出“外部”回文串，但在位置 $i$ ，我们只能利用其完全落在“外部”回文串内的部分。然而位置 $i$ 的答案可能比这个值更大，因此接下来我们将运行朴素算法来尝试将其扩展至“外部”回文串之外，也即标识为 "try moving here" 的区域。

最后，仍有必要提醒的是，我们应当记得在计算完每个 $d_1[i]$ 后更新值 $(l, r)$ 。

同时，再让我们重复一遍：计算偶数长度回文串数组 $d_2[]$ 的算法同上述计算奇数长度回文串数组 $d_1[]$ 的算法十分类似。

## Manacher 算法的复杂度

因为在计算一个特定位置的答案时我们总会运行朴素算法，所以一眼看去该算法的时间复杂度为线性的事实并不显然。

然而更仔细的分析显示出该算法具有线性复杂度。此处我们需要指出， [计算 Z 函数的算法](z-func.md) 和该算法较为类似，并同样具有线性时间复杂度。

实际上，注意到朴素算法的每次迭代均会使 $r$ 增加 $1$ ，以及 $r$ 在算法运行过程中从不减小。这两个观察告诉我们朴素算法总共会进行 $O(n)$ 次迭代。

Manacher 算法的另一部分显然也是线性的，因此总复杂度为 $O(n)$ 。

## Manacher 算法的实现

### 分类讨论

为了计算 $d_1[]$ ，我们有以下代码：

```cpp
vector<int> d1(n);
for (int i = 0, l = 0, r = -1; i < n; i++) {
  int k = (i > r) ? 1 : min(d1[l + r - i], r - i);
  while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {
    k++;
  }
  d1[i] = k--;
  if (i + k > r) {
    l = i - k;
    r = i + k;
  }
}
```

计算 $d_2[]$ 的代码十分类似，但是在算术表达式上有些许不同：

```cpp
vector<int> d2(n);
for (int i = 0, l = 0, r = -1; i < n; i++) {
  int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
  while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) {
    k++;
  }
  d2[i] = k--;
  if (i + k > r) {
    l = i - k - 1;
    r = i + k;
  }
}
```

### 统一处理

虽然在讲解过程及上述实现中我们将 $d_1[]$ 和 $d_2[]$ 的计算分开考虑，但实际上可以通过一个技巧将二者的计算统一为 $d_1[]$ 的计算。

给定一个长度为 $n$ 的字符串 $s$ ，我们在其 $n + 1$ 个空中插入分隔符 $\#$ ，从而构造一个长度为 $2n + 1$ 的字符串 $s'$ 。举例来说，对于字符串 $s = \mathtt{abababc}$ ，其对应的 $s' = \mathtt{\#a\#b\#a\#b\#a\#b\#c\#}$ 。

对于字母间的 $\#$ ，其实际意义为 $s$ 中对应的“空”。而两端的 $\#$ 则是为了实现的方便。

注意到，在对 $s'$ 计算 $d_1[]$ 后，对于一个位置 $i$ ， $d_1[i]$ 所描述的最长的子回文串必定以 $\#$ 结尾（若以字母结尾，由于字母两侧必定各有一个 $\#$ ，因此可向外扩展一个得到一个更长的）。因此，对于 $s$ 中一个以字母为中心的极大子回文串，设其长度为 $m + 1$ ，则其在 $s'$ 中对应一个以相应字母为中心，长度为 $2m + 3$ 的极大子回文串；而对于 $s$ 中一个以空为中心的极大子回文串，设其长度为 $m$ ，则其在 $s'$ 中对应一个以相应表示空的 $\#$ 为中心，长度为 $2m + 1$ 的极大子回文串（上述两种情况下的 $m$ 均为偶数，但该性质成立与否并不影响结论）。综合以上观察及少许计算后易得，在 $s'$ 中， $d_1[i]$ 表示在 $s​$ 中以对应位置为中心的极大子回文串的 **总长度加一** 。

上述结论建立了 $s'$ 的 $d_1[]$ 同 $s$ 的 $d_1[]$ 和 $d_2[]$ 间的关系。

由于该统一处理本质上即求 $s'$ 的 $d_1[]$ ，因此在得到 $s'$ 后，代码同上节计算 $d_1[]$ 的一样。

## 练习题目

-    [UVA #11475 "Extend to Palindrome"](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2470) 
-    [「国家集训队」最长双回文串](https://www.luogu.org/problemnew/show/P4555) 

* * *

 **本页面主要译自博文 [Нахождение всех подпалиндромов](http://e-maxx.ru/algo/palindromes_count) 与其英文翻译版 [Finding all sub-palindromes in $O(N)$ ](https://cp-algorithms.com/string/manacher.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# pam
## 概述

回文树 (EER Tree，Palindromic Tree，也被称为回文自动机）是一种可以存储一个串中所有回文子串的高效数据结构，最初是由 Mikhail Rubinchik 和 Arseny M. Shur 在 2015 年发表。它的灵感来源于后缀树等字符串后缀数据结构，使用回文树可以简单高效地解决一系列涉及回文串的问题。

## 结构

回文树大概长这样

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/pam1.png)

和其它自动机类似的，回文树也是由转移边和后缀链接 (fail 指针）组成，每个节点都可以代表一个回文子串。

因为回文串长度分为奇数和偶数，我们可以像 manacher 那样加入一个不在字符集中的字符（如 '#'）作为分隔符来将所有回文串的长度都变为奇数，但是这样过于麻烦了。有没有更好的办法呢？

答案自然是有。更好的办法就是建两棵树，一棵树中的节点对应的回文子串长度均为奇数，另一棵树中的节点对应的回文子串长度均为偶数。

和其它的自动机一样，一个节点的 fail 指针指向的是这个节点所代表的回文串的最长回文后缀所对应的节点，但是转移边并非代表在原节点代表的回文串后加一个字符，而是表示在原节点代表的回文串前后各加一个相同的字符（不难理解，因为要保证存的是回文串）。

我们还需要在每个节点上维护此节点对应回文子串的长度 len，这个信息保证了我们可以轻松地构造出回文树。

## 建造

回文树有两个初始状态，分别代表长度为 $-1,0$ 的回文串。我们可以称它们为奇根，偶根。它们不表示任何实际的字符串，仅作为初始状态存在，这与其他自动机的根节点是异曲同工的。

偶根的 fail 指针指向奇根，而我们并不关心奇根的 fail 指针，因为奇根不可能失配（奇根转移出的下一个状态长度为 $1$ ，即单个字符。一定是回文子串）

类似后缀自动机，我们增量构造回文树。

考虑构造完前 $p-1$ 个字符的回文树后，向自动机中添加在原串里位置为 $p$ 的字符。

我们从以上一个字符结尾的最长回文子串对应的节点开始，不断沿着 fail 指针走，直到找到一个节点满足 $s_{p}=s_{p-len-1}$ ，即满足此节点所对应回文子串的上一个字符与待添加字符相同。

这里贴出论文中的那张图

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/pam2.png)

我们通过跳 fail 指针找到 A 所对应的节点，然后两边添加 `X` 就到了现在的回文串了（即 `XAX` ），很显然，这个节点就是以 $p$ 结尾的最长回文子串对应的树上节点。（同时，这个时候长度 $-1$ 节点优势出来了，如果没有 `X` 能匹配条件就是同一个位置的 $s_p=s_p$ ，就自然得到了代表字符 `X` 的节点。）此时要判断一下：没有这个节点，就需要新建。

然后我们还需要求出新建的节点的 fail 指针。具体方法与上面的过程类似，不断跳转 fail 指针，从 `A` 出发，即可找到 `XAX` 的最长回文后缀 `XBX` ，将对应节点设为 fail 指针所指的对象即可。

显然，这个节点是不需新建的， `A` 的前 $len_B$ 位和后 $len_B$ 位相同，都是 `B` ，前 $len_B$ 位的两端根据回文串对应关系，都是 `X` ，后面被钦定了是 `X` ，于是这个节点 `XBX` 肯定已经被包含了。

如果 fail 没匹配到，那么将它连向长度为 $0$ 的那个节点，显然这是可行的（因为这是所有节点的后缀）。

## 线性状态数证明

定理：对于一个字符串 $s$ ，它的本质不同回文子串个数最多只有 $|s|$ 个。

证明：考虑使用数学归纳法。

-   当 $|s| =1$ 时， $s$ 只有一个字符，同时也只有一个子串，并且这个子串是回文的，因此结论成立。

-   当 $|s| >1$ 时，设 $t=sc$ ，其中 $t$ 表示 $s$ 最后增加一个字符 $c$ 后形成的字符串，假设结论对 $s$ 串成立。考虑以最后一个字符 $c$ 结尾的回文子串，假设它们的左端点由小到大排序为 $l_1,l_2,\dots,l_k$ 。由于 $t[l_1..|t|]$ 是回文串，因此对于所有位置 $l_1 \le p \le |t|$ ，有 $t[p..|t|]=t[l_1..l_1+|t|-p]$ 。所以，对于 $1 < i \le k$ ， $t[l_i..|t|]$ 已经在 $t[1..|t|-1]$ 中出现过。因此，每次增加一个字符，本质不同的回文子串个数最多增加 $1$ 个。

由数学归纳法，可知该定理成立。

因此回文树状态数是 $O(|s|)$ 的。对于每一个状态，它实际只代表一个本质不同的回文子串，即转移到该节点的状态唯一，因此总转移数也是 $O(|s|)$ 的。

## 正确性证明

以上图为例，增加当前字符 `X` ，由线性状态数的证明，我们只需要找到包含最后一个字符 `X` 的最长回文后缀，也就是 `XAX` 。继续寻找 `XAX` 的最长回文后缀 `XBX` ，建立后缀链接。 `XBX` 对应状态已经在回文树中出现，包含最后一个字符的回文后缀就是 `XAX` ， `XBX` 本身及其对应状态在 fail 树上的所有祖先。

对于 $s$ 回文树的构造，令 $n=|s|$ ，显然除了跳 fail 指针的其他操作都是 $O(n)$ 的。

加入字符时，在上一次的基础上，每次跳 fail 后对应节点在 fail 树的深度 $-1$ ，而连接 fail 后，仅为深度 + 1（但 fail 为 $0$ 时（即到 $-1$ 才符合），深度相当于在 $-1$ 的基础上 $+2$ ）。

因为只加入 $n$ 个字符，所以只会加 $n$ 次深度，最多也只会跳 $2n$ 次 fail。

因此，构造 $s$ 的回文树的时间复杂度是 $O(|s|)$ 。

## 应用

### 本质不同回文子串个数

由线性状态数的证明，容易知道一个串的本质不同回文子串个数等于回文树的状态数（排除奇根和偶根两个状态）。

### 回文子串出现次数

建出回文树，使用类似后缀自动机统计出现次数的方法。

由于回文树的构造过程中，节点本身就是按照拓扑序插入，因此只需要逆序枚举所有状态，将当前状态的出现次数加到其 fail 指针对应状态的出现次数上即可。

例题： [「APIO2014」回文串](https://www.luogu.org/problem/P3649) 

定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。对于给定的字符串 $s$ ，求所有回文子串中的最大存在值。

??? note "参考代码"
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int maxn = 300000 + 5;
    namespace pam {
    int sz, tot, last;
    int cnt[maxn], ch[maxn][26], len[maxn], fail[maxn];
    char s[maxn];
    int node(int l) {
      sz++;
      memset(ch[sz], 0, sizeof(ch[sz]));
      len[sz] = l;
      fail[sz] = cnt[sz] = 0;
      return sz;
    }
    void clear() {
      sz = -1;
      last = 0;
      s[tot = 0] = '$';
      node(0);
      node(-1);
      fail[0] = 1;
    }
    int getfail(int x) {
      while (s[tot - len[x] - 1] /home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!= s[tot]) x = fail[x];
      return x;
    }
    void insert(char c) {
      s[++tot] = c;
      int now = getfail(last);
      if (/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!ch[now][c - 'a']) {
        int x = node(len[now] + 2);
        fail[x] = ch[getfail(fail[now])][c - 'a'];
        ch[now][c - 'a'] = x;
      }
      last = ch[now][c - 'a'];
      cnt[last]++;
    }
    ll solve() {
      ll ans = 0;
      for (int i = sz; i >= 0; i--) {
        cnt[fail[i]] += cnt[i];
      }
      for (int i = 1; i <= sz; i++) {
        ans = max(ans, 1ll * len[i] * cnt[i]);
      }
      return ans;
    }
    }  // namespace pam
    char s[maxn];
    int main() {
      pam::clear();
      scanf("%s", s + 1);
      for (int i = 1; s[i]; i++) {
        pam::insert(s[i]);
      }
      printf("%lld\n", pam::solve());
      return 0;
    }
    ```

### 最小回文划分

> 给定一个字符串 $s(1\le |s| \le 10^5)$ ，求最小的 $k$ ，使得存在 $s_1,s_2,\dots,s_k$ ，满足 $s_i(1\le i \le k)$ 均为回文串，且 $s_1,s_2, \dots ,s_k$ 依次连接后得到的字符串等于 $s$ 。

考虑动态规划，记 $dp[i]$ 表示 $s$ 长度为 $i$ 的前缀的最小划分数，转移只需要枚举以第 $i$ 个字符结尾的所有回文串

$$
dp[i]=1+\min_{ s[j+1..i] \text{ 为回文串} } dp[j]
$$

由于一个字符串最多会有 $O(n^2)$ 个回文子串，因此上述算法的时间复杂度为 $O(n^2)$ ，无法接受，为了优化转移过程，下面给出一些引理。

记字符串 $s$ 长度为 $i$ 的前缀为 $pre(s,i)$ ，长度为 $i$ 的后缀为 $suf(s,i)$ 。

周期：若 $0< p \le |s|$ ， $\forall 1 \le i \le |s|-p,s[i]=s[i+p]$ ，就称 $p$ 是 $s$ 的周期。

border：若 $0 \le r < |s|$ ， $pre(s,r)=suf(s,r)$ ，就称 $pre(s,r)$ 是 $s$ 的 border。

周期和 border 的关系： $t$ 是 $s$ 的 border，当且仅当 $|s|-|t|$ 是 $s$ 的周期。

证明：

若 $t$ 是 $s$ 的 border，那么 $pre(s,|t|)=suf(s,|t|)$ ，因此 $\forall 1\le i \le |t|, s[i]=s[|s|-|t|+i]$ ，所以 $|s|-|t|$ 就是 $s$ 的周期。

若 $|s|-|t|$ 为 $s$ 周期，则 $\forall 1 \le i \le |s|-(|s|-|t|)=|t|,s[i]=s[|s|-|t|+i]$ ，因此 $pre(s,|t|)=suf(s,|t|)$ ，所以 $t$ 是 $s$ 的 border。

引理 $1$ ： $t$ 是回文串 $s$ 的后缀， $t$ 是 $s$ 的 border 当且仅当 $t$ 是回文串。

证明：

对于 $1 \le i \le |t|$ ，由 $s$ 和 $t$ 为回文串，因此有 $s[i]=s[|s|-i+1]=s[|s|-|t|+i]$ ，所以 $t$ 是 $s$ 的 border。

对于 $1 \le i \le |t|$ ，由 $t$ 是 $s$ 的 border，有 $s[i]=s[|s|-|t|+i]$ ，由 $s$ 是回文串，有 $s[i]=s[|s|-i+1]$ ，因此 $s[|s|-i+1]=s[|s|-|t|+i]$ ，所以 $t$ 是回文串。

下图中，相同颜色的位置表示字符对应相同。

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/pam3.png)

引理 $2$ ： $t$ 是回文串 $s$ 的 border ( $|s|\le 2|t|$ )， $s$ 是回文串当且仅当 $t$ 是回文串。

证明：

若 $s$ 是回文串，由引理 $1$ ， $t$ 也是回文串。

若 $t$ 是回文串，由 $t$ 是 $s$ 的 border，因此 $\forall 1 \le i \le |t|, s[i]=s[|s|-|t|+i]=s[|s|-i+1]$ ，因为 $|s| \le 2|t|$ ，所以 $s$ 也是回文串。

引理 $3$ ： $t$ 是字符串 $s$ 的 border，则 $|s|-|t|$ 是 $s$ 的周期， $|s|-|t|$ 为 $s$ 的最小周期，当且仅当 $t$ 是 $s$ 的最长回文真后缀。

引理 $4$ ： $x$ 是一个回文串， $y$ 是 $x$ 的最长回文真后缀， $z$ 是 $y$ 的最长回文真后缀。令 $u,v$ 分别为满足 $x=uy,y=vz$ 的字符串，则有下面三条性质

1.   $|u| \ge |v|$ ；

2.  如果 $|u| > |v|$ ，那么 $|u| > |z|$ ；

3.  如果 $|u| = |v|$ ，那么 $u=v$ 。

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/pam4.png)

证明：

1.  由引理 $3$ 的推论， $|u|=|x|-|y|$ 是 $x$ 的最小周期， $|v|=|y|-|z|$ 是 $y$ 的最小周期。考虑反证法，假设 $|u| < |v|$ ，因为 $y$ 是 $x$ 的后缀，所以 $u$ 既是 $x$ 的周期，也是 $y$ 的周期，而 $|v|$ 是 $y$ 的最小周期，矛盾。所以 $|u| \ge |v|$ 。

2.  因为 $y$ 是 $x$ 的 border，所以 $v$ 是 $x$ 的前缀，设字符串 $w$ ，满足 $x=vw$ （如下图所示），其中 $z$ 是 $w$ 的 border。考虑反证法，假设 $|u| \le |z|$ ，那么 $|zu| \le 2|z|$ ，所以由引理 $2$ ， $w$ 是回文串，由引理 $1$ ， $w$ 是 $x$ 的 border，又因为 $|u| > |v|$ ，所以 $|w| > |y|$ ，矛盾。所以 $|u| > |z|$ 。

3.   $u,v$ 都是 $x$ 的前缀， $|u|=|v|$ ，所以 $u=v$ 。

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/pam5.png)

推论： $s$ 的所有回文后缀按照长度排序后，可以划分成 $\log |s|$ 段等差数列。

证明：

设 $s$ 的所有回文后缀长度从小到大排序为 $l_1,l_2,\dots,l_k$ 。对于任意 $2 \le i \le k-1$ ，若 $l_{i}-l_{i-1}=l_{i+1}-l_{i}$ ，则 $l_{i-1},l_{i},l_{i+1}$ 构成一个等差数列。否则 $l_{i}-l_{i-1}\neq l_{i+1}-l_{i}$ ，由引理 $4$ ，有 $l_{i+1}-l_{i}>l_{i}-l_{i-1}$ ，且 $l_{i+1}-l_{i}>l_{i-1}$ ， $l_{i+1}>2l_{i-1}$ 。因此，若相邻两对回文后缀的长度之差发生变化，那么这个最大长度一定会相对于最小长度翻一倍。显然，长度翻倍最多只会发生 $O(\log |s|)$ 次，也就是 $s$ 的回文后缀长度可以划分成 $\log |s|$ 段等差数列。

该推论也可以通过使用弱周期引理，对 $s$ 的最长回文后缀的所有 border 按照长度 $x$ 分类， $x \in [2^0,2^1),[2^1,2^2),\dots,[2^k,n)$ ，考虑这 $\log |s|$ 组内每组的最长 border 进行证明。详细证明可以参考金策的《字符串算法选讲》和陈孙立的 2019 年 IOI 国家候选队论文《子串周期查询问题的相关算法及其应用》。

有了这个结论后，我们现在可以考虑如何优化 $dp$ 的转移。

回文树上的每个节点 $u$ 需要多维护两个信息， $diff[u]$ 和 $slink[u]$ 。 $diff[u]$ 表示节点 $u$ 和 $fail[u]$ 所代表的回文串的长度差，即 $len[u]-len[fail[u]]$ 。 $slink[u]$ 表示 $u$ 一直沿着 fail 向上跳到第一个节点 $v$ ，使得 $diff[v] \neq diff[u]$ ，也就是 $u$ 所在等差数列中长度最小的那个节点。

根据上面证明的结论，如果使用 $slink$ 指针向上跳的话，每向后填加一个字符，只需要向上跳 $O(\log |s|)$ 次。因此，可以考虑将一个等差数列表示的所有回文串的 $dp$ 值之和（在原问题中指 $\min$ ），记录到最长的那一个回文串对应节点上。

 $g[v]$ 表示 $v$ 所在等差数列的 $dp$ 值之和，且 $v$ 是这个等差数列中长度最长的节点，则 $g[v]=\sum_{slink[x]=v} dp[i-len[x]]$ 。

下面我们考虑如何更新 $g$ 数组和 $dp$ 数组。以下图为例，假设当前枚举到第 $i$ 个字符，回文树上对应节点为 $x$ 。 $g[x]$ 为橙色三个位置的 $dp$ 值之和（最短的回文串 $slink[x]$ 算在下一个等差数列中）。 $fail[x]$ 上一次出现位置是 $i-diff[x]$ （在 $i-diff[x]$ 处结束）， $g[fail[x]]$ 包含的 $dp$ 值是蓝色位置。因此， $g[x]$ 实际上等于 $g[fail[x]]$ 和多出来一个位置的 $dp$ 值之和，多出来的位置是 $i-(len[slink[x]]+diff[x])$ 。最后再用 $g[x]$ 去更新 $dp[i]$ ，这部分等差数列的贡献就计算完毕了，不断跳 $slink[x]$ ，重复这个过程即可。具体实现方式可参考例题代码。

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/pam6.png)

最后，上述做法的正确性依赖于：如果 $x$ 和 $fail[x]$ 属于同一个等差数列，那么 $fail[x]$ 上一次出现位置是 $i-diff[x]$ 。

证明：

根据引理 $1$ ， $fail[x]$ 是 $x$ 的 border，因此其在 $i-diff[x]$ 处出现。

假设 $fail[x]$ 在 $(i-diff[x],i)$ 中的 $j$ 位置出现。由于 $x$ 和 $fail[x]$ 属于同一个等差数列，因此 $2|fail[x]| \ge x$ 。多余的 $fail[x]$ 和 $i-diff[x]$ 处的 $fail[x]$ 有交集，记交集为 $w$ ，设串 $u$ 满足 $uw=fail[x]$ 。用类似引理 $1$ 的方式可以证明， $w$ 是回文串，而 $x$ 的前缀 $s[i-len[x]+1..j]=uwu$ 也是回文串，这与 $fail[x]$ 是 $x$ 的最长回文前缀（后缀）矛盾。

例题： [Codeforces 932G Palindrome Partition](https://codeforces.com/problemset/problem/932/G) 

给定一个字符串 $s$ ，要求将 $s$ 划分为 $t_1, t_2, \dots, t_k$ ，其中 $k$ 是偶数，且 $t_i=t_{k-i}$ ，求这样的划分方案数。

??? note "题解"
    构造字符串 $t= s[0]s[n - 1]s[1]s[n - 2]s[2]s[n - 3] \dots s[n / 2 - 1]s[n / 2]$ ，问题等价于求 $t$ 的偶回文划分方案数，把上面的转移方程改成求和形式并且只在偶数位置更新 $dp$ 数组即可。时间复杂度 $O(n \log n)$ ，空间复杂度 $O(n)$ 。

??? note "参考代码"
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int mod = 1e9 + 7;
    const int maxn = 1000000 + 5;
    inline int add(int x, int y) {
      x += y;
      return x >= mod ? x -= mod : x;
    }
    namespace pam {
    int sz, tot, last;
    int ch[maxn][26], len[maxn], fail[maxn];
    int cnt[maxn], dep[maxn], dif[maxn], slink[maxn];
    char s[maxn];
    int node(int l) {
      sz++;
      memset(ch[sz], 0, sizeof(ch[sz]));
      len[sz] = l;
      fail[sz] = 0;
      cnt[sz] = 0;
      dep[sz] = 0;
      return sz;
    }
    void clear() {
      sz = -1;
      last = 0;
      s[tot = 0] = '$';
      node(0);
      node(-1);
      fail[0] = 1;
    }
    int getfail(int x) {
      while (s[tot - len[x] - 1] /home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!= s[tot]) x = fail[x];
      return x;
    }
    void insert(char c) {
      s[++tot] = c;
      int now = getfail(last);
      if (/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!ch[now][c - 'a']) {
        int x = node(len[now] + 2);
        fail[x] = ch[getfail(fail[now])][c - 'a'];
        dep[x] = dep[fail[x]] + 1;
        ch[now][c - 'a'] = x;
        dif[x] = len[x] - len[fail[x]];
        if (dif[x] == dif[fail[x]])
          slink[x] = slink[fail[x]];
        else
          slink[x] = fail[x];
      }
      last = ch[now][c - 'a'];
      cnt[last]++;
    }
    }  // namespace pam
    using pam::dif;
    using pam::fail;
    using pam::len;
    using pam::slink;
    int n, dp[maxn], g[maxn];
    char s[maxn], t[maxn];
    int main() {
      pam::clear();
      scanf("%s", s + 1);
      n = strlen(s + 1);
      for (int i = 1, j = 0; i <= n; i++) t[++j] = s[i], t[++j] = s[n - i + 1];
      dp[0] = 1;
      for (int i = 1; i <= n; i++) {
        pam::insert(t[i]);
        for (int x = pam::last; x > 1; x = slink[x]) {
          g[x] = dp[i - len[slink[x]] - dif[x]];
          if (dif[x] == dif[fail[x]]) g[x] = add(g[x], g[fail[x]]);
          if (i % 2 == 0) dp[i] = add(dp[i], g[x]);
        }
      }
      printf("%d", dp[n]);
      return 0;
    }
    ```

## 例题

-    [最长双回文串](https://www.luogu.org/problem/P4555) 

-    [拉拉队排练](https://www.luogu.org/problem/P1659) 

-    [「SHOI2011」双倍回文](https://www.luogu.org/problem/P4287) 

-    [HDU 5421 Victor and String](http://acm.hdu.edu.cn/showproblem.php?pid=5421) 

-    [CodeChef Palindromeness](https://www.codechef.com/LTIME23/problems/PALPROB) 

## 相关资料

-    [EERTREE: An Efficient Data Structure for Processing Palindromes in Strings](https://arxiv.org/pdf/1506.04862) 

-    [Palindromic tree](http://adilet.org/blog/palindromic-tree/) 

-   2017 年 IOI 国家候选队论文集 回文树及其应用 翁文涛


-   2019 年 IOI 国家候选队论文集 子串周期查询问题的相关算法及其应用 陈孙立

-   字符串算法选讲 金策

-    [A bit more about palindromes](https://codeforces.com/blog/entry/19193) 

-    [A Subquadratic Algorithm for Minimum Palindromic Factorization](https://arxiv.org/pdf/1403.2431.pdf) 

# automaton
在 OI 中，我们所说的“自动机”一般都指“确定有限状态自动机”。

自动机是 OI 中被广泛使用的一个数学模型，其思想在许多字符串算法中都有涉及，因此我们推荐您在学习一些字符串算法（ [KMP](./kmp.md) 、 [AC 自动机](./ac-automaton.md) 、 [SAM](./sam.md) ）前先完成自动机的学习。学习自动机有助于理解上述算法。

## 前置知识

-   基础图论（太基础了以至于没有内链）。

## 自动机入门

首先理解一下自动机是用来干什么的：自动机是一个对字符串进行判定的数学模型。

这句话涉及到的名词比较多，逐一解释一下。“信号序列”是指一连串有顺序的信号，例如字符串从前到后的每一个字符、数组从 1 到 n 的每一个数、数从高到低的每一位等。“判定”是指针对某一个命题给出或真或假的回答。有时我们需要对一个信号序列进行判定。一个简单的例子就是判定一个二进制数是奇数还是偶数，较复杂的例子例如判定一个字符串是否回文，判定一个字符串是不是某个特定字符串的子序列等等。

自动机的工作原理和地图很类似。假设你在你家，然后你从你家到学校，按顺序经过了很多路口。每个路口都有岔路，而你在所有这些路口的选择就构成了一个序列。

例如，你的选择序列是“家门 -> 右拐 -> 萍水西街 -> 尚园街 -> 古墩路 -> 地铁站 -> 下宁桥”，那你按顺序经过的路口可能是“家 -> 家门口 -> 萍水西街竞舟北路口 -> 萍水西街尚圆街路口 -> 尚园街古墩路口 -> 古墩路中 -> 三坝地铁站 -> 下宁桥地铁站”。可以发现，上学的选择序列不止这一个。同样要去地铁站，你还可以从竞舟北路绕道，或者横穿文鼎苑抄近路。

而我们如果找到一个选择序列，就可以在地图上比划出这个选择序列能不能去学校。比如，如果一个选择序列是“家门 -> 右拐 -> 萍水西街 -> 尚园街 -> 古墩路 -> 地铁站 -> 钱江路 -> 四号线站台 -> 联庄”，那么它就不会带你去同一个学校，但是仍旧可能是一个可被接受的序列，因为目标地点可能不止一个。

也就是说，我们通过这个地图和一组目的地，将信号序列分成了三类，一类是无法识别的信号序列（例如“家门 ->asdfawe”），一类是能去学校的信号序列，另一类是不能的信号序列。我们将所有合法的信号序列分成了两类，完成了一个判定问题。

既然自动机是一个数学模型，那么显然不可能是一张地图。众所周知，对地图进行抽象之后，可以简化为一个有向图。因此，自动机的结构就是一张有向图。

而自动机的工作方式和流程图类似，不同的是：自动机的每一个结点都是一个判定结点；自动机的结点只是一个单纯的状态而非任务；自动机的边可以接受多种字符（不局限于 T 或 F）。

例如，完成“判断一个二进制数是不是偶数”的自动机如下：

/home/llj/Desktop/OI-wiki-master/docs/string/![example automaton](./images/automaton2.png)

从起始结点开始，从高到低接受这个数的二进制序列，然后看最终停在哪里。如果最终停在红圈结点，则是偶数，否则不是。

如果需要判定一个有限的信号序列和另外一个信号序列的关系（例如另一个信号序列是不是某个信号序列的子序列），那么常用的方法是针对那个有限的信号序列构建一个自动机。这个在学习 KMP 的时候会讲到。

需要注意的是，自动机只是一个 **数学模型** ，而 **不是算法** ，也 **不是数据结构** 。实现同一个自动机的方法有很多种，可能会有不一样的时空复杂度，也可能会有不一样的代码长度。

接下来你可以选择继续看自动机的形式化定义，也可以去学习 [KMP](./kmp.md) 、 [AC 自动机](./ac-automaton.md) 或 [SAM](./sam.md) 了。

## 形式化定义

一个 **确定有限状态自动机（DFA）** 由以下五部分构成：

1.   **字符集** （ $\Sigma$ ），该自动机只能输入这些字符。
2.   **状态集合** （ $Q$ ）。如果把一个 DFA 看成一张有向图，那么 DFA 中的状态就相当于图上的顶点。
3.   **起始状态** （ $start$ ）， $start\in Q$ ，是一个特殊的状态。起始状态一般用 $s$ 表示，为了避免混淆，本文中使用 $start$ 。
4.   **接受状态集合** （ $F$ ）， $F\subseteq Q$ ，是一组特殊的状态。
5.   **转移函数** （ $\delta$ ）， $\delta$ 是一个接受两个参数返回一个值的函数，其中第一个参数和返回值都是一个状态，第二个参数是字符集中的一个字符。如果把一个 DFA 看成一张有向图，那么 DFA 中的转移函数就相当于顶点间的边，而每条边上都有一个字符。

DFA 的作用就是识别字符串，一个自动机 $A$ ，若它能识别（接受）字符串 $S$ ，那么 $A(S)=True$ ，否则 $A(S)=False$ 。

当一个 DFA 读入一个字符串时，从初始状态起按照转移函数一个一个字符地转移。如果读入完一个字符串的所有字符后位于一个接受状态，那么我们称这个 DFA **接受** 这个字符串，反之我们称这个 DFA **不接受** 这个字符串。

如果一个状态 $v$ 没有字符 $c$ 的转移，那么我们令 $\delta(v,c)=null$ ，而 $null$ 只能转移到 $null$ ，且 $null$ 不属于接受状态集合。无法转移到任何一个接受状态的状态都可以视作 $null$ ，或者说， $null$ 代指所有无法转移到任何一个接受状态的状态。

我们扩展定义转移函数 $\delta$ ，令其第二个参数可以接收一个字符串： $\delta(v,s)=\delta(\delta(v,s[1]),s[2..|s|])$ ，扩展后的转移函数就可以表示从一个状态起接收一个字符串后转移到的状态。那么， $A(s)=[\delta(start,s)\in F]$ 。

如，一个接受且仅接受字符串 "a", "ab", "aac" 的 DFA：

/home/llj/Desktop/OI-wiki-master/docs/string/![](./images/automaton1.png)

## OI 中常用的自动机

### 字典树

 [字典树](./trie.md) 是大部分 OIer 接触到的第一个自动机，接受且仅接受指定的字符串集合中的元素。

转移函数就是 Trie 上的边，接受状态是将每个字符串插入到 Trie 时到达的那个状态。

### KMP 自动机

 [KMP 算法](./kmp.md) 可以视作自动机，基于字符串 $s$ 的 KMP 自动机接受且仅接受以 $s$ 为后缀的字符串，其接受状态为 $|s|$ 。

转移函数：

$$
\delta(i, c)=
\begin{cases}
i+1&s[i+1]=c\\
0&s[1]\ne c\land i=0\\
\delta(\pi(i),c)&s[i+1]\ne c\land i>0
\end{cases}
$$

### AC 自动机

 [AC 自动机](./ac-automaton.md) 接受且仅接受以指定的字符串集合中的某个元素为后缀的字符串。也就是 Trie + KMP。

### 后缀自动机

 [后缀自动机](./sam.md) 接受且仅接受指定字符串的后缀。

### 广义后缀自动机

 [广义后缀自动机](./general-sam.md) 接受且仅接受指定的字符串集合中的某个元素的后缀。也就是 Trie + SAM。

广义 SAM 与 SAM 的关系就是 AC 自动机与 KMP 自动机的关系。

### 回文自动机

 [回文自动机](./pam.md) 比较特殊，它不能非常方便地定义为自动机。

如果需要定义的话，它接受且仅接受某个字符串的所有回文子串的 **中心及右半部分** 。

“中心及右边部分”在奇回文串中就是字面意思，在偶回文串中定义为一个特殊字符加上右边部分。这个定义看起来很奇怪，但它能让 PAM 真正成为一个自动机，而不仅是两棵树。

### 序列自动机

 [序列自动机](./seq-automaton.md) 接受且仅接受指定字符串的子序列。

## 后缀链接

由于自动机和匹配有着密不可分的关系，而匹配的一个基本思想是“这个串不行，就试试它的后缀可不可以”，所以在很多自动机（KMP、AC 自动机、SAM、PAM）中，都有后缀链接的概念。

一个状态会对应若干字符串，而这个状态的后缀链接，是在自动机上的、是这些字符串的公共真后缀的字符串中，最长的那一个。

一般来讲，后缀链接会形成一棵树，并且不同自动机的后缀链接树有着一些相同的性质，学习时可以加以注意。

## 扩展阅读

在计算复杂性领域中，自动机是一个经典的模型。并且，自动机与正则语言有着密不可分的关系。

如果对相关内容感兴趣的话，推荐阅读博客 [计算复杂性（1) Warming Up: 自动机模型](https://lingeros-tot.github.io/2019/03/05/Warming-Up-自动机模型/) 。

# minimal-string
最小表示法是用于解决字符串最小表示问题的方法（废话

## 字符串的最小表示

### 循环同构

当字符串 $S$ 中可以选定一个位置 $i$ 满足

$$
S[i\cdots n]+S[1\cdots i-1]=T
$$

则称 $S$ 与 $T$ 循环同构

### 最小表示

字符串 $S$ 的最小表示为与 $S$ 循环同构的所有字符串中字典序最小的字符串

## simple 的暴力

我们每次比较 $i$ 和 $j$ 开始的循环同构，把当前比较到的位置记作 $k$ ，每次遇到不一样的字符时便把大的跳过，最后剩下的就是最优解。

```cpp
int k = 0, i = 0, j = 1;
while (k < n && i < n && j < n) {
  if (sec[(i + k) % n] == sec[(j + k) % n]) {
    ++k;
  } else {
    if (sec[(i + k) % n] > sec[(j + k) % n])
      ++i;
    else
      ++j;
    k = 0;
    if (i == j) i++;
  }
}
i = min(i, j);
```

随机数据下表现良好，但是可以构造特殊数据卡掉。

例如：对于 $aaa\cdots aab$ , 不难发现这个算法的复杂度退化为 $O(n^2)$ 。

我们发现，当字符串中出现多个连续重复子串时，此算法效率降低，我们考虑优化这个过程。

## 最小表示法

### 算法核心

考虑对于一对字符串 $A,B$ , 它们在原字符串 $S$ 中的起始位置分别为 $i,j$ , 且它们的前 $k$ 个字符均相同，即

$$
A[i \cdots i+k-1]=B[j \cdots j+k-1]
$$

不妨先考虑 $A[i+k]>B[j+k]$ 的情况，我们发现起始位置下标 $l$ 满足 $i\le l\le i+k$ 的字符串均不能成为答案。因为对于任意一个字符串 $S_{i+p}$ （表示以 $i+p$ 为起始位置的字符串）一定存在字符串 $S_{j+p}$ 比它更优。

所以我们比较时可以跳过下标 $l\in [i,i+k]$ , 直接比较 $S_{i+k+1}$ 

这样，我们就完成了对于上文暴力的优化。

### 时间复杂度

 $O(n)$ 

~~证明：显然~~

### 算法流程

1.  初始化指针 $i$ 为 $0$ ， $j$ 为 $1$ ；初始化匹配长度 $k$ 为 $0$ 
2.  比较第 $k$ 位的大小，根据比较结果跳转相应指针。若跳转后两个指针相同，则随意选一个加一以保证比较的两个字符串不同
3.  重复上述过程，直到比较结束
4.  答案为 $i,j$ 中较小的一个

### 代码

```cpp
int k = 0, i = 0, j = 1;
while (k < n && i < n && j < n) {
  if (sec[(i + k) % n] == sec[(j + k) % n]) {
    k++;
  } else {
    sec[(i + k) % n] > sec[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;
    if (i == j) i++;
    k = 0;
  }
}
i = min(i, j);
```

# index
字符串，就是由字符连接而成的序列。

常见的字符串问题包括字符串匹配问题、子串相关问题、前缀/后缀相关问题、回文串相关问题、子序列相关问题等。

# sam
author: abc1763613206

## 一些前置约定/定义

记 $\Sigma$ 为字符集， $\left|\Sigma\right|$ 为字符集大小。
对于一个字符串 $s$ ，记 $\left|s\right|$ 为其长度。

## 后缀自动机概述

 **后缀自动机** (suffix automaton, SAM) 是一个能解决许多字符串相关问题的有力的数据结构。

举个例子，以下的字符串问题都可以在线性时间内通过 SAM 解决。

-   在另一个字符串中搜索一个字符串的所有出现位置。
-   计算给定的字符串中有多少个不同的子串。

直观上，字符串的 SAM 可以理解为给定字符串的 **所有子串** 的压缩形式。值得注意的事实是，SAM 将所有的这些信息以高度压缩的形式储存。对于一个长度为 $n$ 的字符串，它的空间复杂度仅为 $O(n)$ 。此外，构造 SAM 的时间复杂度仅为 $O(n)$ 。准确地说，一个 SAM 最多有 $2n-1$ 个节点和 $3n-4$ 条转移边。

## SAM 的定义

字符串 $s$ 的 SAM 是一个接受 $s$ 的所有后缀的最小 **DFA** （确定性有限自动机或确定性有限状态自动机）。

换句话说：

-   SAM 是一张有向无环图。结点被称作 **状态** ，边被称作状态间的 **转移** 。
-   图存在一个源点 $t_0$ ，称作 **初始状态** ，其它各结点均可从 $t_0$ 出发到达。
-   每个 **转移** 都标有一些字母。从一个结点出发的所有转移均 **不同** 。
-   存在一个或多个 **终止状态** 。如果我们从初始状态 $t_0$ 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 $s$ 的一个后缀。 $s$ 的每个后缀均可用一条从 $t_0$ 到某个终止状态的路径构成。
-   在所有满足上述条件的自动机中，SAM 的结点数是最少的。

### 子串的性质

SAM 最简单、也最重要的性质是，它包含关于字符串 $s$ 的所有子串的信息。任意从初始状态 $t_0$ 开始的路径，如果我们将转移路径上的标号写下来，都会形成 $s$ 的一个 **子串** 。反之每个 $s$ 的子串对应从 $t_0$ 开始的某条路径。

为了简化表达，我们称子串 **对应** 一条路径（从 $t_0$ 开始、由一些标号构成这个子串）。反过来，我们说任意一条路径 **对应** 它的标号构成的字符串。

到达某个状态的路径可能不止一条，因此我们说一个状态对应一些字符串的集合，这个集合的每个元素对应这些路径。

### 构造 SAM

我们将会在这里展示一些简单的字符串的后缀自动机。

我们用蓝色表示初始状态，用绿色表示终止状态。

对于字符串 $s=“"$ ：

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/SAM/SA.svg)

对于字符串 $s=“a\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"$ ：

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/SAM/SAa.svg)

对于字符串 $s=“aa\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"$ ：

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/SAM/SAaa.svg)

对于字符串 $s=“ab\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"$ ：

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/SAM/SAab.svg)

对于字符串 $s=“abb\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"$ ：

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/SAM/SAabb.svg)

对于字符串 $s=“abbb\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"$ ：

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/SAM/SAabbb.svg)

## 在线性时间内构造 SAM

在我们描述线性时间内构造 SAM 的算法之前，我们需要引入几个对理解构造过程非常重要的概念并对其进行简单证明。

### 结束位置 `endpos` 

考虑字符串 $s​$ 的任意非空子串 $t​$ ，我们记 $endpos(t)​$ 为在字符串 $s​$ 中 $t​$ 的所有结束位置（假设对字符串中字符的编号从零开始）。例如，对于字符串 $“abcbc\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"​$ ，我们有 $endpos(“bc\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!")=2,\,4​$ 。

两个子串 $t_1$ 与 $t_2$ 的 $endpos$ 集合可能相等： $endpos(t_1)=endpos(t_2)$ 。这样所有字符串 $s$ 的非空子串都可以根据它们的 $endpos$ 集合被分为若干 **等价类** 。

显然，SAM 中的每个状态对应一个或多个 $endpos$ 相同的子串。换句话说，SAM 中的状态数等于所有子串的等价类的个数，再加上初始状态。SAM 的状态个数等价于 $endpos$ 相同的一个或多个子串所组成的集合的个数 $+1​$ 。

我们稍后将会用这个假设来介绍构造 SAM 的算法。我们将发现，SAM 需要满足的所有性质，除了最小性以外都满足了。由 Nerode 定理我们可以得出最小性（不会在这篇文章中证明）。

由 $endpos$ 的值我们可以得到一些重要结论：

>  **引理 1：** 字符串 $s$ 的两个非空子串 $u$ 和 $w$ （假设 $\left|u\right|\le \left|w\right|$ ）的 $endpos$ 相同，当且仅当字符串 $u$ 在 $s$ 中的每次出现，都是以 $w$ 后缀的形式存在的。

引理显然成立。如果 $u$ 和 $w$ 的 $endpos$ 相同，则 $u$ 是 $w$ 的一个后缀，且只以 $s$ 中的一个 $w$ 的后缀的形式出现。且根据定义，如果 $u$ 为 $w$ 的一个后缀，且只以后缀的形式在 $s$ 中出现时，两个子串的 $endpos$ 相同。

>  **引理 2：** 考虑两个非空子串 $u$ 和 $w$ （假设 $\left|u\right|\le \left|w\right|$ ）。那么要么 $endpos(u)\cap endpos(w)=\varnothing$ ，要么 $endpos(w)\subseteq endpos(u)$ ，取决于 $u$ 是否为 $w$ 的一个后缀：
>
> $$
> \begin{cases}
> endpos(w) \subseteq endpos(u) & \text{if } u \text{ is a suffix of } w \\
> endpos(w) \cap endpos(u) = \varnothing & \text{otherwise}
> \end{cases}
> $$

证明：如果集合 $endpos(u)$ 与 $endpos(w)$ 有至少一个公共元素，那么由于字符串 $u$ 与 $w$ 在相同位置结束， $u$ 是 $w$ 的一个后缀。所以在每次 $w$ 出现的位置，子串 $u$ 也会出现。所以 $endpos(w)\subseteq endpos(u)$ 。

>  **引理 3：** 考虑一个 $endpos$ 等价类，将类中的所有子串按长度非递增的顺序排序。每个子串都不会比它前一个子串长，与此同时每个子串也是它前一个子串的后缀。换句话说，对于同一等价类的任一两子串，较短者为较长者的后缀，且该等价类中的子串长度恰好覆盖整个区间 $[x,y]$ 。

证明：如果 $endpos$ 等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于 $1$ 的等价类。

由引理 1，两个不同的 $endpos$ 等价的字符串中，较短者总是较长者的真后缀。因此，等价类中没有等长的字符串。

记 $w$ 为等价类中最长的字符串、 $u$ 为等价类中最短的字符串。由引理 1，字符串 $u$ 是字符串 $w$ 的真后缀。现在考虑长度在区间 $[\left|u\right|,\left|w\right|]$ 中的 $w$ 的任意后缀。容易看出，这个后缀也在同一等价类中，因为这个后缀只能在字符串 $s$ 中以 $w$ 的一个后缀的形式存在（也因为较短的后缀 $u$ 在 $s$ 中只以 $w$ 的后缀的形式存在）。因此，由引理 1，这个后缀和字符串 $w$ 的 $endpos$ 相同。

### 后缀链接 `link` 

考虑 SAM 中某个不是 $t_0$ 的状态 $v$ 。我们已经知道，状态 $v$ 对应于具有相同 $endpos$ 的等价类。我们如果定义 $w$ 为这些字符串中最长的一个，则所有其它的字符串都是 $w$ 的后缀。

我们还知道字符串 $w$ 的前几个后缀（按长度降序考虑）全部包含于这个等价类，且所有其它后缀（至少有一个——空后缀）在其它的等价类中。我们记 $t$ 为最长的这样的后缀，然后将 $v$ 的后缀链接连到 $t$ 上。

换句话说，一个 **后缀链接**  $link(v)$ 连接到对应于 $w$ 的最长后缀的另一个 $endpos$ 等价类的状态。

以下我们假设初始状态 $t_0$ 对应于它自己这个等价类（只包含一个空字符串）。为了方便，我们规定 $endpos(t_0)=\{-1,0,\ldots,\left|S\right|-1\}$ 。

>  **引理 4：** 所有后缀链接构成一棵根节点为 $t_0$ 的树。

证明：考虑任意不是 $t_0$ 的状态 $v$ ，后缀链接 $link(v)$ 连接到的状态对应于严格更短的字符串（后缀链接的定义、引理 3）。因此，沿后缀链接移动，我们总是能到达对应空串的初始状态 $t_0$ 。

>  **引理 5：** 通过 $endpos$ 集合构造的树（每个子节点的 $subset$ 都包含在父节点的 $subset$ 中）与通过后缀链接 $link$ 构造的树相同。

证明：由引理 2，任意一个 SAM 的 $endpos$ 集合形成了一棵树（因为两个集合要么完全没有交集要么其中一个是另一个的子集）。

我们现在考虑任意不是 $t_0$ 的状态 $v$ 及后缀链接 $link(v)$ ，由后缀链接和引理 2，我们可以得到

$$
endpos(v)\subseteq endpos(link(v)),
$$

结合前面的引理有：后缀链接构成的树本质上是 $endpos$ 集合构成的一棵树。

以下是对字符串 $“abcbc\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"$ 构造 SAM 时产生的后缀链接树的一个 **例子** ，节点被标记为对应等价类中最长的子串。

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/SAM/SA_suffix_links.svg)

### 小结

在学习算法本身前，我们总结一下之前学过的知识，并引入一些辅助记号。

-    $s$ 的子串可以根据它们结束的位置 $endpos$ 被划分为多个等价类；
-   SAM 由初始状态 $t_0$ 和与每一个 $endpos$ 等价类对应的每个状态组成；
-   对于每一个状态 $v$ ，一个或多个子串与之匹配。我们记 $longest(v)$ 为其中最长的一个字符串，记 $len(v)$ 为它的长度。类似地，记 $shortest(v)$ 为最短的子串，它的长度为 $minlen(v)$ 。那么对应这个状态的所有字符串都是字符串 $longest(v)$ 的不同的后缀，且所有字符串的长度恰好覆盖区间 $[minlength(v),len(v)]$ 中的每一个整数。
-   对于任意不是 $t_0$ 的状态 $v$ ，定义后缀链接为连接到对应字符串 $longest(v)$ 的长度为 $minlen(v)-1$ 的后缀的一条边。从根节点 $t_0$ 出发的后缀链接可以形成一棵树。这棵树也表示 $endpos$ 集合间的包含关系。
-   对于 $t_0$ 以外的状态 $v$ ，可用后缀链接 $link(v)$ 表达 $minlen(v)$ ：

$$
minlen(v)=len(link(v))+1.
$$

-   如果我们从任意状态 $v_0$ 开始顺着后缀链接遍历，总会到达初始状态 $t_0$ 。这种情况下我们可以得到一个互不相交的区间 $[minlen(v_i),len(v_i)]$ 的序列，且它们的并集形成了连续的区间 $[0,len(v_0)]$ 。

### 算法

现在我们可以学习构造 SAM 的算法了。这个算法是 **在线** 算法，我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护 SAM。

为了保证线性的空间复杂度，我们将只保存 $len$ 和 $link$ 的值和每个状态的转移列表，我们不会标记终止状态（但是我们稍后会展示在构造 SAM 后如何分配这些标记）。

一开始 SAM 只包含一个状态 $t_0$ ，编号为 $0$ （其它状态的编号为 $1,2,\ldots$ ）。为了方便，对于状态 $t_0$ 我们指定 $len=0$ 、 $link=-1$ （ $-1$ 表示虚拟状态）。

现在，任务转化为实现给当前字符串添加一个字符 $c$ 的过程。算法流程如下：

-   令 $last$ 为添加字符 $c$ 之前，整个字符串对应的状态（一开始我们设 $last=0$ ，算法的最后一步更新 $last$ ）。
-   创建一个新的状态 $cur$ ，并将 $len(cur)$ 赋值为 $len(last)+1$ ，在这时 $link(cur)$ 的值还未知。
-   现在我们按以下流程进行（从状态 $last$ 开始）。如果还没有到字符 $c$ 的转移，我们就添加一个到状态 $cur$ 的转移，遍历后缀链接。如果在某个点已经存在到字符 $c$ 的转移，我们就停下来，并将这个状态标记为 $p$ 。
-   如果没有找到这样的状态 $p$ ，我们就到达了虚拟状态 $-1$ ，我们将 $link(cur)$ 赋值为 $0$ 并退出。
-   假设现在我们找到了一个状态 $p$ ，其可以通过字符 $c$ 转移。我们将转移到的状态标记为 $q$ 。
-   现在我们分类讨论两种状态，要么 $len(p) + 1 = len(q)$ ，要么不是。
-   如果 $len(p)+1=len(q)$ ，我们只要将 $link(cur)$ 赋值为 $q$ 并退出。
-   否则就会有些复杂。需要 **复制** 状态 $q$ ：我们创建一个新的状态 $clone$ ，复制 $q$ 的除了 $len$ 的值以外的所有信息（后缀链接和转移）。我们将 $len(clone)$ 赋值为 $len(p)+1$ 。  
    复制之后，我们将后缀链接从 $cur$ 指向 $clone$ ，也从 $q$ 指向 $clone$ 。  
    最终我们需要使用后缀链接从状态 $p$ 往回走，只要存在一条通过 $p$ 到状态 $q$ 的转移，就将该转移重定向到状态 $clone$ 。
-   以上三种情况，在完成这个过程之后，我们将 $last$ 的值更新为状态 $cur$ 。

如果我们还想知道哪些状态是 **终止状态** 而哪些不是，我们可以在为字符串 $s$ 构造完完整的 SAM 后找到所有的终止状态。为此，我们从对应整个字符串的状态（存储在变量 $last$ 中），遍历它的后缀链接，直到到达初始状态。我们将所有遍历到的节点都标记为终止节点。容易理解这样做我们会准确地标记字符串 $s$ 的所有后缀，这些状态都是终止状态。

在下一部分，我们将详细叙述算法每一步的细节，并证明它的 **正确性** 。
因为我们只为 $s$ 的每个字符创建一个或两个新状态，所以 SAM 只包含 **线性个** 状态。

而线性规模的转移个数，以及算法总体的线性运行时间还不那么清楚。

### 正确性证明

-   若一个转移 $(p,q)$ 满足 $len(p)+1=len(q)$ ，则我们称这个转移是 **连续的** 。否则，即当 $len(p)+1<len(q)$ 时，这个转移被称为 **不连续的** 。从算法描述中可以看出，连续的、不连续的转移是算法的不同情况。连续的转移是固定的，我们不会再改变了。与此相反，当向字符串中插入一个新的字符时，不连续的转移可能会改变（转移边的端点可能会改变）。
-   为了避免引起歧义，我们记向 SAM 中插入当前字符 $c$ 之前的字符串为 $s$ 。
-   算法从创建一个新状态 $cur$ 开始，对应于整个字符串 $s+c$ 。我们创建一个新的节点的原因很清楚。与此同时我们也创建了一个新的字符和一个新的等价类。
-   在创建一个新的状态之后，我们会从对应整个字符串 $s$ 的状态通过后缀链接进行遍历。对于每一个状态，我们尝试添加一个通过字符 $c$ 到新状态 $cur$ 的转移。然而我们只能添加与原有转移不冲突的转移。因此我们只要找到已存在的 $c$ 的转移，我们就必须停止。
-   最简单的情况是我们到达了虚拟状态 $-1$ ，这意味着我们为所有 $s$ 的后缀添加了 $c$ 的转移。这也意味着，字符 $c$ 从未在字符串 $s$ 中出现过。因此 $cur$ 的后缀链接为状态 $0$ 。
-   第二种情况下，我们找到了现有的转移 $(p,q)$ 。这意味着我们尝试向自动机内添加一个 **已经存在的** 字符串 $x+c$ （其中 $x$ 为 $s$ 的一个后缀，且字符串 $x+c$ 已经作为 $s$ 的一个子串出现过了）。因为我们假设字符串 $s$ 的自动机的构造是正确的，我们不应该在这里添加一个新的转移。然而，难点在于，从状态 $cur$ 出发的后缀链接应该连接到哪个状态呢？我们要把后缀链接连到一个状态上，且其中最长的一个字符串恰好是 $x+c$ ，即这个状态的 $len$ 应该是 $len(p)+1$ 。然而还不存在这样的状态，即 $len(q)>len(p)+1$ 。这种情况下，我们必须通过拆开状态 $q$ 来创建一个这样的状态。
-   如果转移 $(p,\,q)$ 是连续的，那么 $len(q)=len(p)+1$ 。在这种情况下一切都很简单。我们只需要将 $cur$ 的后缀链接指向状态 $q$ 。
-   否则转移是不连续的，即 $len(q)>len(p)+1$ ，这意味着状态 $q$ 不只对应于长度为 $len(p)+1$ 的后缀 $s+c$ ，还对应于 $s$ 的更长的子串。除了将状态 $q$ 拆成两个子状态以外我们别无他法，所以第一个子状态的长度就是 $len(p)+1$ 了。  
    我们如何拆开一个状态呢？我们 **复制** 状态 $q$ ，产生一个状态 $clone$ ，我们将 $len(clone)$ 赋值为 $len(p)+1$ 。由于我们不想改变遍历到 $q$ 的路径，我们将 $q$ 的所有转移复制到 $clone$ 。我们也将从 $clone$ 出发的后缀链接设置为 $q$ 的后缀链接的目标，并设置 $q$ 的后缀链接为 $clone$ 。  
    在拆开状态后，我们将从 $cur$ 出发的后缀链接设置为 $clone$ 。  
    最后一步我们将一些到 $q$ 转移重定向到 $clone$ 。我们需要修改哪些转移呢？只重定向相当于所有字符串 $w+c$ （其中 $w$ 是 $p$ 的最长字符串）的后缀就够了。即，我们需要继续沿着后缀链接遍历，从结点 $p$ 直到虚拟状态 $-1$ 或者是转移到不是状态 $q$ 的一个转移。

### 对操作次数为线性的证明

首先我们假设字符集大小为 **常数** 。如果字符集大小不是常数，SAM 的时间复杂度就不是线性的。从一个结点出发的转移存储在支持快速查询和插入的平衡树中。因此如果我们记 $\Sigma$ 为字符集， $\left|\Sigma\right|$ 为字符集大小，则算法的渐进时间复杂度为 $O(n\log\left|\Sigma\right|)$ ，空间复杂度为 $O(n)$ 。然而如果字符集足够小，可以不写平衡树，以空间换时间将每个结点的转移存储为长度为 $\left|\Sigma\right|$ 的数组（用于快速查询）和链表（用于快速遍历所有可用关键字）。这样算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(n\left|\Sigma\right|)$ 。

所以我们将认为字符集的大小为常数，即每次对一个字符搜索转移、添加转移、查找下一个转移。这些操作的时间复杂度都为 $O(1)$ 。

如果我们考虑算法的各个部分，算法中有三处时间复杂度不明显是线性的：

-   第一处是遍历所有状态 $last$ 的后缀链接，添加字符 $c$ 的转移。
-   第二处是当状态 $q$ 被复制到一个新的状态 $clone$ 时复制转移的过程。
-   第三处是修改指向 $q$ 的转移，将它们重定向到 $clone$ 的过程。

我们使用 SAM 的大小（状态数和转移数）为 **线性的** 的事实（对状态数是线性的的证明就是算法本身，对转移数为线性的的证明将在稍后实现算法后给出）。

因此上述 **第一处和第二处** 的总复杂度显然为线性的，因为单次操作均摊只为自动机添加了一个新转移。

还需为 **第三处** 估计总复杂度，我们将最初指向 $q$ 的转移重定向到 $clone$ 。我们记 $v=longest(p)$ ，这是一个字符串 $s$ 的后缀，每次迭代长度都递减——因为字符串 $s$ 的位置每次迭代都单调上升。这种情况下，如果在循环的第一次迭代之前，相对应的字符串 $v$ 在距离 $last$ 的深度为 $k$  $(k\ge 2)$ 的位置上（深度记为后缀链接的数量），那么在最后一次迭代后，字符串 $v+c$ 将会成为路径上第二个从 $cur$ 出发的后缀链接（它将会成为新的 $last$ 的值）。

因此，循环中的每次迭代都会使作为当前字符串的后缀的字符串 $longest(link(link(last))$ 的位置单调递增。因此这个循环最多不会执行超过 $n$ 次迭代，这正是我们需要证明的。

### 实现

首先，我们实现一种存储一个转移的全部信息的数据结构。如果需要的话，你可以在这里加入一个终止标记，也可以是一些其它信息。我们将用一个 `map` 存储转移的列表，允许我们在总计 $O(n)$ 的空间复杂度和 $O(n\log\left|\Sigma\right|)$ 的时间复杂度内处理整个字符串。（注：在字符集大小为较小的常数，比如 26 时，将 `next` 定义为 `int[26]` 更方便）

```cpp
struct state {
  int len, link;
  std::map<char, int> next;
};
```

SAM 本身将会存储在一个 `state` 结构体数组中。我们记录当前自动机的大小 `sz` 和变量 `last` ，当前整个字符串对应的状态。

```cpp
const int MAXLEN = 100000;
state st[MAXLEN * 2];
int sz, last;
```

我们定义一个函数来初始化 SAM（创建一个只有初始状态的 SAM）。

```cpp
void sam_init() {
  st[0].len = 0;
  st[0].link = -1;
  sz++;
  last = 0;
}
```

最终我们给出主函数的实现：给当前行末增加一个字符，对应地在之前的基础上建造自动机。

```cpp
void sam_extend(char c) {
  int cur = sz++;
  st[cur].len = st[last].len + 1;
  int p = last;
  while (p /home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!= -1 && /home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!st[p].next.count(c)) {
    st[p].next[c] = cur;
    p = st[p].link;
  }
  if (p == -1) {
    st[cur].link = 0;
  } else {
    int q = st[p].next[c];
    if (st[p].len + 1 == st[q].len) {
      st[cur].link = q;
    } else {
      int clone = sz++;
      st[clone].len = st[p].len + 1;
      st[clone].next = st[q].next;
      st[clone].link = st[q].link;
      while (p /home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!= -1 && st[p].next[c] == q) {
        st[p].next[c] = clone;
        p = st[p].link;
      }
      st[q].link = st[cur].link = clone;
    }
  }
  last = cur;
}
```

正如之前提到的一样，如果你用内存换时间（空间复杂度为 $O(n\left|\Sigma\right|)$ ，其中 $\left|\Sigma\right|$ 为字符集大小），你可以在 $O(n)$ 的时间内构造字符集大小任意的 SAM。但是这样你需要为每一个状态储存一个大小为 $\left|\Sigma\right|$ 的数组（用于快速跳转到转移的字符），和另外一个所有转移的链表（用于快速在转移中迭代）。

## 更多性质

### 状态数

对于一个长度为 $n$ 的字符串 $s$ ，它的 SAM 中的状态数 **不会超过**  $2n-1$ （假设 $n\ge 2$ ）。

算法本身即可证明该结论。一开始，自动机含有一个状态，第一次和第二次迭代中只会创建一个节点，剩余的 $n-2$ 步中每步会创建至多 $2$ 个状态。

然而我们也能在 **不借助这个算法** 的情况下 **证明** 这个估计值。我们回忆一下状态数等于不同的 $endpos$ 集合个数。这些 $endpos$ 集合形成了一棵树（祖先节点的集合包含了它所有孩子节点的集合）。考虑将这棵树稍微变形一下：只要它有一个只有一个孩子的内部结点（这意味着该子节点的集合至少遗漏了它的父集合中的一个位置），我们创建一个含有这个遗漏位置的集合。最后我们可以获得一棵每一个内部结点的度数大于 1 的树，且叶子节点的个数不超过 $n$ 。因此这样的树里有不超过 $2n-1$ 个节点。

字符串 $“abbb\ldots bbb\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"$ 的状态数达到了该上界：从第三次迭代后的每次迭代，算法都会拆开一个状态，最终产生恰好 $2n-1$ 个状态。

### 转移数

对于一个长度为 $n$ 的字符串 $s$ ，它的 SAM 中的转移数 **不会超过**  $3n-4$ （假设 $n\ge 3$ ）。

证明如下：

我们首先估计连续的转移的数量。考虑自动机中从状态 $t_0$ 开始的所有最长路径的生成树。生成树只包含连续的边，因此数量少于状态数，即边数不会超过 $2n-2$ 。

现在我们来估计不连续的转移的数量。令当前不连续转移为 $(p,\,q)$ ，其字符为 $c$ 。我们取它的对应字符串 $u+c+w$ ，其中字符串 $u$ 对应于初始状态到 $p$ 的最长路径， $w$ 对应于从 $q$ 到任意终止状态的最长路径。一方面，每个不完整的字符串所对应的形如 $u+c+w$ 的字符串是不同的（因为字符串 $u$ 和 $w$ 仅由完整的转移组成）。另一方面，由终止状态的定义，每个形如 $u+c+w$ 的字符串都是整个字符串 $s$ 的后缀。因为 $s$ 只有 $n$ 个非空后缀，且形如 $u+c+w$ 的字符串都不包含 $s$ （因为整个字符串只包含完整的转移），所以非完整的转移的总数不会超过 $n-1$ 。

将以上两个估计值相加，我们可以得到上界 $3n-3$ 。然而，最大的状态数只能在类似于 $“abbb\ldots bbb\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"$ 的情况中产生，而此时转移数量显然少于 $3n-3$ 。

因此我们可以获得更为紧确的 SAM 的转移数的上界： $3n-4$ 。字符串 $“abbb\ldots bbbc\/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!"$ 就达到了这个上界。

### 额外信息

观察 [实现](#_8) 中的结构体的每个变量。实际上，尽管 SAM 本身由 `next` 组成，但 SAM 构造算法中作为辅助变量的 `link` 和 `len` 在应用中常常比 `next` 重要，甚至可以抛开 `next` 单独使用。

设字符串的长度为 $n$ ，考虑 `extend` 操作中 `cur` 变量的值，这个节点对应的状态是<u>执行 `extend` 操作时的当前字符串</u>，即字符串的一个前缀，每个前缀有一个终点。这样得到的 $n$ 个节点，对应了 $n$ 个不同的 **终点** 。设第 $i$ 个节点为 $v_i$ ，对应的是 $S_{1 \ldots i}$ ，终点是 $i$ 。姑且把这些节点称之为“终点节点”。

考虑给 SAM 赋予树形结构，树的根为 0，且其余节点 $v$ 的父亲为 $link(v)$ 。则这棵树与原 SAM 的关系是：

-   每个节点的终点集合等于其 **子树** 内所有终点节点对应的终点的集合。

在此基础上可以给每个节点赋予一个最长字符串，是其终点集合中 **任意** 一个终点开始 **往前** 取 `len` 个字符得到的字符串。每个这样的字符串都一样，且 `len` 恰好是满足这个条件的最大值。

这些字符串满足的性质是：

-   如果节点 A 是 B 的祖先，则节点 A 对应的字符串是节点 B 对应的字符串的 **后缀** 。

这条性质把字符串所有前缀组成了一棵树，且有许多符合直觉的树的性质。例如， $S_{1 \ldots p}$ 和 $S_{1 \ldots q}$ 的最长公共后缀对应的字符串就是 $v_p$ 和 $v_q$ 对应的 LCA 的字符串。实际上，这棵树与将字符串 $S$ 翻转后得到字符串的压缩后缀树结构相同。

每个状态 $i$ 对应的子串数量是 $len(i)-len(link(i))$ （节点 $0$ 例外）。注意到 $link(i)$ 对应的字符串是 $i$ 对应的字符串的一个后缀，这些子串就是 $i$ 对应字符串的所有后缀，去掉被父亲“抢掉”的那部分，即 $link(i)$ 对应字符串的所有后缀。

## 应用

下面我们来看一些可以用 SAM 解决的问题。简单起见，假设字符集的大小 $k$ 为常数。这允许我们认为增加一个字符和遍历的复杂度为常数。

### 检查字符串是否出现

> 给一个文本串 $T$ 和多个模式串 $P$ ，我们要检查字符串 $P$ 是否作为 $T$ 的一个子串出现。

我们在 $O(\left|T\right|)$ 的时间内对文本串 $T$ 构造后缀自动机。为了检查模式串 $P$ 是否在 $T$ 中出现，我们沿转移（边）从 $t_0$ 开始根据 $P$ 的字符进行转移。如果在某个点无法转移下去，则模式串 $P$ 不是 $T$ 的一个子串。如果我们能够这样处理完整个字符串 $P$ ，那么模式串在 $T$ 中出现过。

对于每个字符串 $P$ ，算法的时间复杂度为 $O(\left|P\right|)$ 。此外，这个算法还找到了模式串 $P$ 在文本串中出现的最大前缀长度。

### 不同子串个数

> 给一个字符串 $S$ ，计算不同子串的个数。

对字符串 $S$ 构造后缀自动机。

每个 $S$ 的子串都相当于自动机中的一些路径。因此不同子串的个数等于自动机中以 $t_0$ 为起点的不同路径的条数。

考虑到 SAM 为有向无环图，不同路径的条数可以通过动态规划计算。即令 $d_{v}$ 为从状态 $v$ 开始的路径数量（包括长度为零的路径），则我们有如下递推方程：

$$
d_{v}=1+\sum_{w:(v,w,c)\in DAWG}d_{w}
$$

即， $d_{v}$ 可以表示为所有 $v$ 的转移的末端的和。

所以不同子串的个数为 $d_{t_0}-1$ （因为要去掉空子串）。

总时间复杂度为： $O(\left|S\right|)$ 。

另一种方法是利用上述后缀自动机的树形结构。每个节点对应的子串数量是 $len(i)-len(link(i))$ ，对自动机所有节点求和即可。

例题： [【模板】后缀自动机](https://www.luogu.org/problem/P3804) ， [SDOI2016 生成魔咒](https://loj.ac/problem/2033) 

### 所有不同子串的总长度

> 给定一个字符串 $S$ ，计算所有不同子串的总长度。

本题做法与上一题类似，只是现在我们需要考虑分两部分进行动态规划：不同子串的数量 $d_{v}$ 和它们的总长度 $ans_{v}$ 。

我们已经在上一题中介绍了如何计算 $d_{v}$ 。 $ans_{v}$ 的值可以通过以下递推式计算：

$$
ans_{v}=\sum_{w:(v,w,c)\in DAWG}d_{w}+ans_{w}
$$

我们取每个邻接结点 $w$ 的答案，并加上 $d_{w}$ （因为从状态 $v$ 出发的子串都增加了一个字符）。

算法的时间复杂度仍然是 $O(\left|S\right|)$ 。

同样可以利用上述后缀自动机的树形结构。每个节点对应的所有后缀长度是 $\frac{len(i)\times (len(i)+1)}{2}$ ，减去其 $link$ 节点的对应值就是该节点的净贡献，对自动机所有节点求和即可。

### 字典序第 $k$ 大子串

> 给定一个字符串 $S$ 。多组询问，每组询问给定一个数 $K_i$ ，查询 $S$ 的所有子串中字典序第 $K_i$ 大的子串。

解决这个问题的思路可以从解决前两个问题的思路发展而来。字典序第 $k$ 大的子串对应于 SAM 中字典序第 $k$ 大的路径，因此在计算每个状态的路径数后，我们可以很容易地从 SAM 的根开始找到第 $k$ 大的路径。

预处理的时间复杂度为 $O(\left|S\right|)$ ，单次查询的复杂度为 $O(\left|ans\right|\cdot\left|\Sigma\right|)$ （其中 $ans$ 是查询的答案， $\left|\Sigma\right|$ 为字符集的大小）。

> 虽然该题是后缀自动机的经典题，但实际上这题由于涉及字典序，用后缀数组做最方便。

例题： [SPOJ - SUBLEX](https://www.spoj.com/problems/SUBLEX/) ， [TJOI2015 弦论](https://loj.ac/problem/2102) 

### 最小循环移位

> 给定一个字符串 $S$ 。找出字典序最小的循环移位。

容易发现字符串 $S+S$ 包含字符串 $S$ 的所有循环移位作为子串。

所以问题简化为在 $S+S$ 对应的后缀自动机上寻找最小的长度为 $\left|S\right|$ 的路径，这可以通过平凡的方法做到：我们从初始状态开始，贪心地访问最小的字符即可。

总的时间复杂度为 $O(\left|S\right|)$ 。

### 出现次数

> 对于一个给定的文本串 $T$ ，有多组询问，每组询问给一个模式串 $P$ ，回答模式串 $P$ 在字符串 $T$ 中作为子串出现了多少次。

利用后缀自动机的树形结构，进行 dfs 即可预处理每个节点的终点集合大小。在自动机上查找模式串 $P$ 对应的节点，如果存在，则答案就是该节点的终点集合大小；如果不存在，则答案为 $0$ .

以下为原方法：

> 对文本串 $T$ 构造后缀自动机。
>
> 接下来做预处理：对于自动机中的每个状态 $v$ ，预处理 $cnt_{v}$ ，使之等于 $endpos(v)$ 集合的大小。事实上，对应同一状态 $v$ 的所有子串在文本串 $T$ 中的出现次数相同，这相当于集合 $endpos$ 中的位置数。
>
> 然而我们不能明确的构造集合 $endpos$ ，因此我们只考虑它们的大小 $cnt$ 。
>
> 为了计算这些值，我们进行以下操作。对于每个状态，如果它不是通过复制创建的（且它不是初始状态 $t_0$ ），我们将它的 $cnt$ 初始化为 1。然后我们按它们的长度 $len$ 降序遍历所有状态，并将当前的 $cnt_{v}$ 的值加到后缀链接指向的状态上，即：
>
> $$
> cnt_{link(v)}+=cnt_{v}
> $$
>
> 这样做每个状态的答案都是正确的。
>
> 为什么这是正确的？不是通过复制获得的状态，恰好有 $\left|T\right|$ 个，并且它们中的前 $i$ 个在我们插入前 $i$ 个字符时产生。因此对于每个这样的状态，我们在它被处理时计算它们所对应的位置的数量。因此我们初始将这些状态的 $cnt$ 的值赋为 $1$ ，其它状态的 $cnt$ 值赋为 $0$ 。
>
> 接下来我们对每一个 $v$ 执行以下操作： $cnt_{link(v)}+=cnt_{v}$ 。其背后的含义是，如果有一个字符串 $v$ 出现了 $cnt_{v}$ 次，那么它的所有后缀也在完全相同的地方结束，即也出现了 $cnt_{v}$ 次。
>
> 为什么我们在这个过程中不会重复计数（即把某些位置数了两次）呢？因为我们只将一个状态的位置添加到 **一个** 其它的状态上，所以一个状态不可能以两种不同的方式将其位置重复地指向另一个状态。
>
> 因此，我们可以在 $O(\left|T\right|)$ 的时间内计算出所有状态的 $cnt$ 的值。
>
> 最后回答询问只需要查找值 $cnt_{t}$ ，其中 $t$ 为模式串对应的状态，如果该模式串不存在答案就为 $0$ 。单次查询的时间复杂度为 $O(\left|P\right|)$ 。

### 第一次出现的位置

> 给定一个文本串 $T$ ，多组查询。每次查询字符串 $P$ 在字符串 $T$ 中第一次出现的位置（ $P$ 的开头位置）。

我们构造一个后缀自动机。我们对 SAM 中的所有状态预处理位置 $firstpos$ 。即，对每个状态 $v$ 我们想要找到第一次出现这个状态的末端的位置 $firstpos[v]$ 。换句话说，我们希望先找到每个集合 $endpos$ 中的最小的元素（显然我们不能显式地维护所有 $endpos$ 集合）。

为了维护 $firstpos$ 这些位置，我们将原函数扩展为 `sam_extend()` 。当我们创建新状态 $cur$ 时，我们令：

$$
firstpos(cur)=len(cur)-1
$$

；当我们将结点 $q$ 复制到 $clone$ 时，我们令：

$$
firstpos(clone)=firstpos(q)
$$

（因为值的唯一的其它选项 $firstpos(cur)$ 显然太大了）。

那么查询的答案就是 $firstpos(t)-\left|P\right|+1$ ，其中 $t$ 为对应字符串 $P$ 的状态。单次查询只需要 $O(\left|P\right|)$ 的时间。

### 所有出现的位置

> 问题同上，这一次需要查询文本串 $T$ 中模式串出现的所有位置。

利用后缀自动机的树形结构，遍历子树，一旦发现终点节点就输出。

以下为原解法：

> 我们还是对文本串 $T$ 构造后缀自动机。与上一个问题相似，我们为所有状态计算位置 $firstpos$ 。
>
> 如果 $t$ 为对应于模式串 $T$ 的状态，显然 $firstpos(t)$ 为答案的一部分。需要查找的其它位置怎么办？我们使用了含有字符串 $P$ 的自动机，我们还需要将哪些状态纳入自动机呢？所有对应于以 $P$ 为后缀的字符串的状态。换句话说我们要找到所有可以通过后缀链接到达状态 $t$ 的状态。
>
> 因此为了解决这个问题，我们需要为每一个状态保存一个指向它的后缀引用列表。查询的答案就包含了对于每个我们能从状态 $t$ 只使用后缀引用进行 DFS 或 BFS 的所有状态的 $firstpos$ 值。
>
> 这种变通方案的时间复杂度为 $O(answer(P))$ ，因为我们不会重复访问一个状态（因为对于仅有一个后缀链接指向一个状态，所以不存在两条不同的路径指向同一状态）。
>
> 我们只需要考虑两个可能有相同 $endpos$ 值的不同状态。如果一个状态是由另一个复制而来的，则这种情况会发生。然而，这并不会对复杂度分析造成影响，因为每个状态至多被复制一次。
>
> 此外，如果我们不从被复制的节点输出位置，我们也可以去除重复的位置。事实上对于一个状态，如果经过被复制状态可以到达，则经过原状态也可以到达。因此，如果我们给每个状态记录标记 `is_clone` 来代表这个状态是不是被复制出来的，我们就可以简单地忽略掉被复制的状态，只输出其它所有状态的 $firstpos$ 的值。
>
> 以下是大致的实现：
>
> ```cpp
> struct state {
>   bool is_clone;
>   int first_pos;
>   std::vector<int> inv_link;
>   // some other variables
> };
>
> // 在构造 SAM 后
> for (int v = 1; v < sz; v++) st[st[v].link].inv_link.push_back(v);
>
> // 输出所有出现位置
> void output_all_occurrences(int v, int P_length) {
>   if (/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!st[v].is_clone) cout << st[v].first_pos - P_length + 1 << endl;
>   for (int u : st[v].inv_link) output_all_occurrences(u, P_length);
> }
> ```

### 最短的没有出现的字符串

> 给定一个字符串 $S$ 和一个特定的字符集，我们要找一个长度最短的没有在 $S$ 中出现过的字符串。

我们在字符串 $S$ 的后缀自动机上做动态规划。

令 $d_{v}$ 为节点 $v$ 的答案，即，我们已经处理完了子串的一部分，当前在状态 $v$ ，想找到不连续的转移需要添加的最小字符数量。计算 $d_{v}$ 非常简单。如果不存在使用字符集中至少一个字符的转移，则 $d_{v}=1$ 。否则添加一个字符是不够的，我们需要求出所有转移中的最小值：

$$
d_{v}=1+\min_{w:(v,w,c)\in SAM}d_{w}
$$

问题的答案就是 $d_{t_0}$ ，字符串可以通过计算过的数组 $d$ 逆推回去。

### 两个字符串的最长公共子串

> 给定两个字符串 $S$ 和 $T$ ，求出最长公共子串，公共子串定义为在 $S$ 和 $T$ 中都作为子串出现过的字符串 $X$ 。

我们对字符串 $S$ 构造后缀自动机。

我们现在处理字符串 $T$ ，对于每一个前缀，都在 $S$ 中寻找这个前缀的最长后缀。换句话说，对于每个字符串 $T$ 中的位置，我们想要找到这个位置结束的 $S$ 和 $T$ 的最长公共子串的长度。显然问题的答案就是所有 $l$ 的最大值。

为了达到这一目的，我们使用两个变量， **当前状态**  $v$ 和 **当前长度**  $l$ 。这两个变量描述当前匹配的部分：它的长度和它们对应的状态。

一开始 $v=t_0$ 且 $l=0$ ，即，匹配为空串。

现在我们来描述如何添加一个字符 $T_{i}$ 并为其重新计算答案：

-   如果存在一个从 $v$ 到字符 $T_{i}$ 的转移，我们只需要转移并让 $l$ 自增一。
-   如果不存在这样的转移，我们需要缩短当前匹配的部分，这意味着我们需要按照后缀链接进行转移：

$$
v=link(v)
$$

与此同时，需要缩短当前长度。显然我们需要将 $l$ 赋值为 $len(v)$ ，因为经过这个后缀链接后我们到达的状态所对应的最长字符串是一个子串。

-   如果仍然没有使用这一字符的转移，我们继续重复经过后缀链接并减小 $l$ ，直到我们找到一个转移或到达虚拟状态 $-1$ （这意味着字符 $T_{i}$ 根本没有在 $S$ 中出现过，所以我们设置 $v=l=0$ ）。

这一部分的时间复杂度为 $O(\left|T\right|)$ ，因为每次移动我们要么可以使 $l$ 增加一，要么可以在后缀链接间移动几次，每次都减小 $l$ 的值。

代码实现：

```cpp
string lcs(const string &S, const string &T) {
  sam_init();
  for (int i = 0; i < S.size(); i++) sam_extend(S[i]);

  int v = 0, l = 0, best = 0, bestpos = 0;
  for (int i = 0; i < T.size(); i++) {
    while (v && /home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!st[v].next.count(T[i])) {
      v = st[v].link;
      l = st[v].length;
    }
    if (st[v].next.count(T[i])) {
      v = st[v].next[T[i]];
      l++;
    }
    if (l > best) {
      best = l;
      bestpos = i;
    }
  }
  return t.substr(bestpos - best + 1, best);
}
```

例题： [SPOJ Longest Common Substring](https://www.spoj.com/problems/LCS/en/) 

### 多个字符串间的最长公共子串

> 给定 $k$ 个字符串 $S_i$ 。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串 $X$ 。

我们将所有的子串连接成一个较长的字符串 $T$ ，以特殊字符 $D_i$ 分开每个字符串（一个字符对应一个字符串）：

$$
T=S_1+D_1+S_2+D_2+\cdots+S_k+D_k.
$$

然后对字符串 $T$ 构造后缀自动机。

现在我们需要在自动机中找到存在于所有字符串 $S_i$ 中的一个字符串，这可以通过使用添加的特殊字符完成。注意如果 $S_j$ 包含了一个子串，则 SAM 中存在一条从包含字符 $D_j$ 的子串而不包含以其它字符 $D_1,\,\ldots,\,D_{j-1},\,D_{j+1},\,\ldots,\,D_k$ 开始的路径。

因此我们需要计算可达性，即对于自动机中的每个状态和每个字符 $D_i$ ，是否存在这样的一条路径。这可以容易地通过 DFS 或 BFS 及动态规划计算。之后，问题的答案就是状态 $v$ 的字符串 $longest(v)$ 中存在所有特殊字符的路径。

例题： [SPOJ Longest Common Substring II](https://www.spoj.com/problems/LCS2/) 

## 例题

-    [HihoCoder #1441 : 后缀自动机一·基本概念](http://hihocoder.com/problemset/problem/1441) 
-    [【模板】后缀自动机](https://www.luogu.org/problem/P3804) 
-    [SDOI2016 生成魔咒](https://loj.ac/problem/2033) 
-    [SPOJ - SUBLEX](https://www.spoj.com/problems/SUBLEX/) 
-    [TJOI2015 弦论](https://loj.ac/problem/2102) 
-    [SPOJ Longest Common Substring](https://www.spoj.com/problems/LCS/en/) 
-    [SPOJ Longest Common Substring II](https://www.spoj.com/problems/LCS2/) 
-    [Codeforces 1037H Security](https://codeforces.com/problemset/problem/1037/H) 
-    [Codeforces 666E Forensic Examination](https://codeforces.com/problemset/problem/666/E) 
-    [HDu4416 Good Article Good sentence](http://acm.hdu.edu.cn/showproblem.php?pid=4416) 
-    [HDu4436 str2int](http://acm.hdu.edu.cn/showproblem.php?pid=4436) 
-    [HDu6583 Typewriter](http://acm.hdu.edu.cn/showproblem.php?pid=6583) 
-    [Codeforces 235C Cyclical Quest](https://codeforces.com/problemset/problem/235/C) 
-    [CTSC2012 熟悉的文章](https://www.luogu.org/problem/P4022) 
-    [NOI2018 你的名字](https://uoj.ac/problem/395) 

## 相关资料

我们先给出与 SAM 有关的最初的一些文献：

-   A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. **Linear 
      Size Finite Automata for the Set of All Subwords of a Word. An Outline of 
      Results** [1983]
-   A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. **The Smallest Automaton 
      Recognizing the Subwords of a Text** [1984]
-   Maxime Crochemore. **Optimal Factor Transducers** [1985]
-   Maxime Crochemore. **Transducers and Repetitions** [1986]
-   A. Nerode. **Linear automaton transformations** [1958]

另外，在更新的一些资源以及很多关于字符串算法的书中，都能找到这个主题：

-   Maxime Crochemore, Rytter Wowjcieh. **Jewels of Stringology** [2002]
-   Bill Smyth. **Computing Patterns in Strings** [2003]
-   Bill Smith. **Methods and algorithms of calculations on lines** [2006]

另外，还有一些资料：

-   《后缀自动机》，陈立杰。
-   《后缀自动机在字典树上的拓展》，刘研绎。
-   《后缀自动机及其应用》，张天扬。
-    <https://www.cnblogs.com/zinthos/p/3899679.html> 
-    <https://codeforces.com/blog/entry/20861> 
-    <https://zhuanlan.zhihu.com/p/25948077> 

* * *

 **本页面主要译自博文 [Суффиксный автомат](http://e-maxx.ru/algo/suffix_automata) 与其英文翻译版 [Suffix Automaton](https://cp-algorithms.com/string/suffix-automaton.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# z-func
author: LeoJacob, TrisolarisHD

假设我们有一个长度为 $n$ 的字符串 $s$ 。该字符串的 **Z 函数** 为一个长度为 $n$ 的数组，其中第 $i$ 个元素为满足从位置 $i$ 开始且为 $s$ 前缀的字符串的最大长度。

换句话说， $z[i]$ 是 $s$ 和从 $i$ 开始的 $s$ 的后缀的最大公共前缀长度。

 **注意** ：为了避免歧义，在这篇文章中下标从 $0$ 开始，即 $s$ 的第一个字符下标为 $0$ ，最后一个字符下标为 $n - 1$ 。

Z 函数的第一个元素， $z[0]$ ，通常不是良定义的。在这篇文章中我们假定它是 $0$ （虽然在算法实现中这没有任何影响）。

国外一般将计算该数组的算法称为 **Z Algorithm** ，而国内则称其为 **扩展 KMP** 。

这篇文章包含在 $O(n)$ 时间复杂度内计算 Z 函数的算法以及其各种应用。

## 样例

下面若干样例展示了对于不同字符串的 Z 函数：

-    $Z(\mathtt{aaaaa}) = [0, 4, 3, 2, 1]$ 
-    $Z(\mathtt{aaabaab}) = [0, 2, 1, 0, 2, 1, 0]$ 
-    $Z(\mathtt{abacaba}) = [0, 0, 1, 0, 3, 0, 1]$ 

## 朴素算法

Z 函数的形式化定义可被表述为下列基础的 $O(n^2)$ 实现。

```cpp
vector<int> z_function_trivial(string s) {
  int n = (int)s.length();
  vector<int> z(n);
  for (int i = 1; i < n; ++i)
    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
  return z;
}
```

我们做的仅仅为循环每个位置 $i$ ，并通过下述做法更新每个 $z[i]$ ：从 $z[i] = 0$ 开始，只要我们没有失配（并且没有到达末尾）就将其加 $1$ 。

诚然，这并不是一个高效的实现。我们接下来将展示一个高效实现的构造过程。

## 计算 Z 函数的高效算法

为了得到一个高效算法，我们将以 $i = 1$ 到 $n - 1$ 的顺序计算 $z[i]$ ，但在计算一个新值的同时，我们将尝试尽最大努力使用之前已经计算好的值。

为了简便起见，定义 **匹配段** 为同 $s$ 一个前缀相同的那些子串。举例来说，所求 Z 函数的第 $i$ 个元素 $z[i]$ 为从位置 $i$ 开始的匹配段的长度（其终止位置位于 $i + z[i] - 1$ ）。

为了达成目标，我们将始终保持 ** $[l;r]$ 为最靠右的匹配段** 。也就是说，在所有已探测到的匹配段中，我们将保持结尾最靠右的那一个。另一方面，下标 $r$ 可被认为是字符串 $s$ 已被算法扫描的边界；任何超过该点的字符都是未知的。

假设当前下标为 $i$ （即我们要计算的下一个 Z 函数值的下标），则有两种情况：

-    $i > r$ -- 当前位置在我们已处理位置 **之外** 。

    我们接下来使用 **朴素算法** （即一个一个的比较字符）来计算 $z[i]$ 。注意如果最后 $z[i] > 0$ ，我们需要更新最靠右的匹配段的下标，因为新的 $r = i + z[i] - 1$ 一定比之前的 $r$ 优。

-    $i \le r$ -- 当前位置位于当前匹配段 $[l;r]$ 之内。

    那么我们可以用已计算过的 Z 函数值来“初始化” $z[i]$ 至某值（至少比“从零开始”要好），甚至可能是某些较大的值。

    为了做到这一点，我们注意到子串 $s[l\dots r]$ 和 $s[0 \dots r - l]$ 匹配。这意味着作为 $z[i]$ 的一个初始近似，我们可以直接使用对应于段 $s[0 \dots r - l]$ 的已计算过的 Z 函数值，也即 $z[i - l]$ 。

    然而， $z[i - l]$ 可能太大了：将其应用到位置 $i$ 结果可能超过下标 $r$ 。这种做法并不合法，原因在于我们对 $r$ 右侧的字符一无所知：他们可能并不满足要求。

    此处给出一个相似场景的 **例子** ：

    $$
    s=\mathtt{aaaabaa}
    $$

    当我们尝试计算末尾位置（ $i = 6$ ）的值时，当前匹配的段为 $[5;6]$ 。位置 $6$ 会匹配位置 $6 - 5 = 1$ ，其 Z 函数值为 $z[1] = 3$ 。显然，我们不能将 $z[6]$ 初始化为 $3$ ，因为这完全不对。我们可以初始化的最大值为 $1$ -- 因为这是使我们不超过段 $[l;r]$ 的边界 $r$ 的最大可能取值。

    因此，我们可以放心的将下列值作为 $z[i]$ 的一个初始近似：

    $$
    z_0[i] = \min(r - i + 1, z[i - l])
    $$

    当将 $z[i]$ 初始化为 $z_0[i]$ 后，我们尝试使用 **朴素算法** 增加 $z[i]$ 的值 -- 因为宏观来讲，对于边界 $r$ 之后的事情，我们无法得知段是否会继续匹配还是失配。

综上所述，整个算法被划分成两种情况，他们只在设置 $z[i]$ 的 **初始值** 时有所不同：在第一种情况下，其被认为为 $0$ ，在第二种情况下它由先前已计算过的值确定（使用前述公式）。之后，该算法的两个分支都被规约为实现 **朴素算法** 。当我们设置完初始值后，该算法即开始执行。

该算法看起来非常简单。尽管在每轮迭代都会运行朴素算法，但我们已经取得了巨大进步：获得了一个时间复杂度为线性的算法。之后我们会证明这一点。

## 实现

实现相对来说十分简明：

```cpp
vector<int> z_function(string s) {
  int n = (int)s.length();
  vector<int> z(n);
  for (int i = 1, l = 0, r = 0; i < n; ++i) {
    if (i <= r) z[i] = min(r - i + 1, z[i - l]);
    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
    if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
  }
  return z;
}
```

### 对该实现的注释

整个解法被作为一个函数给出。该函数返回一个长度为 $n$ 的数组 -- $s$ 的 Z 函数。

数组 $z$ 被初始化为全 $0$ 。当前最右的匹配段被假定为 $[0;0]$ （一个故意为之的不包含任何 $i$ 的小段）。

在循环内，对于 $i=1\dots n - 1$ ，我们首先确定 $z[i]$ 的初始值 -- 其要么保持为 $0$ 或者使用前述公式计算。

之后，朴素算法尝试尽可能多的增加 $z[i]$ 值。

最后，如果必要（即如果 $i + z[i] - 1 > r$ ），我们更新最右匹配段 $[l;r]$ 。

## 算法的渐进行为

我们将证明上述算法的运行时间关于字符串长度呈线性 -- 即其时间复杂度为 $O(n)$ 。

该证明十分简单。

我们只关心内层 `while` 循环，因为其余部分在一次循环中只是一堆常数次操作，其时间复杂度总和为 $O(n)$ 。

我们将证明 `while` 的 **每次迭代** 都将增加匹配段的右边界 $r$ 。

为了做到这一点，我们将考虑算法的所有分支：

-    $i > r$ 

    在这种情况下，要么 `while` 循环不进行任何迭代（如果 $s[0] \neq s[i]$ ），要么其将从位置 $i$ 开始进行若干次迭代，其中每次迭代将向右移动一个字符。每次迭代后，右边界 $r$ 必定被更新。

    因此我们证明了，当 $i > r$ 时， `while` 循环的每轮迭代都会使新的 $r$ 增加 $1$ 。

-    $i \le r$ 

    在这种情况下，我们将 $z[i]$ 初始化为由前述公式给出的某个具体 $z_0$ 。将 $z_0$ 和 $r - i + 1$ 比较，可能有三种情况：

    -    $z_0 < r - i + 1$ 

        我们证明在这种情况下 `while` 循环不会进行任何迭代。

        这是十分容易证明的，比如通过反证法：如果 `while` 循环进行了至少一次迭代，这意味着初始近似 $z[i] = z_0$ 是不准确的（小于匹配的实际长度）。但是由于 $s[l\dots r]$ 和 $s[0\dots r - l]$ 是一样的，这推出 $z[i - l]$ 的值是错误的（比其该有的值小）。

        所以，因为 $z[i - l]$ 是正确的且其值小于 $r - i + 1$ ，故该值同所求的 $z[i]$ 是相同的。

    -    $z_0 = r - i + 1$ 

        在这种情况下， `while` 循环可能会进行若干次迭代。因为我们从 $s[r + 1]$ 开始比较，而其位置已经超过了区间 $[l;r]$ ，故每次迭代都会使 $r$ 增加。

    -    $z_0 > r - i + 1$ 

        根据 $z_0$ 的定义，这种情况是不可能的。

综上，我们已经证明了内层循环的每次迭代都会使 $r$ 向右移动。由于 $r$ 不可能超过 $n - 1$ ，这意味着内层循环至多进行 $n - 1$ 轮迭代。

因为该算法的剩余部分显然时间复杂度为 $O(n)$ ，所以我们已经证明了计算 Z 函数的整个算法时间复杂度为线性。

## 应用

我们现在来考虑在若干具体情况下 Z 函数的应用。

这些应用在很大程度上同 [前缀函数](./kmp.md) 的应用类似。

### 查找子串

为了避免混淆，我们将 $t$ 称作 **文本** ，将 $p$ 称作 **模式** 。所给出的问题是：寻找在文本 $t$ 中模式 $p$ 的所有出现（occurrence）。

为了解决该问题，我们构造一个新的字符串 $s = p + \diamond + t$ ，也即我们将 $p$ 和 $t$ 连接在一起，但是在中间放置了一个分割字符 $\diamond$ （我们将如此选取 $\diamond$ 使得其必定不出现在 $p$ 和 $t$ 中）。

首先计算 $s$ 的 Z 函数。接下来，对于在区间 $[0; \operatorname{length}(t) - 1]$ 中的任意 $i$ ，我们考虑其对应的值 $k = z[i + \operatorname{length}(p) + 1]$ 。如果 $k$ 等于 $\operatorname{length}(p)$ ，那么我们知道有一个 $p$ 的出现位于 $t$ 的第 $i$ 个位置，否则没有 $p$ 的出现位于 $t$ 的第 $i$ 个位置。

其时间复杂度（同时也是其空间复杂度）为 $O(\operatorname{length}(t) + \operatorname{length}(p))$ 。

### 一个字符串中本质不同子串的数目

给定一个长度为 $n$ 的字符串 $s$ ，计算 $s$ 的本质不同子串的数目。

我们将迭代的解决该问题。也即：在知道了当前的本质不同子串的数目的情况下，在 $s$ 末尾添加一个字符后重新计算该数目。

令 $k$ 为当前 $s$ 的本质不同子串数量。我们添加一个新的字符 $c$ 至 $s$ 。显然，会有一些新的子串以新的字符 $c$ 结尾（换句话说，那些以该字符结尾且我们之前未曾遇到的子串）。

构造字符串 $t = s + c$ 并将其反转（以相反顺序书写其字符）。我们现在的任务是计算有多少 $t$ 的前缀未在 $t$ 的其余任何地方出现。让我们计算 $t$ 的 Z 函数并找到其最大值 $z_{\max}$ 。显然， $t$ 的长度为 $z_{\max}$ 的前缀出现在 $t$ 中间的某个位置。自然的，更短的前缀也出现了。

所以，我们已经找到了当将字符 $c$ 添加至 $s$ 后新出现的子串数目为 $\operatorname{length}(t) - z_{\max}$ 。

作为其结果，该解法对于一个长度为 $n$ 的字符串的时间复杂度为 $O(n^2)$ 。

值得注意的是，我们可以用同样的方法在 $O(n)$ 时间内，重新计算在头部添加一个字符，或者移除一个字符（从尾或者头）时的本质不同子串数目。

### 字符串压缩

给定一个长度为 $n$ 的字符串 $s$ ，找到其最短的“压缩”表示，即：寻找一个最短的字符串 $t$ ，使得 $s$ 可以被 $t$ 的一份或多份拷贝的拼接表示。

其中一种解法为：计算 $s$ 的 Z 函数，从小到大循环所有满足 $i$ 整除 $n$ 的 $i$ 。在找到第一个满足 $i + z[i] = n$ 的 $i$ 时终止。那么该字符串 $s$ 可被压缩为长度 $i$ 的字符串。

该事实的证明同应用 [前缀函数](./kmp.md) 的解法证明一样。

## 练习题目

-    [CF126B Password](http://codeforces.com/problemset/problem/126/B) 
-    [UVA # 455 Periodic Strings](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=396) 
-    [UVA # 11022 String Factoring](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1963) 
-    [UVa 11475 - Extend to Palindrome](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=2470) 
-    [LA 6439 - Pasti Pas!](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&category=588&page=show_problem&problem=4450) 
-    [Codechef - Chef and Strings](https://www.codechef.com/problems/CHSTR) 
-    [Codeforces - Prefixes and Suffixes](http://codeforces.com/problemset/problem/432/D) 

* * *

 **本页面主要译自博文 [Z-функция строки и её вычисление](http://e-maxx.ru/algo/z_function) 与其英文翻译版 [Z-function and its calculation](https://cp-algorithms.com/string/z-function.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# trie
字典树，英文名 Trie。顾名思义，就是一个像字典一样的树。

## 简介

先放一张图：

![trie1](./images/trie1.png)

可以发现，这棵字典树用边来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串。举个例子， $1\to4\to 8\to 12$ 表示的就是字符串 `caa` 。

Trie 的结构非常好懂，我们用 $\delta(u,c)$ 表示结点 $u$ 的 $c$ 字符指向的下一个结点，或着说是结点 $u$ 代表的字符串后面添加一个字符 $c$ 形成的字符串的结点。（ $c$ 的取值范围和字符集大小有关，不一定是 $0\sim 26$ 。）

有时需要标记插入进 Trie 的是哪些字符串，每次插入完成时在这个字符串所代表的节点处打上标记即可。

## 代码实现

放一个结构体封装的模板：

```cpp
struct trie {
  int nex[100000][26], cnt;
  bool exist[100000];  // 该结点结尾的字符串是否存在

  void insert(char *s, int l) {  // 插入字符串
    int p = 0;
    for (int i = 0; i < l; i++) {
      int c = s[i] - 'a';
      if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点
      p = nex[p][c];
    }
    exist[p] = 1;
  }
  bool find(char *s, int l) {  // 查找字符串
    int p = 0;
    for (int i = 0; i < l; i++) {
      int c = s[i] - 'a';
      if (!nex[p][c]) return 0;
      p = nex[p][c];
    }
    return exist[p];
  }
};
```

## 应用

### 检索字符串

字典树最基础的应用——查找一个字符串是否在“字典”中出现过。

???+note "[于是他错误的点名开始了](https://www.luogu.org/problemnew/show/P2580)"
    给你 $n$ 个名字串，然后进行 $m$ 次点名，每次你需要回答“名字不存在”、“第一次点到这个名字”、“已经点过这个名字”之一。

    $1\le n\le 10^4$, $1\le m\le 10^5$，所有字符串长度不超过 $50$。

    ??? mdui-shadow-6 "题解"
        对所有名字建 Trie，再在 Trie 中查询字符串是否存在、是否已经点过名，第一次点名时标记为点过名。

    ??? mdui-shadow-6 "参考代码"
        ```cpp
        #include <cstdio>
        
        const int N = 500010;
        
        char s[60];
        int n, m, ch[N][26], tag[N], tot = 1;
        
        int main() {
          scanf("%d", &n);
        
          for (int i = 1; i <= n; ++i) {
            scanf("%s", s + 1);
            int u = 1;
            for (int j = 1; s[j]; ++j) {
              int c = s[j] - 'a';
              if (!ch[u][c]) ch[u][c] = ++tot;
              u = ch[u][c];
            }
            tag[u] = 1;
          }
        
          scanf("%d", &m);
        
          while (m--) {
            scanf("%s", s + 1);
            int u = 1;
            for (int j = 1; s[j]; ++j) {
              int c = s[j] - 'a';
              u = ch[u][c];
              if (!u) break;  // 不存在对应字符的出边说明名字不存在
            }
            if (tag[u] == 1) {
              tag[u] = 2;
              puts("OK");
            } else if (tag[u] == 2)
              puts("REPEAT");
            else
              puts("WRONG");
          }
        
          return 0;
        }
        ```

### AC 自动机

Trie 是 [AC 自动机](./ac-automaton.md) 的一部分。

### 异或相关

将数的二进制表示看做一个字符串，就可以建出字符集为 $\{0,1\}$ 的 Trie 树。

???+note "[BZOJ1954 最长异或路径](https://www.luogu.org/problem/P4551)"
    给你一棵带边权的树，求 $(u, v)$ 使得 $u$ 到 $v$ 的路径上的边权异或和最大，输出这个最大值。

    点数不超过 $10^5$，边权在 $[0,2^{31})$ 内。

    ??? mdui-shadow-6 "题解"
        随便指定一个根 $root$ ，用 $T(u, v)$ 表示 $u$ 和 $v$ 之间的路径的边权异或和，那么 $T(u,v)=T(root, u)\oplus T(root,v)$ ，因为 [LCA](../graph/lca.md) 以上的部分异或两次抵消了。

        那么，如果将所有 $T(root, u)$ 插入到一棵 Trie 中，就可以对每个 $T(root, u)$ 快速求出和它异或和最大的 $T(root, v)$ ：

        从 Trie 的根开始，如果能向和 $T(root, u)$ 的当前位不同的子树走，就向那边走，否则没有选择。

        贪心的正确性：如果这么走，这一位为 $1$ ；如果不这么走，这一位就会为 $0$ 。而高位是需要优先尽量大的。

    ??? mdui-shadow-6 "参考代码"
        ```cpp
        #include <algorithm>
        #include <cstdio>
        
        const int N = 100010;
        
        int head[N], nxt[N << 1], to[N << 1], weight[N << 1], cnt;
        int n, dis[N], ch[N << 5][2], tot = 1, ans;
        
        void insert(int x) {
          for (int i = 30, u = 1; i >= 0; --i) {
            int c = ((x >> i) & 1);
            if (!ch[u][c]) ch[u][c] = ++tot;
            u = ch[u][c];
          }
        }
        
        void get(int x) {
          int res = 0;
          for (int i = 30, u = 1; i >= 0; --i) {
            int c = ((x >> i) & 1);
            if (ch[u][c ^ 1]) {
              u = ch[u][c ^ 1];
              res |= (1 << i);
            } else
              u = ch[u][c];
          }
          ans = std::max(ans, res);
        }
        
        void add(int u, int v, int w) {
          nxt[++cnt] = head[u];
          head[u] = cnt;
          to[cnt] = v;
          weight[cnt] = w;
        }
        
        void dfs(int u, int fa) {
          insert(dis[u]);
          get(dis[u]);
          for (int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if (v == fa) continue;
            dis[v] = dis[u] ^ weight[i];
            dfs(v, u);
          }
        }
        
        int main() {
          scanf("%d", &n);
        
          for (int i = 1; i < n; ++i) {
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            add(u, v, w);
            add(v, u, w);
          }
        
          dfs(1, 0);
        
          printf("%d", ans);
        
          return 0;
        }
        ```

### 可持久化字典树

参见 [可持久化字典树](../ds/persistent-trie.md) 。

# ac-automaton
我知道，很多人在第一次看到这个东西的时侯是非常兴奋的。（别问我为什么知道）不过这个自动机啊它叫作 `Automaton` ，不是 `Automation` ，让萌新失望啦。切入正题。似乎在初学自动机相关的内容时，许多人难以建立对自动机的初步印象，尤其是在自学的时侯。而这篇文章就是为你们打造的。笔者在自学 AC 自动机后花费两天时间制作若干的 gif，呈现出一个相对直观的自动机形态。尽管这个图似乎不太可读，但这绝对是在作者自学的时侯，画得最~~妙不可读~~的 gif 了。另外有些小伙伴问这个 gif 拿什么画的。笔者用 Windows 画图软件制作。

## 概述

AC 自动机是 **以 TRIE 的结构为基础** ，结合 **KMP 的思想** 建立的。

简单来说，建立一个 AC 自动机有两个步骤：

1.  基础的 TRIE 结构：将所有的模式串构成一棵 $Trie$ 。
2.  KMP 的思想：对 $Trie$ 树上所有的结点构造失配指针。

然后就可以利用它进行多模式匹配了。

## 字典树构建

AC 自动机在初始时会将若干个模式串丢到一个 TRIE 里，然后在 TRIE 上建立 AC 自动机。这个 TRIE 就是普通的 TRIE，该怎么建怎么建。

这里需要仔细解释一下 TRIE 的结点的含义，尽管这很小儿科，但在之后的理解中极其重要。TRIE 中的结点表示的是某个模式串的前缀。我们在后文也将其称作状态。一个结点表示一个状态，TRIE 的边就是状态的转移。

形式化地说，对于若干个模式串 $s_1,s_2\dots s_n$ ，将它们构建一棵字典树后的所有状态的集合记作 $Q$ 。

## 失配指针

AC 自动机利用一个 fail 指针来辅助多模式串的匹配。

状态 $u$ 的 fail 指针指向另一个状态 $v$ ，其中 $v\in Q$ ，且 $v$ 是 $u$ 的最长后缀（即在若干个后缀状态中取最长的一个作为 fail 指针）。对于学过 KMP 的朋友，我在这里简单对比一下这里的 fail 指针与 KMP 中的 next 指针：

1.  共同点：两者同样是在失配的时候用于跳转的指针。
2.  不同点：next 指针求的是最长 Border（即最长的相同前后缀），而 fail 指针指向所有模式串的前缀中匹配当前状态的最长后缀。

因为 KMP 只对一个模式串做匹配，而 AC 自动机要对多个模式串做匹配。有可能 fail 指针指向的结点对应着另一个模式串，两者前缀不同。

没看懂上面的对比不要急（也许我的脑回路和泥萌不一样是吧），你只需要知道，AC 自动机的失配指针指向当前状态的最长后缀状态即可。

AC 自动机在做匹配时，同一位上可匹配多个模式串。

### 构建指针

下面介绍构建 fail 指针的 **基础思想** ：（强调！基础思想！基础！）

构建 fail 指针，可以参考 KMP 中构造 Next 指针的思想。

考虑字典树中当前的结点 $u$ ， $u$ 的父结点是 $p$ ， $p$ 通过字符 `c` 的边指向 $u$ ，即 $trie[p,c]=u$ 。假设深度小于 $u$ 的所有结点的 fail 指针都已求得。

1.  如果 $trie[fail[p],c]$ 存在：则让 u 的 fail 指针指向 $trie[fail[p],c]$ 。相当于在 $p$ 和 $fail[p]$ 后面加一个字符 `c` ，分别对应 $u$ 和 $fail[u]$ 。
2.  如果 $trie[fail[p],c]$ 不存在：那么我们继续找到 $trie[fail[fail[p]],c]$ 。重复 1 的判断过程，一直跳 fail 指针直到根结点。
3.  如果真的没有，就让 fail 指针指向根结点。

如此即完成了 $fail[u]$ 的构建。

### 例子

下面放一张 GIF 帮助大家理解。对字符串 `i`  `he`  `his`  `she`  `hers` 组成的字典树构建 fail 指针：

1.  黄色结点：当前的结点 $u$ 。
2.  绿色结点：表示已经 BFS 遍历完毕的结点，
3.  橙色的边：fail 指针。
4.  红色的边：当前求出的 fail 指针。

![AC_automation_gif_b_3.gif](./images/ac-automaton1.gif)

我们重点分析结点 6 的 fail 指针构建：

![AC_automation_6_9.png](./images/ac-automaton1.png)

找到 6 的父结点 5， $fail[5]=10$ 。然而 10 结点没有字母 `s` 连出的边；继续跳到 10 的 fail 指针， $fail[10]=0$ 。发现 0 结点有字母 `s` 连出的边，指向 7 结点；所以 $fail[6]=7$ 。最后放一张建出来的图

![finish](./images/ac-automaton4.png)

## 字典树与字典图

我们直接上代码吧。字典树插入的代码就不分析了（后面完整代码里有），先来看构建函数 `build()` ，该函数的目标有两个，一个是构建 fail 指针，一个是构建自动机。参数如下：

1.   `tr[u,c]` 这个有两种理解方式。我们可以简单理解为字典树上的一条边，即 $trie[u,c]$ ；也可以理解为从状态（结点） $u$ 后加一个字符 `c` 到达的状态（结点），即一个状态转移函数 $trans(u,c)$ 。下文中我们将用第二种理解方式继续讲解。
2.   `q` 队列，用于 BFS 遍历字典树。
3.   `fail[u]` 结点 $u$ 的 fail 指针。

```cpp
void build() {
  for (int i = 0; i < 26; i++)
    if (tr[0][i]) q.push(tr[0][i]);
  while (q.size()) {
    int u = q.front();
    q.pop();
    for (int i = 0; i < 26; i++) {
      if (tr[u][i])
        fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);
      else
        tr[u][i] = tr[fail[u]][i];
    }
  }
}
```

为~~关爱萌新~~，笔者大力~~复读~~一下代码：Build 函数将结点按 BFS 顺序入队，依次求 fail 指针。这里的字典树根结点为 0，我们将根结点的子结点一一入队。若将根结点入队，则在第一次 BFS 的时候，会将根结点儿子的 fail 指针标记为本身。因此我们将根结点的儿子一一入队，而不是将根结点入队。

然后开始 BFS：每次取出队首的结点 u。fail[u]指针已经求得，我们要求 u 的子结点们的 fail 指针。然后遍历字符集（这里是 0-25，对应 a-z）：

1.  如果 $trans(u,i)$ 存在，我们就将 $trans(u,i)$ 的 fail 指针赋值为 $trans(fail[u],i)$ 。这里似乎有一个问题。根据之前的讲解，我们应该用 while 循环，不停的跳 fail 指针，判断是否存在字符 `i` 对应的结点，然后赋值。不过在代码中我们一句话就做完这件事了。
2.  否则， $trans(u,i)$ 不存在，就让 $trans(u,i)$ 指向 $trans(fail[u],i)$ 的状态。

接下来解答一下上文提出的问题。细心的同学会发现， `else` 语句的代码会修改字典树的结构。没错，它将不存在的字典树的状态链接到了失配指针的对应状态。在原字典树中，每一个结点代表一个字符串 $S$ ，是某个模式串的前缀。而在修改字典树结构后，尽管增加了许多转移关系，但结点（状态）所代表的字符串是不变的。

而 $trans(S,c)$ 相当于是在 $S$ 后添加一个字符 `c` 变成另一个状态 $S'$ 。如果 $S'$ 存在，说明存在一个模式串的前缀是 $S'$ ，否则我们让 $trans(S,c)$ 指向 $trans(fail[S],c)$ 。由于 $fail[S]$ 对应的字符串是 $S$ 的后缀，因此 $trans(fail[S],c)$ 对应的字符串也是 $S'$ 的后缀。

换言之在 TRIE 上跳转的时侯，我们只会从 $S$ 跳转到 $S'$ ，相当于匹配了一个 $S'$ ；但在 AC 自动机上跳转的时侯，我们会从 $S$ 跳转到 $S'$ 的后缀，也就是说我们匹配一个字符 `c` ，然后舍弃 $S$ 的部分前缀。舍弃前缀显然是能匹配的。那么 fail 指针呢？它也是在舍弃前缀啊！试想一下，如果文本串能匹配 $S$ ，显然它也能匹配 $S$ 的后缀。所谓的 fail 指针其实就是 $S$ 的一个后缀集合。

 `tr` 数组还有另一种比较简单的理解方式：如果在 $u$ 的位置失配，我们会跳转到 $fail[u]$ 的位置。所以我们可能沿着 $fail$ 数组跳转多次才能来到下一个能匹配的位置。所以我们可以用 `tr` 数组直接记录记录下一个能匹配的位置，这样就能节省下很多时间。

这样修改字典树的结构，使得匹配转移更加完善。同时它将 fail 指针跳转的路径做了压缩（就像并查集的路径压缩），使得本来需要跳很多次 fail 指针变成跳一次。

好的，我知道大家都受不了长篇叙述。上图！我们将之前的 GIF 图改一下：

![AC_automation_gif_b_pro3.gif](./images/ac-automaton2.gif)

1.  蓝色结点：BFS 遍历到的结点 u
2.  蓝色的边：当前结点下，AC 自动机修改字典树结构连出的边。
3.  黑色的边：AC 自动机修改字典树结构连出的边。
4.  红色的边：当前结点求出的 fail 指针
5.  黄色的边：fail 指针
6.  灰色的边：字典树的边

可以发现，众多交错的黑色边将字典树变成了 **字典图** 。图中省 s 略了连向根结点的黑边（否则会更乱）。我们重点分析一下结点 5 遍历时的情况，~~再妙不可读也请大家硬着头皮去读~~。我们求 $trans(5,\text{ s })=6$ 的 fail 指针：

![AC_automation_b_7.png](./images/ac-automaton2.png)

本来的策略是找 fail 指针，于是我们跳到 $fail[5]=10$ 发现没有 `s` 连出的字典树的边，于是跳到 $fail[10]=0$ ，发现有 $trie[0,\text{ s }]=7$ ，于是 $fail[6]=7$ ；但是有了黑边、蓝边，我们跳到 $fail[5]=10$ 之后直接走 $trans(10,\text{ s })=7$ 就走到 $7$ 号结点了。~~其实我知道没人会仔细看这鬼扯的两张图片的 QAQ~~

这就是 build 完成的两件事：构建 fail 指针和建立字典图。这个字典图也会在查询的时候起到关键作用。

## 多模式匹配

接下来分析匹配函数 `query()` ：

```cpp
int query(char *t) {
  int u = 0, res = 0;
  for (int i = 1; t[i]; i++) {
    u = tr[u][t[i] - 'a'];  // 转移
    for (int j = u; j && e[j] != -1; j = fail[j]) {
      res += e[j], e[j] = -1;
    }
  }
  return res;
}
```

声明 $u$ 作为字典树上当前匹配到的结点， $res$ 即返回的答案。循环遍历匹配串， $u$ 在字典树上跟踪当前字符。利用 fail 指针找出所有匹配的模式串，累加到答案中。然后清 0。对 $e[j]$ 取反的操作用来判断 $e[j]$ 是否等于 -1。在上文中我们分析过，字典树的结构其实就是一个 $trans$ 函数，而构建好这个函数后，在匹配字符串的过程中，我们会舍弃部分前缀达到最低限度的匹配。fail 指针则指向了更多的匹配状态。最后上一份图。对于刚才的自动机：

![AC_automation_b_13.png](./images/ac-automaton3.png)

我们从根结点开始尝试匹配 `ushersheishis` ，那么 p 的变化将是：

![AC_automation_gif_c.gif](./images/ac-automaton3.gif)

1.  红色结点：p 结点
2.  粉色箭头：p 在自动机上的跳转，
3.  蓝色的边：成功匹配的模式串
4.  蓝色结点：示跳 fail 指针时的结点（状态）。

## 总结

~~希望~~大家看懂了文章。其实总结一下，你只需要知道 AC 自动机的板子很好背就行啦。

时间复杂度：定义 $|s_i|$ 是模板串的长度， $|S|$ 是文本串的长度， $|\Sigma|$ 是字符集的大小（常数，一般为 26）。如果连了 trie 图，时间复杂度就是 $\Theta(\sum|S_i|+n|\Sigma|+|S|)$ ，其中 $n$ 是 AC 自动机中结点的数目，并且最大可以达到 $\Theta(\sum|s_i|)$ 。如果不连 trie 图，并且在构建 fail 指针的时候避免遍历到空儿子，时间复杂度就是 $O(\sum|s_i|+|S|)$ 。

???+ note "模板 1"
     [LuoguP3808【模板】AC 自动机（简单版）](https://www.luogu.org/problemnew/show/P3808) 

    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e6 + 6;
    int n;

    namespace AC {
    int tr[N][26], tot;
    int e[N], fail[N];
    void insert(char *s) {
      int u = 0;
      for (int i = 1; s[i]; i++) {
        if (!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;
        u = tr[u][s[i] - 'a'];
      }
      e[u]++;
    }
    queue<int> q;
    void build() {
      for (int i = 0; i < 26; i++)
        if (tr[0][i]) q.push(tr[0][i]);
      while (q.size()) {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; i++) {
          if (tr[u][i])
            fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);
          else
            tr[u][i] = tr[fail[u]][i];
        }
      }
    }
    int query(char *t) {
      int u = 0, res = 0;
      for (int i = 1; t[i]; i++) {
        u = tr[u][t[i] - 'a'];  // 转移
        for (int j = u; j && e[j] != -1; j = fail[j]) {
          res += e[j], e[j] = -1;
        }
      }
      return res;
    }
    }  // namespace AC

    char s[N];
    int main() {
      scanf("%d", &n);
      for (int i = 1; i <= n; i++) scanf("%s", s + 1), AC::insert(s);
      scanf("%s", s + 1);
      AC::build();
      printf("%d", AC::query(s));
      return 0;
    }
    ```

???+ note "模板 2"
     [P3796 【模板】AC 自动机（加强版）](https://www.luogu.org/problemnew/show/P3796) 

    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 156, L = 1e6 + 6;
    namespace AC {
    const int SZ = N * 80;
    int tot, tr[SZ][26];
    int fail[SZ], idx[SZ], val[SZ];
    int cnt[N];  // 记录第 i 个字符串的出现次数
    void init() {
      memset(fail, 0, sizeof(fail));
      memset(tr, 0, sizeof(tr));
      memset(val, 0, sizeof(val));
      memset(cnt, 0, sizeof(cnt));
      memset(idx, 0, sizeof(idx));
      tot = 0;
    }
    void insert(char *s, int id) {  // id 表示原始字符串的编号
      int u = 0;
      for (int i = 1; s[i]; i++) {
        if (!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;
        u = tr[u][s[i] - 'a'];
      }
      idx[u] = id;
    }
    queue<int> q;
    void build() {
      for (int i = 0; i < 26; i++)
        if (tr[0][i]) q.push(tr[0][i]);
      while (q.size()) {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; i++) {
          if (tr[u][i])
            fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);
          else
            tr[u][i] = tr[fail[u]][i];
        }
      }
    }
    int query(char *t) {  // 返回最大的出现次数
      int u = 0, res = 0;
      for (int i = 1; t[i]; i++) {
        u = tr[u][t[i] - 'a'];
        for (int j = u; j; j = fail[j]) val[j]++;
      }
      for (int i = 0; i <= tot; i++)
        if (idx[i]) res = max(res, val[i]), cnt[idx[i]] = val[i];
      return res;
    }
    }  // namespace AC
    int n;
    char s[N][100], t[L];
    int main() {
      while (~scanf("%d", &n)) {
        if (n == 0) break;
        AC::init();
        for (int i = 1; i <= n; i++) scanf("%s", s[i] + 1), AC::insert(s[i], i);
        AC::build();
        scanf("%s", t + 1);
        int x = AC::query(t);
        printf("%d\n", x);
        for (int i = 1; i <= n; i++)
          if (AC::cnt[i] == x) printf("%s\n", s[i] + 1);
      }
      return 0;
    }
    ```

## 拓展

### 确定有限状态自动机

如果大家理解了上面的讲解，那么做为拓展延伸，文末我们简单介绍一下自动机与 KMP 自动机。（现在你再去看百科上自动机的定义就会好懂很多啦）

有限状态自动机（deterministic finite automaton，DFA）是由

1.  状态集合 $Q$ ；
2.  字符集 $\Sigma$ ；
3.  状态转移函数 $\delta:Q\times \Sigma \to Q$ ，即 $\delta(q,\sigma)=q',\ q,q'\in Q,\sigma\in \Sigma$ ；
4.  一个开始状态 $s\in Q$ ；
5.  一个接收的状态集合 $F\subseteq Q$ 。

组成的五元组 $(Q,\Sigma,\delta,s,F)$ 。

那这东西你用 AC 自动机理解，状态集合就是字典树（图）的结点；字符集就是 `a` 到 `z` （或者更多）；状态转移函数就是 $trans(u,c)$ 的函数（即 `tr[u,c]` ）；开始状态就是字典树的根结点；接收状态就是你在字典树中标记的字符串结尾结点组成的集合。

### KMP 自动机

KMP 自动机就是一个不断读入待匹配串，每次匹配时走到接受状态的 DFA。如果共有 $m$ 个状态，第 $i$ 个状态表示已经匹配了前 $i$ 个字符。那么我们定义 $trans_{i,c}$ 表示状态 $i$ 读入字符 $c$ 后到达的状态， $next_{i}$ 表示 [prefix function](./kmp.md) ，则有：

$$
trans_{i,c} =
\begin{cases}
i + 1,  & \text{if $b_{i} = c$} \\[2ex]
trans_{next_{i},c}, & \text{else}
\end{cases}
$$

（约定 $next_{0}=0$ ）

我们发现 $trans_{i}$ 只依赖于之前的值，所以可以跟 [KMP](./kmp.md) 一起求出来。

时间和空间复杂度： $O(m|\Sigma|)$ 。一些细节：走到接受状态之后立即转移到该状态的 $next$ 。

对比之下，AC 自动机其实就是 Trie 上的自动机。（虽然一开始丢给你这句话可能不知所措）

# basic
author: Ir1d, ouuan, qinggniq, i-Yirannn

## 定义

### 字符集

一个 **字符集**  $\Sigma$ 是一个建立了全序关系的集合，也就是说， $\Sigma$ 中的任意两个不同的元素 $\alpha$ 和 $\beta$ 都可以比较大小，要么 $\alpha<\beta$ ，要么 $\beta<\alpha$ 。字符集 $\Sigma$ 中的元素称为字符。

### 字符串

一个 **字符串**  $S$ 是将 $n$ 个字符顺次排列形成的序列， $n$ 称为 $S$ 的长度，表示为 $|S|$ 。 $S$ 的第 $i$ 个字符表示为 $S[i]$ 。（在有的地方，也会用 $S[i-1]$ 表示第 $i$ 个字符。）

### 子串

字符串 $S$ 的 **子串**  $S[i..j]，i≤j$ ，表示 $S$ 串中从 $i$ 到 $j$ 这一段，也就是顺次排列 $S[i],S[i+1],\ldots,S[j]$ 形成的字符串。

有时也会用 $S[i..j]$ , $i>j$ 来表示空串。

### 子序列

字符串 $S$ 的 **子序列** 是从 $S$ 中将若干元素提取出来并不改变相对位置形成的序列，即 $S[p_1],S[p_2],\ldots,S[p_k]$ ， $1\le p_1< p_2<\cdots< p_k\le|S|$ 。

### 后缀

 **后缀** 是指从某个位置 $i$ 开始到整个串末尾结束的一个特殊子串。字符串 $S$ 的从 $i$ 开头的后缀表示为 $Suffix(S,i)$ ，也就是 $Suffix(S,i)=S[i..|S|]$ 。

 **真后缀** 指除了 $S$ 本身的 $S$ 的后缀。

### 字典序

以第 $i$ 个字符作为第 $i$ 关键字进行大小比较，空字符小于字符集内任何字符（即： $a< aa$ ）。

### 回文串

 **回文串** 是正着写和倒着写相同的字符串，即满足 $\forall 1\le i\le|s|, s[i]=s[|s|+1-i]$ 的 $s$ 。

## 字符串的存储

1.  使用 `char` 数组存储，用空字符 `\0` 表示字符串的结尾。（C 风格字符串）
2.  使用 C++ 标准库提供的 [ `string` 类](../lang/csl/string.md) 。
3.  字符串常量可以用字符串字面值（用双引号括起来的字符串）表示。

## 参考资料

 [后缀数组 by. 徐智磊](https://wenku.baidu.com/view/0dc03d2b1611cc7931b765ce0508763230127479.html) 

# hash
## Hash 的思想

Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。

!!! warning
    这里的“值域较小”在不同情况下意义不同。

    在 [哈希表](../ds/hash.md) 中，值域需要小到能够接受线性的空间与时间复杂度。

    在字符串哈希中，值域需要小到能够快速比较（ $10^9$ 、 $10^{18}$ 都是可以快速比较的）。

    同时，为了降低哈希冲突率，值域也不能太小。

我们定义一个把字符串映射到整数的函数 $f$ ，这个 $f$ 称为是 Hash 函数。

我们希望这个函数 $f$ 可以方便地帮我们判断两个字符串是否相等。

具体来说，我们希望在 Hash 函数值不一样的时候，两个字符串一定不一样。

另外，反过来不需要成立。我们把这种条件称为是单侧错误。

我们需要关注的是什么？

时间复杂度和 Hash 的准确率。

通常我们采用的是多项式 Hash 的方法，即 $f(s) = \sum s[i] \times b^i \pmod M$ 。

这里面的 $b$ 和 $M$ 需要选取得足够合适才行，以使得 Hash 函数的值分布尽量均匀。

如果 $b$ 和 $M$ 互质，在输入随机的情况下，这个 Hash 函数在 $[0,M)$ 上每个值概率相等，此时单次比较的错误率为 $\frac 1 M$ 。所以，哈希的模数一般会选用大质数。

## Hash 的实现

参考代码：（效率低下的版本，实际使用时一般不会这么写）

```cpp
using std::string;

const int M = 1e9 + 7;
const int B = 233;

typedef long long ll;

int get_hash(const string& s) {
  int res = 0;
  for (int i = 0; i < s.size(); ++i) {
    res = (ll)(res * B + s[i]) % M;
  }
  return res;
}

void cmp(const string& s, const string& t) {
  return get_hash(s) == get_hash(t);
}
```

## Hash 的分析与改进

### 错误率

若进行 $n$ 次比较，每次错误率 $\frac 1 M$ ，那么总错误率是 $1-\left(1-\frac 1 M\right)^n$ 。在随机数据下，若 $M=10^9 + 7$ , $n=10^6$ ，错误率约为 $\frac 1{1000}$ ，并不是能够完全忽略不计的。

所以，进行字符串哈希时，经常会对两个大质数分别取模，这样的话哈希函数的值域就能扩大到两者之积，错误率就非常小了。

### 多次询问子串哈希

单次计算一个字符串的哈希值复杂度是 $O(n)$ ，其中 $n$ 为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率非常低下。

一般采取的方法是对整个字符串先预处理出每个前缀的哈希值，将哈希值看成一个 $b$ 进制的数对 $M$ 取模的结果，这样的话每次就能快速求出子串的哈希了：

令 $f_i(s)$ 表示 $f(s[1..i])$ ，那么 $f(s[l..r])=\frac{f_r(s)-f_{l-1}(s)}{b^{l-1}}$ ，其中 $\frac{1}{b^{l-1}}$ 也可以预处理出来，用 [乘法逆元](../math/inverse.md) 或者是在比较哈希值时等式两边同时乘上 $b$ 的若干次方化为整式均可。

这样的话，就可以在 $O(n)$ 的预处理后每次 $O(1)$ 地计算子串的哈希值了。

## Hash 的应用

### 字符串匹配

求出模式串的哈希值后，求出文本串每个长度为模式串长度的子串的哈希值，分别与模式串的哈希值比较即可。

### 最长回文子串

二分答案，判断是否可行时枚举回文中心（对称轴），哈希判断两侧是否相等。需要分别预处理正着和倒着的哈希值。时间复杂度 $O(n\log n)$ 。

这个问题可以使用 [manacher 算法](./manacher.md) 在 $O(n)$ 的时间内解决。

### 例题

???+note "[CF1200E Compress Words](http://codeforces.com/contest/1200/problem/E)"
    给你若干个字符串，答案串初始为空。第 $i$ 步将第 $i$ 个字符串加到答案串的后面，但是尽量地去掉重复部分（即去掉一个最长的、是原答案串的后缀、也是第 $i$ 个串的前缀的字符串），求最后得到的字符串。

    字符串个数不超过 $10^5$，总长不超过 $10^6$。

    ??? mdui-shadow-6 "题解"
        每次需要求最长的、是原答案串的后缀、也是第 $i$ 个串的前缀的字符串。枚举这个串的长度，哈希比较即可。

        当然，这道题也可以使用 [KMP 算法](./kmp.md) 解决。

    ??? mdui-shadow-6 "参考代码"
        ```cpp
        #include <algorithm>
        #include <cstdio>
        #include <cstring>
        
        const int N = 1000010;
        const int m1 = 998244353;
        const int m2 = 1000001011;
        const int K = 233;
        
        typedef long long ll;
        
        int m, h1[N], h2[N], len, i1[N], i2[N];
        char s[N];
        
        void add(char x) {
          h1[len + 1] = ((ll)h1[len] * K + x) % m1;
          h2[len + 1] = ((ll)h2[len] * K + x) % m2;
          ++len;
        }
        
        int get1(int l, int r) { return (ll)(h1[r] - h1[l - 1] + m1) * i1[l - 1] % m1; }
        int get2(int l, int r) { return (ll)(h2[r] - h2[l - 1] + m2) * i2[l - 1] % m2; }
        
        bool cmp(int l1, int r1, int l2, int r2) {
          return get1(l1, r1) == get1(l2, r2) && get2(l1, r1) == get2(l2, r2);
        }
        
        int qpow(int x, int y, int mod) {
          int out = 1;
          while (y) {
            if (y & 1) out = (ll)out * x % mod;
            x = (ll)x * x % mod;
            y >>= 1;
          }
          return out;
        }
        
        int main() {
          i1[0] = i2[0] = 1;
          int k1 = qpow(K, m1 - 2, m1);  // 求逆元
          int k2 = qpow(K, m2 - 2, m2);
          for (int i = 1; i < N; ++i) {
            i1[i] = (ll)i1[i - 1] * k1 % m1;
            i2[i] = (ll)i2[i - 1] * k2 % m2;
          }
        
          scanf("%d", &m);
        
          while (m--) {
            scanf("%s", s + 1);
            int n = strlen(s + 1);
            for (int i = 1; i <= n; ++i) add(s[i]);
            // 先把当前串加到答案串的后面，可以方便地求哈希
            for (int i = std::min(n, len - n); i >= 0; --i) {
              if (cmp(len - n - i + 1, len - n, len - n + 1, len - n + i)) {
                len -= n;  // 确定了要加多长再真正地加进去
                for (int j = i + 1; j <= n; ++j) add(s[j]);
                printf("%s", s + i + 1);
                break;
              }
            }
          }
        
          return 0;
        }
        ```

# suffix-tree


# lib-func
author: Frankaiyou, henrytbtrue

# C/C++ 标准库中的字符串

## C 标准库

C 标准库是在对字符数组进行操作

###  `strlen` 

 `int strlen(const char *str)` ：返回从 `str[0]` 开始直到 `'\0'` 的字符数。注意，未开启 O2 优化时，该操作写在循环条件中复杂度是 $\Theta(N)$ 的。

###  `printf` 

 `printf("%s", s)` ：用 `%s` 来输出一个字符串（字符数组）。

###  `scanf` 

 `scanf("%s", s)` ：用 `%s` 来读入一个字符串（字符数组）。

###  `sscanf` 

 `sscanf(const char *__source, const char *__format, ...)` ：从字符串 `__source` 里读取变量，比如 `sscanf(str,"%d",&a)` 。

###  `sprintf` 

 `sprintf(char *__stream, const char *__format, ...)` ：将 `__format` 字符串里的内容输出到 `__stream` 中，比如 `sprintf(str,"%d",i)` 。

###  `strcmp` 

 `int strcmp(const char *str1, const char *str2)` ：按照字典序比较 `str1 str2` 若 `str1` 字典序小返回负值，一样返回 0，大返回正值 请注意，不要简单的认为只有 `0, 1, -1` 三种，在不同平台下的返回值都遵循正负，但并非都是 `0, 1, -1` 

###  `strcpy` 

 `char *strcpy(char *str, const char *src)` : 把 `src` 中的字符复制到 `str` 中， `str`  `src` 均为字符数组头指针，返回值为 `str` 包含空终止符号 `'\0'` 。

###  `strncpy` 

 `char *strncpy(char *str, const char *src, int cnt)` ：复制至多 `cnt` 个字符到 `str` 中，若 `src` 终止而数量未达 `cnt` 则写入空字符到 `str` 直至写入总共 `cnt` 个字符。

###  `strcat` 

 `char *strcat(char *str1, const char *str2)` : 将 `str2` 接到 `str1` 的结尾，用 `*str2` 替换 `str1` 末尾的 `'\0'` 返回 `str1` 。

###  `strstr` 

 `char *strstr(char *str1, const char *str2)` ：若 `str2` 是 `str1` 的子串，则返回 `str2` 在 `str1` 的首次出现的地址；如果 `str2` 不是 `str1` 的子串，则返回 `NULL` 。

###  `strchr` 

 `char *strchr(const char *str, int c)` ：找到在字符串 `str` 中第一次出现字符 `c` 的位置，并返回这个位置的地址。如果未找到该字符则返回 `NULL` 。

###  `strrchr` 

 `char *strrchr(const char *str, char c)` ：找到在字符串 `str` 中最后一次出现字符 `c` 的位置，并返回这个位置的地址。如果未找到该字符则返回 `NULL` 。

## C++ 标准库

C++ 标准库是在对字符串对象进行操作，同时也提供对字符数组的兼容。

###  `std::string` 

-   赋值运算符 `=` 右侧可以是 `const string/string/const char*/char*` 。
-   访问运算符 `[cur]` 返回 `cur` 位置的引用。
-   访问函数 `data()/c_str()` 返回一个 `const char*` 指针，内容与该 `string` 相同。
-   容量函数 `size()` 返回字符串字符个数。
-   还有一些其他的函数如 `find()` 找到并返回某字符位置。
-    `std :: string` 重载了比较逻辑运算符，复杂度是 $\Theta(N)$ 的。

# sa
## 一些约定

字符串相关的定义请参考 [字符串基础](./basic.md) 。

字符串下标从 $1$ 开始。

" 后缀 $i$ " 代指以第 $i$ 个字符开头的后缀。

## 后缀数组是什么？

后缀数组（Suffix Array）主要是两个数组： $sa$ 和 $rk$ 。

其中， $sa[i]$ 表示将所有后缀排序后第 $i$ 小的后缀的编号。 $rk[i]$ 表示后缀 $i$ 的排名。

这两个数组满足性质： $sa[rk[i]]=rk[sa[i]]=i$ 。

后缀数组示例：

[/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/sa1.png)][2]

## 后缀数组怎么求？

### O(n^2logn) 做法

我相信这个做法大家还是能自己想到的，用 `string` + `sort` 就可以了。由于比较两个字符串是 $O(n)$ 的，所以排序是 $O(n^2\log n)$ 的。

### O(nlog^2n) 做法

这个做法要用到倍增的思想。

先对每个长度为 $1$ 的子串（即每个字符）进行排序。

假设我们已经知道了长度为 $w$ 的子串的排名 $rk_w[1..n]$ （即， $rk_w[i]$ 表示 $s[i..\min(i+w-1,n)]$ 在 $\{s[x..\min(x+w-1,n)]\ |\ x\in[1,n]\}$ 中的排名），那么，以 $rk_w[i]$ 为第一关键字， $rk_w[i+w]$ 为第二关键字（若 $i+w>n$ 则令 $rk_w[i+w]$ 为无穷小）进行排序，就可以求出 $rk_{2w}[1..n]$ 。

倍增排序示意图：

[/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/sa2.png)][2]

如果用 `sort` 进行排序，复杂度就是 $O(n\log^2n)$ 的。

??? note "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    
    using namespace std;
    
    const int N = 1000010;
    
    char s[N];
    int n, w, sa[N], rk[N << 1], oldrk[N << 1];
    // 为了防止访问 rk[i+w] 导致数组越界，开两倍数组。
    // 当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。
    
    int main() {
      int i, p;
    
      scanf("%s", s + 1);
      n = strlen(s + 1);
      for (i = 1; i <= n; ++i) rk[i] = s[i];
    
      for (w = 1; w < n; w <<= 1) {
        for (i = 1; i <= n; ++i) sa[i] = i;
        sort(sa + 1, sa + n + 1, [](int x, int y) {
          return rk[x] == rk[y] ? rk[x + w] < rk[y + w] : rk[x] < rk[y];
        });  // 这里用到了 lambda
        memcpy(oldrk, rk, sizeof(rk));
        // 由于计算 rk 的时候原来的 rk 会被覆盖，要先复制一份
        for (p = 0, i = 1; i <= n; ++i) {
          if (oldrk[sa[i]] == oldrk[sa[i - 1]] &&
              oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) {
            rk[sa[i]] = p;
          } else {
            rk[sa[i]] = ++p;
          }  // 若两个子串相同，它们对应的 rk 也需要相同，所以要去重
        }
      }
    
      for (i = 1; i <= n; ++i) printf("%d ", sa[i]);
    
      return 0;
    }
    ```

### O(nlogn) 做法

在刚刚的 $O(n\log^2n)$ 做法中，单次排序是 $O(n\log n)$ 的，如果能 $O(n)$ 排序，就能 $O(n\log n)$ 计算后缀数组了。

前置知识： [计数排序](../basic/counting-sort.md) ， [基数排序](../basic/radix-sort.md) 。

由于计算后缀数组的过程中排序的关键字是排名，值域为 $O(n)$ ，并且是一个双关键字的排序，可以使用基数排序优化至 $O(n)$ 。

??? note "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    
    using namespace std;
    
    const int N = 1000010;
    
    char s[N];
    int n, sa[N], rk[N << 1], oldrk[N << 1], id[N], cnt[N];
    
    int main() {
      int i, m, p, w;
    
      scanf("%s", s + 1);
      n = strlen(s + 1);
      m = max(n, 300);
      for (i = 1; i <= n; ++i) ++cnt[rk[i] = s[i]];
      for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
      for (i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;
    
      for (w = 1; w < n; w <<= 1) {
        memset(cnt, 0, sizeof(cnt));
        for (i = 1; i <= n; ++i) id[i] = sa[i];
        for (i = 1; i <= n; ++i) ++cnt[rk[id[i] + w]];
        for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (i = n; i >= 1; --i) sa[cnt[rk[id[i] + w]]--] = id[i];
        memset(cnt, 0, sizeof(cnt));
        for (i = 1; i <= n; ++i) id[i] = sa[i];
        for (i = 1; i <= n; ++i) ++cnt[rk[id[i]]];
        for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (i = n; i >= 1; --i) sa[cnt[rk[id[i]]]--] = id[i];
        memcpy(oldrk, rk, sizeof(rk));
        for (p = 0, i = 1; i <= n; ++i) {
          if (oldrk[sa[i]] == oldrk[sa[i - 1]] &&
              oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) {
            rk[sa[i]] = p;
          } else {
            rk[sa[i]] = ++p;
          }
        }
      }
    
      for (i = 1; i <= n; ++i) printf("%d ", sa[i]);
    
      return 0;
    }
    ```

### 一些常数优化

如果你把上面那份代码交到 [LOJ #111: 后缀排序](https://loj.ac/problem/111) 上：

/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/![](./images/sa3.png)

这是因为，上面那份代码的常数的确很大。

#### 第二关键字无需计数排序

实际上，像这样就可以了：

```cpp
for (p = 0, i = n; i > n - w; --i) id[++p] = i;
for (i = 1; i <= n; ++i) {
  if (sa[i] > w) id[++p] = sa[i] - w;
}
```

意会一下，先把 $s[i+w..i+2w-1]$ 为空串（即第二关键字为无穷小）的位置放前面，再把剩下的按排好的顺序放进去。

#### 优化计数排序的值域

每次对 $rk$ 进行去重之后，我们都计算了一个 $p$ ，这个 $p$ 即是 $rk$ 的值域，将值域改成它即可。

#### 将 rk\[id[i]] 存下来，减少不连续内存访问

这个优化在数据范围较大时效果非常明显。

#### 用函数 cmp 来计算是否重复

同样是减少不连续内存访问，在数据范围较大时效果比较明显。

把 `oldrk[sa[i]] == oldrk[sa[i - 1]] && oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]` 替换成 `cmp(sa[i], sa[i - 1], w)` ， `bool cmp(int x, int y, int w) { return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w]; }` 。

??? note "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    
    using namespace std;
    
    const int N = 1000010;
    
    char s[N];
    int n, sa[N], rk[N], oldrk[N << 1], id[N], px[N], cnt[N];
    // px[i] = rk[id[i]]（用于排序的数组所以叫 px）
    
    bool cmp(int x, int y, int w) {
      return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
    }
    
    int main() {
      int i, m = 300, p, w;
    
      scanf("%s", s + 1);
      n = strlen(s + 1);
      for (i = 1; i <= n; ++i) ++cnt[rk[i] = s[i]];
      for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
      for (i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;
    
      for (w = 1; w < n; w <<= 1, m = p) {  // m=p 就是优化计数排序值域
        for (p = 0, i = n; i > n - w; --i) id[++p] = i;
        for (i = 1; i <= n; ++i)
          if (sa[i] > w) id[++p] = sa[i] - w;
        memset(cnt, 0, sizeof(cnt));
        for (i = 1; i <= n; ++i) ++cnt[px[i] = rk[id[i]]];
        for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (i = n; i >= 1; --i) sa[cnt[px[i]]--] = id[i];
        memcpy(oldrk, rk, sizeof(rk));
        for (p = 0, i = 1; i <= n; ++i)
          rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
      }
    
      for (i = 1; i <= n; ++i) printf("%d ", sa[i]);
    
      return 0;
    }
    ```

### O(n) 做法

在一般的题目中，常数较小的倍增求后缀数组是完全够用的，求后缀数组以外的部分也经常有 $O(n\log n)$ 的复杂度，倍增求解后缀数组不会成为瓶颈。

但如果遇到特殊题目、时限较紧的题目，或者是你想追求更短的用时，就需要学习 $O(n)$ 求后缀数组的方法。

#### SA-IS

可以参考 [诱导排序与 SA-IS 算法](https://riteme.site/blog/2016-6-19/sais.html) 。

#### DC3

可以参考[\[2009\]后缀数组——处理字符串的有力工具 by. 罗穗骞][2]。

## 后缀数组的应用

### 寻找最小的循环移动位置

将字符串 $S$ 复制一份变成 $SS$ 就转化成了后缀排序问题。

例题： [「JSOI2007」字符加密](https://www.luogu.org/problem/P4051) 。

### 在字符串中找子串

任务是在线地在主串 $T$ 中寻找模式串 $S$ 。在线的意思是，我们已经预先知道知道主串 $T$ ，但是当且仅当询问时才知道模式串 $S$ 。我们可以先构造出 $T$ 的后缀数组，然后查找子串 $S$ 。若子串 $S$ 在 $T$ 中出现，它必定是 $T$ 的一些后缀的前缀。因为我们已经将所有后缀排序了，我们可以通过在 $p$ 数组中二分 $S$ 来实现。比较子串 $S$ 和当前后缀的时间复杂度为 $O(|S|)$ ，因此找子串的时间复杂度为 $O(|S|\log |T|)$ 。注意，如果该子串在 $T$ 中出现了多次，每次出现都是在 $p$ 数组中相邻的。因此出现次数可以通过再次二分找到，输出每次出现的位置也很轻松。

### 从字符串首尾取字符最小化字典序

例题： [「USACO07DEC」Best Cow Line](https://www.luogu.org/problem/P2870) 。

题意：给你一个字符串，每次从首或尾取一个字符组成字符串，问所有能够组成的字符串中字典序最小的一个。

??? note "题解"
    暴力做法就是每次最坏 $O(n)$ 地判断当前应该取首还是尾（即比较取首得到的字符串与取尾得到的反串的大小），只需优化这一判断过程即可。

    由于需要在原串后缀与反串后缀构成的集合内比较大小，可以将反串拼接在原串后，并在中间加上一个没出现过的字符（如 `#`，代码中可以直接使用空字符），求后缀数组，即可 $O(1)$ 完成这一判断。

??? note "参考代码"
    ```cpp
    #include <cctype>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    
    using namespace std;
    
    const int N = 1000010;
    
    char s[N];
    int n, sa[N], id[N], oldrk[N << 1], rk[N << 1], px[N], cnt[N];
    
    bool cmp(int x, int y, int w) {
      return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
    }
    
    int main() {
      int i, w, m = 200, p, l = 1, r, tot = 0;
    
      cin >> n;
      r = n;
    
      for (i = 1; i <= n; ++i)
        while (/home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string//home/llj/Desktop/OI-wiki-master/docs/string/!isalpha(s[i] = getchar()))
          ;
      for (i = 1; i <= n; ++i) rk[i] = rk[2 * n + 2 - i] = s[i];
    
      n = 2 * n + 1;
    
      for (i = 1; i <= n; ++i) ++cnt[rk[i]];
      for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
      for (i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;
    
      for (w = 1; w < n; w <<= 1, m = p) {
        for (p = 0, i = n; i > n - w; --i) id[++p] = i;
        for (i = 1; i <= n; ++i)
          if (sa[i] > w) id[++p] = sa[i] - w;
        memset(cnt, 0, sizeof(cnt));
        for (i = 1; i <= n; ++i) ++cnt[px[i] = rk[id[i]]];
        for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (i = n; i >= 1; --i) sa[cnt[px[i]]--] = id[i];
        memcpy(oldrk, rk, sizeof(rk));
        for (p = 0, i = 1; i <= n; ++i)
          rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
      }
    
      while (l <= r) {
        printf("%c", rk[l] < rk[n + 1 - r] ? s[l++] : s[r--]);
        if ((++tot) % 80 == 0) puts("");
      }
    
      return 0;
    }
    ```

## height 数组

### LCP（最长公共前缀）

两个字符串 $S$ 和 $T$ 的 LCP 就是最大的 $x$ ( $x\le \min(|S|, |T|)$ ) 使得 $S_i=T_i\ (\forall\ 1\le i\le x)$ 。

下文中以 $lcp(i,j)$ 表示后缀 $i$ 和后缀 $j$ 的最长公共前缀（的长度）。

### height 数组的定义

 $height[i]=lcp(sa[i],sa[i-1])$ ，即第 $i$ 名的后缀与它前一名的后缀的最长公共前缀。

 $height[1]$ 可以视作 $0$ 。

### O(n) 求 height 数组需要的一个引理

 $height[rk[i]]\ge height[rk[i-1]]-1$ 

证明：

当 $height[rk[i-1]]\le1$ 时，上式显然成立（右边小于等于 $0$ ）。

当 $height[rk[i-1]]>1$ 时：

设后缀 $i-1$ 为 $aAD$ （ $A$ 是一个长度为 $height[rk[i-1]]-1$ 的字符串），那么后缀 $i$ 就是 $AD$ 。设后缀 $sa[rk[i-1]-1]$ 为 $aAB$ ，那么 $lcp(i-1,sa[rk[i-1]-1])=aA$ 。由于后缀 $sa[rk[i-1]-1]+1$ 是 $AB$ ，一定排在后缀 $i$ 的前面，所以后缀 $sa[rk[i]-1]$ 一定含有前缀 $A$ ，所以 $lcp(i,sa[rk[i]-1])$ 至少是 $height[rk[i-1]]-1$ 。

简单来说：

 $i-1$ ： $aAD$ 

 $i$ ： $AD$ 

 $sa[rk[i-1]-1]$ ： $aAB$ 

 $sa[rk[i-1]-1]+1$ ： $AB$ 

 $sa[rk[i]-1]$ ： $A[B/C]$ 

 $lcp(i,sa[rk[i]-1])$ ： $AX$ （ $X$ 可能为空）

### O(n) 求 height 数组的代码实现

利用上面这个引理暴力求即可：

```cpp
for (i = 1, k = 0; i <= n; ++i) {
  if (k) --k;
  while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k;
  ht[rk[i]] = k;  // height太长了缩写为ht
}
```

 $k$ 不会超过 $n$ ，最多减 $n$ 次，所以最多加 $2n$ 次，总复杂度就是 $O(n)$ 。

## height 数组的应用

### 两子串最长公共前缀

 $lcp(sa[i],sa[j])=\min\{height[i+1..j]\}$ 

感性理解：如果 $height$ 一直大于某个数，前这么多位就一直没变过；反之，由于后缀已经排好序了，不可能变了之后变回来。

严格证明可以参考[\[2004\]后缀数组 by. 徐智磊][1]。

有了这个定理，求两子串最长公共前缀就转化为了 [RMQ 问题](../topic/rmq.md) 。

### 比较一个字符串的两个子串的大小关系

假设需要比较的是 $A=S[a..b]$ 和 $B=S[c..d]$ 的大小关系。

若 $lcp(a, c)\ge\min(|A|, |B|)$ ， $A<B\iff |A|<|B|$ 。

否则， $A<B\iff rk[a]< rk[b]$ 。

### 不同子串的数目

子串就是后缀的前缀，所以可以枚举每个后缀，计算前缀总数，再减掉重复。

“前缀总数”其实就是子串个数，为 $n(n+1)/2$ 。

如果按后缀排序的顺序枚举后缀，每次新增的子串就是除了与上一个后缀的 LCP 剩下的前缀。这些前缀一定是新增的，否则会破坏 $lcp(sa[i],sa[j])=\min\{height[i+1..j]\}$ 的性质。只有这些前缀是新增的，因为 LCP 部分在枚举上一个前缀时计算过了。

所以答案为：

 $\frac{n(n+1)}{2}-\sum\limits_{i=2}^nheight[i]$ 

### 出现至少 k 次的子串的最大长度

例题： [「USACO06DEC」Milk Patterns](https://www.luogu.org/problemnew/show/P2852) 。

??? note "题解"
    出现至少 $k$ 次意味着后缀排序后有至少连续 $k$ 个后缀的 LCP 是这个子串。

    所以，求出每相邻 $k-1$ 个 $height$ 的最小值，再求这些最小值的最大值就是答案。

    可以使用单调队列 $O(n)$ 解决，但使用其它方式也足以 AC。

??? note "参考代码"
    ```cpp
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    #include <set>
    
    using namespace std;
    
    const int N = 40010;
    
    int n, k, a[N], sa[N], rk[N], oldrk[N], id[N], px[N], cnt[1000010], ht[N], ans;
    multiset<int> t;  // multiset 是最好写的实现方式
    
    bool cmp(int x, int y, int w) {
      return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
    }
    
    int main() {
      int i, j, w, p, m = 1000000;
    
      scanf("%d%d", &n, &k);
      --k;
    
      for (i = 1; i <= n; ++i) scanf("%d", a + i);
      for (i = 1; i <= n; ++i) ++cnt[rk[i] = a[i]];
      for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
      for (i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;
    
      for (w = 1; w < n; w <<= 1, m = p) {
        for (p = 0, i = n; i > n - w; --i) id[++p] = i;
        for (i = 1; i <= n; ++i)
          if (sa[i] > w) id[++p] = sa[i] - w;
        memset(cnt, 0, sizeof(cnt));
        for (i = 1; i <= n; ++i) ++cnt[px[i] = rk[id[i]]];
        for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (i = n; i >= 1; --i) sa[cnt[px[i]]--] = id[i];
        memcpy(oldrk, rk, sizeof(rk));
        for (p = 0, i = 1; i <= n; ++i)
          rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
      }
    
      for (i = 1, j = 0; i <= n; ++i) {
        if (j) --j;
        while (a[i + j] == a[sa[rk[i] - 1] + j]) ++j;
        ht[rk[i]] = j;
      }
    
      for (i = 1; i <= n; ++i) {
        t.insert(ht[i]);
        if (i > k) t.erase(t.find(ht[i - k]));
        ans = max(ans, *t.begin());
      }
    
      cout << ans;
    
      return 0;
    }
    ```

### 是否有某字符串在文本串中至少不重叠地出现了两次

可以二分目标串的长度 $|s|$ ，将 $h$ 数组划分成若干个连续 LCP 大于等于 $|s|$ 的段，利用 RMQ 对每个段求其中出现的数中最大和最小的下标，若这两个下标的距离满足条件，则一定有长度为 $|s|$ 的字符串不重叠地出现了两次。

### 连续的若干个相同子串

我们可以枚举连续串的长度 $|s|$ ，按照 $|s|$ 对整个串进行分块，对相邻两块的块首进行 LCP 与 LCS 查询，具体可见[\[2009\]后缀数组——处理字符串的有力工具][2]。

### 结合并查集

某些题目求解时要求你将后缀数组划分成若干个连续 LCP 长度大于等于某一值的段，亦即将 $h$ 数组划分成若干个连续最小值大于等于某一值的段并统计每一段的答案。如果有多次询问，我们可以将询问离线。观察到当给定值单调递减的时候，满足条件的区间个数总是越来越少，而新区间都是两个或多个原区间相连所得，且新区间中不包含在原区间内的部分的 $h$ 值都为减少到的这个值。我们只需要维护一个并查集，每次合并相邻的两个区间，并维护统计信息即可。

经典题目： [「NOI2015」品酒大会](https://uoj.ac/problem/131) 

### 结合线段树

某些题目让你求满足条件的前若干个数，而这些数又在后缀排序中的一个区间内。这时我们可以用归并排序的性质来合并两个结点的信息，利用线段树维护和查询区间答案。

### 结合单调栈

例题： [「AHOI2013」差异](https://loj.ac/problem/2377) 

??? note "题解"
    被加数的前两项很好处理，为 $n(n-1)(n+1)/2$ （每个后缀都出现了 $n-1$ 次，后缀总长是 $n(n+1)/2$ ），关键是最后一项，即后缀的两两 LCP。

    我们知道 $lcp(i,j)=k$ 等价于 $\min\{height[i+1..j]\}=k$。所以，可以把 $lcp(i,j)$ 记作 $\min\{x|i+1\le x\le j, height[x]=lcp(i,j)\}$ 对答案的贡献。

    考虑每个位置对答案的贡献是哪些后缀的 LCP，其实就是从它开始向左若干个连续的 $height$ 大于它的后缀中选一个，再从向右若干个连续的 $height$ 不小于它的后缀中选一个。这个东西可以用 [单调栈](../ds/monotonous-stack.md) 计算。

    单调栈部分类似于 [Luogu P2659 美丽的序列](https://www.luogu.org/problem/P2659) 以及 [悬线法](../misc/largest-matrix.md)。

??? note "参考代码"
    ```cpp
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    
    using namespace std;
    
    const int N = 500010;
    
    char s[N];
    int n, sa[N], rk[N << 1], oldrk[N << 1], id[N], px[N], cnt[N], ht[N], sta[N],
        top, l[N];
    long long ans;
    
    bool cmp(int x, int y, int w) {
      return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
    }
    
    int main() {
      int i, k, w, p, m = 300;
    
      scanf("%s", s + 1);
      n = strlen(s + 1);
      ans = 1ll * n * (n - 1) * (n + 1) / 2;
      for (i = 1; i <= n; ++i) ++cnt[rk[i] = s[i]];
      for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
      for (i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;
    
      for (w = 1; w < n; w <<= 1, m = p) {
        for (p = 0, i = n; i > n - w; --i) id[++p] = i;
        for (i = 1; i <= n; ++i)
          if (sa[i] > w) id[++p] = sa[i] - w;
        memset(cnt, 0, sizeof(cnt));
        for (i = 1; i <= n; ++i) ++cnt[px[i] = rk[id[i]]];
        for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (i = n; i >= 1; --i) sa[cnt[px[i]]--] = id[i];
        memcpy(oldrk, rk, sizeof(rk));
        for (p = 0, i = 1; i <= n; ++i)
          rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
      }
    
      for (i = 1, k = 0; i <= n; ++i) {
        if (k) --k;
        while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k;
        ht[rk[i]] = k;
      }
    
      for (i = 1; i <= n; ++i) {
        while (ht[sta[top]] > ht[i]) --top;
        l[i] = i - sta[top];
        sta[++top] = i;
      }
    
      sta[++top] = n + 1;
      ht[n + 1] = -1;
      for (i = n; i >= 1; --i) {
        while (ht[sta[top]] >= ht[i]) --top;
        ans -= 2ll * ht[i] * l[i] * (sta[top] - i);
        sta[++top] = i;
      }
    
      cout << ans;
    
      return 0;
    }
    ```

类似的题目： [「HAOI2016」找相同字符](https://loj.ac/problem/2064) 。

## 习题

-    [Uva 760 - DNA Sequencing](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=701) 
-    [Uva 1223 - Editor](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3664) 
-    [Codechef - Tandem](https://www.codechef.com/problems/TANDEM) 
-    [Codechef - Substrings and Repetitions](https://www.codechef.com/problems/ANUSAR) 
-    [Codechef - Entangled Strings](https://www.codechef.com/problems/TANGLED) 
-    [Codeforces - Martian Strings](http://codeforces.com/problemset/problem/149/E) 
-    [Codeforces - Little Elephant and Strings](http://codeforces.com/problemset/problem/204/E) 
-    [SPOJ - Ada and Terramorphing](http://www.spoj.com/problems/ADAPHOTO/) 
-    [SPOJ - Ada and Substring](http://www.spoj.com/problems/ADASTRNG/) 
-    [UVA - 1227 - The longest constant gene](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3668) 
-    [SPOJ - Longest Common Substring](http://www.spoj.com/problems/LCS/en/) 
-    [UVA 11512 - GATTACA](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2507) 
-    [LA 7502 - Suffixes and Palindromes](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&category=720&page=show_problem&problem=5524) 
-    [GYM - Por Costel and the Censorship Committee](http://codeforces.com/gym/100923/problem/D) 
-    [UVA 1254 - Top 10](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3695) 
-    [UVA 12191 - File Recover](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3343) 
-    [UVA 12206 - Stammering Aliens](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3358) 
-    [Codechef - Jarvis and LCP](https://www.codechef.com/problems/INSQ16F) 
-    [LA 3943 - Liking's Letter](https://icpcarchive.ecs.baylor.edu/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1944) 
-    [UVA 11107 - Life Forms](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2048) 
-    [UVA 12974 - Exquisite Strings](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=862&page=show_problem&problem=4853) 
-    [UVA 10526 - Intellectual Property](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1467) 
-    [UVA 12338 - Anti-Rhyme Pairs](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3760) 
-    [DevSkills Reconstructing Blue Print of Life](https://devskill.com/CodingProblems/ViewProblem/328) 
-    [UVA 12191 - File Recover](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3343) 
-    [SPOJ - Suffix Array](http://www.spoj.com/problems/SARRAY/) 
-    [LA 4513 - Stammering Aliens](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2514) 
-    [SPOJ - LCS2](http://www.spoj.com/problems/LCS2/) 
-    [Codeforces - Fake News (hard)](http://codeforces.com/contest/802/problem/I) 
-    [SPOJ - Longest Commong Substring](http://www.spoj.com/problems/LONGCS/) 
-    [SPOJ - Lexicographical Substring Search](http://www.spoj.com/problems/SUBLEX/) 
-    [Codeforces - Forbidden Indices](http://codeforces.com/contest/873/problem/F) 
-    [Codeforces - Tricky and Clever Password](http://codeforces.com/contest/30/problem/E) 
-    [LA 6856 - Circle of digits](https://icpcarchive.ecs.baylor.edu/index.php?option=onlinejudge&page=show_problem&problem=4868) 

## 参考资料

本页面中（ [4070a9b](https://github.com/24OI/OI-wiki/pull/950/commits/4070a9b3db8576db16c74d3ec33806ad10476eef) 引入的部分）主要译自博文 [Суффиксный массив](http://e-maxx.ru/algo/suffix_array) 与其英文翻译版 [Suffix Array](https://cp-algorithms.com/string/suffix-array.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。

论文：

1.  [\[2004\]后缀数组 by. 徐智磊][1]

2.  [\[2009\]后缀数组——处理字符串的有力工具 by. 罗穗骞][2]

[1]: https://wenku.baidu.com/view/0dc03d2b1611cc7931b765ce0508763230127479.html "[2004] 后缀数组 by. 徐智磊"

[2]: https://wenku.baidu.com/view/5b886b1ea76e58fafab00374.html "[2009] 后缀数组——处理字符串的有力工具 by. 罗穗骞"

# general-sam


# graph
# lgv
## 简介

Lindström–Gessel–Viennot lemma，即 LGV 引理，可以用来处理有向无环图上不相交路径计数等问题。

前置知识： [图论相关概念](./concept.md) 中的基础部分、 [矩阵](../math/matrix.md) 、 [高斯消元求行列式](../math/gauss.md) 。

LGV 引理仅适用于 **有向无环图** 。

## 定义

 $\omega(P)$ 表示 $P$ 这条路径上所有边的边权之积。（路径计数时，可以将边权都设为 $1$ ）（事实上，边权可以为生成函数）

 $e(u, v)$ 表示 $u$ 到 $v$ 的 **每一条** 路径 $P$ 的 $\omega(P)$ 之和，即 $e(u, v)=\sum\limits_{P:u\rightarrow v}\omega(P)$ 。

起点集合 $A$ ，是有向无环图点集的一个子集，大小为 $n$ 。

终点集合 $B$ ，也是有向无环图点集的一个子集，大小也为 $n$ 。

一组 $A\rightarrow B$ 的不相交路径 $S$ ： $S_i$ 是一条从 $A_i$ 到 $B_{\sigma(S)_i}$ 的路径（ $\sigma(S)$ 是一个排列），对于任何 $i\ne j$ ， $S_i$ 和 $S_j$ 没有公共顶点。

 $N(\sigma)$ 表示排列 $\sigma$ 的逆序对个数。

## 引理

$$
M = \begin{bmatrix}e(A_1,B_1)&e(A_1,B_2)&\cdots&e(A_1,B_n)\\
e(A_2,B_1)&e(A_2,B_2)&\cdots&e(A_2,B_n)\\
\vdots&\vdots&\ddots&\vdots\\
e(A_n,B_1)&e(A_n,B_2)&\cdots&e(A_n,B_n)\end{bmatrix}
$$

$$
\det(M)=\sum\limits_{S:A\rightarrow B}(-1)^{N(\sigma(S))}\prod\limits_{i=1}^n \omega(S_i)
$$

其中 $\sum\limits_{S:A\rightarrow B}$ 表示满足上文要求的 $A\rightarrow B$ 的每一组不相交路径 $S$ 。

证明请参考 [维基百科](https://en.wikipedia.org/wiki/Lindström–Gessel–Viennot_lemma) 。

## 例题

 [hdu5852 Intersection is not allowed!](http://acm.hdu.edu.cn/showproblem.php?pid=5852) 

题意：有一个 $n\times n$ 的棋盘，一个棋子从 $(x, y)$ 只能走到 $(x, y+1)$ 或 $(x + 1, y)$ ，有 $k$ 个棋子，一开始第 $i$ 个棋子放在 $(1, a_i)$ ，最终要到 $(n, b_i)$ ，路径要两两不相交，求方案数对 $10^9+7$ 取模。 $1\le n\le 10^5$ , $1\le k\le 100$ ，保证 $1\le a_1<a_2<\dots<a_n\le n$ , $1\le b_1<b_2<\dots<b_n\le n$ 。

观察到如果路径不相交就一定是 $a_i$ 到 $b_i$ ，因此 LGV 引理中一定有 $\sigma(S)_i=i$ ，不需要考虑符号问题。边权设为 $1$ ，直接套用引理即可。

从 $(1, a_i)$ 到 $(n, b_j)$ 的路径条数相当于从 $n-1+b_j-a_i$ 步中选 $n-1$ 步向下走，所以 $e(A_i, B_j)=\binom{n-1+b_j-a_i}{n-1}$ 。

行列式可以使用高斯消元求。

复杂度为 $O(n+k^2(k + \log p))$ ，其中 $\log p$ 是求逆元复杂度。

??? note "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    
    typedef long long ll;
    
    const int K = 105;
    const int N = 100005;
    const int mod = 1e9 + 7;
    
    int T, n, k, a[K], b[K], fact[N << 1], m[K][K];
    
    int qpow(int x, int y) {
      int out = 1;
      while (y) {
        if (y & 1) out = (ll)out * x % mod;
        x = (ll)x * x % mod;
        y >>= 1;
      }
      return out;
    }
    int c(int x, int y) {
      return (ll)fact[x] * qpow(fact[y], mod - 2) % mod *
             qpow(fact[x - y], mod - 2) % mod;
    }
    int main() {
      fact[0] = 1;
      for (int i = 1; i < N * 2; ++i) fact[i] = (ll)fact[i - 1] * i % mod;
    
      scanf("%d", &T);
    
      while (T--) {
        scanf("%d%d", &n, &k);
    
        for (int i = 1; i <= k; ++i) scanf("%d", a + i);
        for (int i = 1; i <= k; ++i) scanf("%d", b + i);
    
        for (int i = 1; i <= k; ++i) {
          for (int j = 1; j <= k; ++j) {
            if (a[i] <= b[j])
              m[i][j] = c(b[j] - a[i] + n - 1, n - 1);
            else
              m[i][j] = 0;
          }
        }
    
        for (int i = 1; i < k; ++i) {
          if (!m[i][i]) {
            for (int j = i + 1; j <= k; ++j) {
              if (m[j][i]) {
                std::swap(m[i], m[j]);
                break;
              }
            }
          }
          if (!m[i][i]) continue;
          for (int j = i + 1; j <= k; ++j) {
            if (!m[j][i]) continue;
            int mul = (ll)m[j][i] * qpow(m[i][i], mod - 2) % mod;
            for (int p = i; p <= k; ++p) {
              m[j][p] = (m[j][p] - (ll)m[i][p] * mul % mod + mod) % mod;
            }
          }
        }
    
        int ans = 1;
    
        for (int i = 1; i <= k; ++i) ans = (ll)ans * m[i][i] % mod;
    
        printf("%d\n", ans);
      }
    
      return 0;
    }
    ```

# tree-ahu
author: Backl1ght

AHU 算法用于判断两棵有根树是否同构。

判断树同构外还有一种常见的做法是 [树哈希](/graph/tree-hash) 。

前置知识： [树基础](/graph/tree-basic) ， [树的重心](/graph/tree-centroid) 

建议配合参考资料里给的例子观看。

## 树同构的定义

### 有根树同构

对于两棵有根树 $T_1(V_1,E_1,r_1)$ 和 $T_2(V_2,E_2,r_2)$ ，如果存在一个双射 $\varphi: V_1 \rightarrow V_2$ ，使得

$$
\forall u,v \in V_1,(u,v) \in E_1 \Leftrightarrow (\varphi(u),\varphi(v))  \in E_2
$$

 **且**  $\varphi(r_1)=r_2$ 成立，那么称有根树 $T_1(V_1,E_1,r_1)$ 和 $T_2(V_2,E_2,r_2)$ 同构。

### 无根树同构

对于两棵无根树 $T_1(V_1,E_1)$ 和 $T_2(V_2,E_2)$ ，如果存在一个双射 $\varphi: V_1 \rightarrow V_2$ ，使得

$$
\forall u,v \in V_1,(u,v) \in E_1 \Leftrightarrow (\varphi(u),\varphi(v))  \in E_2
$$

成立，那么称无根树 $T_1(V_1,E_1)$ 和 $T_2(V_2,E_2)$ 同构。

简单的说就是，如果能够通过把树 $T_1$ 的所有节点重新标号，使得树 $T_1$ 和树 $T_2$  **完全相同** ，那么称这两棵树同构。

## 问题的转化

无根树同构问题可以转化为有根树同构问题。具体方法如下：

对于无根树 $T_1(V_1, E_1)$ 和 $T_2(V_2,E_2)$ ，先分别找出它们的 **所有** 重心。

-   如果这两棵无根树重心数量不同，那么这两棵树不同构。
-   如果这两颗无根树重心数量都为 $1$ ，分别记为 $c_1$ 和 $c_2$ ，那么如果有根树 $T_1(V_1,E_1,c_1)$ 和有根树 $T_2(V_2,E_2,c_2)$ 同构，那么无根树 $T_1(V_1, E_1)$ 和 $T_2(V_2,E_2)$ 同构，反之则不同构。
-   如果这两颗无根树重心数量都为 $2$ ，分别记为 $c_1,c^\prime_1$ 和 $c_2,c^\prime_2$ ，那么如果有根树 $T_1(V_1,E_1,c_1)$ 和有根树 $T_2(V_2,E_2,c_2)$ 同构 **或者** 有根树 $T_1(V_1,E_1,c^\prime_1)$ 和 $T_2(V_2,E_2,c_2)$ 同构，那么无根树 $T_1(V_1, E_1)$ 和 $T_2(V_2,E_2)$ 同构，反之则不同构。

所以，只要解决了有根树同构问题，我们就可以把无根树同构问题根据上述方法转化成有根树同构的问题，进而解决无根树同构的问题。

假设有一个可以 $O(\left|V\right|)$ 解决有根树同构问题的算法，那么根据上述方法我们也可以在 $O(\left|V\right|)$ 的时间内解决无根树同构问题。

## 朴素的 AHU 算法

朴素的 AHU 算法是基于括号序的。

### 原理 1

我们知道一段合法的括号序和一棵有根树唯一对应，而且一棵树的括号序是由它的子树的括号序拼接而成的。如果我们通过改变子树括号序拼接的顺序，从而获得了一段新的括号序，那么新括号序对应的树和原括号序对应的树同构。

### 原理 2

树的同构关系是传递的。既如果 $T_1$ 和 $T_2$ 同构， $T_2$ 和 $T_3$ 同构，那么 $T_1$ 和 $T_3$ 同构。

### 推论

考虑求树括号序的递归算法，我们在回溯时拼接子树的括号序。如果在拼接的时候将字典序小的序列先拼接，并将最后的结果记为 $NAME$ 。

将以节点 $r$ 为根的子树的 $NAME$ 作为节点 $r$ 的 $NAME$ ，记为 $NAME(r)$ ，那么对于有根树 $T_1(V_1,E_1,r_1)$ 和 $T_2(V_2,E_2,r_2)$ ，如果 $NAME(r_1)=NAME(r_2)$ ，那么 $T_1$ 和 $T_2$ 同构。

### 命名算法

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{A rooted tree }T\\
2 & \textbf{Output. } \text{The name of rooted tree }T\\
3 & \text{ASSIGN-NAME(u)}\\
4 & \qquad \text{if  } u \text{  is a leaf}\\
5 & \qquad \qquad \text{NAME(} u \text{) = (0)}\\
6 & \qquad \text{else }\\
7 & \qquad \qquad \text{for all child } v \text{ of } u\\
8 & \qquad \qquad \qquad \text{ASSIGN-NAME(}v\text{)}\\
9 & \qquad \text{sort the names of the children of }u\\
10 & \qquad \text{concatenate the names of all children }u\text{ to temp}\\
11 & \qquad \text{NAME(} u \text{) = (temp)}
\end{array}
$$

### AHU 算法

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{Two rooted trees }T_1(V_1,E_1,r_1)\text{ and }T_2(V_2,E_2,r_2) \\
2 & \textbf{Output. } \text{Whether these two trees are isomorphic}\\
3 & \text{AHU}(T_1(V_1,E_1,r_1), T_2(V_2,E_2,r_2))\\
4 & \qquad \text{ASSIGN-NAME(}r_1\text{)}\\
5 & \qquad \text{ASSIGN-NAME(}r_2\text{)}\\
6 & \qquad \text{if  NAME}(r_1) = \text{NAME}(r_2)\\
7 & \qquad \qquad \text{return true}\\
8 & \qquad \text{else}\\
10 & \qquad \qquad \text{return false}
\end{array}
$$

### 复杂度证明

对于一颗有 $n$ 个节点的有根树，假设他是链状的，那么节点名字长度最长可以是 $n$ ，那么 ASSIGN-NAME 算法的复杂度是 $1+2+\cdots+n$ 的常数倍，即 $\Theta(n^2)$ 。由此，朴素 AHU 算法的复杂度为 $O(n^2)$ 。

## 优化的 AHU 算法

朴素的 AHU 算法的缺点是树的 $NAME$ 的长度可能会过长，我们可以针对这一点做一些优化。

### 原理 1

对树进行层次划分，第 $i$ 层的节点到根的最短距离为 $i$ 。位于第 $i$ 层的节点的 $NAME$ 可以 **只** 由位于第 $i+1$ 层的节点的 $NAME$ 拼接得到。

### 原理 2

在同一层内，节点的 $NAME$ 可以由其在层内的排名唯一标识。

 **注意** ，这里的排名是对两棵树而言的，假设节点 $u$ 位于第 $i$ 层，那么节点 $u$ 的排名等于所有 $T_1$ 和 $T_2$ 第 $i$ 层的节点中 $NAME$ 比 $NAME(u)$ 小的节点的个数。

### 推论

我们可以将节点原来的 $NAME$ 用其在层内的排名代替，然后把原来拼接节点 $NAME$ 用向数组加入元素代替。

这样用整数和数组来代替字符串，既不会影响算法的正确性，又很大的降低了算法的复杂度。

### 复杂度证明

首先注意到第 $i$ 层由拼接得到的 $NAME$ 的总长度为第 $i$ 层点的度数之和，即第 $i+1$ 层的总点数，以下用 $L_i$ 表示。算法的下一步会将这些 $NAME$ 看成字符串（数组）并排序，然后将它们替换为其在层内的排名（即重新映射为一个数）。以下引理表明了对总长为 $L$ 的 $m$ 个字符串排序的复杂度：

1.  我们可以使用基数排序在 $O(L+|\Sigma|)$ 的时间内完成排序，其中 $|\Sigma|$ 为字符集的大小。（有一些实现细节，参见参考资料）
2.  我们可以使用快速排序在 $O(L \log m)$ 的时间内完成排序。证明的大致思路为快排递归树的高度为 $O(\log m)$ ，且暴力比较长度为 $\ell_1$ 和 $\ell_2$ 的两个字符串的复杂度为 $O(\min\{\ell_1,\ell_2\})$ 。

在 AHU 算法中，第 $i$ 层字符串的字符集大小最多为第 $i+1$ 层的点数，即 $L_i$ ，所以基数排序的复杂度是线性的。根据 $\sum_i L_i=O(n)$ ，并将每层的复杂度相加后可以看出，若使用字符串的基数排序，则算法的总复杂度为 $T(n)=O(n)$ 。同理，如果使用快排排序字符串，那么 $T(n)=O(n \log n)$ 。

## 例题

 [SPOJ-TREEISO](https://www.spoj.com/problems/TREEISO/en/) 

题意翻译：给你两颗无根树，判断两棵树是否同构。

???+ note "参考代码"
    ```cpp
    // Tree Isomorphism, O(nlogn)
    // replace quick sort with radix sort ==> O(n)
    // Author: _Backl1ght
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int N = 1e5 + 5;
    const int maxn = N << 1;
    
    int n;
    struct Edge {
      int v, nxt;
    } e[maxn << 1];
    int head[maxn], sz[maxn], f[maxn], maxv[maxn], tag[maxn], tot, Max;
    vector<int> center[2], L[maxn], subtree_tags[maxn];
    void addedge(int u, int v) {
      e[tot].v = v;
      e[tot].nxt = head[u];
      head[u] = tot++;
      e[tot].v = u;
      e[tot].nxt = head[v];
      head[v] = tot++;
    }
    
    void dfs_size(int u, int fa) {
      sz[u] = 1;
      maxv[u] = 0;
      for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa) continue;
        dfs_size(v, u);
        sz[u] += sz[v];
        maxv[u] = max(maxv[u], sz[v]);
      }
    }
    
    void dfs_center(int rt, int u, int fa, int id) {
      maxv[u] = max(maxv[u], sz[rt] - sz[u]);
      if (Max > maxv[u]) {
        center[id].clear();
        Max = maxv[u];
      }
      if (Max == maxv[u]) center[id].push_back(u);
      for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa) continue;
        dfs_center(rt, v, u, id);
      }
    }
    
    int dfs_height(int u, int fa, int depth) {
      L[depth].push_back(u);
      f[u] = fa;
      int h = 0;
      for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa) continue;
        h = max(h, dfs_height(v, u, depth + 1));
      }
      return h + 1;
    }
    
    void init(int n) {
      for (int i = 1; i <= 2 * n; i++) head[i] = 0;
      tot = 1;
      center[0].clear();
      center[1].clear();
    
      int u, v;
      for (int i = 1; i <= n - 1; i++) {
        scanf("%d %d", &u, &v);
        addedge(u, v);
      }
      dfs_size(1, -1);
      Max = n;
      dfs_center(1, 1, -1, 0);
    
      for (int i = 1; i <= n - 1; i++) {
        scanf("%d %d", &u, &v);
        addedge(u + n, v + n);
      }
      dfs_size(1 + n, -1);
      Max = n;
      dfs_center(1 + n, 1 + n, -1, 1);
    }
    
    bool cmp(int u, int v) { return subtree_tags[u] < subtree_tags[v]; }
    
    bool rootedTreeIsomorphism(int rt1, int rt2) {
      for (int i = 0; i <= 2 * n + 1; i++) L[i].clear(), subtree_tags[i].clear();
      int h1 = dfs_height(rt1, -1, 0);
      int h2 = dfs_height(rt2, -1, 0);
      if (h1 != h2) return false;
      int h = h1 - 1;
      for (int j = 0; j < (int)L[h].size(); j++) tag[L[h][j]] = 0;
      for (int i = h - 1; i >= 0; i--) {
        for (int j = 0; j < (int)L[i + 1].size(); j++) {
          int v = L[i + 1][j];
          subtree_tags[f[v]].push_back(tag[v]);
        }
    
        sort(L[i].begin(), L[i].end(), cmp);
    
        for (int j = 0, cnt = 0; j < (int)L[i].size(); j++) {
          if (j && subtree_tags[L[i][j]] != subtree_tags[L[i][j - 1]]) ++cnt;
          tag[L[i][j]] = cnt;
        }
      }
      return subtree_tags[rt1] == subtree_tags[rt2];
    }
    
    bool treeIsomorphism() {
      if (center[0].size() == center[1].size()) {
        if (rootedTreeIsomorphism(center[0][0], center[1][0])) return true;
        if (center[0].size() > 1)
          return rootedTreeIsomorphism(center[0][0], center[1][1]);
      }
      return false;
    }
    
    int main() {
      int T;
      scanf("%d", &T);
      while (T--) {
        scanf("%d", &n);
        init(n);
        puts(treeIsomorphism() ? "YES" : "NO");
      }
      return 0;
    }
    ```

## 参考资料

本文大部分内容译自 [Paper](http://wwwmayr.in.tum.de/konferenzen/Jass08/courses/1/smal/Smal_Paper.pdf) 和 [Slide](https://logic.pdmi.ras.ru/~smal/files/smal_jass08_slides.pdf) 。参考资料里的证明会更加全面和严谨，本文做了一定的简化。

对 AHU 算法的复杂度分析，以及字符串的线性时间基数排序算法可以参见 The Design and Analysis of Computer Algorithms 的 3.2 节 Radix sorting，以及其中的 Example 3.2。

# cut
author: Ir1d, sshwy, GavinZhengOI, Planet6174, ouuan, TrisolarisHD, ylxmf2005

相关阅读： [双连通分量](./bcc.md) ，

割点和桥更严谨的定义参见 [图论相关概念](./concept.md) 。

## 割点

> 对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。

### 如何实现？

如果我们尝试删除每个点，并且判断这个图的连通性，那么复杂度会特别的高。所以要介绍一个常用的算法：Tarjan。

首先，我们上一个图：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/bridge1.png)

很容易的看出割点是 2，而且这个图仅有这一个割点。

首先，我们按照 DFS 序给他打上时间戳（访问的顺序）。

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/bridge2.png)

这些信息被我们保存在一个叫做 `num` 的数组中。

还需要另外一个数组 `low` ，用它来存储不经过其父亲能到达的最小的时间戳。

例如 `low[2]` 的话是 1， `low[5]` 和 `low[6]` 是 3。

然后我们开始 DFS，我们判断某个点是否是割点的根据是：对于某个顶点 $u$ ，如果存在至少一个顶点 $v$ （ $u$ 的儿子），使得 $low_v>=num_u$ ，即不能回到祖先，那么 $u$ 点为割点。

另外，如果搜到了自己（在环中），如果他有两个及以上的儿子，那么他一定是割点了，如果只有一个儿子，那么把它删掉，不会有任何的影响。比如下面这个图，此处形成了一个环，从树上来讲它有 2 个儿子：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/bridge3.png)

我们在访问 1 的儿子时候，假设先 DFS 到了 2，然后标记用过，然后递归往下，来到了 4，4 又来到了 3，当递归回溯的时候，会发现 3 已经被访问过了，所以不是割点。

更新 `low` 的伪代码如下：

```cpp
如果 v 是 u 的儿子 low[u] = min(low[u], low[v]);
否则
low[u] = min(low[u], num[v]);
```

### 例题

 [洛谷 P3388【模板】割点（割顶）](https://www.luogu.org/problemnew/show/P3388) 

??? "例题代码"
    ```cpp
    /*
    洛谷 P3388 【模板】割点（割顶）
    */
    #include <bits/stdc++.h>
    using namespace std;
    int n, m;  // n：点数 m：边数
    int num[100001], low[100001], inde, res;
    // num：记录每个点的时间戳
    // low：能不经过父亲到达最小的编号，inde：时间戳，res：答案数量
    bool vis[100001], flag[100001];  // flag: 答案 vis：标记是否重复
    vector<int> edge[100001];        // 存图用的
    void Tarjan(int u, int father)  // u 当前点的编号，father 自己爸爸的编号
    {
      vis[u] = true;             // 标记
      low[u] = num[u] = ++inde;  // 打上时间戳
      int child = 0;             // 每一个点儿子数量
      for (auto v : edge[u])     // 访问这个点的所有邻居 （C++11）
      {
        if (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!vis[v]) {
          child++;                       // 多了一个儿子
          Tarjan(v, u);                  // 继续
          low[u] = min(low[u], low[v]);  // 更新能到的最小节点编号
          if (father /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= u && low[v] >= num[u] &&
              /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!flag
                  [u])  // 主要代码
                        // 如果不是自己，且不通过父亲返回的最小点符合割点的要求，并且没有被标记过
                        // 要求即为：删了父亲连不上去了，即为最多连到父亲
          {
            flag[u] = true;
            res++;  // 记录答案
          }
        } else if (v /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= father)
          low[u] =
              min(low[u], num[v]);  // 如果这个点不是自己，更新能到的最小节点编号
      }
      if (father == u && child >= 2 &&
          /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!flag[u])  // 主要代码，自己的话需要 2 个儿子才可以
      {
        flag[u] = true;
        res++;  // 记录答案
      }
    }
    int main() {
      cin >> n >> m;                // 读入数据
      for (int i = 1; i <= m; i++)  // 注意点是从 1 开始的
      {
        int x, y;
        cin >> x >> y;
        edge[x].push_back(y);
        edge[y].push_back(x);
      }                             // 使用 vector 存图
      for (int i = 1; i <= n; i++)  // 因为 Tarjan 图不一定连通
        if (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!vis[i]) {
          inde = 0;      // 时间戳初始为 0
          Tarjan(i, i);  // 从第 i 个点开始，父亲为自己
        }
      cout << res << endl;
      for (int i = 1; i <= n; i++)
        if (flag[i]) cout << i << " ";  // 输出结果
      return 0;
    }
    ```

## 割边

和割点差不多，叫做桥。

> 对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边。严谨来说，就是：假设有连通图 $G=\{V,E\}$ ， $e$ 是其中一条边（即 $e \in E$ ），如果 $G-e$ 是不连通的，则边 $e$ 是图 $G$ 的一条割边（桥）。

比如说，下图中，

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![割边示例图](./images/bridge4.png)

红色箭头指向的就是割边。

### 实现

和割点差不多，只要改一处： $low_v>num_u$ 就可以了，而且不需要考虑根节点的问题。

割边是和是不是根节点没关系的，原来我们求割点的时候是指点 $v$ 是不可能不经过父节点 $u$ 为回到祖先节点（包括父节点），所以顶点 $u$ 是割点。如果 $low_v=num_u$ 表示还可以回到父节点，如果顶点 $v$ 不能回到祖先也没有另外一条回到父亲的路，那么 $u-v$ 这条边就是割边。

### 代码实现

下面代码实现了求割边，其中，当 `isbridge[x]` 为真时， `(father[x],x)` 为一条割边。

```cpp
int low[MAXN], dfn[MAXN], iscut[MAXN], dfs_clock;
bool isbridge[MAXN];
vector<int> G[MAXN];
int cnt_bridge;
int father[MAXN];

void tarjan(int u, int fa) {
  father[u] = fa;
  low[u] = dfn[u] = ++dfs_clock;
  for (int i = 0; i < G[u].size(); i++) {
    int v = G[u][i];
    if (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!dfn[v]) {
      tarjan(v, u);
      low[u] = min(low[u], low[v]);
      if (low[v] > dfn[u]) {
        isbridge[v] = true;
        ++cnt_bridge;
      }
    } else if (dfn[v] < dfn[u] && v /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= fa) {
      low[u] = min(low[u], dfn[v]);
    }
  }
}
```

## 练习

-    [P3388【模板】割点（割顶）](https://www.luogu.org/problem/P3388) 
-    [POJ2117 Electricity](https://vjudge.net/problem/POJ-2117) 
-    [HDU4738 Caocao's Bridges](https://vjudge.net/problem/HDU-4738) 
-    [HDU2460 Network](https://vjudge.net/problem/HDU-2460) 
-    [POJ1523 SPF](https://vjudge.net/problem/POJ-1523) 

Tarjan 算法还有许多用途，常用的例如求强连通分量，缩点，还有求 2-SAT 的用途等。

# dag
## 定义

边有向，无环。

英文名叫 Directed Acyclic Graph，缩写是 DAG。

## 性质

-   能 [拓扑排序](./topo.md) 的图，一定是有向无环图；

    如果有环，那么环上的任意两个节点在任意序列中都不满足条件了。

-   有向无环图，一定能拓扑排序；

    （归纳法）假设节点数不超过 $k$ 的 有向无环图都能拓扑排序，那么对于节点数等于 $k$ 的，考虑执行拓扑排序第一步之后的情形即可。

## 判定

如何判定一个图是否是有向无环图呢？

检验它是否可以进行 [拓扑排序](./topo.md) 即可。

当然也有另外的方法，可以对图进行一遍 [DFS](../search/dfs.md) ，在得到的 DFS 树上看看有没有连向祖先的非树边（返祖边）。如果有的话，那就有环了。

# virtual-tree
author: HeRaNO, Ir1d, konnyakuxzy, ksyx, Xeonacid, konnyakuxzy, greyqz

## 引子

???+ note "[「SDOI2011」消耗战](https://www.luogu.org/problem/P2495)"
    ### 题目描述
    
    在一场战争中，战场由 $n$ 个岛屿和 $n-1$ 个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为 $1$ 的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他 $k$ 个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。
    
    侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到 $1$ 号岛屿上）。不过侦查部门还发现了这台机器只能够使用 $m$ 次，所以我们只需要把每次任务完成即可。
    
    ### 输入格式
    
    第一行一个整数 $n$ ，代表岛屿数量。
    
    接下来 n-1 行，每行三个整数 $u,v,w$ ，代表 $u$ 号岛屿和 $v$ 号岛屿由一条代价为 $c$ 的桥梁直接相连，保证 $1\le u,v\le n$ 且 $1\le c\le 10^5$ 。
    
    第 $n+1$ 行，一个整数 $m$ ，代表敌方机器能使用的次数。
    
    接下来 $m$ 行，每行一个整数 $k_i$ ，代表第 $i$ 次后，有 $k_i$ 个岛屿资源丰富，接下来 $k$ 个整数 $h_1,h_2,\cdots ,h_k$ ，表示资源丰富岛屿的编号。
    
    ### 输出格式
    
    输出有 $m$ 行，分别代表每次任务的最小代价。
    
    ### 输入样例
    
    ```text
    10
    1 5 13
    1 9 6
    2 1 19
    2 4 8
    2 3 91
    5 6 8
    7 5 4
    7 8 31
    10 7 9
    3
    2 10 6
    4 5 7 8 3
    3 9 4 6
    ```
    
    ### 输出样例
    
    ```text
    12
    32
    22
    ```
    
    ### 数据范围
    
    对于 $100\%$ 的数据， $2\le n\le 2.5\times 10^5,m\ge 1,\sum k_i\le 5\times 10^5,1\le k_i\le n-1$ 。

## 虚树 Virtual Tree

对于上面那题，我们不难发现——如果树的点数很少，那么我们可以直接跑 DP。

首先我们称某次询问中被选中的点为—— **「关键点」** 。

设 $Dp[i]$ 表示——使 $i$ 不与其子树中任意一个关键点连通的 **最小代价** 。

设 $w[a,b]$ 表示 $a$ 与 $b$ 之间的边的权值。

则：

-   若 $son[i]$ 不是关键点： $Dp[i]=Dp[i] + \min \{Dp[son[i]],w[i,son[i]]\}$ ；
-   若 $son[i]$ 是关键点： $Dp[i]=Dp[i] + w[i,son[i]]$ 。

很好，这样我们得到了一份 $O(n\times q)$ 的代码。

听起来很有意思。

我们不难发现——其实很多点是没有用的。

比如下图：

![vtree1](./images/vtree1.png)

图中只有两个红色的点是 **关键点** ，而别的黑色的点全都是「非关键点」。一号节点（敌人所在之处）是树顶的那个标了 $1$ 的节点。

对于这题来说，我们只需要保证红色的点无法到达 $1$ 号节点就行了。

通过肉眼观察可以得出结论—— $1$ 号节点的右子树（虽然实际上可能有多个子树，但这里只有两个子树，所以暂时这么称呼了）一个红色节点都木有， **所以没必要去 DP 它** ，不是吗？

观察题目给出的条件，红色点（关键点）的总数是与 $n$ 同阶的，也就是说实际上一次询问中红色的点对于整棵树来说是很稀疏的，所以如果我们能让复杂度由红色点的总数来决定就好了。

因此我们需要 **浓缩信息，把一整颗大树浓缩成一颗小树** 。

由此我们引出了 **「虚树」** 这个概念。

我们先直观地来看看虚树的样子。

下图中，左边为原树，右边为生成的新的虚树。

![vtree2](./images/vtree2.png)

![vtree3](./images/vtree3.png)

![vtree4](./images/vtree4.png)

![vtree5](./images/vtree5.png)

看明白了吗？

因为任意两个关键点的 LCA 也是需要保存重要信息的，所以我们需要保存它们的 LCA，也就是虚树中不一定只有关键点。

不难发现虚树中祖先 -> 后代的关系并不会改变。（就是不会出现原本 $a$ 是 $b$ 的祖先结果后面 $a$ 变成 $b$ 的后代了之类的鬼事）

但我们不可能 $O(k^2)$ 暴力枚举 LCA，所以我们不难想到——首先将关键点按 DFS 序排序，然后排完序以后相邻的两个关键点（相邻指的是在排序后的序列中下表差值的绝对值等于 1）求一下 LCA，并把它加入虚树。

因为可能多个节点的 LCA 可能是同一个，所以我们不能多次将它加入虚树。

非常直观的一个方法是：

-   将关键点按 DFS 序排序；
-    `for` 一遍，任意两个相邻的关键点求一下 LCA，并且哈希表判重；
-   然后根据原树中的祖先 -> 后代关系建树（然而我并不知道怎么建树）。

……

感觉很不可做的样子。&lt;(=┘~Д~)┘╧═╧

所以，这里我们提出一种用单调栈的做法。

在提出方案之前，我们先确认一个事实——在虚树里，只要保证祖先 -> 后代的关系没有改变，就可以随意添加节点。

也就是，如果我们乐意，我们可以把原树中所有的点都加入虚树中，也不会导致 WA（虽然会导致 TLE）。

因此，我们为了方便，可以首先将 $1$ 号节点加入虚树中，并且并不会影响答案。

好，开始讲怎么用单调栈来建立一棵虚树吧。

首先我们要明确一个目的——我们要用单调栈来维护一条虚树上的链。

也就是一个栈里相邻的两个节点在虚树上也是相邻的，而且栈是从底部到栈首单调递增的（指的是栈中节点 DFS 序单调递增），说白了就是某个节点的父亲就是栈中它下面的那个节点。

![vtree7](./images/vtree7.png)

首先我们在栈中添加节点 $1$ 。

然后接下来按照 DFS 序从小到大添加关键节点。

假如当前的节点与栈顶节点的 LCA 就是栈顶节点的话，则说明它们是在一条链上的。所以直接把当前节点入栈就行了。

![vtree8](./images/vtree8.png)

假如当前节点与栈顶节点的 LCA 不是栈顶节点的话，比如这样——

![vtree9](./images/vtree9.png)

那就……非常尴尬了

显然，当前单调栈维护的链是：

![vtree10](./images/vtree10.png)

而我们需要把链变成：

![vtree11](./images/vtree11.png)

那么我们就虚树中连上这些边：

![vtree11（复件）](./images/vtree12.png)

并且把这两个点从栈中弹出：

![vtree13](./images/vtree13.png)

假如弹出以后发现栈首不是 LCA 的话要让 LCA 入栈。

再把当前节点入栈就行了。

打个比方吧。

假如那棵树长这样：

![vtree6](./images/vtree6.png)

那么步骤是这样的：

-   将 3 个关键点 $6,4,7$ （我故意打乱了）按照 DFS 序排序，得到序列 $4,6,7$ 。
-   将点 $1$ 入栈。
-   取序列第一个作为当前节点，为 $4$ 。再取栈顶元素，为 $1$ 。求 $1$ 和 $4$ 的 $LCA$ ： $LCA(1,4)=1$ 。
-   发现 $LCA(1,4)=$ 栈顶元素，说明它们在虚树的一条链上，所以直接把当前节点 $4$ 入栈，当前栈为 $4,1$ 。
-   取序列第二个作为当前节点，为 $6$ 。再取栈顶元素，为 $4$ 。求 $6$ 和 $4$ 的 $LCA$ ： $LCA(6,4)=1$ 。
-   发现 $LCA(6,4)\neq$ 栈顶元素，进入判断阶段。
-   判断阶段：发现栈顶节点 $4$ 的 DFS 序是大于 $LCA(6,4)$ 的，但是次大节点（栈顶节点下面的那个节点） $1$ 的 DFS 序是等于 $LCA$ 的（其实 DFS 序相等说明节点也相等），说明 $LCA$ 已经入栈了，所以直接连接 $1->4$ 的边，也就是 $LCA$ 到栈顶元素的边。并把 $4$ 从栈中弹出。
-   结束了判断阶段，将 $6$ 入栈，当前栈为 $6,1$ 。
-   取序列第三个作为当前节点，为 $7$ 。再取栈顶元素，为 $6$ 。求 $7$ 和 $6$ 的 $LCA$ ： $LCA(7,6)=3$ 。
-   发现 $LCA(7,6)\neq$ 栈顶元素，进入判断阶段。
-   判断阶段：发现栈顶节点 $6$ 的 DFS 序是大于 $LCA(7,6)$ 的，但是次大节点（栈顶节点下面的那个节点） $1$ 的 DFS 序是小于 $LCA$ 的，说明 $LCA$ 还没有入过栈，所以直接连接 $3->6$ 的边，也就是 $LCA$ 到栈顶元素的边。把 $6$ 从栈中弹出，并且把 $LCA(6,7)$ 入栈。
-   结束了判断阶段，将 $7$ 入栈，当前栈为 $1,3,7$ 。
-   发现序列里的 3 个节点已经全部加入过栈了，退出循环。
-   此时栈中还有 3 个节点： $1, 3,7$ ，很明显它们是一条链上的，所以直接链接： $1->3$ 和 $3->7$ 的边。
-   虚树就建完啦！

其中有很多细节，比如我是用邻接表存图的方式存虚树的，所以需要清空邻接表。但是直接清空整个邻接表是很慢的，所以我们在 **有一个从未入栈的元素入栈的时候清空该元素对应的邻接表** 即可。

建立虚树的 C++ 代码大概长这样：

```cpp
sort(h + 1, h + 1 + k, cmp);
sta[top = 1] = 1, g.sz = 0, g.head[1] = -1;
// 1号节点入栈，清空1号节点对应的邻接表，设置邻接表边数为1
for (int i = 1, l; i <= k; i += 1)
  if (h[i] != 1)  //如果1号节点是关键节点就不要重复添加
  {
    l = lca(h[i], sta[top]);  //计算当前节点与栈顶节点的LCA
    if (l != sta[top]) {
      //如果LCA和栈顶元素不同，则说明当前节点不再当前栈所存的链上
      while (id[l] < id[sta[top - 1]])
        //当次大节点的Dfs序大于LCA的Dfs序
        g.push(sta[top - 1], sta[top]), top--;
      //把与当前节点所在的链不重合的链连接掉并且弹出
      if (id[l] > id[sta[top - 1]])
        //如果LCA不等于次大节点（这里的大于其实和不等于没有区别）
        g.head[l] = -1, g.push(l, sta[top]), sta[top] = l;
      //说明LCA是第一次入栈，清空其邻接表，连边后弹出栈顶元素，并将LCA入栈
      else
        g.push(l, sta[top--]);
      //说明LCA就是次大节点，直接弹出栈顶元素
    }
    g.head[h[i]] = -1, sta[++top] = h[i];
    //当前节点必然是第一次入栈，清空邻接表并入栈
  }
for (int i = 1; i < top; i += 1)
  g.push(sta[i], sta[i + 1]);  //剩余的最后一条链连接一下
```

于是我们就学会了虚树的建立了！

对于消耗战这题，直接在虚树上跑最开始讲的那个 DP 就行了，我们等于利用了虚树排除了那些没用的非关键节点！

-   若 $son[i]$ 不是关键点： $Dp[i]=Dp[i] + \min \{Dp[son[i]],w[i,son[i]]\}$ 
-   若 $son[i]$ 是关键点： $Dp[i]=Dp[i] + w[i,son[i]]$ 

于是这题很简单就过了。

代码看下面。

## 推荐习题

### BZOJ - 2286 消耗战

代码：

```cpp
#include <bits/stdc++.h>

#define NS (250005)
#define LGS (18)

using namespace std;

typedef long long LL;

template <typename _Tp>
inline void IN(_Tp& dig) {
  char c;
  bool flag = 0;
  dig = 0;
  while (c = getchar(), !isdigit(c))
    if (c == '-') flag = 1;
  while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
  if (flag) dig = -dig;
}

struct graph {
  int head[NS], nxt[NS << 1], to[NS << 1], w[NS << 1], sz;
  void init() { memset(head, -1, sizeof(head)), sz = 0; }
  graph() { init(); }
  void push(int a, int b, int c) {
    nxt[sz] = head[a], to[sz] = b, w[sz] = c, head[a] = sz++;
  }
  int& operator[](const int a) { return to[a]; }
} g;

int n, pre[NS][LGS + 1], dep[NS], mx[NS][LGS + 1], id[NS], dfn;

int m, k, h[NS], sta[NS], top, MX;

LL f[NS];

bool book[NS];

void Init(int a, int fa) {
  pre[a][0] = fa, dep[a] = dep[fa] + 1, id[a] = ++dfn;
  for (int i = 1; i <= LGS; i += 1) {
    pre[a][i] = pre[pre[a][i - 1]][i - 1];
    mx[a][i] = min(mx[a][i - 1], mx[pre[a][i - 1]][i - 1]);
  }
  for (int i = g.head[a]; ~i; i = g.nxt[i])
    if (g[i] != fa) mx[g[i]][0] = g.w[i], Init(g[i], a);
}

int lca(int a, int b) {
  MX = INT_MAX;
  if (dep[a] > dep[b]) swap(a, b);
  for (int i = LGS; i >= 0; i -= 1)
    if (dep[pre[b][i]] >= dep[a]) MX = min(MX, mx[b][i]), b = pre[b][i];
  if (a == b) return a;
  for (int i = LGS; i >= 0; i -= 1)
    if (pre[a][i] != pre[b][i]) {
      MX = min(MX, min(mx[a][i], mx[b][i]));
      a = pre[a][i], b = pre[b][i];
    }
  return pre[a][0];
}

bool cmp(int a, int b) { return id[a] < id[b]; }

void Dp(int a) {
  f[a] = 0;
  for (int i = g.head[a]; ~i; i = g.nxt[i]) {
    Dp(g[i]);
    if (book[g[i]])
      f[a] += g.w[i];
    else
      f[a] += min((LL)g.w[i], f[g[i]]);
  }
}

int main(int argc, char const* argv[]) {
  IN(n);
  for (int i = 1, a, b, c; i < n; i += 1)
    IN(a), IN(b), IN(c), g.push(a, b, c), g.push(b, a, c);
  Init(1, 0), IN(m);
  while (m--) {
    IN(k);
    for (int i = 1; i <= k; i += 1) IN(h[i]), book[h[i]] = 1;
    sort(h + 1, h + 1 + k, cmp);
    sta[top = 1] = 1, g.sz = 0, g.head[1] = -1;
    for (int i = 1, l; i <= k; i += 1)
      if (h[i] != 1) {
        l = lca(sta[top], h[i]);
        if (l != sta[top]) {
          while (id[l] < id[sta[top - 1]]) {
            lca(sta[top - 1], sta[top]);
            g.push(sta[top - 1], sta[top], MX);
            top--;
          }
          if (id[l] > id[sta[top - 1]]) {
            g.head[l] = -1, lca(l, sta[top]);
            g.push(l, sta[top], MX), sta[top] = l;
          } else
            lca(l, sta[top]), g.push(l, sta[top--], MX);
        }
        g.head[h[i]] = -1, sta[++top] = h[i];
      }
    for (int i = 1; i < top; i += 1)
      lca(sta[i], sta[i + 1]), g.push(sta[i], sta[i + 1], MX);
    Dp(1), printf("%lld\n", f[1]);
    for (int i = 1; i <= k; i += 1) book[h[i]] = 0;
  }
  return 0;
}
```

### BZOJ - 3611 大工程

代码：

```cpp
#include <bits/stdc++.h>

#define NS (1000005)
#define LGS (20)

#define INF (100000000)

using namespace std;

typedef long long LL;

template <typename _Tp>
inline void IN(_Tp& dig) {
  char c;
  bool flag = 0;
  dig = 0;
  while (c = getchar(), !isdigit(c))
    if (c == '-') flag = 1;
  while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
  if (flag) dig = -dig;
}

struct graph {
  int head[NS], nxt[NS << 1], to[NS << 1], sz;
  void init() { memset(head, -1, sizeof(head)), sz = 0; }
  graph() { init(); }
  void push(int a, int b) { nxt[sz] = head[a], to[sz] = b, head[a] = sz++; }
  int operator[](const int a) { return to[a]; }
} g;

int n, id[NS], dfn, q, k, h[NS], sz[NS], mn[NS], mx[NS], mnans, mxans;

int pre[NS][LGS + 1], dep[NS];

int sta[NS], top;

bool book[NS];

LL f[NS], tot;

void Init(int a, int fa) {
  pre[a][0] = fa, dep[a] = dep[fa] + 1, id[a] = ++dfn;
  for (int i = 1; i <= LGS; i += 1) pre[a][i] = pre[pre[a][i - 1]][i - 1];
  for (int i = g.head[a]; ~i; i = g.nxt[i])
    if (g[i] != fa) Init(g[i], a);
}

int lca(int a, int b) {
  if (dep[a] > dep[b]) swap(a, b);
  for (int i = LGS; i >= 0; i -= 1)
    if (dep[pre[b][i]] >= dep[a]) b = pre[b][i];
  if (a == b) return a;
  for (int i = LGS; i >= 0; i -= 1)
    if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i];
  return pre[a][0];
}

bool cmp(int a, int b) { return id[a] < id[b]; }

void Dp(int a) {
  sz[a] = book[a], f[a] = 0;
  if (book[a])
    mn[a] = mx[a] = 0;
  else
    mn[a] = INF, mx[a] = -INF;
  for (int i = g.head[a], l; ~i; i = g.nxt[i]) {
    Dp(g[i]), l = dep[g[i]] - dep[a];
    tot += (f[a] + sz[a] * l) * sz[g[i]] + f[g[i]] * sz[a];
    sz[a] += sz[g[i]], f[a] += f[g[i]] + l * sz[g[i]];
    mnans = min(mnans, mn[a] + mn[g[i]] + l);
    mxans = max(mxans, mx[a] + mx[g[i]] + l);
    mn[a] = min(mn[a], mn[g[i]] + l);
    mx[a] = max(mx[a], mx[g[i]] + l);
  }
}

int main(int argc, char const* argv[]) {
  IN(n);
  for (int i = 1, a, b; i < n; i += 1) IN(a), IN(b), g.push(a, b), g.push(b, a);
  Init(1, 0), IN(q);
  while (q--) {
    IN(k);
    for (int i = 1; i <= k; i += 1) IN(h[i]), book[h[i]] = 1;
    sort(h + 1, h + 1 + k, cmp);
    sta[top = 1] = 1, g.sz = 0, g.head[1] = -1;
    for (int i = 1, l; i <= k; i += 1)
      if (h[i] != 1) {
        l = lca(h[i], sta[top]);
        if (l != sta[top]) {
          while (id[l] < id[sta[top - 1]])
            g.push(sta[top - 1], sta[top]), top--;
          if (id[l] > id[sta[top - 1]])
            g.head[l] = -1, g.push(l, sta[top]), sta[top] = l;
          else
            g.push(l, sta[top--]);
        }
        g.head[h[i]] = -1, sta[++top] = h[i];
      }
    for (int i = 1; i < top; i += 1) g.push(sta[i], sta[i + 1]);
    mnans = INF, mxans = -INF, tot = 0, Dp(1);
    printf("%lld %d %d\n", tot, mnans, mxans);
    for (int i = 1; i <= k; i += 1) book[h[i]] = 0;
  }
  return 0;
}
```

### CF613D Kingdom and its Cities

代码：

```cpp
#include <bits/stdc++.h>

#define NS (100005)
#define LGS (17)

using namespace std;

template <typename _Tp>
inline void IN(_Tp& dig) {
  char c;
  bool flag = 0;
  dig = 0;
  while (c = getchar(), !isdigit(c))
    if (c == '-') flag = 1;
  while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
  if (flag) dig = -dig;
}

struct graph {
  int head[NS], nxt[NS << 1], to[NS << 1], sz;
  void init() { memset(head, -1, sizeof(head)), sz = 0; }
  graph() { init(); }
  void push(int a, int b) { nxt[sz] = head[a], to[sz] = b, head[a] = sz++; }
  int operator[](const int a) { return to[a]; }
} g;

int n, id[NS], dfn, q, k, h[NS], c[NS];

int pre[NS][LGS + 1], dep[NS];

int sta[NS], top;

bool book[NS];

void Init(int a, int fa) {
  pre[a][0] = fa, dep[a] = dep[fa] + 1, id[a] = ++dfn;
  for (int i = 1; i <= LGS; i += 1) pre[a][i] = pre[pre[a][i - 1]][i - 1];
  for (int i = g.head[a]; ~i; i = g.nxt[i])
    if (g[i] != fa) Init(g[i], a);
}

int lca(int a, int b) {
  if (dep[a] > dep[b]) swap(a, b);
  for (int i = LGS; i >= 0; i -= 1)
    if (dep[pre[b][i]] >= dep[a]) b = pre[b][i];
  if (a == b) return a;
  for (int i = LGS; i >= 0; i -= 1)
    if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i];
  return pre[a][0];
}

bool cmp(int a, int b) { return id[a] < id[b]; }

int Dp(int a) {
  int tot = 0, ans = 0;
  for (int i = g.head[a]; ~i; i = g.nxt[i]) ans += Dp(g[i]), tot += c[g[i]];
  if (book[a])
    c[a] = 1, ans += tot;
  else if (tot > 1)
    c[a] = 0, ans++;
  else
    c[a] = tot;
  return ans;
}

int main(int argc, char const* argv[]) {
  IN(n);
  for (int i = 1, a, b; i < n; i += 1) IN(a), IN(b), g.push(a, b), g.push(b, a);
  Init(1, 0), IN(q);
  while (q--) {
    IN(k);
    for (int i = 1; i <= k; i += 1) IN(h[i]), book[h[i]] = 1;
    for (int i = 1; i <= k; i += 1)
      if (book[pre[h[i]][0]]) {
        puts("-1");
        goto end;
      }
    sort(h + 1, h + 1 + k, cmp);
    sta[top = 1] = 1, g.sz = 0, g.head[1] = -1;
    for (int i = 1, l; i <= k; i += 1)
      if (h[i] != 1) {
        l = lca(h[i], sta[top]);
        if (l != sta[top]) {
          while (id[l] < id[sta[top - 1]])
            g.push(sta[top - 1], sta[top]), top--;
          if (id[l] > id[sta[top - 1]])
            g.head[l] = -1, g.push(l, sta[top]), sta[top] = l;
          else
            g.push(l, sta[top--]);
        }
        g.head[h[i]] = -1, sta[++top] = h[i];
      }
    for (int i = 1; i < top; i += 1) g.push(sta[i], sta[i + 1]);
    printf("%d\n", Dp(1));
  end:
    for (int i = 1; i <= k; i += 1) book[h[i]] = 0;
  }
  return 0;
}
```

### BZOJ - 3572 世界树

（丧心病狂啊）

代码：

```cpp
#include <bits/stdc++.h>

#define NS (300005)
#define LGS (19)
#define FIR first
#define SEC second

using namespace std;

typedef pair<int, int> PII;

template <typename _Tp>
inline void IN(_Tp& dig) {
  char c;
  bool flag = 0;
  dig = 0;
  while (c = getchar(), !isdigit(c))
    if (c == '-') flag = 1;
  while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
  if (flag) dig = -dig;
}

struct graph {
  int head[NS], nxt[NS << 1], to[NS << 1], sz;
  void init() { memset(head, -1, sizeof(head)), sz = 0; }
  graph() { init(); }
  void push(int a, int b) { nxt[sz] = head[a], to[sz] = b, head[a] = sz++; }
  int operator[](const int a) { return to[a]; }
} g;

int n, m, q, h[NS], arr[NS], ans[NS];

int pre[NS][LGS + 1], dep[NS], id[NS], dfn, sz[NS];

int st[NS], top;

bool book[NS];

PII mx[NS];

bool cmp(int a, int b) { return id[a] < id[b]; }

void Init(int a, int fa) {
  pre[a][0] = fa, dep[a] = dep[fa] + 1, id[a] = ++dfn, sz[a] = 1;
  for (int i = 1; i <= LGS; i += 1) pre[a][i] = pre[pre[a][i - 1]][i - 1];
  for (int i = g.head[a]; ~i; i = g.nxt[i])
    if (g[i] != fa) Init(g[i], a), sz[a] += sz[g[i]];
}

int jump(int a, int k) {
  for (int i = 0; i <= LGS; i += 1)
    if ((k >> i) & 1) a = pre[a][i];
  return a;
}

int lca(int a, int b) {
  if (dep[a] > dep[b]) swap(a, b);
  b = jump(b, dep[b] - dep[a]);
  if (a == b) return a;
  for (int i = LGS; i >= 0; i -= 1)
    if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i];
  return pre[a][0];
}

void dfs1(int a) {
  if (book[a])
    mx[a] = PII(0, a);
  else
    mx[a] = PII(1e8, 0);
  for (int i = g.head[a]; ~i; i = g.nxt[i]) {
    dfs1(g[i]);
    PII tmp = mx[g[i]];
    tmp.FIR = dep[mx[g[i]].SEC] - dep[a];
    mx[a] = min(mx[a], tmp);
  }
}

void dfs2(int a) {
  for (int i = g.head[a]; ~i; i = g.nxt[i]) {
    PII tmp = mx[a];
    tmp.FIR += dep[g[i]] - dep[a];
    mx[g[i]] = min(mx[g[i]], tmp), dfs2(g[i]);
  }
  ans[mx[a].SEC] = max(ans[mx[a].SEC], sz[a]);
}

void dfs3(int a) {
  for (int i = g.head[a], x, y, dis, z; ~i; i = g.nxt[i]) {
    if (x = mx[a].SEC, y = mx[g[i]].SEC, x != y) {
      dis = dep[x] + dep[y] - (dep[lca(x, y)] << 1);
      z = jump(g[i], (dis >> 1) - mx[g[i]].FIR);
      if (dis & 1)
        ans[x] -= sz[z];
      else {
        if (z != a && z != g[i])
          z = jump(g[i], (dis >> 1) - mx[g[i]].FIR - (x < y));
        else if (z == a)
          z = jump(g[i], (dis >> 1) - mx[g[i]].FIR - 1);
        ans[x] -= sz[z];
      }
      if (g[i] != z) ans[y] += sz[z] - sz[g[i]];
    }
    dfs3(g[i]);
  }
}

int main(int argc, char const* argv[]) {
  IN(n);
  for (int i = 1, a, b; i < n; i += 1) IN(a), IN(b), g.push(a, b), g.push(b, a);
  Init(1, 0), IN(q);
  while (q--) {
    IN(m), g.sz = 0;
    for (int i = 1; i <= m; i += 1)
      IN(h[i]), book[h[i]] = 1, ans[arr[i] = h[i]] = 0;
    sort(h + 1, h + 1 + m, cmp), st[top = 1] = 1, g.head[1] = -1;
    for (int i = 1, l; i <= m; i += 1) {
      if (h[i] == 1) continue;
      l = lca(st[top], h[i]);
      if (l != st[top]) {
        while (id[l] < id[st[top - 1]]) g.push(st[top - 1], st[top]), top--;
        if (id[l] > id[st[top - 1]])
          g.head[l] = -1, g.push(l, st[top]), st[top] = l;
        else
          g.push(l, st[top--]);
      }
      g.head[h[i]] = -1, st[++top] = h[i];
    }
    for (int i = 1; i < top; i += 1) g.push(st[i], st[i + 1]);
    dfs1(1), dfs2(1), dfs3(1);
    for (int i = 1; i <= m; i += 1) printf("%d ", ans[arr[i]]);
    putchar(10);
    for (int i = 1; i <= m; i += 1) book[h[i]] = 0;
  }
  return 0;
}
```

# bcc
## 简介

在阅读下列内容之前，请务必了解 [图论相关概念](./concept.md) 部分。

相关阅读： [割点和桥](./cut.md) 

## 定义

割点和桥更严谨的定义参见 [图论相关概念](./concept.md) 。

在一张连通的无向图中，对于两个点 $u$ 和 $v$ ，如果无论删去哪条边（只能删去一条）都不能使它们不连通，我们就说 $u$ 和 $v$  **边双连通** 。

在一张连通的无向图中，对于两个点 $u$ 和 $v$ ，如果无论删去哪个点（只能删去一个，且不能删 $u$ 和 $v$ 自己）都不能使它们不连通，我们就说 $u$ 和 $v$  **点双连通** 。

边双连通具有传递性，即，若 $x,y$ 边双连通， $y,z$ 边双连通，则 $x,z$ 边双连通。

点双连通 **不** 具有传递性，反例如下图， $A,B$ 点双连通， $B,C$ 点双连通，而 $A,C$  **不** 点双连通。

![bcc-counterexample.png](./images/bcc-0.svg)

## DFS

对于一张连通的无向图，我们可以从任意一点开始 DFS，得到原图的一棵生成树（以开始 DFS 的那个点为根），这棵生成树上的边称作 **树边** ，不在生成树上的边称作 **非树边** 。

由于 DFS 的性质，我们可以保证所有非树边连接的两个点在生成树上都满足其中一个是另一个的祖先。

DFS 的代码如下：

```cpp
void DFS(int p) {
  visited[p] = true;
  for (int to : edge[p])
    if (!visited[to]) DFS(to);
}
```

## DFS 找桥并判断边双连通

首先，对原图进行 DFS。

![bcc-1.png](./images/bcc-1.svg)

如上图所示，黑色与绿色边为树边，红色边为非树边。每一条非树边连接的两个点都对应了树上的一条简单路径，我们说这条非树边 **覆盖** 了这条树上路径上所有的边。绿色的树边 **至少** 被一条非树边覆盖，黑色的树边不被 **任何** 非树边覆盖。

我们如何判断一条边是不是桥呢？显然，非树边和绿色的树边一定不是桥，黑色的树边一定是桥。

如何用算法去实现以上过程呢？首先有一个比较暴力的做法，对于每一条非树边，都逐个地将它覆盖的每一条树边置成绿色，这样的时间复杂度为 $O(nm)$ 。

怎么优化呢？可以用差分。对于每一条非树边，在其树上深度较小的点处打上 `-1` 标记，在其树上深度较大的点处打上 `+1` 标记。然后 $O(n)$ 求出每个点的子树内部的标记之和。对于一个点 $u$ ，其子树内部的标记之和等于覆盖了 $u$ 和 $u$ 的父亲之间的树边的非树边数量。若这个值非 $0$ ，则 $u$ 和 $u$ 的父亲之间的树边不是桥，否则是桥。

用以上的方法 $O(n+m)$ 求出每条边分别是否是桥后，两个点是边双连通的，当且仅当它们的树上路径中 **不** 包含桥。

## DFS 找割点并判断点双连通

![bcc-2.png](./images/bcc-2.svg)

如上图所示，黑色边为树边，红色边为非树边。每一条非树边连接的两个点都对应了树上的一条简单路径。

考虑一张新图，新图中的每一个点对应原图中的每一条树边（在上图中用蓝色点表示）。对于原图中的每一条非树边，将这条非树边对应的树上简单路径中的所有边在新图中对应的蓝点连成一个连通块（这在上图中也用蓝色的边体现出来了）。

这样，一个点不是桥，当且仅当与其相连的所有边在新图中对应的蓝点都属于同一个连通块。两个点点双连通，当且仅当它们在原图的树上路径中的所有边在新图中对应的蓝点都属于同一个连通块。

蓝点间的连通关系可以用与求边双连通时用到的差分类似的方法维护，时间复杂度 $O(n+m)$ 。

# node
author: Anguei, sshwy, Xeonacid, Ir1d, MonkeyOliver, hsfzLZH1

拆点是一种图论建模思想，常用于 [网络流](./flow.md) ，用来处理 **点权或者点的流量限制** 的问题，也常用于 **分层图** 。

## 结点有流量限制的最大流

如果把结点转化成边，那么这个问题就可以套板子解决了。

我们考虑把有流量限制的结点转化成这样一种形式：由两个结点 $u,v$ 和一条边 $<u,v>$ 组成的部分。其中，结点 $u$ 承接所有从原图上其他点的出发到原图上该点的边，结点 $v$ 引出所有从原图上该点出发到达原图上其他点的边。边 $<u,v>$ 的流量限制为原图该点的流量限制，再套板子就可以解决本题。这就是拆点的基本思想。

如果原图是这样：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/node1.png)

拆点之后的图是这个样子：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/node2.png)

## 分层图最短路

分层图最短路，如：有 $k$ 次零代价通过一条路径，求总的最小花费。对于这种题目，我们可以采用 DP 相关的思想，设 $\text{dis}_{i, j}$ 表示当前从起点 $i$ 号结点，使用了 $j$ 次免费通行权限后的最短路径。显然， $\text{dis}$ 数组可以这么转移：

 $\text{dis}_{i, j} = \min\{\min\{\text{dis}_{from, j - 1}\}, \min\{\text{dis}_{from,j} + w\}\}$ 

其中， $from$ 表示 $i$ 的父亲节点， $w$ 表示当前所走的边的边权。当 $j - 1 \geq k$ 时， $\text{dis}_{from, j}$ = $\infty$ 。

事实上，这个 DP 就相当于把每个结点拆分成了 $k+1$ 个结点，每个新结点代表使用不同多次免费通行后到达的原图结点。换句话说，就是每个结点 $u_i$ 表示使用 $i$ 次免费通行权限后到达 $u$ 结点。

??? note "[「JLOI2011」飞行路线](https://www.luogu.org/problem/P4568)"

    题意：有一个 $n$ 个点 $m$ 条边的无向图，你可以选择 $k$ 条道路以零代价通行，求 $s$ 到 $t$ 的最小花费。

    参考核心代码：

    ```cpp
    struct State {    // 优先队列的结点结构体
      int v, w, cnt;  // cnt 表示已经使用多少次免费通行权限
      State() {}
      State(int v, int w, int cnt) : v(v), w(w), cnt(cnt) {}
      bool operator<(const State &rhs) const { return w > rhs.w; }
    };

    void dijkstra() {
      memset(dis, 0x3f, sizeof dis);
      dis[s][0] = 0;
      pq.push(State(s, 0, 0));  // 到起点不需要使用免费通行权，距离为零
      while (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!pq.empty()) {
        const State top = pq.top();
        pq.pop();
        int u = top.v, nowCnt = top.cnt;
        if (done[u][nowCnt]) continue;
        done[u][nowCnt] = true;
        for (int i = head[u]; i; i = edge[i].next) {
          int v = edge[i].v, w = edge[i].w;
          if (nowCnt < k && dis[v][nowCnt + 1] > dis[u][nowCnt]) {  // 可以免费通行
            dis[v][nowCnt + 1] = dis[u][nowCnt];
            pq.push(State(v, dis[v][nowCnt + 1], nowCnt + 1));
          }
          if (dis[v][nowCnt] > dis[u][nowCnt] + w) {  // 不可以免费通行
            dis[v][nowCnt] = dis[u][nowCnt] + w;
            pq.push(State(v, dis[v][nowCnt], nowCnt));
          }
        }
      }
    }

    int main() {
      n = read(), m = read(), k = read();
      // 笔者习惯从 1 到 n 编号，而这道题是从 0 到 n - 1，所以要处理一下
      s = read() + 1, t = read() + 1;
      while (m--) {
        int u = read() + 1, v = read() + 1, w = read();
        add(u, v, w), add(v, u, w);  // 这道题是双向边
      }
      dijkstra();
      int ans = std::numeric_limits<int>::max();  // ans 取 int 最大值为初值
      for (int i = 0; i <= k; ++i)
        ans = std::min(ans, dis[t][i]);  // 对到达终点的所有情况取最优值
      println(ans);
    }
    ```

# concept
本页面概述了图论中的一些概念，这些概念并不全是在 OI 中常见的，对于 OIer 来说，只需掌握本页面中的基础部分即可，如果在学习中碰到了不懂的概念，可以再来查阅。

!!! warning
    图论相关定义在不同教材中往往会有所不同，遇到的时候需根据上下文加以判断。

## 图

 **图 (Graph)** 是一个二元组 $G=(V(G), E(G))$ 。其中 $V(G)$ 是非空集，称为 **点集 (Vertex set)** ，对于 $V$ 中的每个元素，我们称其为 **顶点 (Vertex)** 或 **节点 (Node)** ，简称 **点** ； $E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 **边集 (Edge set)** 。

常用 $G=(V,E)$ 表示图。

当 $V,E$ 都是有限集合时，称 $G$ 为 **有限图** 。

当 $V$ 或 $E$ 是无限集合时，称 $G$ 为 **无限图** 。

图有多种，包括 **无向图 (Undirected graph)** ， **有向图 (Directed graph)** ， **混合图 (Mixed graph)** 等

若 $G$ 为无向图，则 $E$ 中的每个元素为一个无序二元组 $(u, v)$ ，称作 **无向边 (Undirected edge)** ，简称 **边 (Edge)** ，其中 $u, v \in V$ 。设 $e = (u, v)$ ，则 $u$ 和 $v$ 称为 $e$ 的 **端点 (Endpoint)** 。

若 $G$ 为有向图，则 $E$ 中的每一个元素为一个有序二元组 $(u, v)$ ，有时也写作 $u \to v$ ，称作 **有向边 (Directed edge)** 或 **弧 (Arc)** ，在不引起混淆的情况下也可以称作 **边 (Edge)** 。设 $e = u \to v$ ，则此时 $u$ 称为 $e$ 的 **起点 (Tail)** ， $v$ 称为 $e$ 的 **终点 (Head)** ，起点和终点也称为 $e$ 的 **端点 (Endpoint)** 。并称 $u$ 是 $v$ 的直接前驱， $v$ 是 $v$ 的直接后继。

???+note "为什么起点是 Tail，终点是 Head？"
    边通常用箭头表示，而箭头是从“尾”指向“头”的。

若 $G$ 为混合图，则 $E$ 中既有向边，又有无向边。

若 $G$ 的每条边 $e_k=(u_k,v_k)$ 都被赋予一个数作为该边的 **权** ，则称 $G$ 为 **赋权图** 。如果这些权都是正实数，就称 $G$ 为 **正权图** 。

图 $G$ 的点数 $\left| V(G) \right|$ 也被称作图 $G$ 的 **阶 (Order)** 。

形象地说，图是由若干点以及连接点与点的边构成的。

## 相邻

在无向图 $G = (V, E)$ 中，若点 $v$ 是边 $e$ 的一个端点，则称 $v$ 和 $e$ 是 **关联的 (Incident)** 或 **相邻的 (Adjacent)** 。对于两顶点 $u$ 和 $v$ ，若存在边 $(u, v)$ ，则称 $u$ 和 $v$ 是 **相邻的 (Adjacent)** 。

一个顶点 $v \in V$ 的 **邻域 (Neighborhood)** 是所有与之相邻的顶点所构成的集合，记作 $N(v)$ 。

一个点集 $S$ 的邻域是所有与 $S$ 中至少一个点相邻的点所构成的集合，记作 $N(S)$ ，即：

$$
N(S) = \bigcup_{v \in S} N(v)
$$

## 度数

与一个顶点 $v$ 关联的边的条数称作该顶点的 **度 (Degree)** ，记作 $d(v)$ 。特别地，对于边 $(v, v)$ ，则每条这样的边要对 $d(v)$ 产生 $2$ 的贡献。

对于无向简单图，有 $d(v) = \left| N(v) \right|$ 。

握手定理（又称图论基本定理）：对于任何无向图 $G = (V, E)$ ，有 $\sum_{v \in V} d(v) = 2 \left| E \right|$ 。

推论：在任意图中，度数为奇数的点必然有偶数个。

若 $d(v) = 0$ ，则称 $v$ 为 **孤立点 (Isolated vertex)** 。

若 $d(v) = 1$ ，则称 $v$ 为 **叶节点 (Leaf vertex)** / **悬挂点 (Pendant vertex)** 。

若 $2 \mid d(v)$ ，则称 $v$ 为 **偶点 (Even vertex)** 。

若 $2 \nmid d(v)$ ，则称 $v$ 为 **奇点 (Odd vertex)** 。图中奇点的个数是偶数。

若 $d(v) = \left| V \right| - 1$ ，则称 $v$ 为 **支配点 (Universal vertex)** 。

对一张图，所有节点的度数的最小值称为 $G$ 的 **最小度 (Minimum degree)** ，记作 $\delta (G)$ ；最大值称为 **最大度 (Maximum degree)** ，记作 $\Delta (G)$ 。即： $\delta (G) = \min_{v \in G} d(v)$ , $\Delta (G) = \max_{v \in G} d(v)$ 。

在有向图 $G = (V, E)$ 中，以一个顶点 $v$ 为起点的边的条数称为该顶点的 **出度 (Out-degree)** ，记作 $d^+(v)$ 。以一个顶点 $v$ 为终点的边的条数称为该节点的 **入度 (In-degree)** ，记作 $d^-(v)$ 。显然 $d^+(v)+d^-(v)=d(v)$ 。

对于任何有向图 $G = (V, E)$ ，有：

$$
\sum_{v \in V} d^+(v) = \sum_{v \in V} d^-(v) = \left| E \right|
$$

若对一张无向图 $G = (V, E)$ ，每个顶点的度数都是一个固定的常数 $k$ ，则称 $G$ 为 ** $k$ - 正则图 ( $k$ -Regular Graph)** 。

如果给定一个序列 a，可以找到一个图 G，以其为度数列，则称 a 是 **可图化** 的。

如果给定一个序列 a，可以找到一个简单图 G，以其为度数列，则称 a 是 **可简单图化** 的。

## 简单图

 **自环 (Loop)** ：对 $E$ 中的边 $e = (u, v)$ ，若 $u = v$ ，则 $e$ 被称作一个自环。

 **重边 (Multiple edge)** ：若 $E$ 中存在两个完全相同的元素（边） $e_1, e_2$ ，则它们被称作（一组）重边。

 **简单图 (Simple graph)** ：若一个图中没有自环和重边，它被称为简单图。非空简单图中一定存在度相同的结点。

如果一张图中有自环或重边，则称它为 **多重图 (Multigraph)** 。

!!! warning
    在无向图中 $(u, v)$ 和 $(v, u)$ 算一组重边，而在有向图中， $u \to v$ 和 $v \to u$ 不为重边。

!!! warning
    在题目中，如果没有特殊说明，是可以存在自环和重边的，在做题时需特殊考虑。

## 路径

 **途径 (Walk)** / **链 (Chain)** ：一个点和边的交错序列，其中首尾是点—— $v_0, e_1, v_1, e_2, v_2, \ldots, e_k, v_k$ ，有时简写为 $v_0 \to v_1 \to v_2 \to \cdots \to v_k$ 。其中 $e_i$ 的两个端点分别为 $v_{i-1}$ 和 $v_i$ 。通常来说，边的数量 $k$ 被称作这条途径的 **长度** （如果边是带权的，长度通常指路径上的边权之和，题目中也可能另有定义）。（以下设 $w = \left[ v_0, e_1, v_1, e_2, v_2, \cdots, e_k, v_k \right]$ 。)

 **迹 (Trail)** ：对于一条途径 $w$ ，若 $e_1, e_2, \cdots, e_k$ 两两互不相同，则称 $w$ 是一条迹。

 **路径 (Path)** （又称 **简单路径 (Simple path)** )：对于一条迹 $w$ ，除了 $v_0$ 和 $v_k$ 允许相同外，其余点两两互不相同，则称 $w$ 是一条路径。

 **回路 (Circuit)** ：对于一个迹 $w$ ，若 $v_0 = v_k$ ，则称 $w$ 是一个回路。

 **环/圈 (Cycle)** （又称 **简单回路/简单环 (Simple circuit)** )：对于一条简单路径 $w$ ，若 $v_0 = v_k$ ，则称 $w$ 是一个环。

!!! warning
    关于路径的定义在不同地方可能有所不同，如，“路径”可能指本文中的“途径”，“环”可能指本文中的“回路”。如果在题目中看到类似的词汇，且没有“简单路径”/“非简单路径”（即本文中的“途径”）等特殊说明，最好询问一下具体指什么。

## 子图

对一张图 $G = (V, E)$ ，若存在另一张图 $H = (V', E')$ 满足 $V' \subseteq V$ 且 $E' \subseteq E$ ，则称 $H$ 是 $G$ 的 **子图 (Subgraph)** ，记作 $H \subseteq G$ 。

若对 $H \subseteq G$ ，满足 $\forall u, v \in V'$ ，只要 $(u, v) \in E$ ，均有 $(u, v) \in E'$ ，则称 $H$ 是 $G$ 的 **导出子图/诱导子图 (Induced subgraph)** 。

容易发现，一个图的导出子图仅由子图的点集决定，因此点集为 $V'$ ( $V' \subseteq V$ ) 的导出子图称为 $V'$ 导出的子图，记作 $G \left[ V' \right]$ 。

若 $H \subseteq G$ 满足 $V' = V$ ，则称 $H$ 为 $G$ 的 **生成子图/支撑子图 (Spanning subgraph)** 。

显然， $G$ 是自身的子图，支撑子图，导出子图；空图是 $G$ 的支撑子图。原图 $G$ 和空图都是 $G$ 的平凡子图。

如果一张无向图 $G$ 的某个生成子图 $F$ 为 $k$ - 正则图，则称 $F$ 为 $G$ 的一个 ** $k$ - 因子 ( $k$ -Factor)** 。

如果有向图 $G = (u, v)$ 的导出子图 $H = G \left[ V^* \right]$ 满足 $\forall v \in V^*, (v, u) \in E$ ，就有 $u \in V^*$ ，则称 $H$ 为 $G$ 的一个 **闭合子图 (Closed subgraph)** 。

## 连通

### 无向图

对于一张无向图 $G = (V, E)$ ，对于 $u, v \in V$ ，若存在一条途径使得 $v_0 = u, v_k = v$ ，则称 $u$ 和 $v$ 是 **连通的 (Connected)** 。由定义，任意一个顶点和自身连通，任意一条边的两个端点连通。

若无向图 $G = (V, E)$ ，满足其中任意两个顶点均连通，则称 $G$ 是 **连通图 (Connected graph)** ， $G$ 的这一性质称作 **连通性 (Connectivity)** 。

若 $H$ 是 $G$ 的一个连通子图，且不存在 $F$ 满足 $H\subsetneq F \subseteq G$ 且 $F$ 为连通图，则 $H$ 是 $G$ 的一个 **连通块/连通分量 (Connected component)** （极大连通子图）。

### 有向图

对于一张有向图 $G = (V, E)$ ，对于 $u, v \in V$ ，若存在一条途径使得 $v_0 = u, v_k = v$ ，则称 $u$  **可达**  $v$ 。由定义，任意一个顶点可达自身，任意一条边的起点可达终点。（无向图中的连通也可以视作双向可达。）

若一张有向图的节点两两互相可达，则称这张图是 **强连通的 (Strongly connected)** 。

若一张有向图的边替换为无向边后可以得到一张连通图，则称原来这张有向图是 **弱连通的 (Weakly connected)** 。

与连通分量类似，也有 **弱连通分量 (Weakly connected component)** （极大弱连通子图）和 **强连通分量 (Strongly Connected component)** （极大强连通子图）。

相关算法请参见 [强连通分量](./scc.md) 。

### 割

相关算法请参见 [割点和桥](./cut.md) 以及 [双连通分量](./bcc.md) 。

在本部分中，有向图的“连通”一般指“强连通”。

对于连通图 $G = (V, E)$ ，若 $V'\subseteq V$ 且 $G\left[V\setminus V'\right]$ （即从 $G$ 中删去 $V'$ 中的点）不是连通图，则 $V'$ 是图 $G$ 的一个 **点割集 (Vertex cut/Separating set)** 。大小为一的点割集又被称作 **割点 (Cut vertex)** 。

对于连通图 $G = (V, E)$ 和整数 $k$ ，若 $|V|\ge k+1$ 且 $G$ 不存在大小为 $k-1$ 的点割集，则称图 $G$ 是 ** $k$ - 点连通的 ( $k$ -vertex-connected)** ，而使得上式成立的最大的 $k$ 被称作图 $G$ 的 **点连通度 (Vertex connectivity)** ，记作 $\kappa(G)$ 。（对于非完全图，点连通度即为最小点割集的大小，而完全图 $K_n$ 的点连通度为 $n-1$ 。）

对于图 $G = (V, E)$ 以及 $u, v\in V$ 满足 $u\ne v$ ， $u$ 和 $v$ 不相邻， $u$ 可达 $v$ ，若 $V'\subseteq V$ ， $u, v\notin V'$ ，且在 $G\left[V\setminus V'\right]$ 中 $u$ 和 $v$ 不连通，则 $V'$ 被称作 $u$ 到 $v$ 的点割集。 $u$ 到 $v$ 的最小点割集的大小被称作 $u$ 到 $v$ 的 **局部点连通度 (Local connectivity)** ，记作 $\kappa(u, v)$ 。

还可以在边上作类似的定义：

对于连通图 $G = (V, E)$ ，若 $E'\subseteq E$ 且 $G' = (V, E\setminus E')$ （即从 $G$ 中删去 $E'$ 中的边）不是连通图，则 $E'$ 是图 $G$ 的一个 **边割集 (Edge cut)** 。大小为一的边割集又被称作 **桥 (Bridge)** 。

对于连通图 $G = (V, E)$ 和整数 $k$ ，若 $G$ 不存在大小为 $k-1$ 的边割集，则称图 $G$ 是 ** $k$ - 边连通的 ( $k$ -edge-connected)** ，而使得上式成立的最大的 $k$ 被称作图 $G$ 的 **边连通度 (Edge connectivity)** ，记作 $\lambda(G)$ 。（对于任何图，边连通度即为最小边割集的大小。）

对于图 $G = (V, E)$ 以及 $u, v\in V$ 满足 $u\ne v$ ， $u$ 可达 $v$ ，若 $E'\subseteq E$ ，且在 $G'=(V, E\setminus E')$ 中 $u$ 和 $v$ 不连通，则 $E'$ 被称作 $u$ 到 $v$ 的边割集。 $u$ 到 $v$ 的最小边割集的大小被称作 $u$ 到 $v$ 的 **局部边连通度 (Local edge-connectivity)** ，记作 $\lambda(u, v)$ 。

 **点双连通 (Biconnected)** 几乎与 $2$ - 点连通完全一致，除了一条边连接两个点构成的图，它是点双连通的，但不是 $2$ - 点连通的。换句话说，没有割点的连通图是点双连通的。

 **边双连通 ( $2$ -edge-connected)** 与 $2$ - 边双连通完全一致。换句话说，没有桥的连通图是边双连通的。

与连通分量类似，也有 **点双连通分量 (Biconnected component)** （极大点双连通子图）和 **边双连通分量 ( $2$ -edge-connected component)** （极大边双连通子图）。

 **Whitney 定理** ：对任意的图 $G$ ，有 $\kappa(G)\le \lambda(G)\le \delta(G)$ 。（不等式中的三项分别为点连通度、边连通度、最小度。）

## 稀疏图/稠密图

若一张图的边数远小于其点数的平方，那么它是一张 **稀疏图 (Sparse graph)** 。

若一张图的边数接近其点数的平方，那么它是一张 **稠密图 (Dense graph)** 。

这两个概念并没有严格的定义，一般用于讨论 [时间复杂度](../misc/complexity.md) 为 $O(|V|^2)$ 的算法与 $O(|E|)$ 的算法的效率差异（在稠密图上这两种算法效率相当，而在稀疏图上 $O(|E|)$ 的算法效率明显更高）。

## 补图

对于无向简单图 $G = (V, E)$ ，它的 **补图 (Complement graph)** 指的是这样的一张图：记作 $\bar G$ ，满足 $V \left( \bar G \right) = V \left( G \right)$ ，且对任意节点对 $(u, v)$ ， $(u, v) \in E \left( \bar G \right)$ 当且仅当 $(u, v) \notin E \left( G \right)$ 。

## 反图

对于有向图 $G = (V, E)$ ，它的 **反图 (Transpose Graph)** 指的是点集不变，每条边反向得到的图，即：若 $G$ 的反图为 $G'=(V, E')$ ，则 $E'=\{(v, u)|(u, v)\in E\}$ 。

## 特殊的图

若无向简单图 $G$ 满足任意不同两点间均有边，则称 $G$ 为 **完全图 (Complete graph)** ， $n$ 阶完全图记作 $K_n$ 。若有向图 $G$ 满足任意不同两点间都有两条方向不同的边，则称 $G$ 为 **有向完全图 (Complete digraph)** 。

边集为空的图称为 **零图 (Null graph)** ， $n$ 阶零图记作 $N_n$ 。易知， $N_n$ 为 $K_n$ 互为补图。

若有向简单图 $G$ 满足任意不同两点间都有恰好一条边（单向），则称 $G$ 为 **竞赛图 (Tournament graph)** 。

若无向简单图 $G = \left( V, E \right)$ 的所有边恰好构成一个圈，则称 $G$ 为 **环图/圈图 (Cycle graph)** ， $n$ ( $n \geq 3$ ) 阶圈图记作 $C_n$ 。易知，一张图为圈图的充分必要条件是，它是 $2$ - 正则连通图。

若无向简单图 $G = \left( V, E \right)$ 满足，存在一个点 $v$ 为支配点，其余点之间没有边相连，则称 $G$ 为 **星图/菊花图 (Star graph)** ， $n + 1$ ( $n \geq 1$ ) 阶星图记作 $S_n$ 。

若无向简单图 $G = \left( V, E \right)$ 满足，存在一个点 $v$ 为支配点，其它点之间构成一个圈，则称 $G$ 为 **轮图 (Wheel Graph)** ， $n + 1$ ( $n \geq 3$ ) 阶轮图记作 $W_n$ 。

若无向简单图 $G = \left( V, E \right)$ 的所有边恰好构成一条简单路径，则称 $G$ 为 **链 (Chain/Path Graph)** ， $n$ 阶的链记作 $P_n$ 。易知，一条链由一个圈图删去一条边而得。

如果一张无向连通图不含环，则称它是一棵 **树 (Tree)** 。相关内容详见 [树基础](./tree-basic.md) 。

如果一张无向连通图包含恰好一个环，则称它是一棵 **基环树** 。

如果一张有向弱连通图每个点的入度都为 $1$ ，则称它是一棵 **基环外向树** 。

如果一张有向弱连通图每个点的出度都为 $1$ ，则称它是一棵 **基环内向树** 。

多棵树可以组成一个 **森林 (Forest)** ，多棵基环树可以组成 **基环森林** ，多棵基环外向树可以组成 **基环外向树森林** ，多棵基环内向树可以组成 **基环内向森林 (Functional graph)** 。

如果一张无向连通图的每条边最多在一个环内，则称它是一棵 **仙人掌 (Cactus)** 。多棵仙人掌可以组成 **沙漠** 。

如果一张图的点集可以被分为两部分，每一部分的内部都没有连边，那么这张图是一张 **二分图 (Bipartite graph)** 。如果二分图中任何两个不在同一部分的点之间都有连边，那么这张图是一张 **完全二分图 (Complete bipartite graph/Biclique)** ，一张两部分分别有 $n$ 个点和 $m$ 个点的完全二分图记作 $K_{n, m}$ 。相关内容详见 [二分图](./bi-graph.md) 。

如果一张图可以画在一个平面上，且没有两条边在非端点处相交，那么这张图是一张 **平面图 (Planar graph)** 。一张图的任何子图都不是 $K_5$ 或 $K_{3, 3}$ 是其为一张平面图的充要条件。对于简单连通平面图 $G=(V, E)$ 且 $V\ge 3$ ， $|E|\le 3|V|-6$ 。

## 同构

两个图 $G$ 和 $H$ ，如果存在一个双射 $f : V(G) \to V(H)$ ，且满足 $(u,v)\in E(G)$ ，当且仅当 $(f(u),f(v))\in E(H)$ ，则我们称 $f$ 为 $G$ 到 $H$ 的一个 **同构 (Isomorphism)** ，且图 $G$ 与图 $H$ 是 **同构的 (Isomorphic)** ，记作 $G \cong H$ 。

从定义可知，若 $G \cong H$ ，必须满足：

-    $|V(G)|=|V(H)|,|E(G)|=|E(H)|$ 
-    $G$ 和 $H$ 结点度的非增序列相同
-    $G$ 和 $H$ 存在同构的导出子图

## 无向简单图的二元运算

对于无向简单图，我们可以定义如下二元运算：

 **交 (Intersection)** ：图 $G = \left( V_1, E_1 \right), H = \left( V_2, E_2 \right)$ 的交定义成图 $G \cap H = \left( V_1 \cap V_2, E_1 \cap E_2 \right)$ 。

容易证明两个无向简单图的交还是无向简单图。

 **并 (Union)** ：图 $G = \left( V_1, E_1 \right), H = \left( V_2, E_2 \right)$ 的并定义成图 $G \cup H = \left( V_1 \cup V_2, E_1 \cup E_2 \right)$ 。

 **和 (Sum)/直和 (Direct sum)** ：对于 $G = \left( V_1, E_1 \right), H = \left( V_2, E_2 \right)$ ，任意构造 $H' \cong H$ 使得 $V \left( H' \right) \cap V_1 = \varnothing$ ( $H'$ 可以等于 $H$ )。此时与 $G \cup H'$ 同构的任何图称为 $G$ 和 $H$ 的和/直和/不交并，记作 $G + H$ 或 $G \oplus H$ 。

若 $G$ 与 $H$ 的点集本身不相交，则 $G \cup H = G + H$ 。

比如，森林可以定义成若干棵树的和。

???+note "并与和的区别"
    可以理解为，“并”会让两张图中“名字相同”的点、边合并，而“和”则不会。

## 特殊的点集/边集

### 支配集

对于无向图 $G=(V, E)$ ，若 $V'\subseteq V$ 且 $\forall v\in(V\setminus V')$ 存在边 $(u, v)\in E$ 满足 $u\in V'$ ，则 $V'$ 是图 $G$ 的一个 **支配集 (Dominating set)** 。

无向图 $G$ 最小的支配集的大小记作 $\gamma(G)$ 。求一张图的最小支配集是 [NP 困难](../misc/cc-basic.md#np-hard) 的。

对于有向图 $G=(V, E)$ ，若 $V'\subseteq V$ 且 $\forall v\in(V\setminus V')$ 存在边 $(u, v)\in E$ 满足 $u\in V'$ ，则 $V'$ 是图 $G$ 的一个 **出 - 支配集 (Out-dominating set)** 。类似地，可以定义有向图的 **入 - 支配集 (In-dominating set)** 。

有向图 $G$ 最小的出 - 支配集大小记作 $\gamma^+(G)$ ，最小的入 - 支配集大小记作 $\gamma^-(G)$ 。

### 边支配集

对于图 $G=(V, E)$ ，若 $E'\subseteq E$ 且 $\forall e\in(E\setminus E')$ 存在 $E'$ 中的边与其有公共点，则称 $E'$ 是图 $G$ 的一个 **边支配集 (Edge dominating set)** 。

求一张图的最小边支配集是 [NP 困难](../misc/cc-basic.md#np-hard) 的。

### 独立集

对于图 $G=(V, E)$ ，若 $V'\subseteq V$ 且 $V'$ 中任意两点都不相邻，则 $V'$ 是图 $G$ 的一个 **独立集 (Independent set)** 。

图 $G$ 最大的独立集的大小记作 $\alpha(G)$ 。求一张图的最大独立集是 [NP 困难](../misc/cc-basic.md#np-hard) 的。

### 匹配

对于图 $G=(V, E)$ ，若 $E'\in E$ 且 $E'$ 中任意两条不同的边都没有公共的端点，且 $E'$ 中任意一条边都不是自环，则 $E'$ 是图 $G$ 的一个 **匹配 (Matching)** ，也可以叫作 **边独立集 (Independent edge set)** 。如果一个点是匹配中某条边的一个端点，则称这个点是 **被匹配的 (matched)/饱和的 (saturated)** ，否则称这个点是 **不被匹配的 (unmatched)** 。

边数最多的匹配被称作一张图的 **最大匹配 (Maximum-cardinality matching)** 。图 $G$ 的最大匹配的大小记作 $\nu(G)$ 。

如果边带权，那么权重之和最大的匹配被称作一张图的 **最大权匹配 (Maximum-weight matching)** 。

如果一个匹配在加入任何一条边后都不再是一个匹配，那么这个匹配是一个 **极大匹配 (Maximal matching)** 。最大的极大匹配就是最大匹配，任何最大匹配都是极大匹配。极大匹配一定是边支配集，但边支配集不一定是匹配。最小极大匹配和最小边支配集大小相等，但最小边支配集不一定是匹配。求最小极大匹配是 NP 困难的。

如果在一个匹配中所有点都是被匹配的，那么这个匹配是一个 **完美匹配 (Perfect matching)** 。如果在一个匹配中只有一个点不被匹配，那么这个匹配是一个 **准完美匹配 (Near-perfect matching)** 。

求一张普通图或二分图的匹配或完美匹配个数都是 [#P 完全](../misc/cc-basic.md#p_1) 的。

对于一个匹配 $M$ ，若一条路径以非匹配点为起点，每相邻两条边的其中一条在匹配中而另一条不在匹配中，则这条路径被称作一条 **交替路径 (Alternating path)** ；一条在非匹配点终止的交替路径，被称作一条 **增广路径 (Augmenting path)** 。

 **托特定理** ： $n$ 阶无向图 $G$ 有完美匹配当且仅当对于任意的 $V' \subset V(G)$ ， $p_{奇}(G-V')\leq |V'|$ ，其中 $p_{奇}$ 表示奇数阶连通分支数。

 **托特定理（推论）** ：任何无桥 3 - 正则图都有完美匹配。

### 点覆盖

对于图 $G=(V, E)$ ，若 $V'\subseteq V$ 且 $\forall e\in E$ 满足 $e$ 的至少一个端点在 $V'$ 中，则称 $V'$ 是图 $G$ 的一个 **点覆盖 (Vertex cover)** 。

点覆盖集必为支配集，但极小点覆盖集不一定是极小支配集。

一个点集是点覆盖的充要条件是其补集是独立集，因此最小点覆盖的补集是最大独立集。求一张图的最小点覆盖是 [NP 困难](../misc/cc-basic.md#np-hard) 的。

一张图的任何一个匹配的大小都不超过其任何一个点覆盖的大小。完全二分图 $K_{n, m}$ 的最大匹配和最小点覆盖大小都为 $\min(n, m)$ 。

### 边覆盖

对于图 $G=(V, E)$ ，若 $E'\subseteq E$ 且 $\forall v\in V$ 满足 $v$ 与 $E'$ 中的至少一条边相邻，则称 $E'$ 是图 $G$ 的一个 **边覆盖 (Edge cover)** 。

最小边覆盖的大小记作 $\rho(G)$ ，可以由最大匹配贪心扩展求得：对于所有非匹配点，将其一条邻边加入最大匹配中，即得到了一个最小边覆盖。

最大匹配也可以由最小边覆盖求得：对于最小边覆盖中每对有公共点的边删去其中一条。

一张图的最小边覆盖的大小加上最大匹配的大小等于图的点数，即 $\rho(G)+\nu(G)=|V(G)|$ 。

一张图的最大匹配的大小不超过最小边覆盖的大小，即 $\nu(G)\le\rho(G)$ 。特别地，完美匹配一定是一个最小边覆盖，这也是上式取到等号的唯一情况。

一张图的任何一个独立集的大小都不超过其任何一个边覆盖的大小。完全二分图 $K_{n, m}$ 的最大独立集和最小边覆盖大小都为 $\max(n, m)$ 。

### 团

对于图 $G=(V, E)$ ，若 $V'\subseteq V$ 且 $V'$ 中任意两个不同的顶点都相邻，则 $V'$ 是图 $G$ 的一个 **团 (Clique)** 。团的导出子图是完全图。

如果一个团在加入任何一个顶点后都不再是一个团，则这个团是一个 **极大团 (Maximal clique)** 。

一张图的最大团的大小记作 $\omega(G)$ ，最大团的大小等于其补图最大独立集的大小，即 $\omega(G)=\alpha(\bar{G})$ 。求一张图的最大团是 [NP 困难](../misc/cc-basic.md#np-hard) 的。

## 参考资料

 [OI 中转站 - 图论概念梳理](https://yhx-12243.github.io/OI-transit/memos/14.html) 

 [Wikipedia](https://en.wikipedia.org/wiki/Glossary_of_graph_theory_terms) （以及相关概念的对应词条）

离散数学（修订版），田文成 周禄新 编著，天津文学出版社，P184-187

戴一奇，胡冠章，陈卫。图论与代数结构[M]. 北京：清华大学出版社，1995.

# tree-divide
## 点分治

点分治适合处理大规模的树上路径信息问题。

??? note " 例题[luogu P3806【模板】点分治 1](https://www.luogu.org/problemnew/show/P3806)"
    给定一棵有 $n$ 个点的带点权树， $m$ 次询问，每次询问给出 $k$ ，询问树上距离为 $k$ 的点对是否存在。

     $n\le 10000,m\le 100,k\le 10000000$ 

我们先随意选择一个节点作为根节点 $rt$ ，所有完全位于其子树中的路径可以分为两种，一种是经过当前根节点的路径，一种是不经过当前根节点的路径。对于经过当前根节点的路径，又可以分为两种，一种是以根节点为一个端点的路径，另一种是两个端点都不为根节点的路径。而后者又可以由两条属于前者链合并得到。所以，对于枚举的根节点 $rt$ ，我们先计算在其子树中且经过该节点的路径对答案的贡献，再递归其子树对不经过该节点的路径进行求解。

在本题中，对于经过根节点 $rt$ 的路径，我们先枚举其所有子节点 $ch$ ，以 $ch$ 为根计算 $ch$ 子树中所有节点到 $rt$ 的距离。记节点 $i$ 到当前根节点 $rt$ 的距离为 $dist_i$ ， $tf_{d}$ 表示之前处理过的子树中是否存在一个节点 $v$ 使得 $dist_v=d$ 。若一个询问的 $k$ 满足 $tf_{k-dist_i}=true$ ，则存在一条长度为 $k$ 的路径。在计算完 $ch$ 子树中所连的边能否成为答案后，我们将这些新的距离加入 $tf$ 数组中。

注意在清空 $tf$ 数组的时候不能直接用 `memset` ，而应将之前占用过的 $tf$ 位置加入一个队列中，进行清空，这样才能保证时间复杂度。

点分治过程中，每一层的所有递归过程合计对每个点处理一次，假设共递归 $h$ 层，则总时间复杂度为 $O(h\times n)$ 。

若我们 **每次选择子树的重心作为根节点** ，可以保证递归层数最少，时间复杂度为 $O(n\log n)$ 。

请注意在重新选择根节点之后一定要重新计算子树的大小，否则一点看似微小的改动就可能会使时间复杂度错误或正确性难以保证。

代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 20010;
const int inf = 2e9;
int n, m, a, b, c, q[maxn], rt, siz[maxn], maxx[maxn], dist[maxn];
int cur, h[maxn], nxt[maxn], p[maxn], w[maxn];
bool tf[10000010], ret[maxn], vis[maxn];
void add_edge(int x, int y, int z) {
  cur++;
  nxt[cur] = h[x];
  h[x] = cur;
  p[cur] = y;
  w[cur] = z;
}
int sum;
void calcsiz(int x, int fa) {
  siz[x] = 1;
  maxx[x] = 0;
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa && /home/llj/Desktop/OI-wiki-master/docs/graph/!vis[p[j]]) {
      calcsiz(p[j], x);
      maxx[x] = max(maxx[x], siz[p[j]]);
      siz[x] += siz[p[j]];
    }
  maxx[x] = max(maxx[x], sum - siz[x]);
  if (maxx[x] < maxx[rt]) rt = x;
}
int dd[maxn], cnt;
void calcdist(int x, int fa) {
  dd[++cnt] = dist[x];
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa && /home/llj/Desktop/OI-wiki-master/docs/graph/!vis[p[j]])
      dist[p[j]] = dist[x] + w[j], calcdist(p[j], x);
}
queue<int> tag;
void dfz(int x, int fa) {
  tf[0] = true;
  tag.push(0);
  vis[x] = true;
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa && /home/llj/Desktop/OI-wiki-master/docs/graph/!vis[p[j]]) {
      dist[p[j]] = w[j];
      calcdist(p[j], x);
      for (int k = 1; k <= cnt; k++)
        for (int i = 1; i <= m; i++)
          if (q[i] >= dd[k]) ret[i] |= tf[q[i] - dd[k]];
      for (int k = 1; k <= cnt; k++) tag.push(dd[k]), tf[dd[k]] = true;
      cnt = 0;
    }
  while (/home/llj/Desktop/OI-wiki-master/docs/graph/!tag.empty()) tf[tag.front()] = false, tag.pop();
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa && /home/llj/Desktop/OI-wiki-master/docs/graph/!vis[p[j]]) {
      sum = siz[p[j]];
      rt = 0;
      maxx[rt] = inf;
      calcsiz(p[j], x);
      calcsiz(rt, -1);
      dfz(rt, x);
    }
}
int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i < n; i++)
    scanf("%d%d%d", &a, &b, &c), add_edge(a, b, c), add_edge(b, a, c);
  for (int i = 1; i <= m; i++) scanf("%d", q + i);
  rt = 0;
  maxx[rt] = inf;
  sum = n;
  calcsiz(1, -1);
  calcsiz(rt, -1);
  dfz(rt, -1);
  for (int i = 1; i <= m; i++)
    if (ret[i])
      printf("AYE\n");
    else
      printf("NAY\n");
  return 0;
}
```

??? note " 例题[luogu  P4178 Tree](https://www.luogu.org/problemnew/show/P4178)"
    给定一棵有 $n$ 个点的带权树，给出 $k$ ，询问树上距离为 $k$ 的点对数量。

     $n\le 40000,k\le 20000,w_i\le 1000$ 

由于这里查询的是树上距离为 $[0,k]$ 的点对数量，所以我们用线段树来支持维护和查询。

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
#define int long long
using namespace std;
const int maxn = 2000010;
const int inf = 2e9;
int n, a, b, c, q, rt, siz[maxn], maxx[maxn], dist[maxn];
int cur, h[maxn], nxt[maxn], p[maxn], w[maxn], ret;
bool vis[maxn];
void add_edge(int x, int y, int z) {
  cur++;
  nxt[cur] = h[x];
  h[x] = cur;
  p[cur] = y;
  w[cur] = z;
}
int sum;
void calcsiz(int x, int fa) {
  siz[x] = 1;
  maxx[x] = 0;
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa && /home/llj/Desktop/OI-wiki-master/docs/graph/!vis[p[j]]) {
      calcsiz(p[j], x);
      maxx[x] = max(maxx[x], siz[p[j]]);
      siz[x] += siz[p[j]];
    }
  maxx[x] = max(maxx[x], sum - siz[x]);
  if (maxx[x] < maxx[rt]) rt = x;
}
int dd[maxn], cnt;
void calcdist(int x, int fa) {
  dd[++cnt] = dist[x];
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa && /home/llj/Desktop/OI-wiki-master/docs/graph/!vis[p[j]])
      dist[p[j]] = dist[x] + w[j], calcdist(p[j], x);
}
queue<int> tag;
struct segtree {
  int cnt, rt, lc[maxn], rc[maxn], sum[maxn];
  void clear() {
    while (/home/llj/Desktop/OI-wiki-master/docs/graph/!tag.empty()) update(rt, 1, 20000000, tag.front(), -1), tag.pop();
    cnt = 0;
  }
  void print(int o, int l, int r) {
    if (/home/llj/Desktop/OI-wiki-master/docs/graph/!o || /home/llj/Desktop/OI-wiki-master/docs/graph/!sum[o]) return;
    if (l == r) {
      printf("%lld %lld\n", l, sum[o]);
      return;
    }
    int mid = (l + r) >> 1;
    print(lc[o], l, mid);
    print(rc[o], mid + 1, r);
  }
  void update(int& o, int l, int r, int x, int v) {
    if (/home/llj/Desktop/OI-wiki-master/docs/graph/!o) o = ++cnt;
    if (l == r) {
      sum[o] += v;
      if (/home/llj/Desktop/OI-wiki-master/docs/graph/!sum[o]) o = 0;
      return;
    }
    int mid = (l + r) >> 1;
    if (x <= mid)
      update(lc[o], l, mid, x, v);
    else
      update(rc[o], mid + 1, r, x, v);
    sum[o] = sum[lc[o]] + sum[rc[o]];
    if (/home/llj/Desktop/OI-wiki-master/docs/graph/!sum[o]) o = 0;
  }
  int query(int o, int l, int r, int ql, int qr) {
    if (/home/llj/Desktop/OI-wiki-master/docs/graph/!o) return 0;
    if (r < ql || l > qr) return 0;
    if (ql <= l && r <= qr) return sum[o];
    int mid = (l + r) >> 1;
    return query(lc[o], l, mid, ql, qr) + query(rc[o], mid + 1, r, ql, qr);
  }
} st;
void dfz(int x, int fa) {
  // tf[0]=true;tag.push(0);
  st.update(st.rt, 1, 20000000, 1, 1);
  tag.push(1);
  vis[x] = true;
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa && /home/llj/Desktop/OI-wiki-master/docs/graph/!vis[p[j]]) {
      dist[p[j]] = w[j];
      calcdist(p[j], x);
      for (int k = 1; k <= cnt; k++)
        if (q - dd[k] >= 0)
          ret += st.query(st.rt, 1, 20000000, max(0ll, 1 - dd[k]) + 1,
                          max(0ll, q - dd[k]) + 1);
      for (int k = 1; k <= cnt; k++)
        st.update(st.rt, 1, 20000000, dd[k] + 1, 1), tag.push(dd[k] + 1);
      cnt = 0;
    }
  st.clear();
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa && /home/llj/Desktop/OI-wiki-master/docs/graph/!vis[p[j]]) {
      sum = siz[p[j]];
      rt = 0;
      maxx[rt] = inf;
      calcsiz(p[j], x);
      calcsiz(rt, -1);
      dfz(rt, x);
    }
}
int main() {
  scanf("%lld", &n);
  for (int i = 1; i < n; i++)
    scanf("%lld%lld%lld", &a, &b, &c), add_edge(a, b, c), add_edge(b, a, c);
  scanf("%lld", &q);
  rt = 0;
  maxx[rt] = inf;
  sum = n;
  calcsiz(1, -1);
  calcsiz(rt, -1);
  dfz(rt, -1);
  printf("%lld\n", ret);
  return 0;
}
```

## 边分治

与上面的点分治类似，我们选取一条边，把树尽量均匀地分成两部分（使边连接的两个子树的 $size$ 尽量接近）。然后递归处理左右子树，统计信息。

ちょっとまって，这不行吧……

考虑一个菊花图

/home/llj/Desktop/OI-wiki-master/docs/graph/![菊花图。png](./images/tree-divide1.png)

我们发现当一个点下有多个 $size$ 接近的儿子时，复杂度变得不对起来。

那，乖乖点分治好了（bushi

我们想如果这个图是个二叉树，那么就完美了。~~（所以，我们只对二叉树使用边分治~~

所以我们考虑如何把一个多叉树转化成二叉树。

显然，我们只需像线段树那样建树就可以了。就像这样

/home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/tree-divide2.png)

新建出来的点根据题目要求给予恰当的信息即可。例如：统计路径长度时，将原边边权赋为 $1$ , 将新建的边边权赋为 $0$ 即可。

分析复杂度，发现最多会增加 $O(n)$ 个点，则总复杂度为 $O(n\log n)$ 

几乎所有点分治的题边分都能做（常数上有差距，但是不卡），所以就不放例题了。

## 点分树

点分树是通过更改原树形态使树的层数变为稳定 $\log n$ 的一种重构树。

常用于解决与树原形态无关的带修改问题。

### 算法分析

我们通过点分治每次找重心的方式来对原树进行重构。

将每次找到的重心与上一层的重心缔结父子关系，这样就可以形成一棵 $\log n$ 层的树。

由于树是 $\log n$ 层的，很多原来并不对劲的暴力在点分树上均有正确的复杂度。

### 代码实现

有一个小 trick：每次用递归上一层的总大小 $tot$ 减去上一层的点的重儿子大小，得到的就是这一层的总大小。这样求重心就只需一次 dfs 了

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef vector<int>::iterator IT;

struct Edge {
  int to, nxt, val;

  Edge() {}
  Edge(int to, int nxt, int val) : to(to), nxt(nxt), val(val) {}
} e[300010];
int head[150010], cnt;

void addedge(int u, int v, int val) {
  e[++cnt] = Edge(v, head[u], val);
  head[u] = cnt;
}

int siz[150010], son[150010];
bool vis[150010];

int tot, lasttot;
int maxp, root;

void getG(int now, int fa) {
  siz[now] = 1;
  son[now] = 0;
  for (int i = head[now]; i; i = e[i].nxt) {
    int vs = e[i].to;
    if (vs == fa || vis[vs]) continue;
    getG(vs, now);
    siz[now] += siz[vs];
    son[now] = max(son[now], siz[vs]);
  }
  son[now] = max(son[now], tot - siz[now]);
  if (son[now] < maxp) {
    maxp = son[now];
    root = now;
  }
}

struct Node {
  int fa;
  vector<int> anc;
  vector<int> child;
} nd[150010];

int build(int now, int ntot) {
  tot = ntot;
  maxp = 0x7f7f7f7f;
  getG(now, 0);
  int g = root;
  vis[g] = 1;
  for (int i = head[g]; i; i = e[i].nxt) {
    int vs = e[i].to;
    if (vis[vs]) continue;
    int tmp = build(vs, ntot - son[vs]);
    nd[tmp].fa = now;
    nd[now].child.push_back(tmp);
  }
  return g;
}

int virtroot;

int main() {
  int n;
  cin >> n;
  for (int i = 1; i < n; i++) {
    int u, v, val;
    cin >> u >> v >> val;
    addedge(u, v, val);
    addedge(v, u, val);
  }
  virtroot = build(1, n);
}
```

# planar
## 定义

如果图 $G$ 能画在平面 $S$ 上，即除顶点处外无边相交，则称 $G$ 可平面嵌入 $S$ ， $G$ 为可平面图或平面图。画出的没有边相交的图称为 $G$ 的平面表示或平面嵌入。

 $K_{3,3}$ 和 $K_5$ 不是平面图。

设 $G$ 是平面图，由 $G$ 的边将 $G$ 所在的平面划分成若干个区域，每个区域称为 $G$ 的一个面，其中面积无限的面称为无限面或外部面，面积有限的称为有限面或内部面。包围每个面的所有边组成的回路称为该面的边界，边界的长度称为该面的次数。

平面图中所有面的次数之和等于边数 $m$ 的 2 倍。

若在简单平面图 $G$ 的任意不相邻顶点间添加边，所得图为非平面图，称 $G$ 为极大平面图。

若 $G$ 为 $n (n \geq 3)$ 阶简单的连通平面图， $G$ 为极大平面图当且仅当 $G$ 的每个面的次数均为 3。

### 欧拉公式

对于任意的连通的平面图 $G$ ，有：

 $n-m+r=2$ 

其中， $n, m, r$ ，分别为 $G$ 的阶数，边数和面数。

推论：对于有 $p (p \geq 2)$ 个连通分支的平面图 $G$ ，有

 $n-m+r=p+1$ 

可推出其他性质：

设 $G$ 是连通的平面图，且 $G$ 的各面的次数至少为 $l(l \geq 3)$ ，则有：

 $m \leq \frac{l}{l-2}(n-2)$ 

推论：对于有 $p (p \geq 2)$ 个连通分支的平面图 $G$ ，有

 $m \leq \frac{l}{l-2}(n-p-1)$ 

推论：设 $G$ 是 $n \geq 3$ 阶 $m$ 条边的简单平面图，则 $m \leq 3n-6$ 

### 判断

若两个图 $G_1$ 与 $G_2$ 同构，或通过反复插入或消去 2 度顶点后是同构的，则称二者是同胚的。

#### 库拉图斯基定理

图 $G$ 是平面图当且仅当 $G$ 不含与 $K_5$ 或 $K_{3,3}$ 同胚的子图。

图 $G$ 是平面图当且仅当 $G$ 中没有可以收缩到 $K_5$ 或 $K_{3,3}$ 的子图。

### 对偶图

设 $G$ 是平面图的某一个平面嵌入，构造图 $G^{*}$ ：

1.  在 $G$ 的每个面 $R_i$ 中放置 $G^{*}$ 的一个顶点 $v_i^{*}$ 
2.  设 $e$ 为 $G$ 的一条边，若 $e$ 在 $G$ 的面 $R_i$ 和 $R_j$ 的公共边界上，做 $G^{*}$ 的边 $e^{*}$ 与 $e$ 相交，且 $e^*$ 关联 $G^{*}$ 的顶点 $v_i^*, v_j^*$ ，即 $e^*=(v_i^*, v_j^*)$ ， $e^*$ 不与其他任何边相交。若 $e$ 为 $G$ 中桥且在 $R_i$ 的边界上，则 $e^*$ 是以 $R_i$ 中顶点 $v_i^*$ 为端点的环，即 $e^*=(v_i^*,v_j^*)$ 

称 $G^{*}$ 为 $G$ 的对偶图。

#### 性质

1.   $G^{*}$ 为平面图，且是平面嵌入。
2.   $G$ 中自环在 $G^{*}$ 中对应桥， $G$ 中桥在 $G^{*}$ 中对应自环。
3.   $G^{*}$ 是连通的。
4.  若 $G$ 的面 $R_i, R_j$ 的边界上至少有两条公共边，则关联 $v_i^*, v_j^*$ 的边有平行边， $G^*$ 多半是多重图。
5.  同构的图的对偶图不一定是同构的。
6.   $G^{**}$ 与 $G$ 同构当且仅当 $G$ 是连通图。

### 应用

平面图最小割转对偶图最短路：BZOJ 1001 狼抓兔子

### 外平面图

设 $G$ 为平面图，若 $G$ 存在平面嵌入 $\tilde{G}$ ，使得 $G$ 中所有顶点都在 $\tilde{G}$ 的一个面的边界上，则称 $G$ 为外可平面图，简称外平面图。

设 $G$ 是简单的外平面图，若对于 $G$ 中任二不相邻顶点 $u, v$ ，令 $G'=G \cup (u, v)$ ，则 $G'$ 不是外平面图，称 $G$ 为极大外平面图。

#### 性质

所有顶点都在外部面边界上的 $n (n \geq 3)$ 阶外可平面图是极大外可平面图当且仅当 $G$ 的每个外部面的边界都是长为 3 的圈，外部面的边界是一个长为 $n$ 的圈。

 $n (n \geq 3)$ 阶极大外平面图有 $n-2$ 个内部面。

设 $G$ 是 $n (n \geq 3)$ 阶极大外平面图，则：

1.   $m=2n-3$ 
2.   $G$ 中至少有 3 个顶点的度数小于等于 3
3.   $G$ 中至少有 2 个顶点的度数为 2
4.   $G$ 的点连通度 $\kappa$ 为 2

一个图 $G$ 是外平面图有当且仅当 $G$ 中不含与 $K_4$ 或 $K_{2,3}$ 同胚的子图。

任何 4 - 连通平面图都是哈密顿图。

# dsu-on-tree
author: abc1763613206, cesonic, Ir1d, MingqiHuang

### 引入

启发式算法是什么呢？

启发式算法是基于人类的经验和直观感觉，对一些算法的优化。

给个例子？

最常见的就是并查集的按秩合并了，有带按秩合并的并查集中，合并的代码是这样的：

```cpp
void merge(int x, int y) {
  int xx = find(x), yy = find(y);
  if (size[xx] < size[yy]) swap(xx, yy);
  fa[yy] = xx;
  size[xx] += size[yy];
}
```

在这里，对于两个大小不一样的集合，我们将小的集合合并到大的集合中，而不是将大的集合合并到小的集合中。

为什么呢？这个集合的大小可以认为是集合的高度（在正常情况下），而我们将集合高度小的并到高度大的显然有助于我们找到父亲

让高度小的树成为高度较大的树的子树，这个优化可以称为启发式合并算法。

### 算法内容

树上启发式合并（dsu on tree）对于某些树上离线问题可以速度大于等于大部分算法且更易于理解和实现的算法。

考虑下面的问题：

给出一棵树，每个节点有颜色，询问一些子树的颜色数量（颜色可重复）。

![dsu-on-tree-1.png](./images/dsu-on-tree-1.png)

对于这种问题解决方式大多是运用大量的数据结构（树套树等），如果可以离线，询问的量巨大，是不是有更简单的方法？

树上莫队！

不行，莫队带根号，我要 log

既然支持离线，考虑预处理后 $O(1)$ 输出答案。

直接暴力预处理的时间复杂度为 $O(n^2)$ ，即对每一个子节点进行一次遍历，每次遍历的复杂度显然与 $n$ 同阶，有 $n$ 个节点，故复杂度为 $O(n^2)$ 。

可以发现，每个节点的答案由其子树何其本身得到，考虑利用这个性质处理问题。

我们可以先预处理出每个节点子树的 $size$ 和它的重儿子，重儿子同树链剖分一样，是拥有节点最多子树的儿子，这个过程显然可以 $O(n)$ 完成

我们用 check[i]表示颜色 $i$ 有没有出现过，ans[i]表示他的颜色个数

遍历一个节点，我们按以下的步骤进行遍历：

-   先遍历其非重儿子，获取它的 ans，但 **不保留遍历后它的 check** ；

-   遍历它的重儿子， **保留它的 check** ；

-   再次遍历其非重儿子及其父亲，用重儿子的 check 对遍历到的节点进行计算，获取整棵子树的 ans；

![dsu-on-tree-2.png](./images/dsu-on-tree-2.png)

上图是一个例子。

这样，对于一个节点，我们遍历了一次重子树，两次非重子树，显然是最划算的。

通过执行这个过程，我们获得了这个节点所有子树的 ans

为什么不合并第一步和第三步呢？因为 check 数组不能重复使用，否则空间会太大，需要在 $O(n)$ 的空间内完成。

显然若一个节点 $u$ 被遍历了 $x$ 次，则其重儿子会被遍历 $x$ 次，轻儿子（如果有的话）会被遍历 $2x$ 次。

注意除了重儿子，每次遍历完 $check$ 要清零。

### 复杂度

（对于不关心复杂度证明的，可以跳过不看）

我们像树链剖分一样定义重边和轻边（连向重儿子的为重边，其余为轻边）关于重儿子和重边的定义，可以见下图，对于一棵有 $n$ 个节点的树：

根节点到树上任意节点的轻边数不超过 $\log n$ 条。我们设根到该节点有 x 条轻边该节点的子树大小为 $y$ ，显然轻边连接的子节点的子树大小小于父亲的一半（若大于一半就不是轻边了），则 $y<n/2^x$ ，显然 $n>2^x$ ，所以 $x<\log n$ 。

又因为如果一个节点是其父亲的重儿子，则他的子树必定在他的兄弟之中最多，所以任意节点到根的路径上所有重边连接的父节点在计算答案是必定不会遍历到这个节点，所以一个节点的被遍历的次数等于他到根节点路径上的轻边树 $+1$ （之所以要 $+1$ 是因为他本身要被遍历到），所以一个节点的被遍历次数 $=\log n+1$ , 总时间复杂度则为 $O(n(\log n+1))=O(n\log n)$ ，输出答案花费 $O(m)$ .

![dsu-on-tree-3.png](./images/dsu-on-tree-3.png)

_图中标红的即为重边，重边连向的子节点为重儿子_

### 大致代码

这里是预处理代码

```cpp
void dfs1(int u, int fa) {
  size[u] = 1;
  for (int i = head[u]; i; i = tree[i].next) {
    int v = tree[i].v;
    if (v != fa) {
      dfs1(v, u);
      size[u] += size[v];
      if (size[v] > size[son[u]]) son[u] = v;
    }
  }
}
```

下面是求答案的代码

```cpp
int dfs2(int u, int fa, bool keep, bool isson) {
  int tmp = 0;
  for (int i = head[u]; i; i = tree[i].next) {
    int v = tree[i].v;
    if (v != fa && v != son[u]) {
      dfs2(v, u, 0, 0);
    }
  }
  if (son[u]) tmp += dfs2(son[u], u, 1, 1);
  for (int i = head[u]; i; i = tree[i].next) {
    int v = tree[i].v;
    if (v != fa && v != son[u]) {
      tmp += dfs2(v, u, 1, 0);
    }
  }
  if (!check[color[u]]) {
    tmp++;
    check[color[u]] = 1;
  }
  if (!keep || isson) ans[u] = tmp;
  if (!keep) memset(check, 0, sizeof(check)), tmp = 0;
  return tmp;
}
```

代码是我口胡出来的，因为没有经过测评不保证正确。

### 运用

1.  某些出题人设置的正解是 dsu on tree 的题

如 [CF741D](http://codeforces.com/problemset/problem/741/D) 。给一棵树，每个节点的权值是'a' 到'v' 的字母，每次询问要求在一个子树找一条路径，使该路径包含的字符排序后成为回文串。

因为是排列后成为回文串，所以一个字符出现了两次相当于没出现，也就是说，这条路径满足 **最多有一个字符出现奇数次** 。

正常做法是对每一个节点 dfs，每到一个节点就强行枚举所有字母找到和他异或后结果为 1 的个数大于 1 的路径，再取最长值，这样是 $O(n^2\log n)$ 的，可以用 dsu on tree 优化到 $O(n\log^2n)$ 。关于具体做法，可以参考下面的扩展阅读

2.  可以用 dsu 乱搞~~吊打 std~~水分的题

可以水一些树套树的部分分（没有修改操作），还可以把树上莫队的 $O(n\sqrt{m})$ 吊着打

### 练习题

 [CF600E Lomsat gelral](http://codeforces.com/problemset/problem/600/E) 

题意翻译：树的节点有颜色，一种颜色占领了一个子树，当且仅当没有其他颜色在这个子树中出现得比它多。求占领每个子树的所有颜色之和。

 [UOJ284 快乐游戏鸡](https://uoj.ac/problem/284) 

### 参考资料/扩展阅读

 [CF741D 作者介绍的 dsu on tree](http://codeforces.com/blog/entry/44351) 

 [这位作者的题解](http://codeforces.com/blog/entry/48871) 

# matrix-tree
author: pw384, s0cks5, Xeonacid

Kirchhoff 矩阵树定理（简称矩阵树定理）解决了一张图的生成树个数计数问题。

## 本篇记号声明

 **本篇中的图，无论无向还是有向，都允许重边，但是不允许自环。** 

### 无向图情况

设 $G$ 是一个有 $n$ 个顶点的无向图。定义度数矩阵 $D(G)$ 为：

$$
D_{ii}(G) = \mathrm{deg}(i), D_{ij} = 0, i\neq j
$$

设 $\#e(i,j)$ 为点 $i$ 与点 $j$ 相连的边数，并定义邻接矩阵 $A$ 为：

$$
A_{ij}(G)=A_{ji}(G)=\#e(i,j), i\neq j
$$

定义 Laplace 矩阵（亦称 Kirchhoff 矩阵） $L$ 为：

$$
L(G) = D(G) - A(G)
$$

记图 $G$ 的所有生成树个数为 $t(G)$ 。

### 有向图情况

设 $G$ 是一个有 $n$ 个顶点的有向图。定义出度矩阵 $D^{out}(G)$ 为：

$$
D^{out}_{ii}(G) = \mathrm{deg^{out}}(i), D^{out}_{ij} = 0, i\neq j
$$

类似地定义入度矩阵 $D^{in}(G)$ 

设 $\#e(i,j)$ 为点 $i$ 指向点 $j$ 的有向边数，并定义邻接矩阵 $A$ 为：

$$
A_{ij}(G)=\#e(i,j), i\neq j
$$

定义出度 Laplace 矩阵 $L^{out}$ 为：

$$
L^{out}(G) = D^{out}(G) - A(G)
$$

定义入度 Laplace 矩阵 $L^{in}$ 为：

$$
L^{in}(G) = D^{in}(G) - A(G)
$$

记图 $G$ 的以 $r$ 为根的所有根向树形图个数为 $t^{root}(G,r)$ 。所谓根向树形图，是说这张图的基图是一棵树，所有的边全部指向父亲。

记图 $G$ 的以 $r$ 为根的所有叶向树形图个数为 $t^{leaf}(G,r)$ 。所谓叶向树形图，是说这张图的基图是一棵树，所有的边全部指向儿子。

## 定理叙述

矩阵树定理具有多种形式。其中用得较多的是定理 1、定理 3 与定理 4。

 **定理 1（矩阵树定理，无向图行列式形式）** 对于任意的 $i$ ，都有

$$
t(G) = \det L(G)\binom{1,2,\cdots,i-1,i+1,\cdots,n}{1,2,\cdots,i-1,i+1,\cdots,n}
$$

其中记号 $L(G)\binom{1,2,\cdots,i-1,i+1,\cdots,n}{1,2,\cdots,i-1,i+1,\cdots,n}$ 表示矩阵 $L(G)$ 的第 $1,\cdots,i-1,i+1,\cdots,n$ 行与第 $1,\cdots,i-1,i+1,\cdots,n$ 列构成的子矩阵。也就是说，无向图的 Laplace 矩阵具有这样的性质，它的所有 $n-1$ 阶主子式都相等。

 **定理 2（矩阵树定理，无向图特征值形式）** 设 $\lambda_1, \lambda_2, \cdots, \lambda_{n-1}$ 为 $L(G)$ 的 $n - 1$ 个非零特征值，那么有

 $t(G) = \frac{1}{n}\lambda_1\lambda_2\cdots\lambda_{n-1}$ 

 **定理 3（矩阵树定理，有向图根向形式）** 对于任意的 $k$ ，都有

$$
t^{root}(G,k) = \det L^{out}(G)\binom{1,2,\cdots,k-1,k+1,\cdots,n}{1,2,\cdots,k-1,k+1,\cdots,n}
$$

因此如果要统计一张图所有的根向树形图，只要枚举所有的根 $k$ 并对 $t^{root}(G,k)$ 求和即可。

 **定理 4（矩阵树定理，有向图叶向形式）** 对于任意的 $k$ ，都有

$$
t^{leaf}(G,k) = \det L^{in}(G)\binom{1,2,\cdots,k-1,k+1,\cdots,n}{1,2,\cdots,k-1,k+1,\cdots,n}
$$

因此如果要统计一张图所有的叶向树形图，只要枚举所有的根 $k$ 并对 $t^{leaf}(G,k)$ 求和即可。

## BEST 定理

 **定理 5 (BEST 定理）** 设 $G$ 是有向欧拉图，那么 $G$ 的不同欧拉回路总数 $ec(G)$ 是

$$
ec(G) = t^{root}(G,k)\prod_{v\in V}(\deg (v) - 1)!
$$

注意，对欧拉图 $G$ 的任意两个节点 $k, k'$ ，都有 $t^{root}(G,k)=t^{root}(G,k')$ ，且欧拉图 $G$ 的所有节点的入度和出度相等。

## 例题

???+ note "[「HEOI2015」小 Z 的房间](https://loj.ac/problem/2122)"

 **解** 矩阵树定理的裸题。将每个空房间看作一个结点，根据输入的信息建图，得到 Laplace 矩阵后，任意删掉 $L$ 的第 $i$ 行第 $i$ 列，求这个子式的行列式即可。求行列式的方法就是高斯消元成上三角阵然后算对角线积。另外本题需要在模 $k$ 的整数子环 $\mathbb{Z}_k$ 上进行高斯消元，采用辗转相除法即可。

???+ note "[「FJOI2007」轮状病毒](https://www.luogu.org/problem/P2144)"

 **解** 本题的解法很多，这里用矩阵树定理是最直接的解法。当输入为 $n$ 时，容易写出其 $n+1$ 阶的 Laplace 矩阵为：

$$
L_n = \begin{bmatrix}
n&	-1&	-1&	-1&	\cdots&	-1&	-1\\
-1&	3&	-1&	0&	\cdots&	0&	-1\\
-1&	-1&	3&	-1&	\cdots&	0&	0\\
-1&	0&	-1&	3&	\cdots&	0&	0\\
\vdots&	\vdots&	\vdots&	\vdots&	\ddots&	\vdots&	\vdots\\
-1&	0&	0&	0&	\cdots&	3&	-1\\
-1&	-1&	0&	0&	\cdots&	-1&	3\\
\end{bmatrix}_{n+1}
$$

求出它的 $n$ 阶子式的行列式即可，剩下的只有高精度计算了。

???+ note "例题 2+"
    将例题 2 的数据加强，要求 $n\leq 100000$ ，但是答案对 1000007 取模。（本题求解需要一些线性代数知识）

     **解** 推导递推式后利用矩阵快速幂即可求得。

??? danger "推导递推式的过程。警告：过程冗杂"
    注意到 $L_n$ 删掉第 1 行第 1 列以后得到的矩阵很有规律，因此其实就是在求矩阵

    $$
    M_n = \begin{bmatrix}
    3&	-1&	0&	\cdots&	0&	-1\\
    -1&	3&	-1&	\cdots&	0&	0\\
    0&	-1&	3&	\cdots&	0&	0\\
    \vdots&	\vdots&	\vdots&	\ddots&	\vdots&	\vdots\\
    0&	0&	0&	\cdots&	3&	-1\\
    -1&	0&	0&	\cdots&	-1&	3\\
    \end{bmatrix}_{n}
    $$

    的行列式。对 $M_n$ 的行列式按第一列展开，得到

    $$
    \det M_n = 3\det \begin{bmatrix}
    3&	-1&	\cdots&	0&	0\\
    -1&	3&	\cdots&	0&	0\\
    \vdots&	\vdots&	\ddots&	\vdots&	\vdots\\
    0&	0&	\cdots&	3&	-1\\
    0&	0&	\cdots&	-1&	3\\
    \end{bmatrix}_{n-1} + \det\begin{bmatrix}
    -1&	0&	\cdots&	0&	-1\\
    -1&	3&	\cdots&	0&	0\\
    \vdots&	\vdots&	\ddots&	\vdots&	\vdots\\
    0&	0&	\cdots&	3&	-1\\
    0&	0&	\cdots&	-1&	3\\
    \end{bmatrix}_{n-1} + (-1)^n \det\begin{bmatrix}
    -1&	0&	\cdots&	0&	-1\\
    3&	-1&	\cdots&	0&	0\\
    -1&	3&	\cdots&	0&	0\\
    \vdots&	\vdots&	\ddots&	\vdots&	\vdots\\
    0&	0&	\cdots&	3&	-1\\
    \end{bmatrix}_{n-1}
    $$

    上述三个矩阵的行列式记为 $d_{n-1}, a_{n-1}, b_{n-1}$ 。注意到 $d_n$ 是三对角行列式，采用类似的展开的方法可以得到 $d_n$ 具有递推公式 $d_n=3d_{n-1}-d_{n-2}$ 。类似地，采用展开的方法可以得到 $a_{n-1}=-d_{n-2}-1$ ，以及 $(-1)^n b_{n-1}=-d_{n-2}-1$ 。将这些递推公式代入上式，得到

    $$
    \det M_n = 3d_{n-1}-2d_{n-2}-2
    $$

    $$
    d_n = 3d_{n-1}-d_{n-2}
    $$

    于是猜测 $\det M_n$ 也是非齐次的二阶线性递推。采用待定系数法可以得到最终的递推公式为

    $$
    \det M_n = 3\det M_{n-1} - \det M_{n-2} + 2
    $$

    改写成 $(\det M_n+2) = 3(\det M_{n-1}+2) - (\det M_{n-2} + 2)$ 后，采用矩阵快速幂即可求出答案。

???+ note "例题 3"

「BZOJ3659」WHICH DREAMED IT

 **解** 本题是 BEST 定理的直接应用，但是要注意，由于题目规定“两种完成任务的方式算作不同当且仅当使用钥匙的顺序不同”，对每个欧拉回路，1 号房间可以沿着任意一条出边出发，从而答案还要乘以 1 号房间的出度。

## 注释

根向树形图也被称为内向树形图，但因为计算内向树形图用的是出度，为了不引起 in 和 out 的混淆，所以采用了根向这一说法。

# hamilton
## 定义

通过图中所有顶点一次且仅一次的通路称为哈密顿通路。

通过图中所有顶点一次且仅一次的回路称为哈密顿回路。

具有哈密顿回路的图称为哈密顿图。

具有哈密顿通路而不具有哈密顿回路的图称为半哈密顿图。

## 性质

设 $G=<V, E>$ 是哈密顿图，则对于 $V$ 的任意非空真子集 $V_1$ ，均有 $p(G-V_1) \leq |V_1|$ 。其中 $p(x)$ 为 $x$ 的连通分支数。

推论：设 $G=<V, E>$ 是半哈密顿图，则对于 $V$ 的任意非空真子集 $V_1$ ，均有 $p(G-V_1) \leq |V_1|+1$ 。其中 $p(x)$ 为 $x$ 的连通分支数。

完全图 $K_{2k+1} (k \geq 1)$ 中含 $k$ 条边不重的哈密顿回路，且这 $k$ 条边不重的哈密顿回路含 $K_{2k+1}$ 中的所有边。

完全图 $K_{2k} (k \geq 2)$ 中含 $k-1$ 条边不重的哈密顿回路，从 $K_{2k}$ 中删除这 $k-1$ 条边不重的哈密顿回路后所得图含 $k$ 条互不相邻的边。

## 充分条件

设 $G$ 是 $n(n \geq 2)$ 的无向简单图，若对于 $G$ 中任意不相邻的顶点 $v_i, v_j$ ，均有 $d(v_i)+ d(v_j) \geq n - 1$ ，则 $G$ 中存在哈密顿通路。

推论 1：设 $G$ 是 $n(n \geq 3)$ 的无向简单图，若对于 $G$ 中任意不相邻的顶点 $v_i, v_j$ ，均有 $d(v_i)+ d(v_j) \geq n$ ，则 $G$ 中存在哈密顿回路，从而 $G$ 为哈密顿图。

推论 2：设 $G$ 是 $n(n \geq 3)$ 的无向简单图，若对于 $G$ 中任意顶点 $v_i$ ，均有 $d(v_i) \geq \frac{n}{2}$ ，则 $G$ 中存在哈密顿回路，从而 $G$ 为哈密顿图。

设 $D$ 为 $n(n \geq 2)$ 阶竞赛图，则 $D$ 具有哈密顿通路。

若 $D$ 含 $n(n \geq 2)$ 阶竞赛图作为子图，则 $D$ 具有哈密顿通路。

强连通的竞赛图为哈密顿图。

若 $D$ 含 $n(n \geq 2)$ 阶强连通的竞赛图作为子图，则 $D$ 具有哈密顿回路。

# prufer
本文翻译自 [e-maxx Prufer Code](https://github.com/e-maxx-eng/e-maxx-eng/blob/master/src/graph/pruefer_code.md) 。另外解释一下，原文的结点是从 $0$ 开始标号的，本文我按照大多数人的习惯改成了从 $1$ 标号。

这篇文章介绍 Prufer 序列 (Prufer code)，这是一种将带标号的树用一个唯一的整数序列表示的方法。

使用 Prufer 序列可以证明凯莱定理 (Cayley's formula)。并且我们也会讲解如何计算在一个图中加边使图连通的方案数。

 **注意** ：我们不考虑含有 $1$ 个结点的树。

## Prufer 序列

Prufer 序列可以将一个带标号 $n$ 个结点的树用 $[1,n]$ 中的 $n-2$ 个整数表示。你也可以把它理解为完全图的生成树与数列之间的双射。

显然你不会想不开拿这玩意儿去维护树结构。这玩意儿常用组合计数问题上。

Heinz Prufer 于 1918 年发明这个序列来证明凯莱定理。

### 对树建立 Prufer 序列

Prufer 是这样建立的：每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点。重复 $n-2$ 次后就只剩下两个结点，算法结束。

显然使用堆可以做到 $O(n\log n)$ 的复杂度

```cpp
// 代码摘自原文，结点是从 0 标号的
vector<vector<int>> adj;

vector<int> pruefer_code() {
  int n = adj.size();
  set<int> leafs;
  vector<int> degree(n);
  vector<bool> killed(n, false);
  for (int i = 0; i < n; i++) {
    degree[i] = adj[i].size();
    if (degree[i] == 1) leafs.insert(i);
  }

  vector<int> code(n - 2);
  for (int i = 0; i < n - 2; i++) {
    int leaf = *leafs.begin();
    leafs.erase(leafs.begin());
    killed[leaf] = true;
    int v;
    for (int u : adj[leaf])
      if (!killed[u]) v = u;
    code[i] = v;
    if (--degree[v] == 1) leafs.insert(v);
  }
  return code;
}
```

给一个例子吧，这是一棵 7 个结点的树的 Prufer 序列构建过程：

![prufer](./images/prufer1.png)

最终的序列就是 $2,2,3,3,2$ 。

当然，也有一个线性的构造算法。

### 线性构造

线性构造的本质就是维护一个指针指向我们将要删除的结点。首先发现，叶结点数是非严格单调递减的。要么删一个，要么删一个得一个。（翻译到这突然就知道该怎么做了，然后对照原文发现没什么问题，于是自己口糊吧）

于是我们考虑这样一个过程：维护一个指针 $p$ 。初始时 $p$ 指向编号最小的叶结点。同时我们维护每个结点的度数，方便我们知道在删除结点的时侯是否产生新的叶结点。操作如下：

1.  删除 $p$ 指向的结点，并检查是否产生新的叶结点。
2.  如果产生新的叶结点，假设编号为 $x$ ，我们比较 $p,x$ 的大小关系。如果 $x>q$ ，那么不做其他操作；否则就立刻删除 $x$ ，然后检查删除 $x$ 后是否产生新的叶结点，重复 $2$ 步骤，直到未产生新节点或者新节点的编号 $>p$ 。
3.  让指针 $p$ 自增直到遇到一个未被删除叶结点为止；

循环上述操作 $n-2$ 次，就完成了序列的构造。接下来考虑算法的正确性。

 $p$ 是当前编号最小的叶结点，若删除 $p$ 后未产生叶结点，我们就只能去寻找下一个叶结点；若产生了叶结点 $x$ ：

-   如果 $x>p$ ，则反正 $p$ 往后扫描都会扫到它，于是不做操作；
-   如果 $x<p$ ，因为 $p$ 原本就是编号最小的，而 $x$ 比 $p$ 还小，所以 $x$ 就是当前编号最小的叶结点，优先删除。删除 $x$ 继续这样的考虑直到没有更小的叶结点。

算法复杂度分析，发现每条边最多被访问一次（在删度数的时侯），而指针最多遍历每个结点一次，因此复杂度是 $O(n)$ 的。

```cpp
// 从原文摘的代码，同样以 0 为起点
vector<vector<int>> adj;
vector<int> parent;

void dfs(int v) {
  for (int u : adj[v]) {
    if (u != parent[v]) parent[u] = v, dfs(u);
  }
}

vector<int> pruefer_code() {
  int n = adj.size();
  parent.resize(n), parent[n - 1] = -1;
  dfs(n - 1);

  int ptr = -1;
  vector<int> degree(n);
  for (int i = 0; i < n; i++) {
    degree[i] = adj[i].size();
    if (degree[i] == 1 && ptr == -1) ptr = i;
  }

  vector<int> code(n - 2);
  int leaf = ptr;
  for (int i = 0; i < n - 2; i++) {
    int next = parent[leaf];
    code[i] = next;
    if (--degree[next] == 1 && next < ptr) {
      leaf = next;
    } else {
      ptr++;
      while (degree[ptr] != 1) ptr++;
      leaf = ptr;
    }
  }
  return code;
}
```

### Prufer 序列的性质

1.  在构造完 Prufer 序列后原树中会剩下两个结点，其中一个一定是编号最大的点 $n$ 。
2.  每个结点在序列中出现的次数是其度数减 $1$ 。（没有出现的就是叶结点）

### 用 Prufer 序列重建树

重建树的方法是类似的。根据 Prufer 序列的性质，我们可以得到原树上每个点的度数。然后你也可以得到度数最小的叶结点编号，而这个结点一定与 Prufer 序列的第一个数连接。然后我们同时删掉这两个结点的度数。

讲到这里也许你已经知道该怎么做了。每次我们选择一个度数为 $1$ 的最小的结点编号，与当前枚举到的 Prufer 序列的点连接，然后同时减掉两个点的度。到最后我们剩下两个度数为 $1$ 的点，其中一个是结点 $n$ 。就把它们建立连接。使用堆维护这个过程，在减度数的过程中如果发现度数减到 $1$ 就把这个结点添加到堆中，这样做的复杂度是 $O(n\log n)$ 的。

```cpp
// 原文摘代码
vector<pair<int, int>> pruefer_decode(vector<int> const& code) {
  int n = code.size() + 2;
  vector<int> degree(n, 1);
  for (int i : code) degree[i]++;

  set<int> leaves;
  for (int i = 0; i < n; i++)
    if (degree[i] == 1) leaves.insert(i);

  vector<pair<int, int>> edges;
  for (int v : code) {
    int leaf = *leaves.begin();
    leaves.erase(leaves.begin());

    edges.emplace_back(leaf, v);
    if (--degree[v] == 1) leaves.insert(v);
  }
  edges.emplace_back(*leaves.begin(), n - 1);
  return edges;
}
```

### 线性时间重建树

同线性构造 Prufer 序列的方法。在删度数的时侯会产生新的叶结点，于是判断这个叶结点与指针 $p$ 的大小关系，如果更小就优先考虑它（原文讲得也很略所以我也不细讲啦）

```cpp
// 原文摘代码
vector<pair<int, int>> pruefer_decode(vector<int> const& code) {
  int n = code.size() + 2;
  vector<int> degree(n, 1);
  for (int i : code) degree[i]++;

  int ptr = 0;
  while (degree[ptr] != 1) ptr++;
  int leaf = ptr;

  vector<pair<int, int>> edges;
  for (int v : code) {
    edges.emplace_back(leaf, v);
    if (--degree[v] == 1 && v < ptr) {
      leaf = v;
    } else {
      ptr++;
      while (degree[ptr] != 1) ptr++;
      leaf = ptr;
    }
  }
  edges.emplace_back(leaf, n - 1);
  return edges;
}
```

通过这些过程其实可以理解，Prufer 序列与带标号无根树建立了双射关系。

## Cayley 定理

凯莱定理描述如下：所有群 $G$ 同构于在 $G$ 上的对称群的子群。

是不是一脸懵逼不知所措

还有另一种表述：完全图 $K_n$ 有 $n^{n-2}$ 棵生成树。

怎么证明？方法很多，但是用 Prufer 序列证是很简单的。任意一个长度为 $n-2$ 的值域 $[1,n]$ 的整数序列都可以通过 Prufer 序列双射对应一个生成树，于是方案数就是 $n^{n-2}$ 。

## 图连通方案数

Prufer 序列可能比你想得还强大。它能创造比凯莱定理更通用的公式。比如以下问题：

> 一个 $n$ 个点 $m$ 条边的带标号无向图有 $k$ 个连通块。我们希望添加 $k-1$ 条边使得整个图连通。求方案数。

设 $s_i$ 表示每个连通块的数量。我们对 $k$ 个连通块构造 Prufer 序列，然后你发现这并不是普通的 Prufer 序列。因为每个连通块的连接方法很多。不能直接淦就设啊。于是设 $d_i$ 为第 $i$ 个连通块的度数。由于度数之和是边数的两倍，于是 $\sum_{i=1}^kd_i=2k-2$ 。则对于给定的 $d$ 序列构造 Prufer 序列的方案数是

$$
\binom{k-2}{d_1-1,d_2-1,\cdots,d_k-1}=\frac{(k-2)!}{(d_1-1)!(d_2-1)!\cdots(d_k-1)!}
$$

对于第 $i$ 个连通块，它的连接方式有 ${s_i}^{d_i}$ 种，因此对于给定 $d$ 序列使图连通的方案数是

$$
\binom{k-2}{d_1-1,d_2-1,\cdots,d_k-1}\cdot \prod_{i=1}^k{s_i}^{d_i}
$$

现在我们要枚举 $d$ 序列，式子变成

$$
\sum_{d_i\ge 1，\sum_{i=1}^kd_i=2k-2}\binom{k-2}{d_1-1,d_2-1,\cdots,d_k-1}\cdot \prod_{i=1}^k{s_i}^{d_i}
$$

好的这是一个非常不喜闻乐见的式子。但是别慌！我们有多元二项式定理：

$$
(x_1 + \dots + x_m)^p = \sum_{\substack{c_i \ge 0 ,\  \sum_{i=1}^m c_i = p}} \binom{p}{c_1, c_2, \cdots ,c_m}\cdot \prod_{i=1}^m{x_i}^{c_i}
$$

那么我们对原式做一下换元，设 $e_i=d_i-1$ ，显然 $\sum_{i=1}^ke_i=k-2$ ，于是原式变成

$$
\sum_{e_i\ge 0，\sum_{i=1}^ke_i=k-2}\binom{k-2}{e_1,e_2,\cdots,e_k}\cdot \prod_{i=1}^k{s_i}^{e_i+1}
$$

化简得到

$$
(s_1+s_2+\cdots+s_k)^{k-2}\cdot \prod_{i=1}^ks_i
$$

即

$$
n^{k-2}\cdot\prod_{i=1}^ks_i
$$

这就是答案啦

## 习题

-    [UVA #10843 - Anne's game](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=20&page=show_problem&problem=1784) 
-    [Timus #1069 - Prufer Code](http://acm.timus.ru/problem.aspx?space=1&num=1069) 
-    [Codeforces - Clues](http://codeforces.com/contest/156/problem/D) 
-    [Topcoder - TheCitiesAndRoadsDivTwo](https://community.topcoder.com/stat?c=problem_statement&pm=10774&rd=14146) 

# tree-basic
图论中的树和现实生活中的树长得一样，只不过我们习惯于处理问题的时候把树根放到上方来考虑。这种数据结构看起来像是一个倒挂的树，因此得名。

一个没有固定根结点的树称为 **无根树** （unrooted tree）。无根树有几种等价的形式化定义：

-   有 $n$ 个结点， $n-1$ 条边的连通无向图

-   无向无环的连通图

-   任意两个结点之间有且仅有一条简单路径的无向图

-   任何边均为桥的连通图

-   没有圈，且在任意不同两点间添加一条边之后所得图含唯一的一个圈的图

在无根树的基础上，指定一个结点称为 **根** ，则形成一棵 **有根树** （rooted tree）。有根树在很多时候仍以无向图表示，只是规定了结点之间的上下级关系，详见下文。

## 有关树的定义

### 适用于无根树和有根树

-    **森林（forest）** ：每个连通分量（连通块）都是树的图。按照定义，一棵树也是森林。

-    **生成树（spanning tree）** ：一个连通无向图的生成子图，同时要求是树。也即在图的边集中选择 $n - 1$ 条，将所有顶点连通。

-    **结点的深度（depth）** ：到根结点的路径上的边数。

-    **树的高度（height）** ：所有结点的深度的最大值。

-    **无根树的叶结点（leaf node）** ：度数不超过 $1$ 的结点。

???+question " 为什么不是度数恰为 $1$ ？"
    考虑 $n = 1$ 。

-    **有根树的叶结点（leaf node）** ：没有子结点的结点。

### 只适用于有根树

-    **父亲（parent node）** ：对于除根以外的每个结点，定义为从该结点到根路径上的第二个结点。
    根结点没有父结点。

-    **祖先（ancestor）** ：一个结点到根结点的路径上，除了它本身外的结点。
    根结点的祖先集合为空。

-    **子结点（child node）** ：如果 $u$ 是 $v$ 的父亲，那么 $v$ 是 $u$ 的子结点。  
    子结点的顺序一般不加以区分，二叉树是一个例外。

-    **兄弟（sibling）** ：同一个父亲的多个子结点互为兄弟。

-    **后代（descendant）** ：子结点和子结点的后代。  
    或者理解成：如果 $u$ 是 $v$ 的祖先，那么 $v$ 是 $u$ 的后代。

-    **子树（subtree）** ：删掉与父亲相连的边后，该结点所在的子图。

![tree-basic.png](images/tree-basic.png)

## 特殊的树

-    **链（chain/path graph）** ：满足与任一结点相连的边不超过 $2$ 条的树称为链。

-    **菊花/星星（star）** ：满足存在 $u$ 使得所有除 $u$ 以外结点均与 $u$ 相连的树称为菊花。

-    **有根二叉树（rooted binary tree）** ：每个结点最多只有两个儿子（子结点）的有根树称为二叉树。常常对两个子结点的顺序加以区分，分别称之为左子结点和右子结点。  
    大多数情况下， **二叉树** 一词均指有根二叉树。

![tree-binary.png](images/tree-binary.png)

-    **完整二叉树（full/proper binary tree）** ：每个结点的子结点数量均为 0 或者 2 的二叉树。换言之，每个结点或者是树叶，或者左右子树均非空。

-    **完全二叉树（complete binary tree）** ：只有最下面两层结点的度数可以小于 2，且最下面一层的结点都集中在该层最左边的连续位置上。

-    **完美二叉树（perfect binary tree）** ：所有叶结点的深度均相同的二叉树称为完美二叉树。

???+warning
    Proper binary tree 的汉译名称不固定，且完全二叉树和满二叉树的定义在不同教材中定义不同，遇到的时候需根据上下文加以判断。

OIers 所说的“满二叉树”多指完美二叉树。

## 存储

### 只记录父结点

用一个数组 `parent[N]` 记录每个结点的父亲结点。

这种方式可以获得的信息较少，不便于进行自顶向下的遍历。常用于自底向上的递推问题中。

### 邻接表

-   对于无根树：为每个结点开辟一个线性列表，记录所有与之相连的结点。
    ```cpp
    std::vector<int> adj[N];
    ```
-   对于有根树：
    -   方法一：若给定的是无向图，则仍可以上述形式存储。下文将介绍如何区分结点的上下关系。
    -   方法二：若输入数据能够确保结点的上下关系，则可以利用这个信息。为每个结点开辟一个线性列表，记录其所有子结点；若有需要，还可在另一个数组中记录其父结点。
        ```cpp
        std::vector<int> children[N];
        int parent[N];
        ```
        当然也可以用其他方式（如链表）替代 `std::vector` 。

### 左孩子右兄弟表示法

对于有根树，存在一种简单的表示方法。

首先，给每个结点的所有子结点任意确定一个顺序。

此后为每个结点记录两个值：其 **第一个子结点**  `child[u]` 和其 **下一个兄弟结点**  `sib[u]` 。若没有子结点，则 `child[u]` 为空；若该结点是其父结点的最后一个子结点，则 `sib[u]` 为空。

遍历一个结点的所有子结点可由如下方式实现。

```cpp
int v = child[u];  // 从第一个子结点开始
while (v != EMPTY_NODE) {
  // ...
  // 处理子结点 v
  // ...
  v = sib[v];  // 转至下一个子结点，即 v 的一个兄弟
}
```

也可简写为以下形式。

```cpp
for (int v = child[u]; v != EMPTY_NODE; v = sib[v]) {
  // ...
  // 处理子结点 v
  // ...
}
```

### 二叉树

需要记录每个结点的左右子结点。

```cpp
int parent[N];
int lch[N], rch[N];
// -- or --
int child[N][2];
```

## 树的遍历

### 树上 DFS

在树上 DFS 是这样的一个过程：先访问根节点，然后分别访问根节点每个儿子的子树。

可以用来求出每个节点的深度、父亲等信息。

### 二叉树上 DFS

（图待补）

#### 先序遍历

先访问根，再访问子节点。

#### 中序遍历

先访问左子树，再访问根，再访问右子树。

#### 后序遍历

先访问子节点，再访问根。

已知中序遍历和另外一个可以求第三个。

### 树上 BFS

从树根开始，严格按照层次来访问节点。

BFS 过程中也可以顺便求出各个节点的深度和父亲节点。

### 无根树

树的遍历一般为深度优先遍历，这个过程中最需要注意的是避免重复访问结点。

由于树是无环图，因此只需记录当前结点是由哪个结点访问而来，此后进入除该结点外的所有相邻结点，即可避免重复访问。

```cpp
void dfs(int u, int from) {
  // 递归进入除了 from 之外的所有子结点
  // 对于出发结点，from 为空，故会访问所有相邻结点，这与期望一致
  for (int v : adj[u])
    if (v != from) {
      dfs(v, u);
    }
}

// 开始遍历时
int EMPTY_NODE = -1;  // 一个不存在的编号
int root = 0;         // 任取一个结点作为出发点
dfs(root, EMPTY_NODE);
```

### 有根树

对于有根树，需要区分结点的上下关系。

考察上面的遍历过程，若从根开始遍历，则访问到一个结点时 `from` 的值，就是其父结点的编号。

通过这个方式，可以对于无向的输入求出所有结点的父结点，以及子结点列表。

# color
## 点着色

（讨论的是无环无向图）

对无向图顶点着色，且相邻顶点不能同色。若 $G$ 是 $k$ - 可着色的，但不是 $(k-1)$ - 可着色的，则称 $k$ 是 $G$ 的色数，记为 $\chi'(G)$ 。

对任意图 $G$ ，有 $\chi(G) \leq \Delta(G) + 1$ ，其中 $\Delta(G)$ 为最大度。

### Brooks 定理

设连通图不是完全图也不是奇圈，则 $\chi(G) \leq \Delta(G)$ 。

## 边着色

对无向图的边着色，要求相邻的边涂不同种颜色。若 $G$ 是 $k$ - 边可着色的，但不是 $(k-1)$ - 边可着色的，则称 $k$ 是 $G$ 的边色数，记为 $\chi'(G)$ 。

### Vizing 定理

设 $G$ 是简单图，则 $\Delta(G) \leq \chi'(G) \leq \Delta(G) + 1$ 

若 $G$ 是二部图，则 $\chi'(G)=\Delta(G)$ 

当 $n$ 为奇数（ $n \neq 1$ ）时， $\chi'(K_n)=n$ ; 当 $n$ 为偶数时， $\chi'(K_n)=n-1$ 

### 二分图 Vizing 定理的构造性证明

按照顺序在二分图中加边。

我们在尝试加入边 $(x,y)$ 的时候，我们尝试寻找对于 $x$ 和 $y$ 的编号最小的尚未被使用过的颜色，假设分别为 $lx$ 和 $ly$ 。

如果 $lx=ly$ 此时我们可以直接将这条边的颜色设置为 $lx$ 。

否则假设 $lx<ly$ , 我们可以尝试将节点 $y$ 连出去的颜色为 $lx$ 的边的颜色修改为 $ly$ 。

修改的过程可以被近似的看成是一条从 $y$ 出发，依次经过颜色为 $lx,ly,\cdots$ 的边的有限唯一增广路。

因为增广路有限所以我们可以将增广路上所有的边反色，即原来颜色为 $lx$ 的修改为 $ly$ ，原来颜色为 $ly$ 的修改为 $lx$ 。

根据二分图的性质，节点 $x$ 不可能为增广路节点，否则与最小未使用颜色为 $lx$ 矛盾。

所以我们可以在增广之后直接将连接 $x$ 和 $y$ 的边的颜色设为 $lx$ 。

总构造时间复杂度为 $O(nm)$ 。

??? note "一道很不简单的例题 [uoj 444 二分图](https://uoj.ac/problem/444)"
    本题为笔者于 2018 年命制的集训队第一轮作业题。

    首先我们可以发现答案下界为度数不为 $k$ 倍数的点的个数。

    下界的构造方法是对二分图进行拆点。

    若 $degree \bmod k \neq 0$ ,我们将其拆为 $degree/k$ 个度数为 k 的节点和一个度数为 $degree \bmod k$ 的节点 。

    若 $degree \bmod k = 0$ ,我们将其拆为 $degree/k$ 个度数为 k 的节点。

    拆出来的点在原图中的意义相同，也就是说，在满足度数限制的情况下，一条边端点可以连接任意一个拆出来的点。

    根据 Vizing 定理，我们显然可以构造出该图的一种 $k$ 染色方案。

    删边部分由于和 Vizing 定理关系不大这里不再展开。

    有兴趣的读者可以自行阅读笔者当时写的题解。

## 色多项式

 $f(G,k)$ 表示 $G$ 的不同 $k$ 着色方式的总数。

 $f(K_n, k) = k(k-1)\cdots(k-n+1)$ 

 $f(N_n, k) = k^n$ 

在无向无环图 $G$ 中，

1.   $e=(v_i, v_j) \notin E(G)$ ，则 $f(G, k) = f(G \cup (v_i, v_j), k)+f(G\backslash(v_i, v_j), k)$ 
2.   $e=(v_i, v_j) \in E(G)$ ，则 $f(G,k)=f(G-e,k)-f(G\backslash e,k)$ 

定理：设 $V_1$ 是 $G$ 的点割集，且 $G[V_1]$ 是 $G$ 的 $|V_1|$ 阶完全子图， $G-V_1$ 有 $p(p \geq 2)$ 个连通分支，则：

 $f(G,k)=\frac{\Pi_{i=1}^{p}{(f(H_i, k))}}{f(G[V_1], k)^{p-1}}$ 

其中 $H_i=G[V_1 \cup V(G_i)]$ 

# mst
## 定义

在阅读下列内容之前，请务必阅读 [图论相关概念](./concept.md) 与 [树基础](./tree-basic.md) 部分，并了解以下定义：

1.  生成子图
2.  生成树

我们定义无向连通图的 **最小生成树** （Minimum Spanning Tree，MST）为边权和最小的生成树。

注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。

## Kruskal 算法

Kruskal 算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。

### 前置知识

 [并查集](../ds/dsu.md) 、 [贪心](../basic/greedy.md) 、 [图的存储](./save.md) 。

### 证明

思路很简单，为了造出一棵最小生成树，我们从最小边权的边开始，按边权从小到大依次加入，如果某次加边产生了环，就扔掉这条边，直到加入了 $n-1$ 条边，即形成了一棵树。

证明：使用归纳法，证明任何时候 K 算法选择的边集都被某棵 MST 所包含。

基础：对于算法刚开始时，显然成立（最小生成树存在）。

归纳：假设某时刻成立，当前边集为 $F$ ，令 $T$ 为这棵 MST，考虑下一条加入的边 $e$ 。

如果 $e$ 属于 $T$ ，那么成立。

否则， $T+e$ 一定存在一个环，考虑这个环上不属于 $F$ 的另一条边 $f$ （一定只有一条）。

首先， $f$ 的权值一定不会比 $e$ 小，不然 $f$ 会在 $e$ 之前被选取。

然后， $f$ 的权值一定不会比 $e$ 大，不然 $T+e-f$ 就是一棵比 $T$ 还优的生成树了。

所以， $T+e-f$ 包含了 $F$ ，并且也是一棵最小生成树，归纳成立。

### 实现

算法虽简单，但需要相应的数据结构来支持……

具体来说，维护一个森林，查询两个结点是否在同一棵树中，连接两棵树。

抽象一点地说，维护一堆 **集合** ，查询两个元素是否属于同一集合，合并两个集合。

伪代码：

$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{The edges of the graph } e , \text{ where each element in } e \text{ is } (u, v, w) \\
  &  \text{ denoting that there is an edge between } u \text{ and } v \text{ weighted } w . \\
2 &  \textbf{Output. } \text{The edges of the MST of the input graph}.\\
3 &  \textbf{Method. } \\ 
4 &  result \gets \varnothing \\
5 &  \text{sort } e \text{ into nondecreasing order by weight } w \\ 
6 &  \textbf{for} \text{ each } (u, v, w) \text{ in the sorted } e \\ 
7 &  \qquad \textbf{if } u \text{ and } v \text{ are not connected in the union-find set } \\
8 &  \qquad\qquad \text{connect } u \text{ and } v \text{ in the union-find set} \\
9 &  \qquad\qquad  result \gets result\;\bigcup\ \{(u, v, w)\} \\
10 &  \textbf{return }  result
\end{array}
$$

其中，查询两点是否连通和连接两点可以使用并查集维护。

如果使用 $O(m\log m)$ 的排序算法，并且使用 $O(m\alpha(m, n))$ 或 $O(m\log n)$ 的并查集，就可以得到时间复杂度为 $O(m\log m)$ 的 Kruskal 算法。

## Prim 算法

Prim 算法是另一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。

### 证明

从任意一个结点开始，将结点分成两类：已加入的，未加入的。

每次从未加入的结点中，找一个与已加入的结点之间边权最小值最小的结点。

然后将这个结点加入，并连上那条边权最小的边。

重复 $n-1$ 次即可。

证明：还是说明在每一步，都存在一棵最小生成树包含已选边集。

基础：只有一个结点的时候，显然成立。

归纳：如果某一步成立，当前边集为 $F$ ，属于 $T$ 这棵 MST，接下来要加入边 $e$ 。

如果 $e$ 属于 $T$ ，那么成立。

否则考虑 $T+e$ 中环上另一条可以加入当前边集的边 $f$ 。

首先， $f$ 的权值一定不小于 $e$ 的权值，否则就会选择 $f$ 而不是 $e$ 了。

然后， $f$ 的权值一定不大于 $e$ 的权值，否则 $T+e-f$ 就是一棵更小的生成树了。

因此， $e$ 和 $f$ 的权值相等， $T+e-f$ 也是一棵最小生成树，且包含了 $F$ 。

### 实现

具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。

其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。

堆优化的方式类似 Dijkstra 的堆优化，但如果使用二叉堆等不支持 $O(1)$ decrease-key 的堆，复杂度就不优于 Kruskal，常数也比 Kruskal 大。所以，一般情况下都使用 Kruskal 算法，在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但 **不一定** 实际跑得更快。

暴力： $O(n^2+m)$ 。

二叉堆： $O((n+m) \log n)$ 。

Fib 堆： $O(n \log n + m)$ 。

伪代码：

$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{The nodes of the graph }V\text{ ; the function }g(u, v)\text{ which}\\
  &  \text{means the weight of the edge }(u, v)\text{; the function }adj(v)\text{ which}\\
  &  \text{means the nodes adjacent to }v.\\
2 &  \textbf{Output. } \text{The sum of weights of the MST of the input graph.} \\
3 &  \textbf{Method.} \\
4 &  result \gets 0 \\
5 & \text{choose an arbitrary node in }V\text{ to be the }root \\
6 &  dis(root)\gets 0 \\
7 &  \textbf{for } \text{each node }v\in(V-\{root\}) \\
8 &  \qquad  dis(v)\gets\infty \\
9 &  rest\gets V \\
10 &  \textbf{while }  rest\ne\varnothing \\
11 &  \qquad cur\gets \text{the node with the minimum }dis\text{ in }rest \\
12 &  \qquad  result\gets result+dis(cur) \\
13 &  \qquad  rest\gets rest-\{cur\} \\
14 &  \qquad  \textbf{for}\text{ each node }v\in adj(cur) \\
15 &  \qquad\qquad  dis(v)\gets\min(dis(v), g(cur, v)) \\
16 &  \textbf{return }  result 
\end{array}
$$

注意：上述代码只是求出了最小生成树的权值，如果要输出方案还需要记录每个点的 $dis$ 代表的是哪条边。

## Boruvka 算法

接下来介绍另一种求解最小生成树的算法——Boruvka 算法。该算法的思想是前两种算法的结合。它可以用于求解 **边权互不相同** 的无向图的最小生成森林。（无向连通图就是最小生成树。）

为了描述该算法，我们需要引入一些定义：

1.  定义 $E'$ 为我们当前找到的最小生成森林的边。在算法执行过程中，我们逐步向 $E'$ 加边，定义 **连通块** 表示一个点集 $V'\subseteq V$ ，且这个点集中的任意两个点 $u$ , $v$ 在 $E'$ 中的边构成的子图上是连通的（互相可达）。
2.  定义一个连通块的 **最小边** 为它连向其它连通块的边中权值最小的那一条。

初始时， $E'=\varnothing$ ，每个点各自是一个连通块：

1.  计算每个点分别属于哪个连通块。将每个连通块都设为“没有最小边”。
2.  遍历每条边 $(u, v)$ ，如果 $u$ 和 $v$ 不在同一个连通块，就用这条边的边权分别更新 $u$ 和 $v$ 所在连通块的最小边。
3.  如果所有连通块都没有最小边，退出程序，此时的 $E'$ 就是原图最小生成森林的边集。否则，将每个有最小边的连通块的最小边加入 $E'$ ，返回第一步。

下面通过一张动态图来举一个例子（图源自 [维基百科](https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm) ）：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![eg](./images/mst-1.gif)

当原图连通时，每次迭代连通块数量至少减半，算法只会迭代不超过 $O(\log V)$ 次，而原图不连通时相当于多个子问题，因此算法复杂度是 $O(E\log V)$ 的。给出算法的伪代码：（修改自 [维基百科](https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm) ）

$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{A graph }G\text{ whose edges have distinct weights. } \\
2 &  \textbf{Output. } \text{The minimum spanning forest of }G .  \\
3 &  \textbf{Method. }  \\
4 & \text{Initialize a forest }F\text{ to be a set of one-vertex trees} \\
5 &  \textbf{while } \text{True} \\
6 &  \qquad \text{Find the components of }F\text{ and label each vertex of }G\text{ by its component } \\
7 &  \qquad \text{Initialize the cheapest edge for each component to "None"} \\
8 &  \qquad  \textbf{for } \text{each edge }(u, v)\text{ of }G  \\
9 &  \qquad\qquad  \textbf{if }  u\text{ and }v\text{ have different component labels} \\
10 &  \qquad\qquad\qquad  \textbf{if }  (u, v)\text{ is cheaper than the cheapest edge for the component of }u  \\
11 &  \qquad\qquad\qquad\qquad\text{ Set }(u, v)\text{ as the cheapest edge for the component of }u \\
12 &  \qquad\qquad\qquad  \textbf{if }  (u, v)\text{ is cheaper than the cheapest edge for the component of }v  \\
13 &  \qquad\qquad\qquad\qquad\text{ Set }(u, v)\text{ as the cheapest edge for the component of }v  \\
14 &  \qquad  \textbf{if }\text{ all components'cheapest edges are "None"} \\
15 &  \qquad\qquad  \textbf{return }  F \\
16 &  \qquad  \textbf{for }\text{ each component whose cheapest edge is not "None"} \\
17 &  \qquad\qquad\text{ Add its cheapest edge to }F \\
\end{array}
$$

## 习题

-    [「HAOI2006」聪明的猴子](https://www.luogu.org/problem/P2504) 
-    [「SCOI2005」繁忙的都市](https://loj.ac/problem/2149) 

## 最小生成树的唯一性

考虑最小生成树的唯一性。如果一条边 **不在最小生成树的边集中** ，并且可以替换与其 **权值相同、并且在最小生成树边集** 的另一条边。那么，这个最小生成树就是不唯一的。

对于 Kruskal 算法，只要计算为当前权值的边可以放几条，实际放了几条，如果这两个值不一样，那么就说明这几条边与之前的边产生了一个环（这个环中至少有两条当前权值的边，否则根据并查集，这条边是不能放的），即最小生成树不唯一。

寻找权值与当前边相同的边，我们只需要记录头尾指针，用单调队列即可在 $O(\alpha(m))$ （m 为边数）的时间复杂度里优秀解决这个问题（基本与原算法时间相同）。

??? note " 例题：[POJ 1679](http://poj.org/problem?id=1679)"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    
    struct Edge {
      int x, y, z;
    };
    int f[100001];
    Edge a[100001];
    int cmp(const Edge& a, const Edge& b) { return a.z < b.z; }
    int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }
    int main() {
      int t;
      scanf("%d", &t);
      while (t--) {
        int n, m;
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; i++) f[i] = i;
        for (int i = 1; i <= m; i++) scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].z);
        sort(a + 1, a + m + 1, cmp);
        int num = 0, ans = 0, tail = 0, sum1 = 0, sum2 = 0;
        bool flag = 1;
        for (int i = 1; i <= m + 1; i++) {
          if (i > tail) {
            if (sum1 /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= sum2) {
              flag = 0;
              break;
            }
            sum1 = 0;
            for (int j = i; j <= m + 1; j++) {
              if (a[j].z /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= a[i].z) {
                tail = j - 1;
                break;
              }
              if (find(a[j].x) /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= find(a[j].y)) ++sum1;
            }
            sum2 = 0;
          }
          if (i > m) break;
          int x = find(a[i].x);
          int y = find(a[i].y);
          if (x /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= y && num /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= n - 1) {
            sum2++;
            num++;
            f[x] = f[y];
            ans += a[i].z;
          }
        }
        if (flag)
          printf("%d\n", ans);
        else
          printf("Not Unique/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!\n");
      }
      return 0;
    }
    ```

## 次小生成树

### 非严格次小生成树

#### 定义

在无向图中，边权和最小的满足边权和 **大于等于** 最小生成树边权和的生成树

#### 求解方法

-   求出无向图的最小生成树 $T$ ，设其权值和为 $M$ 
-   遍历每条未被选中的边 $e = (u,v,w)$ ，找到 $T$ 中 $u$ 到 $v$ 路径上边权最大的一条边 $e' = (s,t,w')$ ，则在 $T$ 中以 $e$ 替换 $e'$ ，可得一棵权值和为 $M' = M + w - w'$ 的生成树 $T'$ .
-   对所有替换得到的答案 $M'$ 取最小值即可

如何求 $u,v$ 路径上的边权最大值呢？

我们可以使用倍增来维护，预处理出每个节点的 $2^i$ 级祖先及到达其 $2^i$ 级祖先路径上最大的边权，这样在倍增求 LCA 的过程中可以直接求得。

### 严格次小生成树

#### 定义

在无向图中，边权和最小的满足边权和 **严格大于** 最小生成树边权和的生成树

#### 求解方法

考虑刚才的非严格次小生成树求解过程，为什么求得的解是非严格的？

因为最小生成树保证生成树中 $u$ 到 $v$ 路径上的边权最大值一定 **不大于** 其他从 $u$ 到 $v$ 路径的边权最大值。换言之，当我们用于替换的边的权值与原生成树中被替换边的权值相等时，得到的次小生成树是非严格的。

解决的办法很自然：我们维护到 $2^i$ 级祖先路径上的最大边权的同时维护 **严格次大边权** ，当用于替换的边的权值与原生成树中路径最大边权相等时，我们用严格次大值来替换即可。

这个过程可以用倍增求解，复杂度 $O(m \log m)$ 。

#### 代码

```cpp
#include <algorithm>
#include <iostream>

const int INF = 0x3fffffff;
const long long INF64 = 0x3fffffffffffffffLL;

struct Edge {
  int u, v, val;
  bool operator<(const Edge &other) const { return val < other.val; }
};

Edge e[300010];
bool used[300010];

int n, m;
long long sum;

class Tr {
 private:
  struct Edge {
    int to, nxt, val;
  } e[600010];
  int cnt, head[100010];

  int pnt[100010][22];
  int dpth[100010];
  // 到祖先的路径上边权最大的边
  int maxx[100010][22];
  // 到祖先的路径上边权次大的边，若不存在则为 -INF
  int minn[100010][22];

 public:
  void addedge(int u, int v, int val) {
    e[++cnt] = (Edge){v, head[u], val};
    head[u] = cnt;
  }

  void insedge(int u, int v, int val) {
    addedge(u, v, val);
    addedge(v, u, val);
  }

  void dfs(int now, int fa) {
    dpth[now] = dpth[fa] + 1;
    pnt[now][0] = fa;
    minn[now][0] = -INF;
    for (int i = 1; (1 << i) <= dpth[now]; i++) {
      pnt[now][i] = pnt[pnt[now][i - 1]][i - 1];
      int kk[4] = {maxx[now][i - 1], maxx[pnt[now][i - 1]][i - 1],
                   minn[now][i - 1], minn[pnt[now][i - 1]][i - 1]};
      // 从四个值中取得最大值
      std::sort(kk, kk + 4);
      maxx[now][i] = kk[3];
      // 取得严格次大值
      int ptr = 2;
      while (ptr >= 0 && kk[ptr] == kk[3]) ptr--;
      minn[now][i] = (ptr == -1 ? -INF : kk[ptr]);
    }

    for (int i = head[now]; i; i = e[i].nxt) {
      if (e[i].to /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= fa) {
        maxx[e[i].to][0] = e[i].val;
        dfs(e[i].to, now);
      }
    }
  }

  int lca(int a, int b) {
    if (dpth[a] < dpth[b]) std::swap(a, b);

    for (int i = 21; i >= 0; i--)
      if (dpth[pnt[a][i]] >= dpth[b]) a = pnt[a][i];

    if (a == b) return a;

    for (int i = 21; i >= 0; i--) {
      if (pnt[a][i] /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= pnt[b][i]) {
        a = pnt[a][i];
        b = pnt[b][i];
      }
    }
    return pnt[a][0];
  }

  int query(int a, int b, int val) {
    int res = -INF;
    for (int i = 21; i >= 0; i--) {
      if (dpth[pnt[a][i]] >= dpth[b]) {
        if (val /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= maxx[a][i])
          res = std::max(res, maxx[a][i]);
        else
          res = std::max(res, minn[a][i]);
        a = pnt[a][i];
      }
    }
    return res;
  }
} tr;

int fa[100010];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

void Kruskal() {
  int tot = 0;
  std::sort(e + 1, e + m + 1);
  for (int i = 1; i <= n; i++) fa[i] = i;

  for (int i = 1; i <= m; i++) {
    int a = find(e[i].u);
    int b = find(e[i].v);
    if (a /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!= b) {
      fa[a] = b;
      tot++;
      tr.insedge(e[i].u, e[i].v, e[i].val);
      sum += e[i].val;
      used[i] = 1;
    }
    if (tot == n - 1) break;
  }
}

int main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  std::cout.tie(0);

  std::cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    int u, v, val;
    std::cin >> u >> v >> val;
    e[i] = (Edge){u, v, val};
  }

  Kruskal();
  long long ans = INF64;
  tr.dfs(1, 0);

  for (int i = 1; i <= m; i++) {
    if (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!used[i]) {
      int _lca = tr.lca(e[i].u, e[i].v);
      // 找到路径上不等于 e[i].val 的最大边权
      long long tmpa = tr.query(e[i].u, _lca, e[i].val);
      long long tmpb = tr.query(e[i].v, _lca, e[i].val);
      // 这样的边可能不存在，只在这样的边存在时更新答案
      if (std::max(tmpa, tmpb) > -INF)
        ans = std::min(ans, sum - std::max(tmpa, tmpb) + e[i].val);
    }
  }
  // 次小生成树不存在时输出 -1
  std::cout << (ans == INF64 ? -1 : ans) << '\n';
  return 0;
}
```

## 瓶颈生成树

### 定义

无向图 $G$ 的瓶颈生成树是这样的一个生成树，它的最大的边权值在 $G$ 的所有生成树中最小。

### 性质

 **最小生成树是瓶颈生成树的充分不必要条件。** 即最小生成树一定是瓶颈生成树，而瓶颈生成树不一定是最小生成树。

关于最小生成树一定是瓶颈生成树这一命题，可以运用反证法证明：我们设最小生成树中的最大边权为 $w$ ，如果最小生成树不是瓶颈生成树的话，则瓶颈生成树的所有边权都小于 $w$ ，我们只需删去原最小生成树中的最长边，用瓶颈生成树中的一条边来连接删去边后形成的两棵树，得到的新生成树一定比原最小生成树的权值和还要小，这样就产生了矛盾。

### 例题

???+note "POJ 2395 Out of Hay"
    给出 n 个农场和 m 条边，农场按 1 到 n 编号，现在有一人要从编号为 1 的农场出发到其他的农场去，求在这途中他最多需要携带的水的重量，注意他每到达一个农场，可以对水进行补给，且要使总共的路径长度最小。
    题目要求的就是瓶颈树的最大边，可以通过求最小生成树来解决。

## 最小瓶颈路

### 定义

无向图 $G$ 中 x 到 y 的最小瓶颈路是这样的一类简单路径，满足这条路径上的最大的边权在所有 x 到 y 的简单路径中是最小的。

### 性质

根据最小生成树定义，x 到 y 的最小瓶颈路上的最大边权等于最小生成树上 x 到 y 路径上的最大边权。虽然最小生成树不唯一，但是每种最小生成树 x 到 y 路径的最大边权相同且为最小值。也就是说，每种最小生成树上的 x 到 y 的路径均为最小瓶颈路。

但是，并不是所有最小瓶颈路都存在一棵最小生成树满足其为树上 x 到 y 的简单路径。

例如下图：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/mst5.png)

1 到 4 的最小瓶颈路显然有以下两条：1-2-3-4。1-3-4。

但是，1-2 不会出现在任意一种最小生成树上。

### 应用

由于最小瓶颈路不唯一，一般情况下会询问最小瓶颈路上的最大边权。

也就是说，我们需要求最小生成树链上的 max。

倍增、树剖都可以解决，这里不再展开。

## Kruskal 重构树

### 定义

在跑 Kruskal 的过程中我们会从小到大加入若干条边。现在我们仍然按照这个顺序。

首先新建 n 个集合，每个集合恰有一个节点，点权为 $0$ 。

每一次加边会合并两个集合，我们可以新建一个点，点权为加入边的边权，同时将两个集合的根节点分别设为新建点的左儿子和右儿子。然后我们将两个集合和新建点合并成一个集合。将新建点设为根。

不难发现，在进行 $n-1$ 轮之后我们得到了一棵恰有 $n$ 个叶子的二叉树，同时每个非叶子节点恰好有两个儿子。这棵树就叫 Kruskal 重构树。

举个例子：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/mst5.png)

这张图的 Kruskal 重构树如下：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/mst6.png)

### 性质

不难发现，最小生成树上两个点之间的简单路径上边权最大值 = Kruskal 重构树上两点之间的 LCA 的权值。

也就是说，到点 $x$ 的简单路径上边权最大值 $\leq val$ 的所有点 $y$ 均在 Kruskal 重构树上的某一棵子树内，且恰好为该子树的所有叶子节点。

我们在 Kruskal 重构树上找到 $x$ 到根的路径上权值 $\leq val$ 的最浅的节点。显然这就是所有满足条件的节点所在的子树的根节点。

??? note "[「LOJ 137」最小瓶颈路 加强版](https://loj.ac/problem/137)"

    ```cpp
    #include<bits/stdc++.h>

    using namespace std;

    const int MAX_VAL_RANGE = 280010;

    int n,m,log2Values[MAX_VAL_RANGE + 1];

    namespace TR
    {
        struct Edge
        {
            int to,nxt,val;
        }e[400010];
        int cnt,head[140010];

        void addedge(int u,int v,int val=0)
        {
            e[++cnt]=(Edge){v,head[u],val};
            head[u]=cnt;
        }

        int val[140010];
        namespace LCA
        {
            int sec[280010],cnt;
            int pos[140010];
            int dpth[140010];

            void dfs(int now,int fa)
            {
                dpth[now]=dpth[fa]+1;
                sec[++cnt]=now;
                pos[now]=cnt;

                for(int i=head[now];i;i=e[i].nxt)
                {
                    if(fa/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!=e[i].to)
                    {
                        dfs(e[i].to,now); 
                        sec[++cnt]=now;
                    }
                }
            }

            int dp[280010][20];
            void init()
            {
                dfs(2*n-1,0);
                for(int i=1;i<=4*n;i++)
                {
                    dp[i][0]=sec[i];
                }
                for(int j=1;j<=19;j++)
                {
                    for(int i=1;i+(1<<j)-1<=4*n;i++)
                    {
                        dp[i][j]=dpth[dp[i][j-1]]<dpth[dp[i+(1<<(j-1))][j-1]]?dp[i][j-1]:dp[i+(1<<(j-1))][j-1];
                    }
                }
            }

            int lca(int x,int y)
            {
                int l=pos[x],r=pos[y];
                if(l>r)
                {
                    swap(l,r);
                }
                int k=log2Values[r - l + 1];
                return dpth[dp[l][k]]<dpth[dp[r-(1<<k)+1][k]]?dp[l][k]:dp[r-(1<<k)+1][k];
            }
        }
    }

    using TR::addedge;

    namespace GR
    {
        struct Edge
        {
            int u,v,val;

            bool operator<(const Edge &other)const
            {
                return val<other.val;
            }
        }e[100010];

        int fa[140010];

        int find(int x)
        {
            return fa[x]==0?x:fa[x]=find(fa[x]);
        }

        void kruskal()
        {
            int tot=0,cnt=n;
            sort(e+1,e+m+1);
            for(int i=1;i<=m;i++)
            {
                int fau=find(e[i].u),fav=find(e[i].v);
                if(fau/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!=fav)
                {
                    cnt++;
                    fa[fau]=fa[fav]=cnt;
                    addedge(fau,cnt);
                    addedge(cnt,fau);
                    addedge(fav,cnt);
                    addedge(cnt,fav);
                    TR::val[cnt]=e[i].val;
                    tot++;
                }
                if(tot==n-1)
                {
                    break;
                }
            }
        }
    }

    int ans;
    int A,B,C,P;
    inline int rnd()
    {
        return A=(A*B+C)%P;
    }

    void initLog2()
    {
        for(int i = 2;i <= MAX_VAL_RANGE;i++) {
            log2Values[i] = log2Values[i >> 1] + 1;
        }
    }

    int main()
    {
        initLog2();
        cin>>n>>m;
        for(int i=1;i<=m;i++)
        {
            int u,v,val;
            cin>>u>>v>>val;
            GR::e[i]=(GR::Edge){u,v,val};
        }
        GR::kruskal();
        TR::LCA::init();
        int Q;
        cin>>Q;
        cin>>A>>B>>C>>P;

        while(Q--)
        {
            int u=rnd()%n+1,v=rnd()%n+1;
            ans+=TR::val[TR::LCA::lca(u,v)];
            ans%=1000000007;
        }
        cout<<ans;
        return 0;
    }
    ```

??? note "[NOI 2018 归程](https://uoj.ac/problem/393)"
    首先预处理出来每一个点到根节点的最短路。

    我们构造出来根据海拔的最大生成树。显然每次询问可以到达的节点是在最小生成树和询问点的最小边权 $\geq p$ 的节点。

    根据 Kruskal 重构树的性质，这些节点满足均在一棵子树内同时为其所有叶子节点。

    也就是说，我们只需要求出 Kruskal 重构树上每一棵子树叶子的权值 min 就可以支持子树询问。

    询问的根节点可以使用 Kruskal 重构树上倍增的方式求出。

    时间复杂度 $O((n+m+Q) \log n)$

# tree-centroid
author: Ir1d, TrisolarisHD, LucienShui, Anguei

## 定义

对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。

（这里以及下文中的“子树”都是指无根树的子树，即包括“向上”的那棵子树，并且不包括整棵树自身。）

## 性质

以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。

树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。

把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。

在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。

## 求法

在 DFS 中计算每个子树的大小，记录“向下”的子树的最大大小，利用总点数 - 当前子树（这里的子树指有根树的子树）的大小得到“向上”的子树的大小，然后就可以依据定义找到重心了。

???+note "参考代码"
    ```cpp
    void getCentroid(int u, int fa) {
      siz[u] = 1;
      wt[u] = 0;
      for (int i = head[u]; ~i; i = nxt[i]) {
        int v = to[i];
        if (v != fa) {
          getCentroid(v, u);
          siz[u] += siz[v];
          wt[u] = max(wt[u], siz[v]);
        }
      }
      wt[u] = max(wt[u], n - siz[u]);
      if (rt == 0 || wt[u] < wt[rt]) rt = u;  // rt 为重心编号
    }
    ```

## 参考

 <http://fanhq666.blog.163.com/blog/static/81943426201172472943638/> 

 <https://www.cnblogs.com/zinthos/p/3899075.html> 

# tree-hash
我们有时需要判断一些树是否同构。这时，选择恰当的哈希方式来将树映射成一个便于储存的哈希值（一般是 32 位或 64 位整数）是一个优秀的方案。

树哈希有很多种哈希方式，下面将选出几种较为常用的方式来加以介绍。

## 方法一

### 公式

$$
f_{now}=size_{now} \times \sum f_{son_{now,i}}\times seed^{i-1}
$$

#### 注

其中 $f_x$ 为以节点 $x$ 为根的子树对应的哈希值。特殊地，我们令叶子节点的哈希值为 $1$ 。

 $size_{x}$ 表示以节点 $x$ 为根的子树大小。

 $son_{x,i}$ 表示 $x$ 所有子节点以 $f$ 作为关键字排序后排名第 $i$ 的儿子。

 $seed$ 为选定的一个合适的种子（最好是质数，对字符串 hash 有了解的人一定不陌生）

上述哈希过程中，可以适当取模避免溢出或加快运行速度。

#### Hack

![treehash1](./images/treehash1.png)

上图中，可以计算出两棵树的哈希值均为 $60(1+seed)$ 。

## 方法二

### 公式

$$
f_{now}=\bigoplus f_{son_{now,i}}\times seed+size_{son_{now,i}}
$$

#### 注

其中 $f_x$ 为以节点 $x$ 为根的子树对应的哈希值。特殊地，我们令叶子节点的哈希值为 $1$ 。

 $size_{x}$ 表示以节点 $x$ 为根的子树大小。

 $son_{x,i}$ 表示 $x$ 所有子节点之一（不用排序）。

 $seed$ 为选定的一个合适的质数。

 $\large\bigoplus$ 表示异或和。

#### Hack

由于异或的性质，如果一个节点下有多棵本质相同的子树，这种哈希值将无法分辨该种子树出现 $1,3,5,\dots$ 次的情况。

## 方法三

### 公式

$$
f_{now}=1+\sum f_{son_{now,i}} \times prime(size_{son_{now,i}})
$$

### 注

其中 $f_x$ 为以节点 $x$ 为根的子树对应的哈希值。

 $size_{x}$ 表示以节点 $x$ 为根的子树大小。

 $son_{x,i}$ 表示 $x$ 所有子节点之一（不用排序）。

 $prime(i)$ 表示第 $i$ 个质数。

## 例题

### 例题一 [「BJOI2015」树的同构](https://www.luogu.org/problemnew/show/P5043) 

我们用上述方式任选其一进行哈希，注意到我们求得的是子树的 hash 值，也就是说只有当根一样时同构的两棵子树 hash 值才相同。由于数据范围较小，我们可以暴力求出以每个点为根时的哈希值，也可以通过 up and down 树形 dp 的方式，遍历树两遍求出以每个点为根时的哈希值，排序后比较。

如果数据范围较大，我们可以通过找重心的方式来优化复杂度。（一棵树的重心最多只有两个，分别比较即可）

#### 做法一

??? "例题参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    
    using i64 = long long;
    using u64 = unsigned long long;
    
    constexpr int maxT = 50;
    constexpr int maxn = 50;
    constexpr int SEED = 98243;
    constexpr int inf = 2147483647;
    
    inline int io() {
      static int _;
      return scanf("%d", &_), _;
    }
    
    template <class _Tp>
    inline _Tp Max(const _Tp x, const _Tp y) {
      return x > y ? x : y;
    }
    template <class _Tp>
    inline void chkMax(_Tp &x, const _Tp y) {
      (x < y) && (x = y);
    }
    template <class _Tp>
    inline void chkMin(_Tp &x, const _Tp y) {
      (x > y) && (x = y);
    }
    template <class _Tp>
    inline void swap(_Tp &x, _Tp &y) {
      _Tp z = x;
      x = y;
      y = z;
    }
    
    struct Edge {
      int v;
      Edge *las;
      inline Edge *init(const int to, Edge *const ls) {
        return v = to, las = ls, this;
      }
    } * las[maxn + 1], pool[maxn << 1], *alc = pool - 1;
    
    inline void lnk(const int u, const int v) {
      if (u == 0) return;
      las[u] = (++alc)->init(v, las[u]);
      las[v] = (++alc)->init(u, las[v]);
    }
    
    u64 hval[maxn + 1];
    void calc(const int u, const int fa) {
      static u64 lis[maxn + 1];
      static int sz[maxn + 1];
    
      /* DFS 时计算 size */
      sz[u] = 1;
      for (Edge *o = las[u]; o; o = o->las)
        if (o->v != fa) calc(o->v, u), sz[u] += sz[o->v];
    
      /* 将 u 各个儿子的哈希值排序 */
      int cnt = 0;
      for (Edge *o = las[u]; o; o = o->las)
        if (o->v != fa) lis[++cnt] = hval[o->v];
      std::sort(lis + 1, lis + cnt + 1);
    
      /* 计算 u 的哈希值 */
      u64 val = 0;
      for (int i = 1; i <= cnt; ++i) val = val * SEED + lis[i];
      hval[u] = val ? val * sz[u] : 1;
    }
    
    int sz[maxn + 1], mxsz[maxn + 1];
    void precalc(const int u, const int fa) {
      /* 找树的重心 */
      sz[u] = 1;
      mxsz[u] = 0;
      for (Edge *o = las[u]; o; o = o->las)
        if (o->v != fa) {
          precalc(o->v, u);
          sz[u] += sz[o->v];
          chkMax(mxsz[u], sz[o->v]);
        }
    }
    
    int main() {
      static int n[maxT + 1];
      static u64 val[maxT + 1][2];
    
      const int T = io();
      for (int i = 1; i <= T; ++i) {
        n[i] = io();
        for (int u = 1; u <= n[i]; ++u) lnk(io(), u);
    
        precalc(1, 0);
        int rtsz = inf, cnt = 0;
        for (int u = 1; u <= n[i]; ++u) chkMin(rtsz, Max(mxsz[u], n[i] - sz[u]));
        for (int u = 1; u <= n[i]; ++u)
          if (rtsz == Max(mxsz[u], n[i] - sz[u]))
            calc(u, 0), val[i][cnt++] = hval[u];
        /* 如果这个点是重心就计算其哈希值 */
    
        if (cnt == 2 && val[i][0] > val[i][1]) swap(val[i][0], val[i][1]);
    
        /* 清空数组 */
        for (int u = 1; u <= n[i]; ++u) las[u] = nullptr;
        alc = pool - 1;
      }
    
      for (int i = 1; i <= T; ++i) {
        bool flag = true;
        for (int j = 1; j != i; ++j)
          if (n[i] == n[j] && val[i][0] == val[j][0] && val[i][1] == val[j][1]) {
            /* 若树 j 与树 i 点数相同且重心哈希值相同，则其同构 */
            flag = false;
            printf("%d\n", j);
            break;
          }
        if (flag) printf("%d\n", i);
      }
    
      return 0;
    }
    ```

#### 做法二

??? "例题参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <tr1/unordered_map>
    #include <vector>
    
    class Solution {
     private:
      typedef unsigned long long ull;
      typedef std::vector<int>::iterator it;
      static const ull seed = 2333233233;
      static const int maxn = 107;
    
      int n, m, size[maxn], lastRoot, root, lastMax, Max, ans;
      ull hashval[maxn], res;
      std::vector<int> e[maxn];
      std::tr1::unordered_map<ull, int> id;
    
      ull getHash(int now, int fa) {
        size[now] = 1;
        hashval[now] = 1;
        for (register it i = e[now].begin(); i != e[now].end(); ++i) {
          int v = *i;
          if (v == fa) {
            continue;
          }
          hashval[now] ^= getHash(v, now) * seed + size[v];
          size[now] += size[v];
        }
        return hashval[now];
      }
    
      void getRoot(int now, int fa) {
        int max = 0;
        size[now] = 1;
        for (register it i = e[now].begin(); i != e[now].end(); ++i) {
          int v = *i;
          if (v == fa) {
            continue;
          }
          getRoot(v, now);
          size[now] += size[v];
          max = std::max(max, size[v]);
        }
        max = std::max(max, n - size[now]);
        if (max < Max && now != lastRoot) {
          root = now;
          Max = max;
        }
      }
    
     public:
      Solution() {
        get();
        solve();
      }
    
      void get() {
        scanf("%d", &m);
        for (register int i = 1; i <= m; i++) {
          scanf("%d", &n);
          for (register int j = 1; j <= n; j++) {
            std::vector<int>().swap(e[j]);
          }
          for (register int j = 1, fa; j <= n; j++) {
            scanf("%d", &fa);
            if (!fa) {
              root = j;
            } else {
              e[fa].push_back(j);
              e[j].push_back(fa);
            }
          }
          lastRoot = root = 0;
          Max = n;
          getRoot(1, 0);
          lastRoot = root, lastMax = Max;
          res = getHash(root, 0);
          if (!id.count(res)) {
            id[res] = i;
          }
          ans = id[res];
    
          Max = n;
          getRoot(1, 0);
          if (lastMax == Max) {
            res = getHash(root, 0);
            if (!id.count(res)) {
              id[res] = i;
            }
            ans = std::min(ans, id[res]);
          }
          printf("%d\n", ans);
        }
      }
    
      void solve() {}
    };
    Solution sol;
    
    int main() {}
    ```

### 例题二 [HDU 6647](http://acm.hdu.edu.cn/showproblem.php?pid=6647) 

题目要求的是遍历一棵无根树产生的本质不同括号序列方案数。

首先，注意到一个结论，对于两棵有根树，如果他们不同构，一定不会生成相同的括号序列。我们先考虑遍历有根树能够产生的本质不同括号序列方案数，假设我们当前考虑的子树根节点为 $u$ ，记 $f(u)$ 表示这棵子树的方案数， $son(u)$ 表示 $u$ 的儿子节点集合，从 $u$ 开始往下遍历，顺序可以随意选择，产生 $|son(u)|!$ 种排列，遍历每个儿子节点 $v$ ， $v$ 的子树内有 $f(v)$ 种方案，因此有 $f(u)=|son(u)|! \cdot \prod_{v\in son(u)} f(v)$ 。但是，同构的子树之间会产生重复， $f(u)$ 需要除掉每种本质不同子树出现次数阶乘的乘积，类似于多重集合的排列。

通过上述树形 dp，可以求出根节点的方案数，再通过 up and down 树形 dp，将父亲节点的哈希值和方案信息转移给儿子，可以求出以每个节点为根时的哈希值和方案数，每种不同的子树只需要计数一次即可。

注意，本题数据较强，树哈希很容易发生冲突。这里提供一个比较简单的解决方法，求出一个节点子树的哈希值后，可以将其前后分别插入一个值再计算一遍哈希值。

#### 做法

??? "例题参考代码"
    ```cpp
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    #include <map>
    #include <set>
    #include <utility>
    #include <vector>
    using namespace std;
    typedef long long ll;
    typedef unsigned long long ull;
    typedef pair<int, int> PII;
    const int mod = 998244353;
    const int inf = 1 << 30;
    const int maxn = 100000 + 5;
    namespace sieve {
    const int maxp = 2000000 + 5;
    int vis[maxp], prime[maxp], tot;
    void init() {
      ms(vis, 0);
      for (int i = 2; i < maxp; i++) {
        if (!vis[i]) prime[++tot] = i;
        for (int j = 1; j <= tot && prime[j] * i < maxp; j++) {
          vis[i * prime[j]] = 1;
          if (i % prime[j] == 0) break;
        }
      }
    }
    }  // namespace sieve
    namespace MyIO {
    struct fastIO {
      char s[100000];
      int it, len;
      fastIO() { it = len = 0; }
      inline char get() {
        if (it < len) return s[it++];
        it = 0;
        len = fread(s, 1, 100000, stdin);
        if (len == 0)
          return EOF;
        else
          return s[it++];
      }
      bool notend() {
        char c = get();
        while (c == ' ' || c == '\n') c = get();
        if (it > 0) it--;
        return c != EOF;
      }
    } buff;
    inline int gi() {
      int r = 0;
      bool ng = 0;
      char c = buff.get();
      while (c != '-' && (c < '0' || c > '9')) c = buff.get();
      if (c == '-') ng = 1, c = buff.get();
      while (c >= '0' && c <= '9') r = r * 10 + c - '0', c = buff.get();
      return ng ? -r : r;
    }
    }  // namespace MyIO
    namespace {
    inline int add(int x, int y) {
      x += y;
      return x >= mod ? x -= mod : x;
    }
    inline int sub(int x, int y) {
      x -= y;
      return x < 0 ? x += mod : x;
    }
    inline int mul(int x, int y) { return 1ll * x * y % mod; }
    inline int qpow(int x, ll n) {
      int r = 1;
      while (n > 0) {
        if (n & 1) r = 1ll * r * x % mod;
        n >>= 1;
        x = 1ll * x * x % mod;
      }
      return r;
    }
    inline int inv(int x) { return qpow(x, mod - 2); }
    }  // namespace
    using MyIO::gi;
    using sieve::prime;
    int ping[maxn], pingv[maxn];
    int n, ans, siz[maxn];
    vector<int> edge[maxn];
    map<ull, int> uqc[maxn];
    map<ull, int>::iterator it;
    ull hashval[maxn], hashrt[maxn];
    ull srchashval[maxn], srchashrt[maxn];
    int dp[maxn], rdp[maxn];
    ull pack(ull val, int sz) { return 2ull + 3ull * val + 7ull * prime[sz + 1]; }
    void predfs(int u, int ff) {
      siz[u] = dp[u] = 1;
      hashval[u] = 1;
      int sz = 0;
      for (int v : edge[u]) {
        if (v == ff) continue;
        predfs(v, u);
        sz++;
        siz[u] += siz[v];
        dp[u] = mul(dp[u], dp[v]);
        uqc[u][hashval[v]]++;
        hashval[u] += hashval[v] * prime[siz[v]];
      }
      srchashval[u] = hashval[u];
      hashval[u] = pack(hashval[u], siz[u]);
      dp[u] = mul(dp[u], ping[sz]);
      for (it = uqc[u].begin(); it != uqc[u].end(); it++) {
        dp[u] = mul(dp[u], pingv[it->second]);
      }
    }
    set<ull> qc;
    void dfs(int u, int ff) {
      if (!qc.count(hashrt[u])) {
        qc.insert(hashrt[u]);
        ans = add(ans, rdp[u]);
      }
      for (int v : edge[u]) {
        if (v == ff) continue;
        ull tmp = srchashrt[u] - hashval[v] * prime[siz[v]];
        tmp = pack(tmp, n - siz[v]);
        uqc[v][tmp]++;
        srchashrt[v] = srchashval[v] + tmp * prime[n - siz[v]];
        hashrt[v] = pack(srchashrt[v], n);
        int tdp = mul(rdp[u], inv(dp[v]));
        tdp = mul(tdp, inv((int)edge[u].size()));
        tdp = mul(tdp, uqc[u][hashval[v]]);
        rdp[v] = mul(dp[v], tdp);
        rdp[v] = mul(rdp[v], (int)edge[v].size());
        rdp[v] = mul(rdp[v], inv(uqc[v][tmp]));
        dfs(v, u);
      }
    }
    int main() {
      sieve::init();
      ping[0] = pingv[0] = 1;
      for (int i = 1; i < maxn; i++) {
        ping[i] = mul(ping[i - 1], i);
        pingv[i] = mul(pingv[i - 1], inv(i));
      }
      int T = gi();
      while (T--) {
        n = gi();
        for (int i = 2, u, v; i <= n; i++) {
          u = gi();
          v = gi();
          edge[u].push_back(v);
          edge[v].push_back(u);
        }
        predfs(1, 0);
        ans = 0;
        qc.clear();
        rdp[1] = dp[1];
        hashrt[1] = hashval[1];
        srchashrt[1] = srchashval[1];
        dfs(1, 0);
        printf("%d\n", ans);
        for (int i = 1; i <= n; i++) {
          edge[i].clear();
          uqc[i].clear();
        }
      }
      return 0;
    }
    ```

## 写在最后

事实上，树哈希是可以很灵活的，可以有各种各样奇怪的姿势来进行 hash，只需保证充分性与必要性，选手完全可以设计出与上述方式不同的 hash 方式。

## 参考资料

方法三参考自博客 [树 hash](https://www.cnblogs.com/huyufeifei/p/10817673.html) 。

# scc
## 简介

在阅读下列内容之前，请务必了解 [图论相关概念](./concept.md) 中的基础部分。

强连通的定义是：有向图 G 强连通是指，G 中任意两个结点连通。

强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图。

这里想要介绍的是如何来求强连通分量。

## Tarjan 算法

Robert E. Tarjan (1948~) 美国人。

Tarjan 发明了很多算法结构。光 Tarjan 算法就有很多，比如求各种连通分量的 Tarjan 算法，求 LCA（Lowest Common Ancestor，最近公共祖先）的 Tarjan 算法。并查集、Splay、Toptree 也是 Tarjan 发明的。

我们这里要介绍的是在有向图中求强连通分量的 Tarjan 算法。

另外，Tarjan 的名字 `j` 不发音，中文译为塔扬。

### DFS 生成树

在介绍该算法之前，先来了解 **DFS 生成树** ，我们以下面的有向图为例：

![scc1.png](./images/scc1.png)

有向图的 DFS 生成树主要有 4 种边（不一定全部出现）：

1.  树边（tree edge）：绿色边，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。
2.  反祖边（back edge）：黄色边，也被叫做回边，即指向祖先结点的边。
3.  横叉边（cross edge）：红色边，它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点 **并不是** 当前结点的祖先时形成的。
4.  前向边（forward edge）：蓝色边，它是在搜索的时候遇到子树中的结点的时候形成的。

我们考虑 DFS 生成树与强连通分量之间的关系。

如果结点 $u$ 是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余结点肯定是在搜索树中以 $u$ 为根的子树中。 $u$ 被称为这个强连通分量的根。

反证法：假设有个结点 $v$ 在该强连通分量中但是不在以 $u$ 为根的子树中，那么 $u$ 到 $v$ 的路径中肯定有一条离开子树的边。但是这样的边只可能是横叉边或者反祖边，然而这两条边都要求指向的结点已经被访问过了，这就和 $u$ 是第一个访问的结点矛盾了。得证。

### Tarjan 算法求强连通分量

在 Tarjan 算法中为每个结点 $u$ 维护了以下几个变量：

1.   $dfn[u]$ ：深度优先搜索遍历时结点 $u$ 被搜索的次序。
2.   $low[u]$ ：设以 $u$ 为根的子树为 $Subtree(u)$ 。 $low[u]$ 定义为以下结点的 $dfn$ 的最小值： $Subtree(u)$ 中的结点；从 $Subtree(u)$ 通过一条不在搜索树上的边能到达的结点。

一个结点的子树内结点的 dfn 都大于该结点的 dfn。

从根开始的一条路径上的 dfn 严格递增，low 严格非降。

按照深度优先搜索算法搜索的次序对图中所有的结点进行搜索。在搜索过程中，对于结点 $u$ 和与其相邻的结点 $v$ （v 不是 u 的父节点）考虑 3 种情况：

1.   $v$ 未被访问：继续对 $v$ 进行深度搜索。在回溯过程中，用 $low[v]$ 更新 $low[u]$ 。因为存在从 $u$ 到 $v$ 的直接路径，所以 $v$ 能够回溯到的已经在栈中的结点， $u$ 也一定能够回溯到。
2.   $v$ 被访问过，已经在栈中：即已经被访问过，根据 $low$ 值的定义（能够回溯到的最早的已经在栈中的结点），则用 $dfn[v]$ 更新 $low[u]$ 。
3.   $v$ 被访问过，已不在在栈中：说明 $v$ 已搜索完毕，其所在连通分量已被处理，所以不用对其做操作。

将上述算法写成伪代码：

    TARJAN_SEARCH(int u)
        vis[u]=true
        low[u]=dfn[u]=++dfncnt
        push u to the stack
        for each (u,v) then do
            if v hasn't been search then
                TARJAN_SEARCH(v) // 搜索
                low[u]=min(low[u],low[v])// 回溯
            else if v has been in the stack then
                low[u]=min(low[u],dfn[v])

对于一个连通分量图，我们很容易想到，在该连通图中有且仅有一个 $dfn[u]=low[u]$ 。该结点一定是在深度遍历的过程中，该连通分量中第一个被访问过的结点，因为它的 DFN 值和 LOW 值最小，不会被该连通分量中的其他结点所影响。

因此，在回溯的过程中，判定 $dfn[u]=low[u]$ 的条件是否成立，如果成立，则栈中从 $u$ 后面的结点构成一个 SCC。

### 实现

```cpp
int dfn[N], low[N], dfncnt, s[N], in_stack[N], tp;
int scc[N], sc;  // 结点 i 所在 scc 的编号
int sz[N];       // 强连通 i 的大小
void tarjan(int u) {
  low[u] = dfn[u] = ++dfncnt, s[++tp] = u, in_stack[u] = 1;
  for (int i = h[u]; i; i = e[i].nex) {
    const int &v = e[i].t;
    if (!dfn[v]) {
      tarjan(v);
      low[u] = min(low[u], low[v]);
    } else if (in_stack[v]) {
      low[u] = min(low[u], dfn[v]);
    }
  }
  if (dfn[u] == low[u]) {
    ++sc;
    while (s[tp] != u) {
      scc[s[tp]] = sc;
      sz[sc]++;
      in_stack[s[tp]] = 0;
      --tp;
    }
    scc[s[tp]] = sc;
    sz[sc]++;
    in_stack[s[tp]] = 0;
    --tp;
  }
}
```

时间复杂度 $O(n + m)$ 。

## Kosaraju 算法

Kosaraju 算法依靠两次简单的 DFS 实现。

第一次 DFS，选取任意顶点作为起点，遍历所有未访问过的顶点，并在回溯之前给顶点编号，也就是后序遍历。

第二次 DFS，对于反向后的图，以标号最大的顶点作为起点开始 DFS。这样遍历到的顶点集合就是一个强连通分量。对于所有未访问过的结点，选取标号最大的，重复上述过程。

两次 DFS 结束后，强连通分量就找出来了，Kosaraju 算法的时间复杂度为 $O(n+m)$ 。

### 实现

```cpp
// g 是原图，g2 是反图

void dfs1(int u) {
  vis[u] = true;
  for (int v : g[u])
    if (!vis[v]) dfs1(v);
  s.push_back(u);
}

void dfs2(int u) {
  color[u] = sccCnt;
  for (int v : g2[u])
    if (!color[v]) dfs2(v);
}

void kosaraju() {
  sccCnt = 0;
  for (int i = 1; i <= n; ++i)
    if (!vis[i]) dfs1(i);
  for (int i = n; i >= 1; --i)
    if (!color[s[i]]) {
      ++sccCnt;
      dfs2(s[i]);
    }
}
```

## Garbow 算法

## 应用

我们可以将一张图的每个强连通分量都缩成一个点。

然后这张图会变成一个 DAG（为什么？）。

DAG 好啊，能拓扑排序了就能做很多事情了。

举个简单的例子，求一条路径，可以经过重复结点，要求经过的不同结点数量最多。

## 推荐题目

 [USACO Fall/HAOI 2006 受欢迎的牛](https://loj.ac/problem/10091) 

 [POJ1236 Network of Schools](http://poj.org/problem?id=1236) 

# euler
## 定义

通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。

通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。

具有欧拉回路的无向图称为欧拉图。

具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。

有向图也可以有类似的定义。

非形式化地讲，欧拉图就是从任意一个点开始都可以一笔画完整个图，半欧拉图必须从某个点开始才能一笔画完整个图。

## 性质

欧拉图中所有顶点的度数都是偶数。

若 $G$ 是欧拉图，则它为若干个边不重的圈的并。

若 $G$ 是半欧拉图，则它为若干个边不重的圈和一条简单路径的并。

## 判别法

 $G$ 是欧拉图当且仅当 $G$ 是连通的且没有奇度顶点。

 $G$ 是半欧拉图当且仅当 $G$ 中恰有两个奇度顶点。

## 求欧拉回路或欧拉路

例题： [Luogu P2731 骑马修栅栏](https://www.luogu.com.cn/problem/P2731) 

???+note "题面"
    给定一张有 500 个顶点的无向图，求这张图的一条欧拉路或欧拉回路。如果有多组解，输出最小的那一组。

    在本题中，欧拉路或欧拉回路不需要经过所有顶点。

    边的数量 m 满足 $1\leq m \leq 1024$ 。

### Fleury 算法

也称避桥法，一个偏暴力的算法。算法流程为每次选择下一条边的时候优先选择不是桥的边。

一个广泛使用但是错误的实现方式是先 Tarjan 预处理桥边，然后再 DFS 避免走桥。但是由于走图过程中边会被删去，一些非桥边会变为桥边导致错误。最简单的实现方法是每次删除一条边之后暴力跑一遍 Tarjan 找桥，时间复杂度是 $\Theta(m(n+m))=\Theta(m^2)$ 。复杂的实现方法要用到动态图等，实用价值不高。

在解决本题的时候只需要再贪心就好，不过由于复杂度不对，还是看更优的算法吧。

### 逐步插入回路法（Hierholzer 算法）

算法流程为从一条回路开始，每次任取一条目前回路中的点，将其替换为一条简单回路，以此寻找到一条欧拉回路。如果从路开始的话，就可以寻找到一条欧拉路。

Hierholzer 算法的暴力实现如下：

$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{The edges of the graph } e , \text{ where each element in } e \text{ is } (u, v) \\
2 &  \textbf{Output. } \text{The vertex of the Euler Road of the input graph}.\\
3 &  \textbf{Method. } \\ 
4 &  \textbf{Function } \text{Hierholzer } (v) \\
5 &  \qquad circle \gets \text{Find a Circle in } e \text{ Begin with } v \\
6 &  \qquad \textbf{if } circle=\varnothing \\
7 &  \qquad\qquad \textbf{return } v \\
8 &  \qquad e \gets e-circle \\
9 &  \qquad \textbf{for} \text{ each } v \in circle \\
10&  \qquad\qquad v \gets \text{Hierholzer}(v) \\
11&  \qquad \textbf{return } circle \\
12&  \textbf{Endfunction}\\
13&  \textbf{return } \text{Hierholzer}(\text{any vertex})
\end{array}
$$

这个算法的时间复杂度约为 $O(nm+m^2)$ 。实际上还有复杂度更低的实现方法，就是将找回路的 Dfs 和 Hierholzer 的递归合并，边找回路边 Hierholzer，保存答案可以使用 `stack<int>` ，因为如果找的不是回路的话必须将那一部分放在最后。

如果需要输出字典序最小的欧拉路或欧拉回路的话，因为需要将边排序，时间复杂度是 $\Theta(n+m\log m)$ （计数排序或者基数排序可以优化至 $\Theta(n+m)$ ）。如果不需要排序，时间复杂度是 $\Theta(n+m)$ 。

对于这道例题的一个代码实现如下。注意，不能使用邻接矩阵存图，否则时间复杂度会退化为 $\Theta(nm)$ 。由于需要将边排序，建议使用前向星或者 vector 存图。示例代码使用 vector。

???+note "代码实现"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <stack>
    #include <vector>
    using namespace std;
    
    struct edge {
      int to;
      bool exists;
      int revref;
    
      bool operator<(const edge& b) const { return to < b.to; }
    };
    
    vector<edge> beg[505];
    int cnt[505];
    
    const int dn = 500;
    stack<int> ans;
    
    void Hierholzer(int x)  // 关键函数
    {
      for (int& i = cnt[x]; i < (int)beg[x].size();) {
        if (beg[x][i].exists) {
          edge e = beg[x][i];
          beg[x][i].exists = 0;
          beg[e.to][e.revref].exists = 0;
          ++i;
          Hierholzer(e.to);
        } else {
          ++i;
        }
      }
      ans.push(x);
    }
    
    int deg[505];
    int reftop[505];
    
    int main() {
      for (int i = 1; i <= dn; ++i) {
        beg[i].reserve(1050);  // vector 用 reserve 避免动态分配空间，加快速度
      }
    
      int m;
      scanf("%d", &m);
      for (int i = 1; i <= m; ++i) {
        int a, b;
        scanf("%d%d", &a, &b);
        beg[a].push_back((edge){b, 1, 0});
        beg[b].push_back((edge){a, 1, 0});
        ++deg[a];
        ++deg[b];
      }
    
      for (int i = 1; i <= dn; ++i) {
        if (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!beg[i].empty()) {
          sort(beg[i].begin(), beg[i].end());  // 为了要按字典序贪心，必须排序
        }
      }
    
      for (int i = 1; i <= dn; ++i) {
        for (int j = 0; j < (int)beg[i].size(); ++j) {
          beg[i][j].revref = reftop[beg[i][j].to]++;
        }
      }
    
      int bv = 0;
      for (int i = 1; i <= dn; ++i) {
        if (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!deg[bv] && deg[i]) {
          bv = i;
        } else if (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!(deg[bv] & 1) && (deg[i] & 1)) {
          bv = i;
        }
      }
    
      Hierholzer(bv);
    
      while (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!ans.empty()) {
        printf("%d\n", ans.top());
        ans.pop();
      }
    }
    ```

### 应用

有向欧拉图可用于计算机译码。

设有 $m$ 个字母，希望构造一个有 $m^n$ 个扇形的圆盘，每个圆盘上放一个字母，使得圆盘上每连续 $n$ 位对应长为 $n$ 的符号串。转动一周（ $m^n$ 次）后得到由 $m$ 个字母产生的长度为 $n$ 的 $m^n$ 个各不相同的符号串。

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](../images/euler1.png)

构造如下有向欧拉图：

设 $S = \{a_1, a_2, \cdots, a_m\}$ ，构造 $D=<V, E>$ ，如下：

 $V = \{a_{i_1}a_{i_2}\cdots a_{i_{n-1}} |a_i \in S, 1 \leq i \leq n - 1 \}$ 

 $E = \{a_{j_1}a_{j_2}\cdots a_{j_{n-1}}|a_j \in S, 1 \leq j \leq n\}$ 

规定 $D$ 中顶点与边的关联关系如下：

顶点 $a_{i_1}a_{i_2}\cdots a_{i_{n-1}}$ 引出 $m$ 条边： $a_{i_1}a_{i_2}\cdots a_{i_{n-1}}a_r, r=1, 2, \cdots, m$ 。

边 $a_{j_1}a_{j_2}\cdots a_{j_{n-1}}$ 引入顶点 $a_{j_2}a_{j_3}\cdots a_{j_{n}}$ 。

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](../images/euler2.png)

这样的 $D$ 是连通的，且每个顶点入度等于出度（均等于 $m$ ），所以 $D$ 是有向欧拉图。

任求 $D$ 中一条欧拉回路 $C$ ，取 $C$ 中各边的最后一个字母，按各边在 $C$ 中的顺序排成圆形放在圆盘上即可。

## 练习题

 [「洛谷 1341」无序字母对](https://www.luogu.org/problem/P1341) 

 [「洛谷 2731」骑马修栅栏](https://www.luogu.org/problem/P2731) 

# index
 **图论 (Graph theory)** 是数学的一个分支，图是图论的主要研究对象。 **图 (Graph)** 是由若干给定的顶点及连接两顶点的边所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。

## 参考资料

 <https://zh.wikipedia.org/wiki/图论> 

# 2-sat
> SAT 是适定性（Satisfiability）问题的简称。一般形式为 k - 适定性问题，简称 k-SAT。而当 $k>2$ 时该问题为 NP 完全的。所以我们只研究 $k=2$ 的情况。

## 定义

2-SAT，简单的说就是给出 $n$ 个集合，每个集合有两个元素，已知若干个 $<a,b>$ ，表示 $a$ 与 $b$ 矛盾（其中 $a$ 与 $b$ 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 $n$ 个两两不矛盾的元素。显然可能有多种选择方案，一般题中只需要求出一种即可。

## 现实意义

比如邀请人来吃喜酒，夫妻二人必须去一个，然而某些人之间有矛盾（比如 A 先生与 B 女士有矛盾，C 女士不想和 D 先生在一起），那么我们要确定能否避免来人之间没有矛盾，有时需要方案。这是一类生活中常见的问题。

使用布尔方程表示上述问题。设 $a$ 表示 A 先生去参加，那么 B 女士就不能参加（ $\neg a$ )； $b$ 表示 C 女士参加，那么 $\neg b$ 也一定成立（D 先生不参加）。总结一下，即 $(a \vee b)$ （变量 $a, b$ 至少满足一个）。对这些变量关系建有向图，则有： $\neg a\Rightarrow b\wedge\neg b\Rightarrow a$ （ $a$ 不成立则 $b$ 一定成立；同理， $b$ 不成立则 $a$ 一定成立）。建图之后，我们就可以使用缩点算法来求解 2-SAT 问题了。

## 常用解决方法

### Tarjan [SCC 缩点](./scc.md) 

算法考究在建图这点，我们举个例子来讲：

假设有 ${a1,a2}$ 和 ${b1,b2}$ 两对，已知 $a1$ 和 $b2$ 间有矛盾，于是为了方案自洽，由于两者中必须选一个，所以我们就要拉两条条有向边 $(a1,b1)$ 和 $(b2,a2)$ 表示选了 $a1$ 则必须选 $b1$ ，选了 $b2$ 则必须选 $a2$ 才能够自洽。

然后通过这样子建边我们跑一遍 Tarjan SCC 判断是否有一个集合中的两个元素在同一个 SCC 中，若有则输出不可能，否则输出方案。构造方案只需要把几个不矛盾的 SCC 拼起来就好了。

输出方案时可以通过变量在图中的拓扑序确定该变量的取值。如果变量 $\neg x$ 的拓扑序在 $x$ 之后，那么取 $x$ 值为真。应用到 Tarjan 算法的缩点，即 $x$ 所在 SCC 编号在 $\neg x$ 之前时，取 $x$ 为真。因为 Tarjan 算法求强连通分量时使用了栈，所以 Tarjan 求得的 SCC 编号相当于反拓扑序。

显然地，时间复杂度为 $O(n+m)$ 。

### 爆搜

就是沿着图上一条路径，如果一个点被选择了，那么这条路径以后的点都将被选择，那么，出现不可行的情况就是，存在一个集合中两者都被选择了。

那么，我们只需要枚举一下就可以了，数据不大，答案总是可以出来的。

#### 爆搜模板

下方代码来自刘汝佳的白书：

```cpp
// 来源：白书第 323 页
struct Twosat {
  int n;
  vector<int> g[maxn * 2];
  bool mark[maxn * 2];
  int s[maxn * 2], c;
  bool dfs(int x) {
    if (mark[x ^ 1]) return false;
    if (mark[x]) return true;
    mark[x] = true;
    s[c++] = x;
    for (int i = 0; i < (int)g[x].size(); i++)
      if (!dfs(g[x][i])) return false;
    return true;
  }
  void init(int n) {
    this->n = n;
    for (int i = 0; i < n * 2; i++) g[i].clear();
    memset(mark, 0, sizeof(mark));
  }
  void add_clause(int x, int y) {  // 这个函数随题意变化
    g[x].push_back(y ^ 1);         // 选了 x 就必须选 y^1
    g[y].push_back(x ^ 1);
  }
  bool solve() {
    for (int i = 0; i < n * 2; i += 2)
      if (!mark[i] && !mark[i + 1]) {
        c = 0;
        if (!dfs(i)) {
          while (c > 0) mark[s[--c]] = false;
          if (!dfs(i + 1)) return false;
        }
      }
    return true;
  }
};
```

## 例题

###  **HDU3062 [Party](http://acm.hdu.edu.cn/showproblem.php?pid=3062) ** 

> 题面：有 n 对夫妻被邀请参加一个聚会，因为场地的问题，每对夫妻中只有 $1$ 人可以列席。在 $2n$ 个人中，某些人之间有着很大的矛盾（当然夫妻之间是没有矛盾的），有矛盾的 $2$ 个人是不会同时出现在聚会上的。有没有可能会有 $n$ 个人同时列席？

这是一道多校题，裸的 2-SAT 判断是否有方案，按照我们上面的分析，如果 $a1$ 中的丈夫和 $a2$ 中的妻子不合，我们就把 $a1$ 中的丈夫和 $a2$ 中的丈夫连边，把 $a2$ 中的妻子和 $a1$ 中的妻子连边，然后缩点染色判断即可。

```cpp
// 作者：小黑 AWM
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#define maxn 2018
#define maxm 4000400
using namespace std;
int Index, instack[maxn], DFN[maxn], LOW[maxn];
int tot, color[maxn];
int numedge, head[maxn];
struct Edge {
  int nxt, to;
} edge[maxm];
int sta[maxn], top;
int n, m;
void add(int x, int y) {
  edge[++numedge].to = y;
  edge[numedge].nxt = head[x];
  head[x] = numedge;
}
void tarjan(int x) {  // 缩点看不懂请移步强连通分量上面有一个链接可以点。
  sta[++top] = x;
  instack[x] = 1;
  DFN[x] = LOW[x] = ++Index;
  for (int i = head[x]; i; i = edge[i].nxt) {
    int v = edge[i].to;
    if (!DFN[v]) {
      tarjan(v);
      LOW[x] = min(LOW[x], LOW[v]);
    } else if (instack[v])
      LOW[x] = min(LOW[x], DFN[v]);
  }
  if (DFN[x] == LOW[x]) {
    tot++;
    do {
      color[sta[top]] = tot;  // 染色
      instack[sta[top]] = 0;
    } while (sta[top--] != x);
  }
}
bool solve() {
  for (int i = 0; i < 2 * n; i++)
    if (!DFN[i]) tarjan(i);
  for (int i = 0; i < 2 * n; i += 2)
    if (color[i] == color[i + 1]) return 0;
  return 1;
}
void init() {
  top = 0;
  tot = 0;
  Index = 0;
  numedge = 0;
  memset(sta, 0, sizeof(sta));
  memset(DFN, 0, sizeof(DFN));
  memset(instack, 0, sizeof(instack));
  memset(LOW, 0, sizeof(LOW));
  memset(color, 0, sizeof(color));
  memset(head, 0, sizeof(head));
}
int main() {
  while (~scanf("%d%d", &n, &m)) {
    init();
    for (int i = 1; i <= m; i++) {
      int a1, a2, c1, c2;
      scanf("%d%d%d%d", &a1, &a2, &c1, &c2);  // 自己做的时候别用 cin 会被卡
      add(2 * a1 + c1,
          2 * a2 + 1 - c2);  // 我们将 2i+1 表示为第 i 对中的，2i 表示为妻子。
      add(2 * a2 + c2, 2 * a1 + 1 - c1);
    }
    if (solve())
      printf("YES\n");
    else
      printf("NO\n");
  }
  return 0;
}
```

## 练习题

HDU1814 [和平委员会](http://acm.hdu.edu.cn/showproblem.php?pid=1814) 

POJ3683 [牧师忙碌日](http://poj.org/problem?id=3683) 

# kth-path
## 问题描述

给定一个有 $n$ 个结点， $m$ 条边的有向图，求从 $s$ 到 $t$ 的所有不同路径中的第 $k$ 短路径的长度。

## A\*算法

A\*算法定义了一个对当前状态 $x$ 的估价函数 $f(x)=g(x)+h(x)$ ，其中 $g(x)$ 为从初始状态到达当前状态的实际代价， $h(x)$ 为从当前状态到达目标状态的最佳路径的估计代价。每次取出 $f(x)$ 最优的状态 $x$ ，扩展其所有子状态，可以用 **优先队列** 来维护这个值。

在求解 $k$ 短路问题时，令 $h(x)$ 为从当前结点到达终点 $t$ 的最短路径长度。可以通过在反向图上对结点 $t$ 跑单源最短路预处理出对每个结点的这个值。

由于设计的距离函数和估价函数，对于每个状态需要记录两个值，为当前到达的结点 $x$ 和已经走过的距离 $g(x)$ ，将这种状态记为 $(x,g(x))$ 。

开始我们将初始状态 $(s,0)$ 加入优先队列。每次我们取出估价函数 $f(x)=g(x)+h(x)$ 最小的一个状态，枚举该状态到达的结点 $x$ 的所有出边，将对应的子状态加入优先队列。当我们访问到一个结点第 $k$ 次时，对应的状态的 $g(x)$ 就是从 $x$ 到该结点的第 $k$ 短路。

优化：由于只需要求出从初始结点到目标结点的第 $k$ 短路，所以已经取出的状态到达一个结点的次数大于 $k$ 次时，可以不扩展其子状态。因为之前 $k$ 次已经形成了 $k$ 条合法路径，当前状态不会影响到最后的答案。

当图的形态是一个 $n$ 元环的时候，该算法最坏是 $O(nk\log n)$ 的。但是这种算法可以在相同的复杂度内求出从起始点 $s$ 到每个结点的前 $k$ 短路。

### 参考实现

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 5010;
const int maxm = 400010;
const int inf = 2e9;
int n, m, s, t, k, u, v, ww, H[maxn], cnt[maxn];
int cur, h[maxn], nxt[maxm], p[maxm], w[maxm];
int cur1, h1[maxn], nxt1[maxm], p1[maxm], w1[maxm];
bool tf[maxn];
void add_edge(int x, int y, double z) {
  cur++;
  nxt[cur] = h[x];
  h[x] = cur;
  p[cur] = y;
  w[cur] = z;
}
void add_edge1(int x, int y, double z) {
  cur1++;
  nxt1[cur1] = h1[x];
  h1[x] = cur1;
  p1[cur1] = y;
  w1[cur1] = z;
}
struct node {
  int x, v;
  bool operator<(node a) const { return v + H[x] > a.v + H[a.x]; }
};
priority_queue<node> q;
struct node2 {
  int x, v;
  bool operator<(node2 a) const { return v > a.v; }
} x;
priority_queue<node2> Q;
int main() {
  scanf("%d%d%d%d%d", &n, &m, &s, &t, &k);
  while (m--) {
    scanf("%d%d%d", &u, &v, &ww);
    add_edge(u, v, ww);
    add_edge1(v, u, ww);
  }
  for (int i = 1; i <= n; i++) H[i] = inf;
  Q.push({t, 0});
  while (!Q.empty()) {
    x = Q.top();
    Q.pop();
    if (tf[x.x]) continue;
    tf[x.x] = true;
    H[x.x] = x.v;
    for (int j = h1[x.x]; j; j = nxt1[j]) Q.push({p1[j], x.v + w1[j]});
  }
  q.push({s, 0});
  while (!q.empty()) {
    node x = q.top();
    q.pop();
    cnt[x.x]++;
    if (x.x == t && cnt[x.x] == k) {
      printf("%d\n", x.v);
      return 0;
    }
    if (cnt[x.x] > k) continue;
    for (int j = h[x.x]; j; j = nxt[j]) q.push({p[j], x.v + w[j]});
  }
  printf("-1\n");
  return 0;
}
```

## 可持久化可并堆优化 k 短路算法

### 最短路树与任意路径的关系与性质

在反向图上从 $t$ 开始跑最短路，设在原图上结点 $x$ 到 $t$ 的最短路长度为 $dist_x$ ，建出 **任意** 一棵以 $t$ 为根的最短路树 $T$ 。

所谓最短路径树，就是满足从树上的每个结点 $x$ 到根节点 $t$ 的简单路径都是 $x$ 到 $t$ 的 **其中** 一条最短路径。

设一条从 $s$ 到 $t$ 的路径经过的边集为 $P$ ，去掉 $P$ 中与 $T$ 的交集得到 $P'$ 。

 $P'$ 有如下性质：

1.  对于一条不在 $T$ 上的边 $e$ ，其为从 $u$ 到 $v$ 的一条边，边权为 $w$ ，定义其代价 $\Delta e=dist_v+w-dist_u$ ，即为选择该边后路径长度的增加量。则路径 $P$ 的长度 $L_P=dist_s+\sum_{e\in P'} \Delta e$ 。

2.  将 $P$ 和 $P'$ 中的所有边按照从 $s$ 到 $t$ 所经过的顺序依次排列，则对于 $P'$ 中相邻的两条边 $e_1,e_2$ ，有 $u_{e_2}$ 与 $v_{e_1}$ 相等或为其在 $T$ 上的祖先。因为在 $P$ 中 $e_1,e_2$ 直接相连或中间都为树边。

3.  对于一个确定存在的 $P'$ ，有且仅有一个 $S$ ，使得 $S'=P'$ 。因为由于性质 $2$ ， $P'$ 中相邻的两条边的起点和终点之间在 $T$ 上只有一条路径。

### 问题转化

性质 $1$ 告诉我们知道集合 $P'$ 后，如何求出 $L_P$ 的值。

性质 $2$ 告诉我们所有 $P'$ 一定满足的条件，所有满足这个条件的边集 $P'$ 都是合法的，也就告诉我们生成 $P'$ 的方法。

性质 $3$ 告诉我们对于每个合法的 $P'$ 有且仅有一个边集 $P$ 与之对应。

那么问题转化为：求 $L_P$ 的值第 $k$ 小的满足性质 $2$ 的集合 $P'$ 。

### 算法描述

由于性质 $2$ ，我们可以记录按照从 $s$ 到 $t$ 的顺序排列的最后一条边和 $L_P$ 的值，来表示一个边集 $P'$ 。

我们用一个小根堆来维护这样的边集 $P'$ 。

初始我们将起点为 $1$ 或 $1$ 在 $T$ 上的祖先的所有的边中 $\Delta e$ 最小的一条边加入小根堆。

每次取出堆顶的一个边集 $S$ ，有两种方法可以生成可能的新边集：

1.  替换 $S$ 中的最后一条边为满足相同条件的 $\Delta e$ 更大的边。

2.  在最后一条边后接上一条边，设 $x$ 为 $S$ 中最后一条边的终点，由性质 $2$ 可得这条边需要满足其起点为 $x$ 或 $x$ 在 $T$ 上的祖先。

将生成的新边集也加入小根堆。重复以上操作 $k-1$ 次后求出的就是从 $s$ 到 $t$ 的第 $k$ 短路。

对于每个结点 $x$ ，我们将以其为起点的边的 $\Delta e$ 建成一个小根堆。为了方便查找一个结点 $x$ 与 $x$ 在 $T$ 上的祖先在小根堆上的信息，我们将这些信息合并在一个编号为 $x$ 的小根堆上。回顾以上生成新边集的方法，我们发现只要我们把紧接着可能的下一个边集加入小根堆，并保证这种生成方法可以覆盖所有可能的边集即可。记录最后选择的一条边在堆上对应的结点 $t$ ，有更优的方法生成新的边集：

1.  替换 $S$ 中的最后一条边为 $t$ 在堆上的左右儿子对应的边。

2.  在最后一条边后接上一条新的边，设 $x$ 为 $S$ 中最后一条边的终点，则接上编号为 $x$ 的小根堆的堆顶结点对应的边。

用这种方法，每次生成新的边集只会扩展出最多三个结点，小根堆中的结点总数是 $O(n+k)$ 。

所以此算法的瓶颈在合并一个结点与其在 $T$ 上的祖先的信息，如果使用朴素的二叉堆，时间复杂度为 $O(nm\log m)$ ，空间复杂度为 $O(nm)$ ；如果使用可并堆，每次仍然需要复制堆中的全部结点，时间复杂度同样无法承受。

### 可持久化可并堆优化

 **在阅读本内容前，请先了解 [可持久化可并堆](../ds/persistent-heap.md) 的相关知识。** 

使用可持久化可并堆优化合并一个结点与其在 $T$ 上的祖先的信息，每次将一个结点与其在 $T$ 上的父亲合并，时间复杂度为 $O(n\log m)$ ，空间复杂度为 $O((n+k)\log m)$ 。这样在求出一个结点对应的堆时，无需复制结点且之后其父亲结点对应的堆仍然可以正常访问。

### 参考实现

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 200010;
int n, m, s, t, k, x, y, ww, cnt, fa[maxn];
struct Edge {
  int cur, h[maxn], nxt[maxn], p[maxn], w[maxn];
  void add_edge(int x, int y, int z) {
    cur++;
    nxt[cur] = h[x];
    h[x] = cur;
    p[cur] = y;
    w[cur] = z;
  }
} e1, e2;
int dist[maxn];
bool tf[maxn], vis[maxn], ontree[maxn];
struct node {
  int x, v;
  node* operator=(node a) {
    x = a.x;
    v = a.v;
    return this;
  }
  bool operator<(node a) const { return v > a.v; }
} a;
priority_queue<node> Q;
void dfs(int x) {
  vis[x] = true;
  for (int j = e2.h[x]; j; j = e2.nxt[j])
    if (!vis[e2.p[j]])
      if (dist[e2.p[j]] == dist[x] + e2.w[j])
        fa[e2.p[j]] = x, ontree[j] = true, dfs(e2.p[j]);
}
struct LeftistTree {
  int cnt, rt[maxn], lc[maxn * 20], rc[maxn * 20], dist[maxn * 20];
  node v[maxn * 20];
  LeftistTree() { dist[0] = -1; }
  int newnode(node w) {
    cnt++;
    v[cnt] = w;
    return cnt;
  }
  int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (v[x] < v[y]) swap(x, y);
    int p = ++cnt;
    lc[p] = lc[x];
    v[p] = v[x];
    rc[p] = merge(rc[x], y);
    if (dist[lc[p]] < dist[rc[p]]) swap(lc[p], rc[p]);
    dist[p] = dist[rc[p]] + 1;
    return p;
  }
} st;
void dfs2(int x) {
  vis[x] = true;
  if (fa[x]) st.rt[x] = st.merge(st.rt[x], st.rt[fa[x]]);
  for (int j = e2.h[x]; j; j = e2.nxt[j])
    if (fa[e2.p[j]] == x && !vis[e2.p[j]]) dfs2(e2.p[j]);
}
int main() {
  scanf("%d%d%d%d%d", &n, &m, &s, &t, &k);
  for (int i = 1; i <= m; i++)
    scanf("%d%d%d", &x, &y, &ww), e1.add_edge(x, y, ww), e2.add_edge(y, x, ww);
  Q.push({t, 0});
  while (!Q.empty()) {
    a = Q.top();
    Q.pop();
    if (tf[a.x]) continue;
    tf[a.x] = true;
    dist[a.x] = a.v;
    for (int j = e2.h[a.x]; j; j = e2.nxt[j]) Q.push({e2.p[j], a.v + e2.w[j]});
  }
  if (k == 1) {
    if (tf[s])
      printf("%d\n", dist[s]);
    else
      printf("-1\n");
    return 0;
  }
  dfs(t);
  for (int i = 1; i <= n; i++)
    if (tf[i])
      for (int j = e1.h[i]; j; j = e1.nxt[j])
        if (!ontree[j])
          if (tf[e1.p[j]])
            st.rt[i] = st.merge(
                st.rt[i],
                st.newnode({e1.p[j], dist[e1.p[j]] + e1.w[j] - dist[i]}));
  for (int i = 1; i <= n; i++) vis[i] = false;
  dfs2(t);
  if (st.rt[s]) Q.push({st.rt[s], dist[s] + st.v[st.rt[s]].v});
  while (!Q.empty()) {
    a = Q.top();
    Q.pop();
    cnt++;
    if (cnt == k - 1) {
      printf("%d\n", a.v);
      return 0;
    }
    if (st.lc[a.x])
      Q.push({st.lc[a.x], a.v - st.v[a.x].v + st.v[st.lc[a.x]].v});
    if (st.rc[a.x])
      Q.push({st.rc[a.x], a.v - st.v[a.x].v + st.v[st.rc[a.x]].v});
    x = st.rt[st.v[a.x].x];
    if (x) Q.push({x, a.v + st.v[x].v});
  }
  printf("-1\n");
  return 0;
}
```

## 习题

 [「SDOI2010」魔法猪学院](https://www.luogu.org/problemnew/show/P2483) 

# mdst
## 最小树形图

有向图上的最小生成树（Minimum Directed Spanning Tree）称为最小树形图。

常用的算法是朱刘算法（也称 Edmonds 算法），可以在 $O(nm)$ 时间内解决最小树形图问题。

### 流程

1.  对于每个点，选择它入度最小的那条边
2.  如果没有环，算法终止；否则进行缩环并更新其他点到环的距离。

### 代码

```cpp
bool solve() {
  ans = 0;
  int u, v, root = 0;
  for (;;) {
    f(i, 0, n) in[i] = 1e100;
    f(i, 0, m) {
      u = e[i].s;
      v = e[i].t;
      if (u != v && e[i].w < in[v]) {
        in[v] = e[i].w;
        pre[v] = u;
      }
    }
    f(i, 0, m) if (i != root && in[i] > 1e50) return 0;
    int tn = 0;
    memset(id, -1, sizeof id);
    memset(vis, -1, sizeof vis);
    in[root] = 0;
    f(i, 0, n) {
      ans += in[i];
      v = i;
      while (vis[v] != i && id[v] == -1 && v != root) {
        vis[v] = i;
        v = pre[v];
      }
      if (v != root && id[v] == -1) {
        for (int u = pre[v]; u != v; u = pre[u]) id[u] = tn;
        id[v] = tn++;
      }
    }
    if (tn == 0) break;
    f(i, 0, n) if (id[i] == -1) id[i] = tn++;
    f(i, 0, m) {
      u = e[i].s;
      v = e[i].t;
      e[i].s = id[u];
      e[i].t = id[v];
      if (e[i].s != e[i].t) e[i].w -= in[v];
    }
    n = tn;
    root = id[root];
  }
  return ans;
}
```

# shortest-path
## 定义

（还记得这些定义吗？在阅读下列内容之前，请务必了解 [图论相关概念](./concept.md) 中的基础部分。）

-   路径
-   最短路
-   有向图中的最短路、无向图中的最短路
-   单源最短路、每对结点之间的最短路

## 性质

对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点。

对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边。

对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过 $n$ ，边数不会超过 $n-1$ 。

## Floyd 算法

是用来求任意两个结点之间的最短路的。

复杂度比较高，但是常数小，容易实现。（我会说只有三个 `for` 吗？）

适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）

### 实现

我们定义一个数组 `f[k][x][y]` ，表示只允许经过结点 $1$ 到 $k$ ，结点 $x$ 到结点 $y$ 的最短路长度。

很显然， `f[n][x][y]` 就是结点 $x$ 到结点 $y$ 的最短路长度。

我们来考虑怎么求这个数组

 `f[0][x][y]` ：边权，或者 $0$ ，或者 $+\infty$ （ `f[0][x][x]` 什么时候应该是 $+\infty$ ？）

 `f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])` 

上面两行都显然是对的，然而这个做法空间是 $O(N^3)$ 。

但我们发现数组的第一维是没有用的，于是可以直接改成 `f[x][y] = min(f[x][y], f[x][k]+f[k][y])` ，

```cpp
for (k = 1; k <= n; k++) {
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= n; j++) {
      f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
    }
  }
}
```

时间复杂度是 $O(N^3)$ ，空间复杂度是 $O(N^2)$ 。

### 应用

???+ question "给一个正权无向图，找一个最小权值和的环。"
    首先这一定是一个简单环。

    想一想这个环是怎么构成的。

    考虑环上编号最大的结点 u。

     `f[u-1][x][y]` 和 (u,x), (u,y）共同构成了环。

    在 Floyd 的过程中枚举 u，计算这个和的最小值即可。

     $O(n^3)$ 。

???+question "已知一个有向图中任意两点之间是否有连边，要求判断任意两点是否连通。"
    该问题即是求 **图的传递闭包** 。

    我们只需要按照 Floyd 的过程，逐个加入点判断一下。

    只是此时的边的边权变为 $1/0$ ，而取 $\min$ 变成了 **与** 运算。

    再进一步用 bitset 优化，复杂度可以到 $O(\frac{n^3}{w})$ 。

    ```cpp
    // std::bitset<SIZE> f[SIZE];
    for (k = 1; k <= n; k++)
      for (i = 1; i <= n; i++)
        if (f[i][k]) f[i] = f[i] & f[k];
    ```

* * *

## Bellman-Ford 算法

一种基于松弛（relax）操作的最短路算法。

支持负权。

能找到某个结点出发到所有结点的最短路，或者报告某些最短路不存在。

在国内 OI 界，你可能听说过的“SPFA”，就是 Bellman-Ford 算法的一种实现。（优化）

### 实现

假设结点为 $S$ 。

先定义 $dist(u)$ 为 $S$ 到 $u$ （当前）的最短路径长度。

 $relax(u,v)$ 操作指： $dist(v) = min(dist(v), dist(u) + edge\_len(u, v))$ .

 $relax$ 是从哪里来的呢？

三角形不等式： $dist(v) \leq dist(u) + edge\_len(u, v)$ 。

证明：反证法，如果不满足，那么可以用松弛操作来更新 $dist(v)$ 的值。

Bellman-Ford 算法如下：

```text
while (1) for each edge(u, v) relax(u, v);
```

当一次循环中没有松弛操作成功时停止。

每次循环是 $O(m)$ 的，那么最多会循环多少次呢？

答案是 $\infty$ ！（如果有一个 $S$ 能走到的负环就会这样）

但是此时某些结点的最短路不存在。

我们考虑最短路存在的时候。

由于一次松弛操作会使最短路的边数至少 $+1$ ，而最短路的边数最多为 $n-1$ 。

所以最多执行 $n-1$ 次松弛操作，即最多循环 $n-1$ 次。

总时间复杂度 $O(NM)$ 。 **（对于最短路存在的图）** 

```text
relax(u, v) {
	dist[v] = min(dist[v], dist[u] + edge_len(u, v));
}
for (i = 1; i <= n; i++) {
	dist[i] = edge_len(S, i);
}
for (i = 1; i < n; i++) {
	for each edge(u, v) {
		relax(u, v);
	}
}
```

注：这里的 $edge\_len(u, v)$ 表示边的权值，如果该边不存在则为 $+\infty$ ， $u=v$ 则为 $0$ 。

### 应用

给一张有向图，问是否存在负权环。

做法很简单，跑 Bellman-Ford 算法，如果有个点被松弛成功了 $n$ 次，那么就一定存在。

如果 $n-1$ 次之内算法结束了，就一定不存在。

### 队列优化：SPFA

即 Shortest Path Faster Algorithm。

很多时候我们并不需要那么多无用的松弛操作。

很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。

那么我们用队列来维护“哪些结点可能会引起松弛操作”，就能只访问必要的边了。

```text
q = new queue();
q.push(S);
in_queue[S] = true;
while (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!q.empty()) {
	u = q.pop();
	in_queue[u] = false;
	for each edge(u, v) {
		if (relax(u, v) && /home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!in_queue[v]) {
			q.push(v);
			in_queue[v] = true;
		}
	}
}
```

虽然在大多数情况下 SPFA 跑得很快，但其最坏情况下的时间复杂度为 $O(NM)$ ，将其卡到这个复杂度也是不难的，所以考试时要谨慎使用（在没有负权边时最好使用 Dijkstra 算法，在有负权边且题目中的图没有特殊性质时，若 SPFA 是标算的一部分，题目不应当给出 Bellman-Ford 算法无法通过的数据范围）。

#### SPFA 的优化之 SLF

即 Small Label First。

即在新元素加入队列时，如果队首元素权值大于新元素权值，那么就把新元素加入队首，否则依然加入队尾。

该优化在确实在一些图上有显著效果，但是如果有负权边的话，可以直接卡到指数级。

* * *

## Dijkstra 算法

Dijkstra 是个人名（荷兰姓氏）。

IPA:/ˈdikstrɑ/或/ˈdɛikstrɑ/。

这种算法只适用于非负权图，但是时间复杂度非常优秀。

也是用来求单源最短路径的算法。

### 实现

主要思想是，将结点分成两个集合：已确定最短路长度的，未确定的。

一开始第一个集合里只有 $S$ 。

然后重复这些操作：

1.  对那些刚刚被加入第一个集合的结点的所有出边执行松弛操作。
2.  从第二个集合中，选取一个最短路长度最小的结点，移到第一个集合中。

直到第二个集合为空，算法结束。

时间复杂度：只用分析集合操作， $n$ 次 `delete-min` ， $m$ 次 `decrease-key` 。

如果用暴力： $O(n^2 + m) = O(n^2)$ 。

如果用堆 $O(m \log n)$ 。

如果用 priority_queue： $O(m \log m)$ 。

（注：如果使用 priority_queue，无法删除某一个旧的结点，只能插入一个权值更小的编号相同结点，这样操作导致堆中元素是 $O(m)$ 的）

如果用线段树（ZKW 线段树）： $O(m \log n + n) = O(m \log n)$ 

如果用 Fibonacci 堆： $O(n \log n + m)$ （这就是为啥优秀了）。

等等，还没说正确性呢！

分两步证明：先证明任何时候第一个集合中的元素的 $dist$ 一定不大于第二个集合中的。

再证明第一个集合中的元素的最短路已经确定。

第一步，一开始时成立（基础），在每一步中，加入集合的元素一定是最大值，且是另一边最小值，每次松弛操作又是加上非负数，所以仍然成立。（归纳）（利用非负权值的性质）

第二步，考虑每次加进来的结点，到他的最短路，上一步必然是第一个集合中的元素（否则他不会是第二个集合中的最小值，而且有第一步的性质），又因为第一个集合内的点已经全部松弛过了，所以最短路显然确定了。

```text
H = new heap();
H.insert(S, 0);
dist[S] = 0;
for (i = 1; i <= n; i++) {
	u = H.delete_min();
	for each edge(u, v) {
		if (relax(u, v)) {
			H.decrease_key(v, dist[v]);
		}
	}
}
```

## Johnson 全源最短路径算法

Johnson 和 Floyd 一样，是一种能求出无负环图上任意两点间最短路径的算法。该算法在 1977 年由 Donald B. Johnson 提出。

任意两点间的最短路可以通过枚举起点，跑 $n$ 次 Bellman-Ford 算法解决，时间复杂度是 $O(n^2m)$ 的，也可以直接用 Floyd 算法解决，时间复杂度为 $O(n^3)$ 。

注意到堆优化的 Dijkstra 算法求单源最短路径的时间复杂度比 Bellman-Ford 更优，如果枚举起点，跑 $n$ 次 Dijkstra 算法，就可以在 $O(nm\log m)$ （取决于 Dijkstra 算法的实现）的时间复杂度内解决本问题，比上述跑 $n$ 次 Bellman-Ford 算法的时间复杂度更优秀，在稀疏图上也比 Floyd 算法的时间复杂度更加优秀。

但 Dijkstra 算法不能正确求解带负权边的最短路，因此我们需要对原图上的边进行预处理，确保所有边的边权均非负。

一种容易想到的方法是给所有边的边权同时加上一个正数 $x$ ，从而让所有边的边权均非负。如果新图上起点到终点的最短路经过了 $k$ 条边，则将最短路减去 $kx$ 即可得到实际最短路。

但这样的方法是错误的。考虑下图：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/shortest-path1.png)

 $1 \to 2$ 的最短路为 $1 \to 5 \to 3 \to 2$ ，长度为 $−2$ 。

但假如我们把每条边的边权加上 $5$ 呢？

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/shortest-path2.png)

新图上 $1 \to 2$ 的最短路为 $1 \to 4 \to 2$ ，已经不是实际的最短路了。

Johnson 算法则通过另外一种方法来给每条边重新标注边权。

我们新建一个虚拟节点（在这里我们就设它的编号为 $0$ ）。从这个点向其他所有点连一条边权为 $0$ 的边。

接下来用 Bellman-Ford 算法求出从 $0$ 号点到其他所有点的最短路，记为 $h_i$ 。

假如存在一条从 $u$ 点到 $v$ 点，边权为 $w$ 的边，则我们将该边的边权重新设置为 $w+h_u-h_v$ 。

接下来以每个点为起点，跑 $n$ 轮 Dijkstra 算法即可求出任意两点间的最短路了。

一开始的 Bellman-Ford 算法并不是时间上的瓶颈，若使用 `priority_queue` 实现 Dijkstra 算法，该算法的时间复杂度是 $O(nm\log m)$ 。

### 正确性证明

为什么这样重新标注边权的方式是正确的呢？

在讨论这个问题之前，我们先讨论一个物理概念——势能。

诸如重力势能，电势能这样的势能都有一个特点，势能的变化量只和起点和终点的相对位置有关，而与起点到终点所走的路径无关。

势能还有一个特点，势能的绝对值往往取决于设置的零势能点，但无论将零势能点设置在哪里，两点间势能的差值是一定的。

接下来回到正题。

在重新标记后的图上，从 $s$ 点到 $t$ 点的一条路径 $s \to p_1 \to p_2 \to \dots \to p_k \to t$ 的长度表达式如下：

 $(w(s,p_1)+h_s-h_{p_1})+(w(p_1,p_2)+h_{p_1}-h_{p_2})+ \dots +(w(p_k,t)+h_{p_k}-h_t)$ 

化简后得到：

 $w(s,p_1)+w(p_1,p_2)+ \dots +w(p_k,t)+h_s-h_t$ 

无论我们从 $s$ 到 $t$ 走的是哪一条路径， $h_s-h_t$ 的值是不变的，这正与势能的性质相吻合！

为了方便，下面我们就把 $h_i$ 称为 $i$ 点的势能。

上面的新图中 $s \to t$ 的最短路的长度表达式由两部分组成，前面的边权和为原图中 $s \to t$ 的最短路，后面则是两点间的势能差。因为两点间势能的差为定值，因此原图上 $s \to t$ 的最短路与新图上 $s \to t$ 的最短路相对应。

到这里我们的正确性证明已经解决了一半——我们证明了重新标注边权后图上的最短路径仍然是原来的最短路径。接下来我们需要证明新图中所有边的边权非负，因为在非负权图上，Dijkstra 算法能够保证得出正确的结果。

根据三角形不等式，图上任意一边 $(u,v)$ 上两点满足： $h_v \leq h_u + w(u,v)$ 。这条边重新标记后的边权为 $w'(u,v)=w(u,v)+h_u-h_v \geq 0$ 。这样我们证明了新图上的边权均非负。

这样，我们就证明了 Johnson 算法的正确性。

* * *

## 不同方法的比较

| Floyd      | Bellman-Ford    | Dijkstra       | Johnson         |
| ---------- | --------------- | -------------- | --------------- |
| 每对结点之间的最短路 | 单源最短路           | 单源最短路          | 每对结点之间的最短路      |
| 没有负环的图     | 任意图（可以判定负环是否存在） | 非负权图           | 没有负环的图          |
|  $O(N^3)$  |  $O(NM)$        |  $O(M\log M)$  |  $O(NM\log M)$  |

注：表中的 Dijkstra 算法在计算复杂度时均用 `priority_queue` 实现。

## 输出方案

开一个 `pre` 数组，在更新距离的时候记录下来后面的点是如何转移过去的，算法结束前再递归地输出路径即可。

比如 Floyd 就要记录 `pre[i][j] = k;` ，Bellman-Ford 和 Dijkstra 一般记录 `pre[v] = u` 。

# save
author: Ir1d, sshwy, Xeonacid, partychicken, Anguei, HeRaNO
在 OI 中，想要对图进行操作，就需要先学习图的存储方式。

## 约定

本文默认读者已阅读并了解了 [图论相关概念](./concept.md) 中的基础内容，如果在阅读中遇到困难，也可以在 [图论相关概念](./concept.md) 中进行查阅。

在本文中，用 $n$ 代指图的点数，用 $m$ 代指图的边数，用 $d^+(u)$ 代指点 $u$ 的出度，即以 $u$ 为出发点的边数。

## 直接存边

### 方法

使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权。）

??? note "参考代码"
    ```cpp
    #include <iostream>
    #include <vector>
    
    using namespace std;
    
    struct Edge {
      int u, v;
    };
    
    int n, m;
    vector<Edge> e;
    vector<bool> vis;
    
    bool find_edge(int u, int v) {
      for (int i = 1; i <= m; ++i) {
        if (e[i].u == u && e[i].v == v) {
          return true;
        }
      }
      return false;
    }
    
    void dfs(int u) {
      if (vis[u]) return;
      vis[u] = true;
      for (int i = 1; i <= m; ++i) {
        if (e[i].u == u) {
          dfs(e[i].v);
        }
      }
    }
    
    int main() {
      cin >> n >> m;
    
      vis.resize(n + 1, false);
      e.resize(m + 1);
    
      for (int i = 1; i <= m; ++i) cin >> e[i].u >> e[i].v;
    
      return 0;
    }
    ```

### 复杂度

查询是否存在某条边： $O(m)$ 。

遍历一个点的所有出边： $O(m)$ 。

遍历整张图： $O(nm)$ 。

空间复杂度： $O(m)$ 。

### 应用

由于直接存边的遍历效率低下，一般不用于遍历图。

在 [Kruskal 算法](./mst.md#kruskal) 中，由于需要将边按边权排序，需要直接存边。

在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，需要重新建图时利用直接存下的边来建图。

## 邻接矩阵

### 方法

使用一个二维数组 `adj` 来存边，其中 `adj[u][v]` 为 1 表示存在 $u$ 到 $v$ 的边，为 0 表示不存在。如果是带边权的图，可以在 `adj[u][v]` 中存储 $u$ 到 $v$ 的边的边权。

??? note "参考代码"
    ```cpp
    #include <iostream>
    #include <vector>
    
    using namespace std;
    
    int n, m;
    vector<bool> vis;
    vector<vector<bool> > adj;
    
    bool find_edge(int u, int v) { return adj[u][v]; }
    
    void dfs(int u) {
      if (vis[u]) return;
      vis[u] = true;
      for (int v = 1; v <= n; ++v) {
        if (adj[u][v]) {
          dfs(v);
        }
      }
    }
    
    int main() {
      cin >> n >> m;
    
      vis.resize(n + 1, false);
      adj.resize(n + 1, vector<bool>(n + 1, false));
    
      for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u][v] = true;
      }
    
      return 0;
    }
    ```

### 复杂度

查询是否存在某条边： $O(1)$ 。

遍历一个点的所有出边： $O(n)$ 。

遍历整张图： $O(n^2)$ 。

空间复杂度： $O(n^2)$ 。

### 应用

邻接矩阵只适用于没有重边（或重边可以忽略）的情况。

其最显著的优点是可以 $O(1)$ 查询一条边是否存在。

由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。

## 邻接表

### 方法

使用一个支持动态增加元素的数据结构构成的数组，如 `vector<int> adj[n + 1]` 来存边，其中 `adj[u]` 存储的是点 $u$ 的所有出边的相关信息（终点、边权等）。

??? note "参考代码"
    ```cpp
    #include <iostream>
    #include <vector>
    
    using namespace std;
    
    int n, m;
    vector<bool> vis;
    vector<vector<int> > adj;
    
    bool find_edge(int u, int v) {
      for (int i = 0; i < adj[u].size(); ++i) {
        if (adj[u][i] == v) {
          return true;
        }
      }
      return false;
    }
    
    void dfs(int u) {
      if (vis[u]) return;
      vis[u] = true;
      for (int i = 0; i < adj[u].size(); ++i) dfs(adj[u][i]);
    }
    
    int main() {
      cin >> n >> m;
    
      vis.resize(n + 1, false);
      adj.resize(n + 1);
    
      for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
      }
    
      return 0;
    }
    ```

### 复杂度

查询是否存在 $u$ 到 $v$ 的边： $O(d^+(u))$ （如果事先进行了排序就可以使用 [二分查找](../basic/binary.md) 做到 $O(\log(d^+(u)))$ ）。

遍历点 $u$ 的所有出边： $O(d^+(u))$ 。

遍历整张图： $O(n+m)$ 。

空间复杂度： $O(m)$ 。

### 应用

存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）。

尤其适用于需要对一个点的所有出边进行排序的场合。

## 链式前向星

### 方法

本质上是用链表实现的邻接表，核心代码如下：

```cpp
// head[u] 和 cnt 的初始值都为 -1
void add(int u, int v) {
  nxt[++cnt] = head[u];  // 当前边的后继
  head[u] = cnt;         // 起点 u 的第一条边
  to[cnt] = v;           // 当前边的终点
}

// 遍历 u 的出边
for (int i = head[u]; ~i; i = nxt[i]) {  // ~i 表示 i != -1
  int v = to[i];
}
```

??? note "参考代码"
    ```cpp
    #include <iostream>
    #include <vector>
    
    using namespace std;
    
    int n, m;
    vector<bool> vis;
    vector<int> head, nxt, to;
    
    void add(int u, int v) {
      nxt.push_back(head[u]);
      head[u] = to.size();
      to.push_back(v);
    }
    
    bool find_edge(int u, int v) {
      for (int i = head[u]; ~i; i = nxt[i]) {  // ~i 表示 i != -1
        if (to[i] == v) {
          return true;
        }
      }
      return false;
    }
    
    void dfs(int u) {
      if (vis[u]) return;
      vis[u] = true;
      for (int i = head[u]; ~i; i = nxt[i]) dfs(to[i]);
    }
    
    int main() {
      cin >> n >> m;
    
      vis.resize(n + 1, false);
      head.resize(n + 1, -1);
    
      for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        add(u, v);
      }
    
      return 0;
    }
    ```

### 复杂度

查询是否存在 $u$ 到 $v$ 的边： $O(d^+(u))$ 。

遍历点 $u$ 的所有出边： $O(d^+(u))$ 。

遍历整张图： $O(n+m)$ 。

空间复杂度： $O(m)$ 。

### 应用

存各种图都很适合，但不能快速查询一条边是否存在，也不能方便地对一个点的出边进行排序。

优点是边是带编号的，有时会非常有用，而且如果 `cnt` 的初始值为奇数，存双向边时 `i ^ 1` 即是 `i` 的反边（常用于 [网络流](./flow.md) ）。

# bi-graph
## 定义

二分图，又称二部图，英文名叫 Bipartite graph。

二分图是什么？节点由两个集合组成，且两个集合内部没有边的图。

换言之，存在一种方案，将节点划分成满足以上性质的两个集合。

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/bi-graph.png)

（图源 [英文维基](https://en.wikipedia.org/wiki/Bipartite_graph) ）

## 性质

-   如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点。

-   ??? question "二分图不存在长度为奇数的环"
        因为每一条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合。

## 判定

如何判定一个图是不是二分图呢？

换言之，我们需要知道是否可以将图中的顶点分成两个满足条件的集合。

显然，直接枚举答案集合的话实在是太慢了，我们需要更高效的方法。

考虑上文提到的性质，我们可以使用 [DFS（图论）](./dfs.md) 或者 [BFS](./bfs.md) 来遍历这张图。如果发现了奇环，那么就不是二分图，否则是。

## 应用

### 二分图匹配

#### 匹配

设 $G$ 为二分图，若在 $G$ 的子图 $M$ 中，任意两条边都没有公共节点，那么称 $M$ 为二分图 $G$ 的一个匹配，且 $M$ 的边数为匹配数。

#### 完备匹配

设 $G=<V_1, V_2, E>$ 为二分图， $|V_1| \leq |V_2|$ ， $M$ 为 $G$ 中一个最大匹配，且 $|M|=2|V_1|$ ，则称 $M$ 为 $V_1$ 到 $V_2$ 的完备匹配。

#### 霍尔定理

设二分图 $G=<V_1, V_2, E>, |V_1| \leq |V_2|$ ，则 $G$ 中存在 $V_1$ 到 $V_2$ 的完备匹配当且仅当对于任意的 $S \subset V_1$ ，均有 $|S|\leq|N(S)|$ ，其中 $N(S)=\Cup_{v_i \in S}{N(V_i)}$ ，是 $S$ 的邻域。

#### 最大匹配

寻找二分图边数最大的匹配称为最大匹配问题。

对此，有解决此问题的 **匈牙利算法** ，时间复杂度为 $O(NM)$ 。

算法步骤大致如下：

1.  首先从任意一个未配对的点 $u$ 开始，选择他的任意一条边（ $u$ - $v$ ），如此时 $v$ 还未配对，则配对成功，配对数加一，若 $v$ 已经配对，则尝试寻找 $v$ 的配对的另一个配对（该步骤可能会被递归的被执行多次），若该尝试成功，则配对成功，配对数加一。

2.  若上一步配对不成功，那么重新选择一条未被选择过的边，重复上一步，直到点 $u$ 的所有的边都被选择过为止。

3.  对剩下每一个没有被配对的点执行步骤 1，直到所有的点都尝试完毕。

用下面的二分图为例：

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/bi-graph-1.png)

先对节点 1 和 2 尝试匹配，假设他们分别找到了 4 和 5。

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/bi-graph-2.png)

接下来对节点 3 尝试匹配，选择边（3-4），但发现 4 已经有匹配了，我们尝试寻找 4 的匹配的其他匹配，即 1 的其他匹配。
这个匹配显然只能从未被选择的边里找（灰色的），我们可以遍历 1 的所有边，寻找未被选择的，很容易找到边（1-5）。

我们发现 5 已经被匹配了，所以我们尝试寻找 5 的匹配的其他匹配，即 2 的其他匹配。类似的，可以找到 6。

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/bi-graph-3.png)

于是我们得到了新的匹配方案，且该方案比之前的匹配数多一。

/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/bi-graph-4.png)

可以发现，当尝试对节点 3 进行匹配时，走过了一条路径（3-4-1-5-2-6），最后找到了新的匹配方案，我们把这样的道路叫做 **增广路** ，其本质是一条起点和终点都是未匹配节点的路径。

匈牙利算法执行的过程也可以看作是不断寻找增广路的过程，当在当前匹配方案下再也找不到增广路，那么当前匹配方案便是最大匹配了。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e3 + 10;
int n, m, e;
vector<int> G[N];  //使用邻接表来储存边
int match[N], vis[N];
bool dfs(int u) {
  int len = G[u].size();
  for (int i = 0; i < len; i++) {  //遍历每一条边
    int v = G[u][i];
    if (vis[v]) continue;
    vis[v] = 1;
    if (/home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph//home/llj/Desktop/OI-wiki-master/docs/graph/!match[v] ||
        dfs(match[v])) {  //如果v没有匹配，或者v的匹配找到了新的匹配
      match[v] = u;
      match[u] = v;  //更新匹配信息
      return 1;
    }
  }
  return 0;
}
int main() {
  scanf("%d %d %d", &n, &m, &e);
  for (int i = 1; i <= e; i++) {
    int a, b;
    scanf("%d %d", &a, &b);
    if (a > n || b > m) continue;
    G[a].push_back(n + b);
    G[n + b].push_back(a);
  }
  int ans = 0;
  for (int i = 1; i <= n; i++) {  //对每一个点尝试匹配
    for (int j = 1; j <= n + m; j++) vis[j] = 0;
    if (dfs(i)) ans++;
  }
  printf("%d", ans);
  return 0;
}
```

除此之外，该问题还可以转化为 [最大流](graph/flow/max-flow) 问题解决。

设 $G=<V_1, V_2, E>$ 是一个二分图，不妨在图中添加源点 $s$ 和汇点 $t$ ，从 $s$ 向 $V_1$ 中的所有节点连一条流量为 1 的边， $V_2$ 中的所有节点也向 $t$ 连一条流量为 1 的边，并且将 $V_1$ 和 $V_2$ 之间的边改成从 $V_1$ 指向 $V_2$ ，流量为 1 的边。此时该图的最大流量即为最大匹配数，流量流过的边和点构成的子图即为 $G$ 的最大匹配。

若使用 Dinic 算法，则时间复杂度为 $O(N \sqrt{M+N})$ 。

例题参考：

 [洛谷 P3386【模板】二分图匹配](https://www.luogu.com.cn/problem/P3386) 

#### 最大权匹配

设 $G$ 为带边权的二分图，寻找 $G$ 边权和最大的匹配称为最大权匹配问题。

该问题可以转化为 [费用流](graph/flow/min-cost) 问题解决。

设 $G=<V_1, V_2, E>$ 是一个带边权的二分图，不妨在图中添加源点 $s$ 和汇点 $t$ ，从 $s$ 向 $V_1$ 中的所有节点连一条流量为 1，费用为 0 的边，从 $V_1$ 和 $V_2$ 的所有节点向 $t$ 连一条流量为 1，费用为 0 的边，并且将 $V_1$ 和 $V_2$ 之间的边改成从 $V_1$ 指向 $V_2$ ，流量为 1，费用为边权的边。此时该图的最大费最大流的费用即为最大权匹配的边权和，流量流过的边和点构成的子图（删去新添加的点和边后）即为 $G$ 的最大权匹配。

### 一般图匹配

对于一个图 $G(V, E)$ ，它的匹配 $M$ 是二元组 $(u, v)$ 组成的集合，其中 $u, v \in V, (u, v) \in E$ ，并且 $M$ 中不存在重复的点。

当 $|M|$ 最大的时候，我们称 $M$ 为 $G$ 的最大匹配。

该问题可以使用带花树算法或 Tutte 矩阵来解决。

# lca
## 定义

最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。
为了方便，我们记某点集 $S={v_1,v_2,\ldots,v_n}$ 的最近公共祖先为 $\text{LCA}(v_1,v_2,\ldots,v_n)$ 或 $\text{LCA}(S)$ 。

## 性质

> 本节 **性质** 部分内容翻译自 [wcipeg](http://wcipeg.com/wiki/Lowest_common_ancestor) ，并做过修改。

1.   $\text{LCA}({u})=u$ ；
2.   $u$ 是 $v$ 的祖先，当且仅当 $\text{LCA}(u,v)=u$ ；
3.  如果 $u$ 不为 $v$ 的祖先并且 $v$ 不为 $u$ 的祖先，那么 $u,v$ 分别处于 $\text{LCA}(u,v)$ 的两棵不同子树中；
4.  前序遍历中， $\text{LCA}(S)$ 出现在所有 $S$ 中元素之前，后序遍历中 $\text{LCA}(S)$ 则出现在所有 $S$ 中元素之后；
5.  两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $\text{LCA}(A\cup B)=\text{LCA}(\text{LCA}(A), \text{LCA}(B))$ ；
6.  两点的最近公共祖先必定处在树上两点间的最短路上；
7.   $d(u,v)=h(u)+h(v)-2h(\text{LCA}(u,v))$ ，其中 $d$ 是树上两点间的距离， $h$ 代表某点到树根的距离。

## 求法

### 朴素算法

可以每次找深度比较大的那个点，让它向上跳。显然在树上，这两个点最后一定会相遇，相遇的位置就是想要求的 LCA。
或者先向上调整深度较大的点，令他们深度相同，然后再共同向上跳转，最后也一定会相遇。

朴素算法预处理时需要 dfs 整棵树，时间复杂度为 $O(n)$ ，单次查询时间复杂度为 $\Theta(n)$ 。但由于随机树高为 $O(\log n)$ ，所以朴素算法在随机树上的单次查询时间复杂度为 $O(\log n)$ 。

### 倍增算法

倍增算法是最经典的 LCA 求法，他是朴素算法的改进算法。通过预处理 `fa[x][i]` 数组，游标可以快速移动，大幅减少了游标跳转次数。 `fa[x][i]` 表示点 $x$ 的第 $2^i$ 个祖先。 `fa[x][i]` 数组可以通过 dfs 预处理出来。

现在我们看看如何优化这些跳转：
在调整游标的第一阶段中，我们可以计算出 $u,v$ 两点的深度之差，设其为 $y$ 。通过将 $y$ 进行二进制拆分，我们将 $y$ 次游标跳转优化为 `count_one_in_binary_representation(y)` 次游标跳转。
在第二阶段中，我们从最大的 $i$ 开始循环尝试，一直尝试到 $0$ （包括 $0$ ），如果 `fa[u][i] != fa[v][i]` ，则令 `u = fa[u][i]; v = fa[v][i]` ，那么最后的 LCA 为 `fa[u][0]` 。

倍增算法的预处理时间复杂度为 $O(n \log n)$ ，单次查询时间复杂度为 $O(\log n)$ 。
另外倍增算法可以通过交换 `fa` 数组的两维使较小维放在前面。这样可以减少 cache miss 次数，提高程序效率。

!!! 例题
     [HDU 2586 How far away?](http://acm.hdu.edu.cn/showproblem.php?pid=2586) 树上最短路查询。原题为多组数据，以下代码为针对单组数据的情况编写的。

可先求出 LCA，再结合性质 $7$ 进行解答。也可以直接在求 LCA 时求出结果。
以下代码仅供参考。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>
#define MXN 50007
using namespace std;
std::vector<int> v[MXN];
std::vector<int> w[MXN];

int fa[MXN][31], cost[MXN][31], dep[MXN];
int n, m;
int a, b, c;
void dfs(int root, int fno) {
  fa[root][0] = fno;
  dep[root] = dep[fa[root][0]] + 1;
  for (int i = 1; i < 31; ++i) {
    fa[root][i] = fa[fa[root][i - 1]][i - 1];
    cost[root][i] = cost[fa[root][i - 1]][i - 1] + cost[root][i - 1];
  }
  int sz = v[root].size();
  for (int i = 0; i < sz; ++i) {
    if (v[root][i] == fno) continue;
    cost[v[root][i]][0] = w[root][i];
    dfs(v[root][i], root);
  }
}
int lca(int x, int y) {
  if (dep[x] > dep[y]) swap(x, y);
  int tmp = dep[y] - dep[x], ans = 0;
  for (int j = 0; tmp; ++j, tmp >>= 1)
    if (tmp & 1) ans += cost[y][j], y = fa[y][j];
  if (y == x) return ans;
  for (int j = 30; j >= 0 && y != x; --j) {
    if (fa[x][j] != fa[y][j]) {
      ans += cost[x][j] + cost[y][j];
      x = fa[x][j];
      y = fa[y][j];
    }
  }
  ans += cost[x][0] + cost[y][0];
  return ans;
}
int main() {
  memset(fa, 0, sizeof(fa));
  memset(cost, 0, sizeof(cost));
  memset(dep, 0, sizeof(dep));
  scanf("%d", &n);
  for (int i = 1; i < n; ++i) {
    scanf("%d %d %d", &a, &b, &c);
    ++a, ++b;
    v[a].push_back(b);
    v[b].push_back(a);
    w[a].push_back(c);
    w[b].push_back(c);
  }
  dfs(1, 0);
  scanf("%d", &m);
  for (int i = 0; i < m; ++i) {
    scanf("%d %d", &a, &b);
    ++a, ++b;
    printf("%d\n", lca(a, b));
  }
  return 0;
}
```

### Tarjan 算法

 `Tarjan 算法` 是一种 `离线算法` ，需要使用 `并查集` 记录某个结点的祖先结点。做法如下：

1.  首先接受输入（邻接链表）、查询（存储在另一个邻接链表内）。查询边其实是虚拟加上去的边，为了方便，每次输入查询边的时候，将这个边及其反向边都加入到 `queryEdge` 数组里。
2.  然后对其进行一次 DFS 遍历，同时使用 `visited` 数组进行记录某个结点是否被访问过、 `parent` 记录当前结点的父亲结点。
3.  其中涉及到了 `回溯思想` ，我们每次遍历到某个结点的时候，认为这个结点的根结点就是它本身。让以这个结点为根节点的 DFS 全部遍历完毕了以后，再将 `这个结点的根节点` 设置为 `这个结点的父一级结点` 。
4.  回溯的时候，如果以该节点为起点， `queryEdge` 查询边的另一个结点也恰好访问过了，则直接更新查询边的 LCA 结果。
5.  最后输出结果。

Tarjan 算法需要初始化并查集，所以预处理的时间复杂度为 $O(n)$ ，Tarjan 算法处理所有询问的时间复杂度为 $O(n + m)$ 。但是 Tarjan 算法的常数比倍增算法大。

需要注意的是，Tarjan 算法中使用的并查集性质比较特殊，在仅使用路径压缩优化的情况下，单次调用 `find()` 函数的时间复杂度为均摊 $O(1)$ ，而不是 $O(\log n)$ 。具体可以见 [并查集部分的引用：A Linear-Time Algorithm for a Special Case of Disjoint Set Union](../ds/dsu.md#references) 。

```cpp
#include <algorithm>
#include <iostream>
using namespace std;

class Edge {
 public:
  int toVertex, fromVertex;
  int next;
  int LCA;
  Edge() : toVertex(-1), fromVertex(-1), next(-1), LCA(-1){};
  Edge(int u, int v, int n) : fromVertex(u), toVertex(v), next(n), LCA(-1){};
};

const int MAX = 100;
int head[MAX], queryHead[MAX];
Edge edge[MAX], queryEdge[MAX];
int parent[MAX], visited[MAX];
int vertexCount, edgeCount, queryCount;

void init() {
  for (int i = 0; i <= vertexCount; i++) {
    parent[i] = i;
  }
}

int find(int x) {
  if (parent[x] == x) {
    return x;
  } else {
    return find(parent[x]);
  }
}

void tarjan(int u) {
  parent[u] = u;
  visited[u] = 1;

  for (int i = head[u]; i != -1; i = edge[i].next) {
    Edge& e = edge[i];
    if (!visited[e.toVertex]) {
      tarjan(e.toVertex);
      parent[e.toVertex] = u;
    }
  }

  for (int i = queryHead[u]; i != -1; i = queryEdge[i].next) {
    Edge& e = queryEdge[i];
    if (visited[e.toVertex]) {
      queryEdge[i ^ 1].LCA = e.LCA = find(e.toVertex);
    }
  }
}

int main() {
  memset(head, 0xff, sizeof(head));
  memset(queryHead, 0xff, sizeof(queryHead));

  cin >> vertexCount >> edgeCount >> queryCount;
  int count = 0;
  for (int i = 0; i < edgeCount; i++) {
    int start = 0, end = 0;
    cin >> start >> end;

    edge[count] = Edge(start, end, head[start]);
    head[start] = count;
    count++;

    edge[count] = Edge(end, start, head[end]);
    head[end] = count;
    count++;
  }

  count = 0;
  for (int i = 0; i < queryCount; i++) {
    int start = 0, end = 0;
    cin >> start >> end;

    queryEdge[count] = Edge(start, end, queryHead[start]);
    queryHead[start] = count;
    count++;

    queryEdge[count] = Edge(end, start, queryHead[end]);
    queryHead[end] = count;
    count++;
  }

  init();
  tarjan(1);

  for (int i = 0; i < queryCount; i++) {
    Edge& e = queryEdge[i * 2];
    cout << "(" << e.fromVertex << "," << e.toVertex << ") " << e.LCA << endl;
  }

  return 0;
}
```

### 用欧拉序列转化为 RMQ 问题

对一棵树进行 DFS，无论是第一次访问还是回溯，每次到达一个结点时都将编号记录下来，可以得到一个长度为 $2n-1$ 的序列，这个序列被称作这棵树的欧拉序列（可以看成是这棵树的一条欧拉回路所经过的节点构成的序列）。

在下文中，把结点 $u$ 在欧拉序列中第一次出现的位置编号记为 $pos(u)$ （也称作节点 $u$ 的欧拉序），把欧拉序列本身记作 $E[1..2n-1]$ 。

有了欧拉序列，LCA 问题可以在线性时间内转化为 RMQ 问题，即 $pos(LCA(u, v))=\min\{pos(k)|k\in E[pos(u)..pos(v)]\}$ 。

这个等式不难理解：从 $u$ 走到 $v$ 的过程中一定会经过 $LCA(u,v)$ ，但不会经过 $LCA(u,v)$ 的祖先。因此，从 $u$ 走到 $v$ 的过程中经过的欧拉序最小的结点就是 $LCA(u, v)$ 。

用 DFS 计算欧拉序列的时间复杂度是 $O(n)$ ，且欧拉序列的长度也是 $O(n)$ ，所以 LCA 问题可以在 $O(n)$ 的时间内转化成等规模的 RMQ 问题。

参考代码：

```cpp
int dfn[N << 1], dep[N << 1], dfntot = 0;
void dfs(int t, int depth) {
  dfn[++dfntot] = t;
  pos[t] = dfntot;
  dep[dfntot] = depth;
  for (int i = head[t]; i; i = side[i].next) {
    dfs(side[i].to, t, depth + 1);
    dfn[++dfntot] = t;
    dep[dfntot] = depth;
  }
}
void st_preprocess() {
  lg[0] = -1;  // 预处理 lg 代替库函数 log2 来优化常数
  for (int i = 1; i <= (N << 1); ++i) lg[i] = lg[i >> 1] + 1;
  for (int i = 1; i <= (N << 1) - 1; ++i) st[0][i] = dfn[i];
  for (int i = 1; i <= lg[(N << 1) - 1]; ++i)
    for (int j = 1; j + (1 << n) - 1 <= ((N << 1) - 1); ++j)
      st[i][j] = dep[st[i - 1][j]] < dep[st[i - 1][j + (1 << i - 1)]
                     ? st[i - 1][j]
                     : st[i - 1][j + (1 << i - 1)];
}
```

当我们需要查询某点对 $(u, v)$ 的 LCA 时，查询区间 $[\min\{pos[u], pos[v]\}, \max\{pos[u], pos[v]\}]$ 上最小值的所代表的节点即可。

若使用 ST 表来解决 RMQ 问题，那么该算法不支持在线修改，预处理的时间复杂度为 $O(n\log n)$ ，每次查询 LCA 的时间复杂度为 $O(1)$ 。

### 树链剖分

LCA 为两个游标跳转到同一条重链上时深度较小的那个游标所指向的点。

树链剖分的预处理时间复杂度为 $O(n)$ ，单次查询的时间复杂度为 $O(\log n)$ ，并且常数较小。

###  [动态树](../ds/lct.md) 

设连续两次 [access](../ds/lct.md#access) 操作的点分别为 `u` 和 `v` ，则第二次 [access](../ds/lct.md#access) 操作返回的点即为 `u` 和 `v` 的 LCA.

在无 link 和 cut 等操作的情况下，使用 link cut tree 单次查询的时间复杂度为 $O(\log n)$ 。

### 标准 RMQ

时间复杂度 $O(N)-O(1)$ ，空间复杂度 $O(N)$ ，支持在线查询，常数较大，编程复杂度较高。

流程：

-   通过 DFS 序将树上 LCA 问题转为序列 RMQ 问题

-   通过单调栈将序列转为笛卡尔树

-   在笛卡尔树上求欧拉序，如此转化为 $\pm 1$ RMQ

-   对新序列分块，做分块 ST 表，块内通过二进制状压 DP 维护

每一步的复杂度都是 $O(N)$ 的，因此总复杂度依然是 $O(N)$ 。

提供 RMQ 转标准 RMQ 的代码，为洛谷上 ST 表的例题 [ **P3865** 【模板】ST 表](https://www.luogu.org/problemnew/show/P3865) 

```cpp
// Copyright (C) 2018 Skqliao. All rights served.
#include <bits/stdc++.h>

#define rep(i, l, r) for (int i = (l), _##i##_ = (r); i < _##i##_; ++i)
#define rof(i, l, r) for (int i = (l)-1, _##i##_ = (r); i >= _##i##_; --i)
#define ALL(x) (x).begin(), (x).end()
#define SZ(x) static_cast<int>((x).size())
typedef long long ll;
typedef std::pair<int, int> pii;
template <typename T>
inline bool chkMin(T &a, const T &b) {
  return a > b ? a = b, 1 : 0;
}
template <typename T>
inline bool chkMax(T &a, const T &b) {
  return a < b ? a = b, 1 : 0;
}

const int MAXN = 1e5 + 5;

struct PlusMinusOneRMQ {
  const static int M = 8;
  int blocklen, block, Minv[MAXN], F[MAXN / M * 2 + 5][M << 1], T[MAXN],
      f[1 << M][M][M], S[MAXN];
  void init(int n) {
    blocklen = std::max(1, (int)(log(n * 1.0) / log(2.0)) / 2);
    block = n / blocklen + (n % blocklen > 0);
    int total = 1 << (blocklen - 1);
    for (int i = 0; i < total; i++) {
      for (int l = 0; l < blocklen; l++) {
        f[i][l][l] = l;
        int now = 0, minv = 0;
        for (int r = l + 1; r < blocklen; r++) {
          f[i][l][r] = f[i][l][r - 1];
          if ((1 << (r - 1)) & i) {
            now++;
          } else {
            now--;
            if (now < minv) {
              minv = now;
              f[i][l][r] = r;
            }
          }
        }
      }
    }
    T[1] = 0;
    for (int i = 2; i < MAXN; i++) {
      T[i] = T[i - 1];
      if (!(i & (i - 1))) {
        T[i]++;
      }
    }
  }
  void initmin(int a[], int n) {
    for (int i = 0; i < n; i++) {
      if (i % blocklen == 0) {
        Minv[i / blocklen] = i;
        S[i / blocklen] = 0;
      } else {
        if (a[i] < a[Minv[i / blocklen]]) {
          Minv[i / blocklen] = i;
        }
        if (a[i] > a[i - 1]) {
          S[i / blocklen] |= 1 << (i % blocklen - 1);
        }
      }
    }
    for (int i = 0; i < block; i++) {
      F[i][0] = Minv[i];
    }
    for (int j = 1; (1 << j) <= block; j++) {
      for (int i = 0; i + (1 << j) - 1 < block; i++) {
        int b1 = F[i][j - 1], b2 = F[i + (1 << (j - 1))][j - 1];
        F[i][j] = a[b1] < a[b2] ? b1 : b2;
      }
    }
  }
  int querymin(int a[], int L, int R) {
    int idl = L / blocklen, idr = R / blocklen;
    if (idl == idr)
      return idl * blocklen + f[S[idl]][L % blocklen][R % blocklen];
    else {
      int b1 = idl * blocklen + f[S[idl]][L % blocklen][blocklen - 1];
      int b2 = idr * blocklen + f[S[idr]][0][R % blocklen];
      int buf = a[b1] < a[b2] ? b1 : b2;
      int c = T[idr - idl - 1];
      if (idr - idl - 1) {
        int b1 = F[idl + 1][c];
        int b2 = F[idr - 1 - (1 << c) + 1][c];
        int b = a[b1] < a[b2] ? b1 : b2;
        return a[buf] < a[b] ? buf : b;
      }
      return buf;
    }
  }
};

struct CartesianTree {
 private:
  struct Node {
    int key, value, l, r;
    Node(int key, int value) {
      this->key = key;
      this->value = value;
      l = r = 0;
    }
    Node() {}
  };
  Node tree[MAXN];
  int sz;
  int S[MAXN], top;

 public:
  void build(int a[], int n) {
    top = 0;
    tree[0] = Node(-1, INT_MAX);
    S[top++] = 0;
    sz = 0;
    for (int i = 0; i < n; i++) {
      tree[++sz] = Node(i, a[i]);
      int last = 0;
      while (tree[S[top - 1]].value <= tree[sz].value) {
        last = S[top - 1];
        top--;
      }
      tree[sz].l = last;
      tree[S[top - 1]].r = sz;
      S[top++] = sz;
    }
  }
  Node &operator[](const int x) { return tree[x]; }
};

class stdRMQ {
 public:
  void work(int a[], int n) {
    ct.build(a, n);
    dfs_clock = 0;
    dfs(0, 0);
    rmq.init(dfs_clock);
    rmq.initmin(depseq, dfs_clock);
  }
  int query(int L, int R) {
    int cl = clk[L], cr = clk[R];
    if (cl > cr) {
      std::swap(cl, cr);
    }
    return Val[rmq.querymin(depseq, cl, cr)];
  }

 private:
  CartesianTree ct;
  PlusMinusOneRMQ rmq;
  int dfs_clock, clk[MAXN], Val[MAXN << 1], depseq[MAXN << 1];
  void dfs(int rt, int d) {
    clk[ct[rt].key] = dfs_clock;
    depseq[dfs_clock] = d;
    Val[dfs_clock++] = ct[rt].value;
    if (ct[rt].l) {
      dfs(ct[rt].l, d + 1);
      depseq[dfs_clock] = d;
      Val[dfs_clock++] = ct[rt].value;
    }
    if (ct[rt].r) {
      dfs(ct[rt].r, d + 1);
      depseq[dfs_clock] = d;
      Val[dfs_clock++] = ct[rt].value;
    }
  }
} doit;

int A[MAXN];

int main() {
  int n, m, l, r;
  scanf("%d%d", &n, &m);
  for (int i = 0; i < n; ++i) {
    scanf("%d", &A[i]);
  }
  doit.work(A, n);
  while (m--) {
    scanf("%d%d", &l, &r);
    printf("%d\n", doit.query(l - 1, r - 1));
  }
  return 0;
}
```

## 习题

-    [祖孙询问](https://loj.ac/problem/10135) 
-    [货车运输](https://loj.ac/problem/2610) 
-    [点的距离](https://loj.ac/problem/10130) 

# bfs
author: Ir1d, greyqz, yjl9903, Anguei, TrisolarisHD, ChungZH, Xeonacid, ylxmf2005

BFS 全称是 [Breadth First Search](https://en.wikipedia.org/wiki/Breadth-first_search) ，中文名是宽度优先搜索，也叫广度优先搜索。

是图上最基础、最重要的搜索算法之一。

所谓宽度优先。就是每次都尝试访问同一层的节点。
如果同一层都访问完了，再访问下一层。

这样做的结果是，BFS 算法找到的路径是从起点开始的 **最短** 合法路径。换言之，这条路所包含的边数最小。

在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。

算法过程可以看做是图上火苗传播的过程：最开始只有起点着火了，在每一时刻，有火的节点都向它相邻的所有节点传播火苗。

## 实现

伪代码：

```text
bfs(s) {
  q = new queue()
  q.push(s), visited[s] = true
  while (!q.empty()) {
    u = q.pop()
    for each edge(u, v) {
      if (!visited[v]) {
        q.push(v)
        visited[v] = true
      }
    }
  }
}
```

C++：

```cpp
void bfs(int u) {
  while (!Q.empty()) Q.pop();
  Q.push(u);
  vis[u] = 1;
  d[u] = 0;
  p[u] = -1;
  while (!Q.empty()) {
    u = Q.front();
    Q.pop();
    for (int i = head[u]; i; i = e[i].x) {
      if (!vis[e[i].t]) {
        Q.push(e[i].t);
        vis[e[i].t] = 1;
        d[e[i].t] = d[u] + 1;
        p[e[i].t] = u;
      }
    }
  }
}
void restore(int x) {
  vector<int> res;
  for (int v = x; v != -1; v = p[v]) {
    res.push_back(v);
  }
  std::reverse(res.begin(), res.end());
  for (int i = 0; i < res.size(); ++i) printf("%d", res[i]);
  puts("");
}
```

具体来说，我们用一个队列 Q 来记录要处理的节点，然后开一个 $vis[]$ 布尔数组来标记某个节点是否已经访问过了。

开始的时候，我们把起点 s 以外的节点的 vis 值设为 0，意思是没有访问过。然后把起点 s 放入队列 Q 中。

之后，我们每次从队列 Q 中取出队首的点 u，把 u 相邻的所有点 v 标记为已经访问过了并放入队列 Q。

直到某一时刻，队列 Q 为空，这时 BFS 结束。

在 BFS 的过程中，也可以记录一些额外的信息。比如上面的代码中，d 数组是用来记录某个点到起点的距离（要经过的最少边数），p 数组是记录从起点到这个点的最短路上的上一个点。

有了 d 数组，可以方便地得到起点到一个点的距离。

有了 p 数组，可以方便地还原出起点到一个点的最短路径。上面的 restore 函数就是在做这件事：restore(x) 输出的是从起点到 x 这个点所经过的点。

时间复杂度 $O(n + m)$ 

空间复杂度 $O(n)$ （vis 数组和队列）

## open-closed 表

在实现 BFS 的时候，我们把未被访问过的节点放在一个称为 open 的容器中，而把已经访问过了的节点放在 closed 容器中。

## 在树/图上 BFS

### BFS 序列

类似 BFS 序列，BFS 序列是指在 BFS 过程中访问的节点编号的序列。

### 一般图上 BFS

如果原图不连通，只能访问到从起点出发能够到达的点。

BFS 序列通常也不唯一。

类似的我们也可以定义 BFS 树：在 BFS 过程中，通过记录每个节点从哪个点访问而来，可以建立一个树结构，即为 BFS 树。

## 应用

-   在一个无权图上求从起点到其他所有点的最短路径。
-   在 $O(n+m)$ 时间内求出所有连通块。（我们只需要从每个没有被访问过的节点开始做 BFS，显然每次 BFS 会走完一个连通块）
-   如果把一个游戏的动作看做是状态图上的一条边（一个转移），那么 BFS 可以用来找到在游戏中从一个状态到达另一个状态所需要的最小步骤。
-   在一个边权为 0/1 的图上求最短路。（需要修改入队的过程，如果某条边权值为 0，且可以减小边的终点到图的起点的距离，那么把边的起点加到队列首而不是队列尾）
-   在一个有向无权图中找最小环。（从每个点开始 BFS，在我们即将抵达一个之前访问过的点开始的时候，就知道遇到了一个环。图的最小环是每次 BFS 得到的最小环的平均值。）
-   找到一定在 $(a, b)$ 最短路上的边。（分别从 a 和 b 进行 BFS，得到两个 d 数组。之后对每一条边 $(u, v)$ ，如果 $d_a[u]+1+d_b[v]=d_a[b]$ ，则说明该边在最短路上）
-   找到一定在 $(a, b)$ 最短路上的点。（分别从 a 和 b 进行 BFS，得到两个 d 数组。之后对每一个点 v，如果 $d_a[u]+d_b[v]=d_a[b]$ ，则说明该点在最短路上）
-   找到一条长度为偶数的最短路。（我们需要一个构造一个新图，把每个点拆成两个新点，原图的边 $(u, v)$ 变成 $((u, 0), (v, 1))$ 和 $((u, 1), (v, 0))$ 。对新图做 BFS， $(s, 0)$ 和 $(t, 0)$ 之间的最短路即为所求）

## 例题

-    [「NOIP2017」奶酪](http://uoj.ac/problem/332) 

## 参考

 <https://cp-algorithms.com/graph/breadth-first-search.html> 

## 双端队列 BFS

如果你不了解双端队列 `deque` 的话，请到 STL-queue 中学习。

双端队列 BFS 又称 0-1 BFS

### 适用范围

边权值为可能有，也可能没有（由于 BFS 适用于权值为 1 的图，所以一般是 0 or 1），或者能够转化为这种边权值的最短路问题。

例如在走迷宫问题中，你可以花 1 个金币走 5 步，也可以不花金币走 1 步，这就可以用 0-1 BFS 解决。

### 实现

一般情况下，我们把没有权值的边扩展到的点放到队首，有权值的边扩展到的点放到队尾。这样即可保证在整个队列中，像普通 BFS 一样，越靠近队首，权值越小，且权值零一之间有分隔。

下面是伪代码：

```cpp
while (队列不为空) {
  int u = 队首;
  弹出队首;
  for (枚举 u 的邻居) {
    更新数据
    if (...)
      添加到队首;
    else
      添加到队尾;
  }
}
```

### 例题

###  [Codeforces 173B](http://codeforces.com/problemset/problem/173/B) 

一个 $n \times m$ 的图，现在有一束激光从左上角往右边射出，每遇到 '#'，你可以选择光线往四个方向射出，或者什么都不做，问最少需要多少个 '#' 往四个方向射出才能使光线在第 $n$ 行往右边射出。

此题目正解不是 0-1 BFS 但是适用 0-1 BFS 可以不需要思考过程，赛时许多大佬都是这么做的。

做法很简单，一个方向射出不需要花费（0），而往四个方向射出需要花费（1），然后直接来就可以了。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define INF (1 << 29)
int n, m;
char grid[1001][1001];
int dist[1001][1001][4];
int fx[] = {1, -1, 0, 0};
int fy[] = {0, 0, 1, -1};
deque<int> q;

void add_front(int x, int y, int dir, int d) {
  if (d < dist[x][y][dir]) {
    dist[x][y][dir] = d;
    q.push_front(dir);
    q.push_front(y);
    q.push_front(x);
  }
}

void add_back(int x, int y, int dir, int d) {
  if (d < dist[x][y][dir]) {
    dist[x][y][dir] = d;
    q.push_back(x);
    q.push_back(y);
    q.push_back(dir);
  }
}

int main() {
  cin >> n >> m;
  for (int i = 0; i < n; i++) cin >> grid[i];

  for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
      for (int k = 0; k < 4; k++) dist[i][j][k] = INF;

  add_front(n - 1, m - 1, 3, 0);

  while (!q.empty()) {
    int x = q[0], y = q[1], dir = q[2];
    q.pop_front();
    q.pop_front();
    q.pop_front();
    int d = dist[x][y][dir];
    int nx = x + fx[dir], ny = y + fy[dir];
    if (nx >= 0 && nx < n && ny >= 0 && ny < m) add_front(nx, ny, dir, d);
    if (grid[x][y] == '#')
      for (int i = 0; i < 4; i++)
        if (i != dir) add_back(x, y, i, d + 1);
  }
  if (dist[0][0][3] == INF)
    cout << -1 << endl;
  else
    cout << dist[0][0][3] << endl;
  return 0;
}
```

## 优先队列 BFS

优先队列，相当于一个二叉堆，STL 中提供了 [ `std::priority_queue` ](../lang/csl/container-adapter.md) ，可以方便我们使用优先队列。

在基于优先队列的 BFS 中，我们每次从队首取出代价最小的结点进行进一步搜索。容易证明这个贪心思想是正确的，因为从这个结点开始扩展的搜索，一定不会更新原来那些代价更高的结点。换句话说，其余那些代价更高的结点，我们不回去考虑更新它。

当然，每个结点可能会被入队多次，只是每次入队的代价不同。当该结点第一次从优先队列中取出，以后便无需再在该结点进行搜索，直接忽略即可。所以，优先队列的 BFS 当中，每个结点只会被处理一次。

相对于普通队列的 BFS，时间复杂度多了一个 $\log$ ，毕竟要维护这个优先队列嘛。不过普通 BFS 有可能每个结点入队、出队多次，时间复杂度会达到 $O(n^2)$ ，不是 $O(n)$ 。所以优先队列 BFS 通常还是快的。

诶？这怎么听起来这么像堆优化的 [Dijkstra](./shortest-path.md#dijkstra) 算法呢？事实上，堆优化 Dijkstra 就是优先队列 BFS。

# dfs
author: Ir1d, greyqz, yjl9903, partychicken, ChungZH, qq1010903229, TrisolarisHD, Acfboy

DFS 全称是 [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search) ，中文名是深度优先搜索，是一种用于遍历或搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。

该算法讲解时常常与 BFS 并列，但两者除了都能遍历图的联通块以外，用途完全不同，很少有能混用两种算法的情况。

DFS 常常用来指代用递归函数实现的搜索，但实际上两者并不一样。有关该类搜索思想请参阅 [DFS（搜索）](../search/dfs.md) .

DFS 最显著的特征在于其 **递归调用自身** 。同时与 BFS 类似，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保 **每个点仅访问一次** 。符合以上两条规则的函数，便是广义上的 DFS。

具体地说，DFS 大致结构如下：

    DFS(v) // v 可以是图中的一个顶点，也可以是抽象的概念，如 dp 状态等。
      在 v 上打访问标记
      for u in v 的相邻节点
        if u 没有打过访问标记 then
          DFS(u)
        end
      end
    end

以上代码只包含了 DFS 必需的主要结构。实际的 DFS 会在以上代码基础上加入一些代码，利用 DFS 性质进行其他操作。

该算法通常的时间复杂度为 $O(n+m)$ ，空间复杂度为 $O(n)$ ，其中 $n$ 表示点数， $m$ 表示边数。注意空间复杂度包含了栈空间，栈空间的空间复杂度是 $O(n)$ 的。在平均 $O(1)$ 遍历一条边的条件下才能达到此时间复杂度，例如用前向星或邻接表存储图；如果用邻接矩阵则不一定能达到此复杂度。

> 备注：目前大部分算法竞赛（包括 NOIP、大部分省选以及 CCF 举办的各项赛事）都支持 **无限栈空间** ，即：栈空间不单独限制，但总内存空间仍然受题面限制。但大部分操作系统会对栈空间做额外的限制，因此在本地调试时需要一些方式来取消栈空间限制。
>
> -   在 Windows 上，通常的方法是在 **编译选项** 中加入 `-Wl,--stack=1000000000` ，表示将栈空间限制设置为 1000000000 字节。
> -   在 Linux 上，通常的方法是在运行程序前 **在终端内** 执行 `ulimit -s unlimited` ，表示栈空间无限。每个终端只需执行一次，对之后每次程序运行都有效。

## 实现

以链式前向星为例：（和上方伪代码每行一一对应）

```cpp
void dfs(int u) {
  vis[u] = 1;
  for (int i = head[u]; i; i = e[i].x) {
    if (!vis[e[i].t]) {
      dfs(v);
    }
  }
}
```

### DFS 序列

DFS 序列是指 DFS 调用过程中访问的节点编号的序列。

我们发现，每个子树都对应 DFS 序列中的连续一段（一段区间）。

### 括号序列

DFS 进入某个节点的时候记录一个左括号 `(` ，退出某个节点的啥时候记录一个右括号 `)` 。

每个节点会出现两次。相邻两个节点的深度相差 1。

### 一般图上 DFS

对于非连通图，只能访问到起点所在的连通分量。

对于连通图，DFS 序列通常不唯一。

注：树的 DFS 序列也是不唯一的。

在 DFS 过程中，通过记录每个节点从哪个点访问而来，可以建立一个树结构，称为 DFS 树。DFS 树是原图的一个生成树。

 [DFS 树](./scc.md#dfs) 有很多性质，比如可以用来求 [强连通分量](./scc.md) 。

# topo
## 定义

拓扑排序的英文名是 Topological sorting。

拓扑排序要解决的问题是给一个图的所有节点排序。

我们可以拿大学选课的例子来描述这个过程，比如学习大学课程中有：单变量微积分，线性代数，离散数学概述，概率论与统计学概述，语言基础，算法导论，机器学习。当我们想要学习 算法导论 的时候，就必须先学会 离散数学概述 和 概率论与统计学概述，不然在课堂就会听的一脸懵逼。当然还有一个更加前的课程 单变量微积分。这些课程就相当于几个顶点 $u$ , 顶点之间的有向边 $(u,v)$ 就相当于学习课程的顺序。显然拓扑排序不是那么的麻烦，不然你是如何选出合适的学习顺序。下面将介绍如何将这个过程抽象出来，用算法来实现。

但是如果某一天排课的老师打瞌睡了，说想要学习 算法导论，还得先学 机器学习，而 机器学习 的前置课程又是 算法导论，然后你就一万脸懵逼了，我到底应该先学哪一个？当然我们在这里不考虑什么同时学几个课程的情况。在这里，算法导论 和 机器学习 间就出现了一个环，显然你现在没办法弄清楚你需要学什么了，于是你也没办法进行拓扑排序了。因而如果有向图中存在环路，那么我们就没办法进行 拓扑排序 了。

因此我们可以说 在一个 [DAG（有向无环图）](./dag.md) 中，我们将图中的顶点以线性方式进行排序，使得对于任何的顶点 $u$ 到 $v$ 的有向边 $(u,v)$ , 都可以有 $u$ 在 $v$ 的前面。

还有给定一个 DAG，如果从 $i$ 到 $j$ 有边，则认为 $j$ 依赖于 $i$ 。如果 $i$ 到 $j$ 有路径（ $i$ 可达 $j$ ），则称 $j$ 间接依赖于 $i$ 。

拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。

## Kahn 算法

将入度为 $0$ 的点组成一个集合 $S$ 

每次从 $S$ 里面取出一个顶点 $u$ （可以随便取）放入 $L$ , 然后遍历顶点 $u$ 的所有边 $(u, v_1), (u, v_2), (u, v_3) \cdots$ , 并删除，并判断如果该边的另一个顶点，如果在移除这一条边后入度为 $0$ , 那么就将这个顶点放入集合 $L$ 中。不断地重复取出顶点然后……

最后当集合为空后，就检查图中是否存在任何边。如果有，那么这个图一定有环路，否者返回 $L$ , $L$ 中顺序就是拓扑排序的结果

首先看来自 [Wikipedia](https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm) 的伪代码

```text
L← Empty list that will contain the sorted elements
S ← Set of all nodes with no incoming edges
while S is non-empty do
    remove a node n from S
    insert n into L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
if graph has edges then
    return error (graph has at least onecycle)
else
    return L (a topologically sortedorder)
```

代码的核心是，是维持一个入度为 0 的顶点。

可以参考该图

![topo](images/topo.png)

对其排序的结果就是：2 -> 8 -> 0 -> 3 -> 7 -> 1 -> 5 -> 6 -> 9 -> 4 -> 11 -> 10 -> 12

### 时间复杂度

假设这个图 $G = (V, E)$ 在初始化入度为 $0$ 的集合 $S$ 的时候就需要遍历整个图，并检查每一条边，因而有 $O(E+V)$ 的复杂度。然后对该集合进行操作，显然也是需要 $O(E+V)$ 的时间复杂度。

因而总的时间复杂度就有 $O(E+V)$ 

### 实现

伪代码：

```text
bool toposort() {
	q = new queue();
	for (i = 0; i < n; i++)
		if (in_deg[i] == 0) q.push(i);
	ans = new vector();
	while (!q.empty()) {
		u = q.pop();
		ans.push_back(u);
		for each edge(u, v) {
			if (--in_deg[v] == 0) q.push(v);
		}
	}
	if (ans.size() == n) {
		for (i = 0; i < n; i++)
			std::cout << ans[i] << std::endl;
		return true;
	} else {
		return false;
	}
}
```

## DFS 算法

```cpp
// dfs 版本
bool dfs(int u) {
  c[u] = -1;
  for (int v = 0; v <= n; v++)
    if (G[u][v]) {
      if (c[v] < 0)
        return false;
      else if (!c[v])
        dfs(v);
    }
  c[u] = 1;
  topo.push_back(u);
  return true;
}
bool toposort() {
  topo.clear();
  memset(c, 0, sizeof(c));
  for (int u = 0; u <= n; u++)
    if (!c[u])
      if (!dfs(u)) return false;
  reverse(topo.begin(), topo.end());
  return true;
}
```

时间复杂度： $O(E+V)$ 空间复杂度： $O(V)$ 

### 合理性证明

考虑一个图，删掉某个入度为 $0$ 的节点之后，如果新图可以拓扑排序，那么原图一定也可以。反过来，如果原图可以拓扑排序，那么删掉后也可以。

### 应用

拓扑排序可以用来判断图中是否有环，

还可以用来判断图是否是一条链。

## 参考

1.  离散数学及其应用。ISBN:9787111555391
2.   <https://blog.csdn.net/dm_vincent/article/details/7714519> 
3.  Topological sorting, <https://en.wikipedia.org/w/index.php?title=Topological_sorting&oldid=854351542> 

# min-circle
## 问题

给出一个图，问其中的有 $n$ 个节点构成的边权和最小的环 $(n\ge 3)$ 是多大。

图的最小环也称围长。

### 暴力解法

设 $u$ 和 $v$ 之间有一条边长为 $w$ 的边， $dis(u,v)$ 表示删除 $u$ 和 $v$ 之间的连边之后， $u$ 和 $v$ 之间的最短路。

那么最小环是 $dis(u,v)+w$ 。

总时间复杂度 $O(n^2m)$ 。

### Dijkstra

枚举所有边，每一次求删除一条边之后对这条边的起点跑一次 Dijkstra，道理同上。

时间复杂度 $O(m(n+m)\log n)$ 。

### Floyd

记原图中 $u,v$ 之间边的边权为 $val\left(u,v\right)$ 。

我们注意到 Floyd 算法有一个性质：在最外层循环到点 $k$ 时（尚未开始第 $k$ 次循环），最短路数组 $dis$ 中， $dis_{u,v}$ 表示的是从 $u$ 到 $v$ 且仅经过编号在 $\left[1, k\right)$ 区间中的点的最短路。

由最小环的定义可知其至少有三个顶点，设其中编号最大的顶点为 $w$ ，环上与 $w$ 相邻两侧的两个点为 $u,v$ ，则在最外层循环枚举到 $k=w$ 时，该环的长度即为 $dis_{u,v}+val\left(v,w\right)+val\left(w,u\right)$ 。

故在循环时对于每个 $k$ 枚举满足 $i<k,j<k$ 的 $(i,j)$ ，更新答案即可。

时间复杂度： $O(n^3)$ 

下面给出 C++ 的参考实现：

```cpp
int val[maxn + 1][maxn + 1];  // 原图的邻接矩阵
inline int floyd(const int &n) {
  static int dis[maxn + 1][maxn + 1];  // 最短路矩阵
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= n; ++j) dis[i][j] = val[i][j];  // 初始化最短路矩阵
  int ans = inf;
  for (int k = 1; k <= n; ++k) {
    for (int i = 1; i < k; ++i)
      for (int j = 1; j < i; ++j)
        ans = std::min(ans, dis[i][j] + val[i][k] + val[k][j]);  // 更新答案
    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= n; ++j)
        dis[i][j] = std::min(
            dis[i][j], dis[i][k] + dis[k][j]);  // 正常的 floyd 更新最短路矩阵
  }
  return ans;
}
```

## 例题

GDOI2018 Day2 巡逻

给出一张 $n$ 个点的无负权边无向图，要求执行 $q$ 个操作，三种操作

1.  删除一个图中的点以及与它有关的边
2.  恢复一个被删除点以及与它有关的边
3.  询问点 $x$ 所在的最小环大小

对于 $50\%$ 的数据，有 $n,q \le 100$ 

对于每一个点 $x$ 所在的简单环，都存在两条与 $x$ 相邻的边，删去其中的任意一条，简单环将变为简单路径。

那么枚举所有与 $x$ 相邻的边，每次删去其中一条，然后跑一次 Dijkstra。

或者直接对每次询问跑一遍 Floyd 求最小环， $O(qn^3)$ 

对于 $100\%$ 的数据，有 $n,q \le 400$ 。

还是利用 Floyd 求最小环的算法。

若没有删除，删去询问点将简单环裂开成为一条简单路。

然而第二步的求解改用 Floyd 来得出。

那么答案就是要求出不经过询问点 $x$ 的情况下任意两点之间的距离。

怎么在线？

强行离线，利用离线的方法来避免删除操作。

将询问按照时间顺序排列，对这些询问建立一个线段树。

每个点的出现时间覆盖所有除去询问该点的时刻外的所有询问，假设一个点被询问 $x$ 次，则它的出现时间可以视为 $x + 1$ 段区间，插入到线段树上。

完成之后遍历一遍整棵线段树，在经过一个点时存储一个 Floyd 数组的备份，然后加入被插入在这个区间上的所有点，在离开时利用备份数组退回去即可。

这个做法的时间复杂度为 $O(qn^2\log q)$ 。

还有一个时间复杂度更优秀的在线做法。

对于一个对点 $x$ 的询问，我们以 $x$ 为起点跑一次最短路，然后把最短路树建出来，顺便处理出每个点是在 $x$ 的哪棵子树内。

那么一定能找出一条非树边，满足这条非树边的两个端点在根的不同子树中，使得这条非树边 $+$ 两个端点到根的路径就是最小环。

证明：

显然最小环包含至少两个端点在根的不同子树中一条非树边。

假设这条边为 $(u,v)$ ，那么最短路树上 $x$ 到 $u$ 的路径是所有 $x$ 到 $u$ 的路径中最短的那条， $x$ 到 $v$ 的路径也是最短的那条，那么 $x\to u\to v\to x$ 这个环肯定不会比最小环要长。

那么就可以枚举所有非树边，更新答案。

每次询问的复杂度为跑一次单源最短路的复杂度，为 $O(n^2)​$ 。

总时间复杂度为 $O(qn^2)$ 。

# flow
网络流在 OI 中是显得尤为重要的。在《算法导论》中就用了 35 页来讲述网络流的知识，在这里，给大家介绍网络流中的一些基本知识。

## 网络

首先，请分清楚 **网络** （或者流网络，Flow Network）与 **网络流** （Flow）的概念。

网络是指一个有向图 $G=(V,E)$ 。

每条边 $(u,v)\in E$ 都有一个权值 $c(u,v)$ ，称之为容量（Capacity），当 $(u,v)\notin E$ 时有 $c(u,v)=0$ 。

其中有两个特殊的点：源点（Source） $s\in V$ 和汇点（Sink） $t\in V,(s\neq t)$ 。

## 流

设 $f(u,v)$ 定义在二元组 $(u\in V,v\in V)$ 上的实数函数且满足

1.  容量限制：对于每条边，流经该边的流量不得超过该边的容量，即， $f(u,v)\leq c(u,v)$ 
2.  斜对称性：每条边的流量与其相反边的流量之和为 0，即 $f(u,v)=-f(v,u)$ 
3.  流守恒性：从源点流出的流量等于汇点流入的流量，即 $\forall x\in V-\{s,t\},\sum_{(u,x)\in E}f(u,x)=\sum_{(x,v)\in E}f(x,v)$ 

那么 $f$ 称为网络 $G$ 的流函数。对于 $(u,v)\in E$ ， $f(u,v)$ 称为边的 **流量** ， $c(u,v)-f(u,v)$ 称为边的 **剩余容量** 。整个网络的流量为 $\sum_{(s,v)\in E}f(s,v)$ ，即 **从源点发出的所有流量之和** 。

一般而言也可以把网络流理解为整个图的流量。而这个流量必满足上述三个性质。

_注_：流函数的完整定义为

$$
f(u,v)=\left\{\begin{split}
&f(u,v)&,(u,v)\in E\\
&-f(v,u)&,(v,u)\in E\\
&0&,(u,v)\notin E,(v,u)\notin E
\end{split}\right.
$$

## 网络流的常见问题

网络流问题中常见的有以下三种：最大流，最小割，费用流。

### 最大流

我们有一张图，要求从源点流向汇点的最大流量（可以有很多条路到达汇点），就是我们的最大流问题。

### 最小费用最大流

最小费用最大流问题是这样的：每条边都有一个费用，代表单位流量流过这条边的开销。我们要在求出最大流的同时，要求花费的费用最小。

### 最小割

割其实就是删边的意思，当然最小割就是割掉 $X$ 条边来让 $S$ 跟 $T$ 不互通。我们要求 $X$ 条边加起来的流量综合最小。这就是最小割问题。

## 网络流 24 题

 <https://loj.ac/problems/tag/30> 

# dynamic-tree-divide
## 动态点分治

动态点分治用来解决 **带点权/边权修改** 的树上路径信息统计问题。

### 点分树

回顾点分治的计算过程。

对于一个结点 $x$ 来说，其子树中的简单路径包括两种：经过结点 $x$ 的，由一条或两条从 $x$ 出发的路径组成的；和不经过结点 $x$ 的，即已经包含在其所有儿子结点子树中的路径。

对于一个子树中简单路径的计算，我们选择一个分治中心 $rt$ ，计算经过该节点的子树中路径的信息，然后对于其每个儿子结点，将删去 $rt$ 后该点所在连通块作为一个子树，递归计算。选择的分治中心点可以构成一个树形结构，称为 **点分树** 。我们发现，计算点分树中同一层的结点所代表的连通块（即以该结点为分治中心的连通块）的大小总和是 $O(n)$ 的。这意味着，点分治的时间复杂度是与点分树的深度相关的，若点分树的深度为 $h$ ，则点分治的复杂度为 $O(nh)$ 。

可以证明，当我们每次选择连通块的重心作为分治中心的时候，点分树的深度最小，为 $O(\log n)$ 的。这样，我们就可以在 $O(n\log n)$ 的时间复杂度内统计树上 $O(n^2)$ 条路径的信息了。

由于树的形态在动态点分治的过程中不会改变，所以点分树的形态在动态点分治的过程中也不会改变。

下面给出求点分树的参考代码：

```cpp
void calcsiz(int x, int f) {
  siz[x] = 1;
  maxx[x] = 0;
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] != f && !vis[p[j]]) {
      calcsiz(p[j], x);
      siz[x] += siz[p[j]];
      maxx[x] = max(maxx[x], siz[p[j]]);
    }
  maxx[x] =
      max(maxx[x], sum - siz[x]);  // maxx[x] 表示以 x 为根时的最大子树大小
  if (maxx[x] < maxx[rt])
    rt = x;  //这里不能写 <= ，保证在第二次 calcsiz 时 rt 不改变
}
void pre(int x) {
  vis[x] = true;  //表示在之后的过程中不考虑 x 这个点
  for (int j = h[x]; j; j = nxt[j])
    if (!vis[p[j]]) {
      sum = siz[p[j]];
      rt = 0;
      maxx[rt] = inf;
      calcsiz(p[j], -1);
      calcsiz(rt, -1);  //计算两次，第二次求出以 rt 为根时的各子树大小
      fa[rt] = x;
      pre(rt);  //记录点分树上的父亲
    }
}
int main() {
  sum = n;
  rt = 0;
  maxx[rt] = inf;
  calcsiz(1, -1);
  calcsiz(rt, -1);
  pre(rt);
}
```

### 实现修改

在查询和修改的时候，我们在点分树上暴力跳父亲修改。由于点分树的深度最多是 $O(\log n)$ 的，所以这样做复杂度能得到保证。

在动态点分治的过程中，需要一个结点到其点分树上的祖先的距离等其他信息，由于一个点最多有 $O(\log n)$ 个祖先，我们可以在计算点分树时额外计算深度 $dep[x]$ 或使用 LCA，预处理出这些距离或实现实时查询。 **注意** ：一个结点到其点分树上的祖先的距离不一定递增，不能累加！

在动态点分治的过程中，一个结点在其点分树上的祖先结点的信息中可能会被重复计算，这是我们需要消去重复部分的影响。一般的方法是对于一个连通块用两种方式记录：一个是其到分治中心的距离信息，另一个是其到点分树上分治中心父亲的距离信息。这一部分内容将在例题中得到展现。

??? note " 例题[「ZJOI2007」捉迷藏](https://www.luogu.org/problemnew/show/P2056)"

给定一棵有 $n$ 个结点的树，初始时所有结点都是黑色的。你需要实现以下两种操作：

1.  反转一个结点的颜色（白变黑，黑变白）；
2.  询问树上两个最远的黑点的距离。

     $n\le 10^5,m\le 5\times 10^5$ 

求出点分树，对于每个结点 $x$ 维护两个 **可删堆** 。 $dist[x]$ 存储结点 $x$ 代表的连通块中的所有黑点到 $x$ 的距离信息， $ch[x]$ 表示结点 $x$ 在点分树上的所有儿子和它自己中的黑点到 $x$ 的距离信息，由于本题贪心的求答案方法，且两个来自于同一子树的路径不能成为一条完成的路径，我们只在这个堆中插入其自己的值和其每个子树中的最大值。我们发现， $ch[x]$ 中最大的两个值（如果没有两个就是所有值）的和就是分治时分支中心为 $x$ 时经过结点 $x$ 的最长黑端点路径。我们可以用可删堆 $ans$ 存储所有结点的答案，这个堆中的最大值就是我们所求的答案。

我们可以根据上面的定义维护 $dist[x],ch[x],ans$ 这些可删堆。当 $dist[x]$ 中的值发生变化时，我们也可以在 $O(\log n)$ 的时间复杂度内维护 $ch[x],ans$ 。

现在我们来看一下，当我们反转一个点的颜色时， $dist[x]$ 值会发生怎样的改变。当结点原来是黑色时，我们要进行的是删除操作；当结点原来是白色时，我们要进行的是插入操作。

假如我们要反转结点 $x$ 的颜色。对于其所有祖先 $u$ ，我们在 $dist[u]$ 中插入或删除 $dist(x,u)$ ，并同时维护 $ch[x],ans$ 的值。特别的，我们要在 $ch[x]$ 中插入或删除值 $0$ 。

参考代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 100010;
const int inf = 2e9;
int n, a, b, m, x, col[maxn];
// 0 off 1 on
char op;
int cur, h[maxn * 2], nxt[maxn * 2], p[maxn * 2];
void add_edge(int x, int y) {
  cur++;
  nxt[cur] = h[x];
  h[x] = cur;
  p[cur] = y;
}
bool vis[maxn];
int rt, sum, siz[maxn], maxx[maxn], fa[maxn], dep[maxn];
void calcsiz(int x, int f) {
  siz[x] = 1;
  maxx[x] = 0;
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] != f && !vis[p[j]]) {
      calcsiz(p[j], x);
      siz[x] += siz[p[j]];
      maxx[x] = max(maxx[x], siz[p[j]]);
    }
  maxx[x] = max(maxx[x], sum - siz[x]);
  if (maxx[x] < maxx[rt]) rt = x;
}
struct heap {
  priority_queue<int> A, B;  // heap=A-B
  void insert(int x) { A.push(x); }
  void erase(int x) { B.push(x); }
  int top() {
    while (!B.empty() && A.top() == B.top()) A.pop(), B.pop();
    return A.top();
  }
  void pop() {
    while (!B.empty() && A.top() == B.top()) A.pop(), B.pop();
    A.pop();
  }
  int top2() {
    int t = top(), ret;
    pop();
    ret = top();
    A.push(t);
    return ret;
  }
  int size() { return A.size() - B.size(); }
} dist[maxn], ch[maxn], ans;
void dfs(int x, int f, int d, heap& y) {
  y.insert(d);
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] != f && !vis[p[j]]) dfs(p[j], x, d + 1, y);
}
void pre(int x) {
  vis[x] = true;
  for (int j = h[x]; j; j = nxt[j])
    if (!vis[p[j]]) {
      rt = 0;
      maxx[rt] = inf;
      sum = siz[p[j]];
      calcsiz(p[j], -1);
      calcsiz(rt, -1);
      fa[rt] = x;
      dfs(p[j], -1, 1, dist[rt]);
      ch[x].insert(dist[rt].top());
      dep[rt] = dep[x] + 1;
      pre(rt);
    }
  ch[x].insert(0);
  if (ch[x].size() >= 2)
    ans.insert(ch[x].top() + ch[x].top2());
  else if (ch[x].size())
    ans.insert(ch[x].top());
}
struct LCA {
  int dep[maxn], lg[maxn], fa[maxn][20];
  void dfs(int x, int f) {
    for (int j = h[x]; j; j = nxt[j])
      if (p[j] != f) dep[p[j]] = dep[x] + 1, fa[p[j]][0] = x, dfs(p[j], x);
  }
  void init() {
    dfs(1, -1);
    for (int i = 2; i <= n; i++) lg[i] = lg[i / 2] + 1;
    for (int j = 1; j <= lg[n]; j++)
      for (int i = 1; i <= n; i++) fa[i][j] = fa[fa[i][j - 1]][j - 1];
  }
  int query(int x, int y) {
    if (dep[x] > dep[y]) swap(x, y);
    int k = dep[y] - dep[x];
    for (int i = 0; k; k = k / 2, i++)
      if (k & 1) y = fa[y][i];
    if (x == y) return x;
    k = dep[x];
    for (int i = lg[k]; i >= 0; i--)
      if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
    return fa[x][0];
  }
  int dist(int x, int y) { return dep[x] + dep[y] - 2 * dep[query(x, y)]; }
} lca;
int d[maxn][20];
int main() {
  scanf("%d", &n);
  for (int i = 1; i < n; i++)
    scanf("%d%d", &a, &b), add_edge(a, b), add_edge(b, a);
  lca.init();
  rt = 0;
  maxx[rt] = inf;
  sum = n;
  calcsiz(1, -1);
  calcsiz(rt, -1);
  pre(rt);
  // for(int i=1;i<=n;i++)printf("%d ",fa[i]);printf("\n");
  for (int i = 1; i <= n; i++)
    for (int j = i; j; j = fa[j]) d[i][dep[i] - dep[j]] = lca.dist(i, j);
  scanf("%d", &m);
  while (m--) {
    scanf(" %c", &op);
    if (op == 'G') {
      if (ans.size())
        printf("%d\n", ans.top());
      else
        printf("-1\n");
    } else {
      scanf("%d", &x);
      if (!col[x]) {
        if (ch[x].size() >= 2) ans.erase(ch[x].top() + ch[x].top2());
        ch[x].erase(0);
        if (ch[x].size() >= 2) ans.insert(ch[x].top() + ch[x].top2());
        for (int i = x; fa[i]; i = fa[i]) {
          if (ch[fa[i]].size() >= 2)
            ans.erase(ch[fa[i]].top() + ch[fa[i]].top2());
          ch[fa[i]].erase(dist[i].top());
          dist[i].erase(d[x][dep[x] - dep[fa[i]]]);
          if (dist[i].size()) ch[fa[i]].insert(dist[i].top());
          if (ch[fa[i]].size() >= 2)
            ans.insert(ch[fa[i]].top() + ch[fa[i]].top2());
        }
      } else {
        if (ch[x].size() >= 2) ans.erase(ch[x].top() + ch[x].top2());
        ch[x].insert(0);
        if (ch[x].size() >= 2) ans.insert(ch[x].top() + ch[x].top2());
        for (int i = x; fa[i]; i = fa[i]) {
          if (ch[fa[i]].size() >= 2)
            ans.erase(ch[fa[i]].top() + ch[fa[i]].top2());
          if (dist[i].size()) ch[fa[i]].erase(dist[i].top());
          dist[i].insert(d[x][dep[x] - dep[fa[i]]]);
          ch[fa[i]].insert(dist[i].top());
          if (ch[fa[i]].size() >= 2)
            ans.insert(ch[fa[i]].top() + ch[fa[i]].top2());
        }
      }
      col[x] ^= 1;
    }
  }
  return 0;
}
```

??? note " 例题[bzoj 3730 震波](https://www.lydsy.com/JudgeOnline/problem.php?id=3730)"

给定一棵有 $n$ 个结点的树，树上每个结点都有一个权值 $v[x]$ 。实现以下两种操作：

1.  询问与结点 $x$ 距离不超过 $y$ 的结点权值和；
2.  修改结点 $x$ 的点权为 $y$ ，即 $v[x]=y$ 。

我们用动态开点权值线段树记录距离信息。

类似于上题的思路，对于每个结点，我们维护线段树 $dist[x]$ ，表示分治块 $x$ 中的所有结点到结点 $x$ 的距离信息，下标为距离，权值加上点权。线段树 $ch[x]$ 表示分治块 $x$ 中所有结点到结点 $x$ 在分治树上的父亲结点的距离信息。

在本题中，所有查询和修改都需要在点分树上对所有祖先进行修改。

以查询操作为例，如果我们要查询距离结点 $x$ 不超过 $y$ 的结点的权值和，我们要先将答案加上线段树 $dist[x]$ 中下标从 $0$ 到 $y$ 的权值和，然后我们遍历 $x$ 的所有祖先 $u$ ，设其低一级祖先为 $v$ ，令 $d=dist(x,u)$ ，如果我们不进入包含 $x$ 的子树，即以 $v$ 为根的子树，那么我们要将答案加上线段树 $dist[u]$ 中下标从 $0$ 到 $y-d$ 的权值和。由于我们重复计算了以 $v$ 为根的部分，我们要将答案减去线段树 $ch[v]$ 中下标从 $0$ 到 $y-d$ 的权值和。

在进行修改操作时，我们要同时维护 $dist[x]$ 和 $ch[x]$ 。

参考代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 100010;
const int inf = 2e9;
const int ddd = 6000010;
struct Segtree {
  int cnt, rt[maxn], sum[ddd], lc[ddd], rc[ddd];
  void update(int& o, int l, int r, int x, int v) {
    if (!o) o = ++cnt;
    if (l == r) {
      sum[o] += v;
      return;
    }
    int mid = (l + r) >> 1;
    if (x <= mid)
      update(lc[o], l, mid, x, v);
    else
      update(rc[o], mid + 1, r, x, v);
    sum[o] = sum[lc[o]] + sum[rc[o]];
  }
  int query(int o, int l, int r, int ql, int qr) {
    if (!o || r < ql || l > qr) return 0;
    if (ql <= l && r <= qr) return sum[o];
    int mid = (l + r) >> 1;
    return query(lc[o], l, mid, ql, qr) + query(rc[o], mid + 1, r, ql, qr);
  }
} dist, ch;
int n, m, val[maxn], u, v, op, x, y, lstans;
int cur, h[maxn * 2], nxt[maxn * 2], p[maxn * 2];
void add_edge(int x, int y) {
  cur++;
  nxt[cur] = h[x];
  h[x] = cur;
  p[cur] = y;
}
struct LCA {
  int dep[maxn], lg[maxn], fa[maxn][20];
  void dfs(int x, int f) {
    for (int j = h[x]; j; j = nxt[j])
      if (p[j] != f) dep[p[j]] = dep[x] + 1, fa[p[j]][0] = x, dfs(p[j], x);
  }
  void init() {
    dep[1] = 1;
    dfs(1, -1);
    for (int i = 2; i <= n; i++) lg[i] = lg[i / 2] + 1;
    for (int j = 1; j <= lg[n]; j++)
      for (int i = 1; i <= n; i++) fa[i][j] = fa[fa[i][j - 1]][j - 1];
  }
  int query(int x, int y) {
    if (dep[x] > dep[y]) swap(x, y);
    int k = dep[y] - dep[x];
    for (int i = 0; k; k = k / 2, i++)
      if (k & 1) y = fa[y][i];
    if (x == y) return x;
    k = dep[x];
    for (int i = lg[k]; i >= 0; i--)
      if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
    return fa[x][0];
  }
  int dist(int x, int y) { return dep[x] + dep[y] - 2 * dep[query(x, y)]; }
} lca;
int rt, sum, siz[maxn], maxx[maxn], fa[maxn];
int d[maxn][20], dep[maxn];
bool vis[maxn];
void calcsiz(int x, int fa) {
  siz[x] = 1;
  maxx[x] = 0;
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] != fa && !vis[p[j]]) {
      calcsiz(p[j], x);
      siz[x] += siz[p[j]];
      maxx[x] = max(maxx[x], siz[p[j]]);
    }
  maxx[x] = max(maxx[x], sum - siz[x]);
  if (maxx[x] < maxx[rt]) rt = x;
}
void dfs1(int x, int fa, int y, int d) {
  ch.update(ch.rt[y], 0, n, d, val[x]);
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] != fa && !vis[p[j]]) dfs1(p[j], x, y, d + 1);
}
void dfs2(int x, int fa, int y, int d) {
  dist.update(dist.rt[y], 0, n, d, val[x]);
  for (int j = h[x]; j; j = nxt[j])
    if (p[j] != fa && !vis[p[j]]) dfs2(p[j], x, y, d + 1);
}
void pre(int x) {
  vis[x] = true;
  dfs2(x, -1, x, 0);
  for (int j = h[x]; j; j = nxt[j])
    if (!vis[p[j]]) {
      rt = 0;
      maxx[rt] = inf;
      sum = siz[p[j]];
      calcsiz(p[j], -1);
      calcsiz(rt, -1);
      dfs1(p[j], -1, rt, 1);
      fa[rt] = x;
      dep[rt] = dep[x] + 1;
      pre(rt);
    }
}
int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; i++) scanf("%d", val + i);
  for (int i = 1; i < n; i++)
    scanf("%d%d", &u, &v), add_edge(u, v), add_edge(v, u);
  lca.init();
  rt = 0;
  maxx[rt] = inf;
  sum = n;
  calcsiz(1, -1);
  calcsiz(rt, -1);
  pre(rt);
  // for(int i=1;i<=n;i++)printf("%d ",fa[i]);printf("\n");
  for (int i = 1; i <= n; i++)
    for (int j = i; j; j = fa[j]) d[i][dep[i] - dep[j]] = lca.dist(i, j);
  while (m--) {
    scanf("%d%d%d", &op, &x, &y);
    x ^= lstans;
    y ^= lstans;
    if (op == 0) {
      lstans = dist.query(dist.rt[x], 0, n, 0, y);
      int nww = 0;
      for (int i = x; fa[i]; i = fa[i]) {
        nww = d[x][dep[x] - dep[fa[i]]];  // lca.dist(x,fa[i]);
        lstans += dist.query(dist.rt[fa[i]], 0, n, 0, y - nww);
        lstans -= ch.query(ch.rt[i], 0, n, 0, y - nww);
      }
      printf("%d\n", lstans);
    }
    if (op == 1) {
      int nww = 0;
      dist.update(dist.rt[x], 0, n, 0, y - val[x]);
      for (int i = x; fa[i]; i = fa[i]) {
        nww = d[x][dep[x] - dep[fa[i]]];  // lca.dist(x,fa[i]);
        dist.update(dist.rt[fa[i]], 0, n, nww, y - val[x]);
        ch.update(ch.rt[i], 0, n, nww, y - val[x]);
      }
      val[x] = y;
    }
  }
  return 0;
}
```

# diff-constraints
author: Ir1d, Anguei, hsfzLZH1

 **差分约束系统** 是一种特殊的 $n$ 元一次不等式组，它包含 $n$ 个变量 $x_1,x_2,...,x_n$ 以及 $m$ 个约束条件，每个约束条件是由两个其中的变量做差构成的，形如 $x_i-x_j\leq c_k$ ，其中 $c_k$ 是常数（可以是非负数，也可以是负数）。我们要解决的问题是：求一组解 $x_1=a_1,x_2=a_2,...,x_n=a_n$ ，使得所有的约束条件得到满足，否则判断出无解。

差分约束系统中的每个约束条件 $x_i-x_j\leq c_k$ 都可以变形成 $x_i\leq x_j+c_k$ ，这与单源最短路中的三角形不等式 $dist[y]\leq dist[x]+z$ 非常相似。因此，我们可以把每个变量 $x_i$ 看做图中的一个结点，对于每个约束条件 $x_i-x_j\leq c_k$ ，从结点 $j$ 向结点 $i$ 连一条长度为 $c_k$ 的有向边。

注意到，如果 $\{a_1,a_2,...,a_n\}$ 是该差分约束系统的一组解，那么对于任意的常数 $d$ ， $\{a_1+d,a_2+d,...,a_n+d\}$ 显然也是该差分约束系统的一组解，因为这样做差后 $d$ 刚好被消掉。

设 $dist[0]=0$ 并向每一个点连一条边，跑单源最短路，若图中存在负环，则给定的差分约束系统无解，否则， $x_i=dist[i]$ 为该差分约束系统的一组解。

一般使用 Bellman-Ford 或队列优化的 Bellman-Ford（俗称 SPFA，在某些随机图跑得很快）判断图中是否存在负环，最坏时间复杂度为 $O(nm)$ 。

## 常用变形技巧

### 例题 [luogu P1993 小 K 的农场](https://www.luogu.org/problemnew/show/P1993) 

题目大意：求解差分约束系统，有 $m$ 条约束条件，每条都为形如 $x_a-x_b\geq c_k$ ， $x_a-x_b\leq c_k$ 或 $x_a=x_b$ 的形式，判断该差分约束系统有没有解。

|          题意          |                       转化                      |                连边               |
| :------------------: | :-------------------------------------------: | :-----------------------------: |
|  $x_a - x_b \geq c$  |              $x_b - x_a \leq -c$              |         `add(a, b, -c);`        |
|  $x_a - x_b \leq c$  |               $x_a - x_b \leq c$              |         `add(b, a, c);`         |
|      $x_a = x_b$     |  $x_a - x_b \leq 0, \space x_b - x_a \leq 0$  |  `add(b, a, 0), add(a, b, 0);`  |

跑判断负环，如果不存在负环，输出 `Yes` ，否则输出 `No` 。

给出一种用 DFS-SPFA 实现的判负环（时间复杂度极度不稳定）：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 400010;
int n, m, op, u, v, we, cur, h[maxn], nxt[maxn], p[maxn], w[maxn], dist[maxn];
bool tf[maxn], ans;
inline void add_edge(int x, int y, int z) {
  cur++;
  nxt[cur] = h[x];
  h[x] = cur;
  p[cur] = y;
  w[cur] = z;
}
void dfs(int x) {
  tf[x] = true;
  for (int j = h[x]; j != -1; j = nxt[j])
    if (dist[p[j]] > dist[x] + w[j]) {
      if (tf[p[j]] || ans) {
        ans = 1;
        break;
      }
      dist[p[j]] = dist[x] + w[j];
      dfs(p[j]);
    }
  tf[x] = false;
}
int main() {
  cur = 0;
  ans = false;
  memset(h, -1, sizeof h);
  memset(dist, 127, sizeof dist);
  scanf("%d%d", &n, &m);
  while (m--) {
    scanf("%d%d%d", &op, &u, &v);
    if (op == 1)
      scanf("%d", &we), add_edge(u, v, -we);
    else if (op == 2)
      scanf("%d", &we), add_edge(v, u, we);
    else if (op == 3)
      add_edge(u, v, 0), add_edge(v, u, 0);
  }
  for (int i = 1; i <= n; i++) {
    dfs(i);
    if (ans) break;
  }
  if (ans)
    printf("No\n");
  else
    printf("Yes\n");
  return 0;
}
```

### 例题 [P4926\[1007\]倍杀测量者](https://www.luogu.org/problemnew/show/P4926) 

不考虑二分等其他的东西，这里只论述差分系统 $\frac{x_i}{x_j}\leq c_k$ 的求解方法。

对每个 $x_i,x_j$ 和 $c_k$ 取一个 $\log$ 就可以把乘法变成加法运算，即 $\log x_i-\log x_j \leq \log c_k$ ，这样就可以用差分约束解决了。

## Bellman-Ford 判负环代码实现

下面是用 Bellman-Ford 算法判断图中是否存在负环的代码实现，请在调用前先保证图是连通的。

```cpp
bool Bellman_Ford() {
  for (int i = 0; i < n; i++) {
    bool jud = false;
    for (int j = 1; j <= n; j++)
      for (int k = h[j]; ~k; k = nxt[k])
        if (dist[j] > dist[p[k]] + w[k])
          dist[j] = dist[p[k]] + w[k], jud = true;
    if (!jud) break;
  }
  for (int i = 1; i <= n; i++)
    for (int j = h[i]; ~j; j = nxt[j])
      if (dist[i] > dist[p[j]] + w[j]) return false;
  return true;
}
```

## 习题

 [Usaco2006 Dec Wormholes 虫洞](https://loj.ac/problem/10085) 

 [「SCOI2011」糖果](https://loj.ac/problem/2436) 

 [POJ 1364 King](http://poj.org/problem?id=1364) 

 [POJ 2983 Is the Information Reliable?](http://poj.org/problem?id=2983) 

# hld
author: Ir1d, TrisolarisHD, ouuan, hsfzLZH1, Xeonacid, greyqz, Chrogeek, ftxj, sshwy, LuoshuiTianyi, hyp1231

## 树链剖分的思想及能解决的问题

树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。

具体来说，将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。

 **树链剖分** （树剖/链剖）有多种形式，如 **重链剖分** ， **长链剖分** 和用于 Link/cut Tree 的剖分（有时被称作“实链剖分”），大多数情况下（没有特别说明时），“树链剖分”都指“重链剖分”。

重链剖分可以将树上的任意一条路径划分成不超过 $O(\log n)$ 条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 LCA 为链的一个端点）。

重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。

如：

1.  修改 **树上两点之间的路径上** 所有点的值。
2.  查询 **树上两点之间的路径上** 节点权值的 **和/极值/其它（在序列上可以用数据结构维护，便于合并的信息）** 。

除了配合数据结构来维护树上路径信息，树剖还可以用来 $O(\log n)$ （且常数较小）地求 LCA。在某些题目中，还可以利用其性质来灵活地运用树剖。

## 重链剖分

我们给出一些定义：

定义 **重子节点** 表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。

定义 **轻子节点** 表示剩余的所有子结点。

从这个结点到重子节点的边为 **重边** 。

到其他轻子节点的边为 **轻边** 。

若干条首尾衔接的重边构成 **重链** 。

把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。

如图：

/home/llj/Desktop/OI-wiki-master/docs/graph/![HLD](./images/hld.png)

## 实现

树剖的实现分两个 DFS 的过程。伪代码如下：

第一个 DFS 记录每个结点的父节点（father）、深度（deep）、子树大小（size）、重子节点（hson）。

$$
\begin{array}{l}
\text{TREE-BUILD }(u,dep) \\
\begin{array}{ll}
1 & u.hson\gets 0 \\
2 & u.hson.size\gets 0 \\
3 & u.deep\gets dep \\
4 & u.size\gets 1 \\
5 & \textbf{for }\text{each }u\text{'s son }v \\
6 & \qquad u.size\gets u.size + \text{TREE-BUILD }(v,dep+1) \\
7 & \qquad v.father\gets u \\
8 & \qquad \textbf{if }v.size> u.hson.size \\
9 & \qquad \qquad u.hson\gets v \\
10 & \textbf{return } u.size
\end{array}
\end{array}
$$

第二个 DFS 记录所在链的链顶（top，应初始化为结点本身）、重边优先遍历时的 DFS 序（dfn）、DFS 序对应的节点编号（rank）。

$$
\begin{array}{l}
\text{TREE-DECOMPOSITION }(u,top) \\
\begin{array}{ll}
1 & u.top\gets top \\
2 & tot\gets tot+1\\
3 & u.dfn\gets tot \\
4 & rank(tot)\gets u \\
5 & \textbf{if }u.hson\text{ is not }0 \\
6 & \qquad \text{TREE-DECOMPOSITION }(u.hson,top) \\
7 & \qquad \textbf{for }\text{each }u\text{'s son }v \\
8 & \qquad \qquad \textbf{if }v\text{ is not }u.hson \\
9 & \qquad \qquad \qquad \text{TREE-DECOMPOSITION }(v,v) 
\end{array}
\end{array}
$$

以下为代码实现。

我们先给出一些定义：

-    $fa(x)$ 表示节点 $x$ 在树上的父亲。
-    $dep(x)$ 表示节点 $x$ 在树上的深度。
-    $siz(x)$ 表示节点 $x$ 的子树的节点个数。
-    $son(x)$ 表示节点 $x$ 的 **重儿子** 。
-    $top(x)$ 表示节点 $x$ 所在 **重链** 的顶部节点（深度最小）。
-    $dfn(x)$ 表示节点 $x$ 的 **DFS 序** ，也是其在线段树中的编号。
-    $rnk(x)$ 表示 DFS 序所对应的节点编号，有 $rnk(dfn(x))=x$ 。

我们进行两遍 DFS 预处理出这些值，其中第一次 DFS 求出 $fa(x)$ , $dep(x)$ , $siz(x)$ , $son(x)$ ，第二次 DFS 求出 $top(x)$ , $dfn(x)$ , $rnk(x)$ 。

```cpp
void dfs1(int o) {
  son[o] = -1;
  siz[o] = 1;
  for (int j = h[o]; j; j = nxt[j])
    if (/home/llj/Desktop/OI-wiki-master/docs/graph/!dep[p[j]]) {
      dep[p[j]] = dep[o] + 1;
      fa[p[j]] = o;
      dfs1(p[j]);
      siz[o] += siz[p[j]];
      if (son[o] == -1 || siz[p[j]] > siz[son[o]]) son[o] = p[j];
    }
}
void dfs2(int o, int t) {
  top[o] = t;
  cnt++;
  dfn[o] = cnt;
  rnk[cnt] = o;
  if (son[o] == -1) return;
  dfs2(son[o], t);  // 优先对重儿子进行 DFS，可以保证同一条重链上的点 DFS 序连续
  for (int j = h[o]; j; j = nxt[j])
    if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= son[o] && p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa[o]) dfs2(p[j], p[j]);
}
```

## 重链剖分的性质

 **树上每个节点都属于且仅属于一条重链** 。

重链开头的结点不一定是重子节点（因为重边是对于每一个结点都有定义的）。

所有的重链将整棵树 **完全剖分** 。

在剖分时 **优先遍历重儿子** ，最后重链的 DFS 序就会是连续的。

在剖分时 **重边优先遍历** ，最后树的 DFN 序上，重链内的 DFN 序是连续的。按 DFN 排序后的序列即为剖分后的链。

一颗子树内的 DFN 序是连续的。

可以发现，当我们向下经过一条 **轻边** 时，所在子树的大小至少会除以二。

因此，对于树上的任意一条路径，把它拆分成从 $lca$ 分别向两边往下走，分别最多走 $O(\log n)$ 次，因此，树上的每条路径都可以被拆分成不超过 $O(\log n)$ 条重链。

## 常见应用

### 路径上维护

用树链剖分求树上两点路径权值和，伪代码如下：

$$
\begin{array}{l}
\text{TREE-PATH-SUM }(u,v) \\
\begin{array}{ll}
1 & tot\gets 0 \\
2 & \textbf{while }u.top\text{ is not }v.top \\
3 & \qquad \textbf{if }u.top.deep< v.top.deep \\
4 & \qquad \qquad \text{SWAP}(u, v) \\
5 & \qquad tot\gets tot + \text{sum of values between }u\text{ and }u.top \\
6 & \qquad u\gets u.top.father \\
7 & tot\gets tot + \text{sum of values between }u\text{ and }v \\
8 & \textbf{return } tot 
\end{array}
\end{array}
$$

链上的 DFS 序是连续的，可以使用线段树、树状数组维护。

每次选择深度较大的链往上跳，直到两点在同一条链上。

同样的跳链结构适用于维护、统计路径上的其他信息。

### 子树维护

有时会要求，维护子树上的信息，譬如将以 $x$ 为根的子树的所有结点的权值增加 $v$ 。

在 DFS 搜索的时候，子树中的结点的 DFS 序是连续的。

每一个结点记录 bottom 表示所在子树连续区间末端的结点。

这样就把子树信息转化为连续的一段区间信息。

### 求最近公共祖先

不断向上跳重链，当跳到同一条重链上时，深度较小的结点即为 LCA。

向上跳重链时需要先跳所在重链顶端深度较大的那个。

参考代码：

```cpp
int lca(int u, int v) {
  while (top[u] /home/llj/Desktop/OI-wiki-master/docs/graph/!= top[v]) {
    if (dep[top[u]] > dep[top[v]])
      u = fa[top[u]];
    else
      v = fa[top[v]];
  }
  return dep[u] > dep[v] ? v : u;
}
```

??? note "怎么有理有据地卡树剖"

    一般情况下树剖的 $O(\log n)$ 常数不满很难卡，如果要卡只能建立二叉树深度低。

    于是我们可以考虑折中方案。

    我们建立一颗 $\sqrt{n}$ 个节点的二叉树。对于每个节点到其儿子的边，我们将其替换成一条长度为 $\sqrt{n}$ 的链。

    这样子我们可以将随机询问轻重链切换次数卡到平均 $\frac{\log n}{2}$ 次，同时有 $O(\sqrt{n} \log n)$ 的深度。

    加上若干随机叶子看上去可以卡树剖。但是树剖常数小有可能卡不掉。

## 例题

###  [「ZJOI2008」树的统计](https://loj.ac/problem/10138) 

#### 题目大意

对一棵有 $n$ 个节点，节点带权值的静态树，进行三种操作共 $q$ 次：

1.  修改单个节点的权值；
2.  查询 $u$ 到 $v$ 的路径上的最大权值；
3.  查询 $u$ 到 $v$ 的路径上的权值之和。

保证 $1\le n\le 30000$ , $0\le q\le 200000$ 。

#### 解法

根据题面以及以上的性质，你的线段树需要维护三种操作：

1.  单点修改；
2.  区间查询最大值；
3.  区间查询和。

单点修改很容易实现。

由于子树的 DFS 序连续（无论是否树剖都是如此），修改一个节点的子树只用修改这一段连续的 DFS 序区间。

问题是如何修改/查询两个节点之间的路径。

考虑我们是如何用 **倍增法求解 LCA** 的。首先我们 **将两个节点提到同一高度，然后将两个节点一起向上跳** 。对于树链剖分也可以使用这样的思想。

在向上跳的过程中，如果当前节点在重链上，向上跳到重链顶端，如果当前节点不在重链上，向上跳一个节点。如此直到两节点相同。沿途更新/查询区间信息。

对于每个询问，最多经过 $O(\log n)$ 条重链，每条重链上线段树的复杂度为 $O(\log n)$ ，因此总时间复杂度为 $O(n\log n+q\log^2 n)$ 。实际上重链个数很难达到 $O(\log n)$ （可以用完全二叉树卡满），所以树剖在一般情况下常数较小。

给出一种代码实现：

```cpp
// st 是线段树结构体
int querymax(int x, int y) {
  int ret = -inf, fx = top[x], fy = top[y];
  while (fx /home/llj/Desktop/OI-wiki-master/docs/graph/!= fy) {
    if (dep[fx] >= dep[fy])
      ret = max(ret, st.query1(1, 1, n, dfn[fx], dfn[x])), x = fa[fx];
    else
      ret = max(ret, st.query1(1, 1, n, dfn[fy], dfn[y])), y = fa[fy];
    fx = top[x];
    fy = top[y];
  }
  if (dfn[x] < dfn[y])
    ret = max(ret, st.query1(1, 1, n, dfn[x], dfn[y]));
  else
    ret = max(ret, st.query1(1, 1, n, dfn[y], dfn[x]));
  return ret;
}
```

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #define lc o << 1
    #define rc o << 1 | 1
    const int maxn = 60010;
    const int inf = 2e9;
    int n, a, b, w[maxn], q, u, v;
    int cur, h[maxn], nxt[maxn], p[maxn];
    int siz[maxn], top[maxn], son[maxn], dep[maxn], fa[maxn], dfn[maxn], rnk[maxn],
        cnt;
    char op[10];
    inline void add_edge(int x, int y) {
      cur++;
      nxt[cur] = h[x];
      h[x] = cur;
      p[cur] = y;
    }
    struct SegTree {
      int sum[maxn * 4], maxx[maxn * 4];
      void build(int o, int l, int r) {
        if (l == r) {
          sum[o] = maxx[o] = w[rnk[l]];
          return;
        }
        int mid = (l + r) >> 1;
        build(lc, l, mid);
        build(rc, mid + 1, r);
        sum[o] = sum[lc] + sum[rc];
        maxx[o] = std::max(maxx[lc], maxx[rc]);
      }
      int query1(int o, int l, int r, int ql, int qr)  // max
      {
        if (l > qr || r < ql) return -inf;
        if (ql <= l && r <= qr) return maxx[o];
        int mid = (l + r) >> 1;
        return std::max(query1(lc, l, mid, ql, qr), query1(rc, mid + 1, r, ql, qr));
      }
      int query2(int o, int l, int r, int ql, int qr)  // sum
      {
        if (l > qr || r < ql) return 0;
        if (ql <= l && r <= qr) return sum[o];
        int mid = (l + r) >> 1;
        return query2(lc, l, mid, ql, qr) + query2(rc, mid + 1, r, ql, qr);
      }
      void update(int o, int l, int r, int x, int t) {
        if (l == r) {
          maxx[o] = sum[o] = t;
          return;
        }
        int mid = (l + r) >> 1;
        if (x <= mid)
          update(lc, l, mid, x, t);
        else
          update(rc, mid + 1, r, x, t);
        sum[o] = sum[lc] + sum[rc];
        maxx[o] = std::max(maxx[lc], maxx[rc]);
      }
    } st;
    void dfs1(int o) {
      son[o] = -1;
      siz[o] = 1;
      for (int j = h[o]; j; j = nxt[j])
        if (/home/llj/Desktop/OI-wiki-master/docs/graph/!dep[p[j]]) {
          dep[p[j]] = dep[o] + 1;
          fa[p[j]] = o;
          dfs1(p[j]);
          siz[o] += siz[p[j]];
          if (son[o] == -1 || siz[p[j]] > siz[son[o]]) son[o] = p[j];
        }
    }
    void dfs2(int o, int t) {
      top[o] = t;
      cnt++;
      dfn[o] = cnt;
      rnk[cnt] = o;
      if (son[o] == -1) return;
      dfs2(son[o], t);
      for (int j = h[o]; j; j = nxt[j])
        if (p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= son[o] && p[j] /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa[o]) dfs2(p[j], p[j]);
    }
    int querymax(int x, int y) {
      int ret = -inf, fx = top[x], fy = top[y];
      while (fx /home/llj/Desktop/OI-wiki-master/docs/graph/!= fy) {
        if (dep[fx] >= dep[fy])
          ret = std::max(ret, st.query1(1, 1, n, dfn[fx], dfn[x])), x = fa[fx];
        else
          ret = std::max(ret, st.query1(1, 1, n, dfn[fy], dfn[y])), y = fa[fy];
        fx = top[x];
        fy = top[y];
      }
      if (dfn[x] < dfn[y])
        ret = std::max(ret, st.query1(1, 1, n, dfn[x], dfn[y]));
      else
        ret = std::max(ret, st.query1(1, 1, n, dfn[y], dfn[x]));
      return ret;
    }
    int querysum(int x, int y) {
      int ret = 0, fx = top[x], fy = top[y];
      while (fx /home/llj/Desktop/OI-wiki-master/docs/graph/!= fy) {
        if (dep[fx] >= dep[fy])
          ret += st.query2(1, 1, n, dfn[fx], dfn[x]), x = fa[fx];
        else
          ret += st.query2(1, 1, n, dfn[fy], dfn[y]), y = fa[fy];
        fx = top[x];
        fy = top[y];
      }
      if (dfn[x] < dfn[y])
        ret += st.query2(1, 1, n, dfn[x], dfn[y]);
      else
        ret += st.query2(1, 1, n, dfn[y], dfn[x]);
      return ret;
    }
    int main() {
      scanf("%d", &n);
      for (int i = 1; i < n; i++)
        scanf("%d%d", &a, &b), add_edge(a, b), add_edge(b, a);
      for (int i = 1; i <= n; i++) scanf("%d", w + i);
      dep[1] = 1;
      dfs1(1);
      dfs2(1, 1);
      st.build(1, 1, n);
      scanf("%d", &q);
      while (q--) {
        scanf("%s%d%d", op, &u, &v);
        if (/home/llj/Desktop/OI-wiki-master/docs/graph/!strcmp(op, "CHANGE")) st.update(1, 1, n, dfn[u], v);
        if (/home/llj/Desktop/OI-wiki-master/docs/graph/!strcmp(op, "QMAX")) printf("%d\n", querymax(u, v));
        if (/home/llj/Desktop/OI-wiki-master/docs/graph/!strcmp(op, "QSUM")) printf("%d\n", querysum(u, v));
      }
      return 0;
    }
    ```

###  [Nauuo and Binary Tree](https://loj.ac/problem/6669) 

这是一道交互题，也是树剖的非传统应用。

#### 题目大意

有一棵以 $1$ 为根的二叉树，你可以询问任意两点之间的距离，求出每个点的父亲。

节点数不超过 $3000$ ，你最多可以进行 $30000$ 次询问。

#### 解法

首先可以通过 $n-1$ 次询问确定每个节点的深度。

然后考虑按深度从小到大确定每个节点的父亲，这样的话确定一个节点的父亲时其所有祖先一定都是已知的。

确定一个节点的父亲之前，先对树已知的部分进行重链剖分。

假设我们需要在子树 $u$ 中找节点 $k$ 所在的位置，我们可以询问 $k$ 与 $u$ 所在重链的尾端的距离，就可以进一步确定 $k$ 的位置，具体见图：

/home/llj/Desktop/OI-wiki-master/docs/graph/![](./images/hld2.png)

其中红色虚线是一条重链， $d$ 是询问的结果即 $dis(k, bot[u])$ ， $v$ 的深度为 $(dep[k]+dep[bot[u]]-d)/2$ 。

这样的话，如果 $v$ 只有一个儿子， $k$ 的父亲就是 $v$ ，否则可以递归地在 $w$ 的子树中找 $k$ 的父亲。

时间复杂度 $O(n^2)$ ，询问复杂度 $O(n\log n)$ 。

具体地，设 $T(n)$ 为最坏情况下在一棵大小为 $n$ 的树中找到一个新节点的位置所需的询问次数，可以得到：

$$
T(n)\le
\begin{cases}
0&n=1\\
T\left(\left\lfloor\frac{n-1}2\right\rfloor\right)+1&n\ge2
\end{cases}
$$

 $2999+\sum_{i=1}^{2999}T(i)\le 29940$ ，事实上这个上界是可以通过构造数据达到的，然而只要进行一些随机扰动（如对深度进行排序时使用不稳定的排序算法），询问次数很难超过 $21000$ 次。

??? note "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <iostream>
    
    using namespace std;
    
    const int N = 3010;
    
    int n, fa[N], ch[N][2], dep[N], siz[N], son[N], bot[N], id[N];
    
    int query(int u, int v) {
      printf("? %d %d\n", u, v);
      fflush(stdout);
      int d;
      scanf("%d", &d);
      return d;
    }
    
    void setFather(int u, int v) {
      fa[v] = u;
      if (ch[u][0])
        ch[u][1] = v;
      else
        ch[u][0] = v;
    }
    
    void dfs(int u) {
      if (ch[u][0]) dfs(ch[u][0]);
      if (ch[u][1]) dfs(ch[u][1]);
    
      siz[u] = siz[ch[u][0]] + siz[ch[u][1]] + 1;
    
      if (ch[u][1])
        son[u] = int(siz[ch[u][0]] < siz[ch[u][1]]);
      else
        son[u] = 0;
    
      if (ch[u][son[u]])
        bot[u] = bot[ch[u][son[u]]];
      else
        bot[u] = u;
    }
    
    void solve(int u, int k) {
      if (/home/llj/Desktop/OI-wiki-master/docs/graph/!ch[u][0]) {
        setFather(u, k);
        return;
      }
      int d = query(k, bot[u]);
      int v = bot[u];
      while (dep[v] > (dep[k] + dep[bot[u]] - d) / 2) v = fa[v];
      int w = ch[v][son[v] ^ 1];
      if (w)
        solve(w, k);
      else
        setFather(v, k);
    }
    
    int main() {
      int i;
    
      scanf("%d", &n);
    
      for (i = 2; i <= n; ++i) {
        id[i] = i;
        dep[i] = query(1, i);
      }
    
      sort(id + 2, id + n + 1, [](int x, int y) { return dep[x] < dep[y]; });
    
      for (i = 2; i <= n; ++i) {
        dfs(1);
        solve(1, id[i]);
      }
    
      printf("/home/llj/Desktop/OI-wiki-master/docs/graph/!");
      for (i = 2; i <= n; ++i) printf(" %d", fa[i]);
      printf("\n");
      fflush(stdout);
    
      return 0;
    }
    ```

## 长链剖分

长链剖分本质上就是另外一种链剖分方式。

定义 **重子节点** 表示其子节点中子树深度最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。

定义 **轻子节点** 表示剩余的子结点。

从这个结点到重子节点的边为 **重边** 。

到其他轻子节点的边为 **轻边** 。

若干条首尾衔接的重边构成 **重链** 。

把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。

如图（这种剖分方式既可以看成重链剖分也可以看成长链剖分）：

/home/llj/Desktop/OI-wiki-master/docs/graph/![HLD](./images/hld.png)

长链剖分实现方式和重链剖分类似，这里就不再展开。

### 常见应用

首先，我们发现长链剖分从一个节点到根的路径的轻边切换条数是 $\sqrt{n}$ 级别的。

??? note "如何构造数据将轻重边切换次数卡满"
    我们可以构造这么一颗二叉树 T：

    假设构造的二叉树参数为 $D$ 。

    若 $D \neq 0$, 则在左儿子构造一颗参数为 $D-1$ 的二叉树，在右儿子构造一个长度为 $2D-1$ 的链。

    若 $D = 0$,则我们可以直接构造一个单独叶节点，并且结束调用。

    这样子构造一定可以将单独叶节点到根的路径全部为轻边且需要 $D^2$ 级别的节点数。

    取 $D=\sqrt{n}$ 即可。

#### 长链剖分优化 DP

一般情况下可以使用长链剖分来优化的 DP 会有一维状态为深度维。

我们可以考虑使用长链剖分优化树上 DP。

具体的，我们每个节点的状态直接继承其重儿子的节点状态，同时将轻儿子的 DP 状态暴力合并。

/home/llj/Desktop/OI-wiki-master/docs/graph/!/home/llj/Desktop/OI-wiki-master/docs/graph/!/home/llj/Desktop/OI-wiki-master/docs/graph/! note "[CF 1009F](http://codeforces.com/contest/1009/problem/F)"
    我们设 $f_{i,j}$ 表示在子树 i 内，和 i 距离为 j 的点数。

    直接暴力转移时间复杂度为 $O(n^2)$

    我们考虑每次转移我们直接继承重儿子的 DP 数组和答案，并且考虑在此基础上进行更新。

    首先我们需要将重儿子的 DP 数组前面插入一个元素 1,这代表着当前节点。

    然后我们将所有轻儿子的 DP 数组暴力和当前节点的 DP 数组合并。

    注意到因为轻儿子的 DP 数组长度为轻儿子所在重链长度，而所有重链长度和为 $n$。

    也就是说，我们直接暴力合并轻儿子的总时间复杂度为 $O(n)$ 。

注意，一般情况下 DP 数组的内存分配为一条重链整体分配内存，链上不同的节点有不同的首位置指针。

DP 数组的长度我们可以根据子树最深节点算出。

例题参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005;
struct edge {
  int to, next;
} e[N * 2];
int head[N], tot, n;
int d[N], fa[N], mx[N];
int *f[N], g[N], mxp[N];
int dfn[N];
void add(int x, int y) {
  e[++tot] = (edge){y, head[x]};
  head[x] = tot;
}
void dfs1(int x) {
  d[x] = 1;
  for (int i = head[x]; i; i = e[i].next)
    if (e[i].to /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa[x]) {
      fa[e[i].to] = x;
      dfs1(e[i].to);
      d[x] = max(d[x], d[e[i].to] + 1);
      if (d[e[i].to] > d[mx[x]]) mx[x] = e[i].to;
    }
}
void dfs2(int x) {
  dfn[x] = ++*dfn;
  f[x] = g + dfn[x];
  if (mx[x]) dfs2(mx[x]);
  for (int i = head[x]; i; i = e[i].next)
    if (e[i].to /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa[x] && e[i].to /home/llj/Desktop/OI-wiki-master/docs/graph/!= mx[x]) dfs2(e[i].to);
}
void getans(int x) {
  if (mx[x]) {
    getans(mx[x]);
    mxp[x] = mxp[mx[x]] + 1;
  }
  f[x][0] = 1;
  if (f[x][mxp[x]] <= 1) mxp[x] = 0;
  for (int i = head[x]; i; i = e[i].next)
    if (e[i].to /home/llj/Desktop/OI-wiki-master/docs/graph/!= fa[x] && e[i].to /home/llj/Desktop/OI-wiki-master/docs/graph/!= mx[x]) {
      getans(e[i].to);
      int len = d[e[i].to];
      For(j, 0, len - 1) {
        f[x][j + 1] += f[e[i].to][j];
        if (f[x][j + 1] > f[x][mxp[x]]) mxp[x] = j + 1;
        if (f[x][j + 1] == f[x][mxp[x]] && j + 1 < mxp[x]) mxp[x] = j + 1;
      }
    }
}
int main() {
  scanf("%d", &n);
  for (int i = 1; i < n; i++) {
    int x, y;
    scanf("%d%d", &x, &y);
    add(x, y);
    add(y, x);
  }
  dfs1(1);
  dfs2(1);
  getans(1);
  for (int i = 1; i <= n; i++) printf("%d\n", mxp[i]);
}
```

当然长链剖分优化 DP 技巧非常多，包括但是不仅限于打标记等等。这里不再展开。

参考 [租酥雨的博客](https://www.cnblogs.com/zhoushuyu/p/9468669.html) 。

#### 长链剖分求 k 级祖先

即询问一个点向父亲跳 $k$ 次跳到的节点。

首先我们假设我们已经预处理了每一个节点的 $2^i$ 级祖先。

现在我们假设我们找到了询问节点的 $2^i$ 级祖先满足 $2^i < k < 2^{i+1}$ 。

我们考虑求出其所在重链的节点并且按照深度列入表格。假设重链长度为 $d$ 。

同时我们在预处理的时候找到每条重链的根节点的 $1$ 到 $d$ 级祖先，同样放入表格。

根据长链剖分的性质， $k-2^i < 2^i < d$ , 也就是说，我们可以 $O(1)$ 在这条长链的表格上求出的这个节点的 $k$ 级祖先。

预处理需要倍增出 $2^i$ 次级祖先，同时需要预处理每条重链对应的表格。

预处理复杂度 $O(n\log n)$ , 询问复杂度 $O(1)$ 。

## 练习

 [「luogu P3379」【模板】最近公共祖先（LCA）](https://www.luogu.org/problemnew/show/P3379) （树剖求 LCA 无需数据结构，可以用作练习）

 [「JLOI2014」松鼠的新家](https://loj.ac/problem/2236) （当然也可以用树上差分）

 [「HAOI2015」树上操作](https://loj.ac/problem/2125) 

 [「luogu P3384」【模板】树链剖分](https://www.luogu.org/problemnew/show/P3384) 

 [「NOI2015」软件包管理器](https://uoj.ac/problem/128) 

 [「SDOI2011」染色](https://www.luogu.org/problem/P2486) 

 [「SDOI2014」旅行](https://www.lydsy.com/JudgeOnline/problem.php?id=3531) 

 [「POI2014」Hotel 加强版](https://www.lydsy.com/JudgeOnline/problem.php?id=4543) （长链剖分优化 DP)

 [攻略](https://www.lydsy.com/JudgeOnline/problem.php?id=3252) （长链剖分优化贪心）

# chord
弦图是一种特殊的图，很多在一般图上的 NP 问题在弦图上都有优秀的线性时间复杂度算法。

## 一些定义与性质

 **子图** ：点集和边集均为原图点集和边集子集的图。

 **导出子图（诱导子图）** ：点集为原图点集子集，边集为所有满足 **两个端点均在选定点集中** 的图。

 **团** ：完全子图。

 **极大团** ：不是其他团子图的图。

 **最大团** ：点数最大的团。

 **团数** ：最大团的点数，记为 $\omega(G)$ 。

 **最小染色** ：用最少的颜色给点染色使得所有边连接的两点颜色不同。

 **色数** ：最小染色的颜色数，记为 $\chi(G)$ 。

 **最大独立集** ：最大的点集使得点集中任意两点都没有边直接相连。该集合的大小记为 $\alpha(G)$ 。

 **最小团覆盖** ：用最少的团覆盖所有的点。使用团的数量记为 $\kappa(G)$ 。

 **弦** ：连接环中不相邻两点的边。

 **弦图** ：任意长度大于 $3$ 的环都有一个弦的图称为弦图。

 **Lemma 1** ：团数 $\omega(G)\le \chi(G)$ 色数

证明：考虑单独对最大团的导出子图进行染色，至少需要 $\omega(G)$ 种颜色。

 **Lemma 2** ：最大独立集数 $\alpha(G)\le \kappa(G)$ 最小团覆盖数

证明：每个团中至多选择一个点。

 **Lemma 3** ：弦图的任意导出子图一定是弦图。

证明：如果弦图有导出子图不是弦图，说明在这个导出子图上存在大于 $3$ 的无弦环，则无论原图如何（怎么加边）都不会使得原图是弦图，矛盾。

 **Lemma 4** ：弦图的任意导出子图一定不可能是一个点数大于 $3$ 的环。

证明：一个点数大于 $3$ 的环不是弦图，用以上定理即可。

## 弦图的判定

### 问题描述

给定一个无向图，判断其是否为弦图。

### 点割集

对于图 $G$ 上的两点 $u,v$ ，定义这两点间的 **点割集** 为满足删除这一集合后， $u,v$ 两点之间不连通。如果关于 $u,v$ 两点间的一个点割集的任意子集都不是点割集，则称这个点割集为 **极小点割集** 。

 **Lemma 5** ：图关于 $u,v$ 的极小点割集将原图分成了若干个连通块，设包含 $u$ 的连通块为 $V_1$ ，包含 $v$ 的连通块为 $V_2$ ，则对于极小点割集上的任意一点 $a$ ， $N(a)$ 一定包含 $V_1$ 和 $V_2$ 中的点。

证明：若 $N(a)$ 只包含 $V_1$ 或 $V_2$ 中的至多一个连通块中的点，从点割集中删去 $a$ 点，仍不连通，则原点割集不是最小点割集。

 **Lemma 6** ：弦图上任意两点间的极小点割集的导出子图一定为一个团。

证明：极小点割集大小 $\le 1$ 时，导出子图一定为一个团。

否则，设极小点割集上有两点为 $x,y$ ，由 **Lemma 5** 得， $N(x)$ 中有 $V_1,V_2$ 中的点，设为 $x_1,x_2$ ，同样的，设 $y_1,y_2$ ，注意，可能有 $x_1=y_1,x_2=y_2$ 。

由于 $V_1,V_2$ 均为连通块，则在 $x_1,y_1$ 和 $x_2,y_2$ 两个点对之间存在最短路径。设 $x,y$ 在 $V_1,V_2$ 内部的最短路为 $x-x_1\sim y_1-y,x-x_2\sim y_2-y$ ，则图上存在一个环 $x-x_1\sim y_1-y-y_2\sim x_2-x$ ，该环的大小一定 $\ge 4$ ，根据弦图的定义，此时该环上一定存在一条弦。

若这条弦连接了 $V_1,V_2$ 两个连通块，则点集不是点割集。若这条弦连接了单个连通块内部的两个点或一个连通块内部的一个点和一个点割集上的点，都不满足最短路的性质。所以这条弦只能连接 $x,y$ 两点。

由此，可证弦图中每个极小点割集中的两点都有边直接相连，故性质得证。

### 单纯点

设 $N(x)$ 表示与点 $x$ 相邻的点集。若点集 $\{x\}+N(x)$ 的导出子图为一个团，则称点 $x$ 为单纯点。

 **Lemma 7** ：任何一个弦图都至少有一个单纯点，不是完全图的弦图至少有两个不相邻的单纯点。

证明：数学归纳法。单独考虑每一连通块。

归纳基底：当图与完全图同构时，图上任意一点都是单纯点。当图的点数 $\le 3$ 时，引理成立。

若图上的点数 $\ge 4$ 且图不为完全图，可知必然存在 $u,v$ 使得 $(u,v)\notin E$ 。设 $I$ 是图关于 $u,v$ 的极小点割集。设 $A,B$ 分别是删去 $I$ 后的导出子图上 $u,v$ 所在的连通块。由于问题的对称性，我们只考虑 $A$ 一侧的情况，设 $L=A+I$ 。若 $L$ 为完全图，则 $u$ 为单纯点；若不是，因为 $L$ 是原图的导出子图，一定也是弦图，所以有两个不相邻的单纯点，因为 $I$ 是一个团，其上两点都相邻，所以 $A$ 中一定有一个单纯点。该单纯点扩展到全图也为单纯点。

由于每次将整个图分成若干个连通块证明，大小一定减小，且都满足性质，故归纳成立。

### 完美消除序列

令 $n=|V|$ ，完美消除序列 $v_1,v_2,\ldots ,v_n$ 为 $1,2,\ldots ,n$ 的一个排列，满足 $v_i$ 在 $\{v_i,v_{i+1},\ldots ,v_n\}$ 的导出子图中为单纯点。

 **Lemma 8** ：一个无向图是弦图当且仅当其有一个完全消除序列。

充分性：点数为 $1$ 的弦图有完全消除序列。由 **Lemma 3** 和 **Lemma 7** ，点数为 $n$ 的弦图的完美消除序列可以由点数为 $n-1$ 的弦图的完美消除序列加上一个单纯点得到。

必要性：假设有无向图存在结点数 $>3$ 的环且拥有完美消除序列，设在完美消除序列中出现的第一个环上的点为 $v$ ，设 $v$ 在环上与 $v_1,v_2$ 相连，则有完美消除序列的性质即单纯点的定义可得 $v_1,v_2$ 直接有边相连，矛盾。

### 朴素算法

每次找到一个 **单纯点**  $v$ ，加入到完美消除序列中。

将点 $v$ 与其相邻的边从图上删除。

重复以上过程，若所有点都被删除，则原图是弦图且求得了一个完美消除序列；若图上不存在单纯点，则原图不是弦图。

时间复杂度 $O(n^4)$ 。

### MCS 算法

 **最大势算法** （Maximum Cardinality Search）是一种可以在 $O(n+m)$ 的时间复杂度内求出无向图的完美消除序列的方法。

逆序给结点编号，即按从 $n$ 到 $1$ 的顺序给点标号。

设 $label_x$ 表示第 $x$ 个点与多少个已经标号的点相邻，每次选择 $label$ 值最大的未标号结点进行标号。

用链表维护对于每个 $i$ ，满足 $label_x=i$ 的 $x$ 。

由于每条边对 $\sum_{i=1}^n label_i$ 的贡献最多是 $2$ ，时间复杂度 $O(n+m)$ 。

 **正确性证明** ：

设编号为 $x$ 的结点在最大势算法得出的序列上出现的位置为 $a_x$ 。我们要证明当原图为弦图时，序列的逆序为原图的完美消除序列。

当一个点 $u$ 被标记时，若 $label_u$ 为 $0$ 或 $1$ ，则 $u$ 必然为单纯点。

若 $label_u>1$ ，必然可以选出两点 $v,w$ 与 $u$ 直接相连，且 $v,w$ 在 $u$ 之前标记过，如果最大势算法成立，则 $v,u$ 必然直接相连。

考虑使用反证法。假设存在这样的 $v,w$ ，设 $v$ 在 $w$ 之前被标记，且 $v,w$ 之间 **不直接有边相连** 。

为了更方便地分析问题，我们将原图划分为几个点集。与 $u,v$ 均直接相连的点集 $S$ ；只与 $v$ 相连，不与 $u$ 相连的点集 $A$ ；只与 $w$ 相连，不与 $u$ 相连的点集 $B$ 。

 **Lemma 9** ：删去 $u,S$ 后， $A,v$ 不连通；删去 $v,S$ 后， $B,u$ 不连通。

证明：若删去后仍连通，考虑 $A,v$ 间的最短路径 $A\sim v$ ，存在一个大于三元的环 $w-u-A\sim v-w$ ，必然存在一条弦，若弦为 $A,w$ 不满足点集 $A$ 的定义，若弦为 $u,v$ 不满足题设，若弦在 $A\sim v$ 中不满足最短路，若弦是 $w$ 与 $A~v$ 中不为 $A,v$ 的一点，则该点应在 $S$ 中。

对称同理。

 **Lemma 10** ：删去 $w$ 后， $A,B$ 中没有任意两点连通，与 $u,v$ 均直接相连的所有点必然在集合 $S$ 中。

证明：若删去后仍连通，设选择的两点之间的最短路为 $A\sim B$ ，则存在一个大于三元的环 $w-u-A\sim B-v-w$ ，类似以上讨论可得。若有一点 $x$ 与 $u,v$ 均直接相连，则存在一个四元环 $w-u-x-v$ ，弦必然为 $w,x$ ，故 $x$ 必在 $S$ 中。

以上两个定理保证了将与 $v,w$ 中至少一个点直接相连的所有点划分为的点集是相互独立且覆盖了全部情况的。

 **Theorem 1** ：在对弦图使用最大势算法时，当一个点被标记时，它在已经标记结点中一定为一个单纯点。

证明：当我们标记了 $v$ 时，设 $A$ 中被标记的点数为 $x$ ， $S$ 中被标记的点数为 $y$ ，则 $label_u=y+1,label_w=y$ 。

若接下来标记的是 $S$ 中的点，则不会改变 $label_u$ 和 $label_w$ 的大小关系。若接下来标记的是 $A$ 中的点，则这些点对 $u,w$ 的 $label$ 无影响。

故此时 $u$ 必然在 $w$ 前标记，与题设矛盾。故所有 $v,w$ 之间必然直接有边相连，当 $u$ 被标记时一定是单纯点。

至此，最大势算法的正确性得证。

参考代码：

```cpp
while (cur) {
  p[cur] = h[nww];
  rnk[p[cur]] = cur;
  h[nww] = nxt[h[nww]];
  lst[h[nww]] = 0;
  lst[p[cur]] = nxt[p[cur]] = 0;
  tf[p[cur]] = true;
  for (vector<int>::iterator it = G[p[cur]].begin(); it != G[p[cur]].end();
       it++)
    if (!tf[*it]) {
      if (h[deg[*it]] == *it) h[deg[*it]] = nxt[*it];
      nxt[lst[*it]] = nxt[*it];
      lst[nxt[*it]] = lst[*it];
      lst[*it] = nxt[*it] = 0;
      deg[*it]++;
      nxt[*it] = h[deg[*it]];
      lst[h[deg[*it]]] = *it;
      h[deg[*it]] = *it;
    }
  cur--;
  if (h[nww + 1]) nww++;
  while (nww && !h[nww]) nww--;
}
```

如果此时原图是弦图，此时求出的就是完美消除序列；但是由于原图可能不是弦图，此时求出的一定不是完美消除序列，所以问题转化为 **判断求出的序列是否是原图的完美消除序列** 。

### 判断一个序列是否是完美消除序列

#### 朴素算法

根据定义，依次判断完美消除序列 $v$ 上 $\{v_i,v_{i+1},\ldots ,v_n\}$ 中与 $v_i$ 相邻的点是否构成了一个团。时间复杂度 $O(nm)$ 。

#### 优化后的算法

根据完美消除序列的定义，设 $v_i$ 在 ${v_i,v_{i+1},\ldots , v_n}$ 中相邻的点从小到大为 $\{v_{c_1},v_{c_2},\ldots ,v_{c_k} \}$ ，则只需判断 $v_{c_1}$ 与其他点是否直接连通即可。时间复杂度 $O(n+m)$ 。

```cpp
jud = true;
for (int i = 1; i <= n; i++) {
  cur = 0;
  for (vector<int>::iterator it = G[p[i]].begin(); it != G[p[i]].end(); it++)
    if (rnk[p[i]] < rnk[*it]) {
      s[++cur] = *it;
      if (rnk[s[cur]] < rnk[s[1]]) swap(s[1], s[cur]);
    }
  for (int j = 2; j <= cur; j++)
    if (!st[s[1]].count(s[j])) {
      jud = false;
      break;
    }
}
if (!jud)
  printf("Imperfect\n");
else
  printf("Perfect\n");
```

至此， **弦图判定问题** 可以在 $O(n+m)$ 的时间复杂度内解决。

## 弦图的极大团

令 $N(x)$ 为满足与 $x$ 直接有边相连且在完美消除序列上的 $x$ 之后的序列。则弦图的极大团一定为 $\{x\}+N(x)$ 。

证明：考虑弦图的一个极大团 $V$ ，其中的点在完美消除序列中出现的第一个点 $x$ ，一定有 $V\subseteq \{x\}+N(x)$ ，又因为 $V$ 是极大团，所以 $V=\{x\}+N(x)$ 。

弦图最多有 $n$ 个极大团。求出弦图的每个极大团，可以判断每个 $\{x\}+N(x)$ 是否为极大团。

设 $A=\{x\}+N(x),B=\{y\}+N(y)$ ，若 $A\subsetneqq B$ ，则 $A$ 不是极大团。此时在完美消除序列上显然有 $y$ 在 $x$ 前。

设 $nxt_x$ 表示 $N(x)$ 中在完美消除序列上最靠前的点， $y*$ 表示所有满足 $A\subseteq B$ 的 $y$ 中的最靠后的点。此时必然有 $nxt_{y*}=x$ ，否则 $y*$ 不是最靠后的，令 $y*=nxt_{y*}$ 仍然满足条件。

 $A\subsetneqq B$ 当且仅当 $|A|+1\le |B|$ 。

问题转化为判断是否存在 $y$ ，满足 $nxt_y=x$ 且 $|N(x)|+1\le |N(y)|$ 。时间复杂度 $O(n+m)$ 。

```cpp
for (int i = 1; i <= n; i++) {
  cur = 0;
  for (vector<int>::iterator it = G[p[i]].begin(); it != G[p[i]].end(); it++)
    if (rnk[p[i]] < rnk[*it]) {
      s[++cur] = *it;
      if (rnk[s[cur]] < rnk[s[1]]) swap(s[1], s[cur]);
    }
  fst[p[i]] = s[1];
  N[p[i]] = cur;
}
for (int i = 1; i <= n; i++) {
  if (!vis[p[i]]) ans++;
  if (N[p[i]] >= N[fst[p[i]]] + 1) vis[fst[p[i]]] = true;
}
```

## 弦图的色数/弦图的团数

一种构造方法：按完美消除序列从后往前依次给每个点染色，给每个点染上可以染的最小颜色。时间复杂度 $O(m+n)$ 。

正确性证明：设以上方法使用了 $t$ 种颜色，则 $t\ge \chi(G)$ 。由于团上每个点都是不同的颜色，所以 $t=\omega(G)$ ，由 **Lemma 1** ， $t=\omega(G)\le \chi(G)$ 。综上，可得 $t=\chi(G)=\omega(G)$ 。

无需染色方案，只需求出弦图的色数/团数时，可以取 $|\{x\}+N(x)|$ 的最大值得到。

```cpp
for (int i = 1; i <= n; i++) ans = max(ans, deg[i] + 1);
```

## 弦图的最大独立集/最小团覆盖

最大独立集：完美消除序列从前往后，选择所有没有与已经选择的点有直接连边的点。

最小团覆盖：设最大独立集为 $\{v_1,v_2,\ldots ,v_t\}$ ，则团的集合 $\{\{v_1+N(v_1)\},\{v_2+N(v_2)\},\ldots ,\{v_t+N(v_t)\} \}$ 为图的最小团覆盖。时间复杂度均为 $O(n+m)$ 。

正确性证明：设以上方案独立集数和团覆盖数为 $t$ ，由定义得 $t\le \alpha(G),t\ge \kappa(G)$ ，由 **Lemma 2** 得， $\alpha(G)\le \kappa(G)$ ，所以 $t=\alpha(G)=\kappa(G)$ 。

```cpp
for (int i = 1; i <= n; i++)
  if (!vis[p[i]]) {
    ans++;
    for (vector<int>::iterator it = G[p[i]].begin(); it != G[p[i]].end(); it++)
      vis[*it] = true;
  }
```

## 习题

 [SP5446 FISHNET - Fishing Net](https://www.luogu.org/problem/SP5446) 

 [P3196\[HNOI2008\]神奇的国度](https://www.luogu.org/problem/P3196) 

 [P3852\[TJOI2007\]小朋友](https://www.luogu.org/problem/P3852) 

## 参考资料

 [弦图相关](https://yhx-12243.github.io/OI-transit/memos/15.html) 

 [2009 WC 讲稿](https://wenku.baidu.com/view/cd36284ba31614791711cc7931b765ce05087a30.html) 

 [弦图总结 - 租酥雨](https://www.cnblogs.com/zhoushuyu/p/8716935.html) 

## min-cut
## 概念

### 割

对于一个网络流图 $G=(V,E)$ ，其割的定义为一种 **点的划分方式** ：将所有的点划分为 $S$ 和 $T=V-S$ 两个集合，其中源点 $s\in S$ ，汇点 $t\in T$ 。

### 割的容量

我们的定义割 $(S,T)$ 的容量 $c(S,T)$ 表示所有从 $S$ 到 $T$ 的边的容量之和，即 $c(S,T)=\sum_{u\in S,v\in T}c(u,v)$ 。当然我们也可以用 $c(s,t)$ 表示 $c(S,T)$ 。

### 最小割

最小割就是求得一个割 $(S,T)$ 使得割的容量 $c(S,T)$ 最小。

* * *

## 证明

### 最大流最小割定理

 **定理** ： $f(s,t)_{\max}=c(s,t)_{\min}$ 

对于任意一个可行流 $f(s,t)$ 的割 $(S,T)$ ，我们可以得到：

$$
f(s,t)=S\text{出边的总流量}-S\text{入边的总流量}\le S\text{出边的总流量}=c(s,t)
$$

如果我们求出了最大流 $f$ ，那么残余网络中一定不存在 $s$ 到 $t$ 的増广路经，也就是 $S$ 的出边一定是满流， $S$ 的入边一定是零流，于是有：

$$
f(s,t)=S\text{出边的总流量}-S\text{入边的总流量}=S\text{出边的总流量}=c(s,t)
$$

结合前面的不等式，我们可以知道此时 $f$ 已经达到最大。

* * *

## 代码

### 最小割

通过 **最大流最小割定理** ，我们可以直接得到如下代码：

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    
    const int N = 1e4 + 5, M = 2e5 + 5;
    int n, m, s, t, tot = 1, lnk[N], ter[M], nxt[M], val[M], dep[N], cur[N];
    
    void add(int u, int v, int w) {
      ter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot, val[tot] = w;
    }
    void addedge(int u, int v, int w) { add(u, v, w), add(v, u, 0); }
    int bfs(int s, int t) {
      memset(dep, 0, sizeof(dep));
      memcpy(cur, lnk, sizeof(lnk));
      std::queue<int> q;
      q.push(s), dep[s] = 1;
      while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = lnk[u]; i; i = nxt[i]) {
          int v = ter[i];
          if (val[i] && !dep[v]) q.push(v), dep[v] = dep[u] + 1;
        }
      }
      return dep[t];
    }
    int dfs(int u, int t, int flow) {
      if (u == t) return flow;
      int ans = 0;
      for (int &i = cur[u]; i && ans < flow; i = nxt[i]) {
        int v = ter[i];
        if (val[i] && dep[v] == dep[u] + 1) {
          int x = dfs(v, t, std::min(val[i], flow - ans));
          if (x) val[i] -= x, val[i ^ 1] += x, ans += x;
        }
      }
      if (ans < flow) dep[u] = -1;
      return ans;
    }
    int dinic(int s, int t) {
      int ans = 0;
      while (bfs(s, t)) {
        int x;
        while ((x = dfs(s, t, 1 << 30))) ans += x;
      }
      return ans;
    }
    int main() {
      scanf("%d%d%d%d", &n, &m, &s, &t);
      while (m--) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        addedge(u, v, w);
      }
      printf("%d\n", dinic(s, t));
      return 0;
    }
    ```

### 方案

我们可以通过从源点 $s$ 开始 $\text{DFS}$ ，每次走残量大于 $0$ 的边，找到所有 $S$ 点集内的点。

```cpp
void dfs(int u) {
  vis[u] = 1;
  for (int i = lnk[u]; i; i = nxt[i]) {
    int v = ter[i];
    if (!vis[v] && val[i]) dfs(v);
  }
}
```

### 割边数量

只需要将每条边的容量变为 $1$ ，然后重新跑 $\text{Dinic}$ 即可。

* * *

## 问题模型

有 $n$ 个物品和两个集合 $A,B$ ，如果将一个物品放入 $A$ 集合会花费 $a_i$ ，放入 $B$ 集合会花费 $b_i$ ；还有若干个形如 $u_i,v_i,w_i$ 限制条件，表示如果 $u_i$ 和 $v_i$ 同时不在一个集合会花费 $w_i$ 。每个物品必须且只能属于一个集合，求最小的代价。

这是一个经典的 **二者选其一** 的最小割题目。我们对于每个集合设置源点 $s$ 和汇点 $t$ ，第 $i$ 个点由 $s$ 连一条容量为 $a_i$ 的边、向 $t$ 连一条容量为 $b_i$ 的边。对于限制条件 $u,v,w$ ，我们在 $u,v$ 之间连容量为 $w$ 的双向边。

注意到当源点和汇点不相连时，代表这些点都选择了其中一个集合。如果将连向 $s$ 或 $t$ 的边割开，表示不放在 $A$ 或 $B$ 集合，如果把物品之间的边割开，表示这两个物品不放在同一个集合。

最小割就是最小花费。

* * *

## 习题

-    [「USACO 4.4」Pollutant Control](https://www.luogu.org/problemnew/show/P1344) 
-    [「USACO 5.4」Telecowmunication](https://www.luogu.org/problemnew/show/P1345) 
-    [「Luogu 1361」小 M 的作物](https://www.luogu.org/problemnew/show/P1361) 
-    [「SHOI 2007」善意的投票](https://www.luogu.org/problem/P2057) 

* * *

## bound
在阅读这篇文章之前请先阅读 [最大流](./max-flow.md) 并确保自己熟练掌握最大流算法。

## 概述

上下界网络流本质是给流量网络的每一条边设置了流量上界 $c(u,v)$ 和流量下界 $b(u,v)$ 。也就是说，一种可行的流必须满足 $b(u,v) \leq f(u,v) \leq c(u,v)$ 。同时必须满足除了源点和汇点之外的其余点流量平衡。

根据题目要求，我们可以使用上下界网络流解决不同问题。

## 无源汇上下界可行流

给定无源汇流量网络 $G$ 。询问是否存在一种标定每条边流量的方式，使得每条边流量满足上下界同时每一个点流量平衡。

不妨假设每条边已经流了 $b(u,v)$ 的流量，设其为初始流。同时我们在新图中加入 $u$ 连向 $v$ 的流量为 $c(u,v) - b(u,v)$ 的边。考虑在新图上进行调整。

由于最大流需要满足初始流量平衡条件（最大流可以看成是下界为 $0$ 的上下界最大流），但是构造出来的初始流很有可能不满足初始流量平衡。假设一个点初始流入流量减初始流出流量为 $M$ 。

若 $M=0$ ，此时流量平衡，不需要附加边。

若 $M>0$ ，此时出流量过大，需要新建附加源点 $S'$ ， $S'$ 向其连流量为 $M$ 的附加边。

若 $M<0$ ，此时入流量过大，需要新建附加汇点 $T'$ ，其向 $T'$ 连流量为 $-M$ 的附加边。

如果附加边满流，说明这一个点的流量平衡条件可以满足，否则这个点的流量平衡条件不满足。（因为原图加上附加流之后才会满足原图中的流量平衡。）

在建图完毕之后跑 $S'$ 到 $T'$ 的最大流，若 $S'$ 连出去的边全部满流，则存在可行流，否则不存在。

## 有源汇上下界可行流

给定有源汇流量网络 $G$ 。询问是否存在一种标定每条边流量的方式，使得每条边流量满足上下界同时除了源点和汇点每一个点流量平衡。

假设源点为 $S$ ，汇点为 $T$ 。

则我们可以加入一条 $T$ 到 $S$ 的上界为 $\infty$ ，下界为 $0$ 的边转化为无源汇上下界可行流问题。

若有解，则 $S$ 到 $T$ 的可行流流量等于 $T$ 到 $S$ 的附加边的流量。

## 有源汇上下界最大流

给定有源汇流量网络 $G$ 。询问是否存在一种标定每条边流量的方式，使得每条边流量满足上下界同时除了源点和汇点每一个点流量平衡。如果存在，询问满足标定的最大流量。

我们找到网络上的任意一个可行流。如果找不到解就可以直接结束。

否则我们考虑删去所有附加边之后的残量网络并且在网络上进行调整。

我们在残量网络上再跑一次 $S$ 到 $T$ 的最大流，将可行流流量和最大流流量相加即为答案。

!!! warning "一个非常易错的问题"
     $S$ 到 $T$ 的最大流直接在跑完有源汇上下界可行的残量网络上跑。

    千万不可以在原来的流量网络上跑。

## 有源汇上下界最小流

给定有源汇流量网络 $G$ 。询问是否存在一种标定每条边流量的方式，使得每条边流量满足上下界同时除了源点和汇点每一个点流量平衡。如果存在，询问满足标定的最小流量。

类似的，我们考虑将残量网络中不需要的流退掉。

我们找到网络上的任意一个可行流。如果找不到解就可以直接结束。

否则我们考虑删去所有附加边之后的残量网络。

我们在残量网络上再跑一次 $T$ 到 $S$ 的最大流，将可行流流量减去最大流流量即为答案。

??? note "[AHOI 2014 支线剧情](https://loj.ac/problem/2226)"

    对于每条 $x$ 到 $y$ 花费 $v$ 的剧情边设上界为 $\infty$ , 下界为 $1$。

    对于每个点，向 $T$ 连边权 $c$, 上界 $\infty$ , 下界为 $1$ 。

    $S$ 点为 $1$ 号节点。

    跑一次 上下界带源汇最小费用可行流 即可。

    因为最小费用可行流解法与最小可行流类似，这里不再展开。

## min-cost
在看这篇文章前请先看 [网络流简介](../flow.md) 这篇 wiki 的定义部分

## 费用流

给定一个网络 $G=(V,E)$ ，每条边除了有容量限制 $c(u,v)$ ，还有一个单位限制 $w(u,v)$ 

当 $(u,v)$ 的流量为 $f(u,v)$ 时，需要花费 $f(u,v)\times w(u,v)$ .

 $w$ 也满足斜对称性，即 $w(u,v)=-w(v,u)$ .

则该网络中总花费最小的最大流称为 **最小费用最大流** ，即在最大化 $\sum_{(s,v)\in E}f(s,v)$ 的前提下最小化 $\sum_{(u,v)\in E}f(u,v)\times w(u,v)$ .

### 费用

我们定义一条边的费用 $w(u,v)$ 表示边 $(u,v)$ 上单位流量的费用。也就是说，当边 $(u,v)$ 的流量为 $f(u,v)$ 时，需要花费 $f(u,v)\times w(u,v)$ 的费用。

### 最小费用最大流

网络流图中，花费最小的最大流被称为 **最小费用最大流** ，这也是接下来我们要研究的对象。

## MCMF 算法

在最大流的 EK 算法求解最大流的基础上，把 **用 BFS 求解任意增广路** 改为 **用 SPFA 求解单位费用之和最小的增广路** 即可

相当于把 $w(u,v)$ 作为边权，在残存网络上求最短路

???+ "核心代码"
    ```cpp
    struct qxx {
      int nex, t, v, c;
    };
    qxx e[M];
    int h[N], cnt = 1;
    void add_path(int f, int t, int v, int c) {
      e[++cnt] = (qxx){h[f], t, v, c}, h[f] = cnt;
    }
    void add_flow(int f, int t, int v, int c) {
      add_path(f, t, v, c);
      add_path(t, f, 0, -c);
    }
    int dis[N], pre[N], incf[N];
    bool vis[N];
    bool spfa() {
      memset(dis, 0x3f, sizeof(dis));
      queue<int> q;
      q.push(s), dis[s] = 0, incf[s] = INF, incf[t] = 0;
      while (q.size()) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int i = h[u]; i; i = e[i].nex) {
          const int &v = e[i].t, &w = e[i].v, &c = e[i].c;
          if (!w || dis[v] <= dis[u] + c) continue;
          dis[v] = dis[u] + c, incf[v] = min(w, incf[u]), pre[v] = i;
          if (!vis[v]) q.push(v), vis[v] = 1;
        }
      }
      return incf[t];
    }
    int maxflow, mincost;
    void update() {
      maxflow += incf[t];
      for (int u = t; u != s; u = e[pre[u] ^ 1].t) {
        e[pre[u]].v -= incf[t], e[pre[u] ^ 1].v += incf[t];
        mincost += incf[t] * e[pre[u]].c;
      }
    }
    // 调用：while(spfa())update();
    ```

## 类 Dinic 算法

我们可以在 Dinic 算法的基础上进行改进，把 BFS 求分层图改为用 SPFA（由于有负权边，所以不能直接用 Dijkstra）来求一条单位费用之和最小的路径，也就是把 $w(u,v)$ 当做边权然后在残量网络上求最短路，当然在 DFS 中也要略作修改。这样就可以求得网络流图的 **最小费用最大流** 了。

如何建 **反向边** ？对于一条边 $(u,v,w,c)$ （其中 $w$ 和 $c$ 分别为容量和费用），我们建立正向边 $(u,v,w,c)$ 和反向边 $(v,u,0,-c)$ （其中 $-c$ 是使得从反向边经过时退回原来的费用）。

 **优化** ：如果你是“关于 SPFA，它死了”言论的追随者，那么你可以使用 Primal-Dual 原始对偶算法将 SPFA 改成 Dijkstra！

 **时间复杂度** ：可以证明上界为 $O(nmf)$ ，其中 $f$ 表示流量。

???+ "代码实现"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    
    const int N = 5e3 + 5, M = 1e5 + 5;
    const int INF = 0x3f3f3f3f;
    int n, m, tot = 1, lnk[N], cur[N], ter[M], nxt[M], cap[M], cost[M], dis[N], ret;
    bool vis[N];
    
    void add(int u, int v, int w, int c) {
      ter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot, cap[tot] = w, cost[tot] = c;
    }
    void addedge(int u, int v, int w, int c) { add(u, v, w, c), add(v, u, 0, -c); }
    bool spfa(int s, int t) {
      memset(dis, 0x3f, sizeof(dis));
      memcpy(cur, lnk, sizeof(lnk));
      std::queue<int> q;
      q.push(s), dis[s] = 0, vis[s] = 1;
      while (!q.empty()) {
        int u = q.front();
        q.pop(), vis[u] = 0;
        for (int i = lnk[u]; i; i = nxt[i]) {
          int v = ter[i];
          if (cap[i] && dis[v] > dis[u] + cost[i]) {
            dis[v] = dis[u] + cost[i];
            if (!vis[v]) q.push(v), vis[v] = 1;
          }
        }
      }
      return dis[t] != INF;
    }
    int dfs(int u, int t, int flow) {
      if (u == t) return flow;
      vis[u] = 1;
      int ans = 0;
      for (int &i = cur[u]; i && ans < flow; i = nxt[i]) {
        int v = ter[i];
        if (!vis[v] && cap[i] && dis[v] == dis[u] + cost[i]) {
          int x = dfs(v, t, std::min(cap[i], flow - ans));
          if (x) ret += x * cost[i], cap[i] -= x, cap[i ^ 1] += x, ans += x;
        }
      }
      vis[u] = 0;
      return ans;
    }
    int mcmf(int s, int t) {
      int ans = 0;
      while (spfa(s, t)) {
        int x;
        while ((x = dfs(s, t, INF))) ans += x;
      }
      return ans;
    }
    int main() {
      int s, t;
      scanf("%d%d%d%d", &n, &m, &s, &t);
      while (m--) {
        int u, v, w, c;
        scanf("%d%d%d%d", &u, &v, &w, &c);
        addedge(u, v, w, c);
      }
      int ans = mcmf(s, t);
      printf("%d %d\n", ans, ret);
      return 0;
    }
    ```

## 习题

-    [「Luogu 3381」【模板】最小费用最大流](https://www.luogu.org/problemnew/show/P3381) 
-    [「Luogu 4452」航班安排](https://www.luogu.org/problemnew/show/P4452) 
-    [「SDOI 2009」晨跑](https://www.luogu.org/problem/P2153) 
-    [「SCOI 2007」修车](https://www.luogu.org/problem/P2053) 
-    [「HAOI 2010」订货](https://www.luogu.org/problem/P2517) 
-    [「NOI 2012」美食节](https://loj.ac/problem/2674) 

## max-flow
网络流基本概念参见 [网络流简介](../flow.md) 

## 概述

我们有一张图，要求从源点流向汇点的最大流量（可以有很多条路到达汇点），就是我们的最大流问题。

## Ford-Fulkerson 增广路算法

该方法通过寻找增广路来更新最大流，有 EK,dinic,SAP,ISAP 主流算法。

求解最大流之前，我们先认识一些概念。

### 残量网络

首先我们介绍一下一条边的剩余容量 $c_f(u,v)$ （Residual Capacity），它表示的是这条边的容量与流量之差，即 $c_f(u,v)=c(u,v)-f(u,v)$ 。

对于流函数 $f$ ，残存网络 $G_f$ （Residual Network）是网络 $G$ 中所有结点 **和剩余容量大于 0** 的边构成的子图。形式化的定义，即 $G_f=(V_f=V,E_f=\left\{(u,v)\in E,c_f(u,v)>0\right\})$ 。

注意，剩余容量大于 0 的边可能不在原图 $G$ 中（根据容量、剩余容量的定义以及流函数的斜对称性得到）。可以理解为，残量网络中包括了那些还剩了流量空间的边构成的图，也包括虚边（即反向边）。

### 増广路

在原图 $G$ 中若一条从源点到汇点的路径上所有边的 **剩余容量都大于 0** ，这条路被称为增广路（Augmenting Path）。

或者说，在残存网络 $G_f$ 中，一条从源点到汇点的路径被称为增广路。如图：

/home/llj/Desktop/OI-wiki-master/docs/graph/flow/![flow](./images/flow1.png)

我们从 $4$ 到 $3$ ，肯定可以先从流量为 $20$ 的这条边先走。那么这条边就被走掉了，不能再选，总的流量为 $20$ （现在）。然后我们可以这样选择：

1.   $4\rightarrow2\rightarrow3$ 这条 **增广路** 的总流量为 $20$ 。到 $2$ 的时候还是 $30$ ，到 $3$ 了就只有 $20$ 了。

2.   $4\rightarrow2\rightarrow1\rightarrow3$ 这样子我们就很好的保留了 $30$ 的流量。

所以我们这张图的最大流就应该是 $20+30=50$ 。

求最大流是很简单的，接下来讲解求最大流的 3 种方法。

### Edmond-Karp 动能算法（EK 算法）

这个算法很简单，就是 BFS **找增广路** ，然后对其进行 **增广** 。你可能会问，怎么找？怎么增广？

1.  找？我们就从源点一直 BFS 走来走去，碰到汇点就停，然后增广（每一条路都要增广）。我们在 BFS 的时候就注意一下流量合不合法就可以了。

2.  增广？其实就是按照我们找的增广路在重新走一遍。走的时候把这条路的能够成的最大流量减一减，然后给答案加上最小流量就可以了。

再讲一下 **反向边** 。增广的时候要注意建造反向边，原因是这条路不一定是最优的，这样子程序可以进行反悔。假如我们对这条路进行增广了，那么其中的每一条边的反向边的流量就是它的流量。

/home/llj/Desktop/OI-wiki-master/docs/graph/flow/![](./images/flow2.png)

讲一下一些小细节。如果你是用邻接矩阵的话，反向边直接就是从 $table[x,y]$ 变成 $table[y,x]$ 。如果是常用的链式前向星，那么在加入边的时候就要先加入反向边。那么在用的时候呢，我们直接 $i\operatorname{xor}1$ 就可以了 ( $i$ 为边的编号）。为什么呢？相信大家都是知道 $\operatorname{xor}$ 的，那么我们在加入正向边后加入反向边，就是靠近的，所以可以使用 $\operatorname{xor}$ 。我们还要注意一开始的编号要设置为 $tot=1$ ，因为边要从编号 $2$ 开始，这样子 $\operatorname{xor}$ 对编号 $2,3$ 的边才有效果。

EK 算法的时间复杂度为 $O(nm^2)$ （其中 $n$ 为点数， $m$ 为边数）。效率还有很大提升空间。

```cpp
#define maxn 250
#define INF 0x3f3f3f3f

struct Edge {
  int from, to, cap, flow;
  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}
};

struct EK {
  int n, m;
  vector<Edge> edges;
  vector<int> G[maxn];
  int a[maxn], p[maxn];

  void init(int n) {
    for (int i = 0; i < n; i++) G[i].clear();
    edges.clear();
  }

  void AddEdge(int from, int to, int cap) {
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    m = edges.size();
    G[from].push_back(m - 2);
    G[to].push_back(m - 1);
  }

  int Maxflow(int s, int t) {
    int flow = 0;
    for (;;) {
      memset(a, 0, sizeof(a));
      queue<int> Q;
      Q.push(s);
      a[s] = INF;
      while (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!Q.empty()) {
        int x = Q.front();
        Q.pop();
        for (int i = 0; i < G[x].size(); i++) {
          Edge& e = edges[G[x][i]];
          if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!a[e.to] && e.cap > e.flow) {
            p[e.to] = G[x][i];
            a[e.to] = min(a[x], e.cap - e.flow);
            Q.push(e.to);
          }
        }
        if (a[t]) break;
      }
      if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!a[t]) break;
      for (int u = t; u /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= s; u = edges[p[u]].from) {
        edges[p[u]].flow += a[t];
        edges[p[u] ^ 1].flow -= a[t];
      }
      flow += a[t];
    }
    return flow;
  }
};
```

### Dinic 算法

 **Dinic 算法** 的过程是这样的：每次增广前，我们先用 BFS 来将图分层。设源点的层数为 $0$ ，那么一个点的层数便是它离源点的最近距离。

通过分层，我们可以干两件事情：

1.  如果不存在到汇点的增广路（即汇点的层数不存在），我们即可停止增广。
2.  确保我们找到的增广路是最短的。（原因见下文）

接下来是 DFS 找增广路的过程。

我们每次找增广路的时候，都只找比当前点层数多 $1$ 的点进行增广（这样就可以确保我们找到的增广路是最短的）。

Dinic 算法有两个优化：

1.   **多路增广** ：每次找到一条增广路的时候，如果残余流量没有用完怎么办呢？我们可以利用残余部分流量，再找出一条增广路。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。
2.   **当前弧优化** ：如果一条边已经被增广过，那么它就没有可能被增广第二次。那么，我们下一次进行增广的时候，就可以不必再走那些已经被增广过的边。

设点数为 $n$ ，边数为 $m$ ，那么 Dinic 算法的时间复杂度是 $O(n^{2}m)$ ，在稀疏图上效率和 EK 算法相当，但在稠密图上效率要比 EK 算法高很多。

特别地，在求解二分图最大匹配问题时，可以证明 Dinic 算法的时间复杂度是 $O(m\sqrt{n})$ 。

```cpp
#define maxn 250
#define INF 0x3f3f3f3f

struct Edge {
  int from, to, cap, flow;
  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}
};

struct Dinic {
  int n, m, s, t;
  vector<Edge> edges;
  vector<int> G[maxn];
  int d[maxn], cur[maxn];
  bool vis[maxn];

  void init(int n) {
    for (int i = 0; i < n; i++) G[i].clear();
    edges.clear();
  }

  void AddEdge(int from, int to, int cap) {
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    m = edges.size();
    G[from].push_back(m - 2);
    G[to].push_back(m - 1);
  }

  bool BFS() {
    memset(vis, 0, sizeof(vis));
    queue<int> Q;
    Q.push(s);
    d[s] = 0;
    vis[s] = 1;
    while (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!Q.empty()) {
      int x = Q.front();
      Q.pop();
      for (int i = 0; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i]];
        if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!vis[e.to] && e.cap > e.flow) {
          vis[e.to] = 1;
          d[e.to] = d[x] + 1;
          Q.push(e.to);
        }
      }
    }
    return vis[t];
  }

  int DFS(int x, int a) {
    if (x == t || a == 0) return a;
    int flow = 0, f;
    for (int& i = cur[x]; i < G[x].size(); i++) {
      Edge& e = edges[G[x][i]];
      if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0) {
        e.flow += f;
        edges[G[x][i] ^ 1].flow -= f;
        flow += f;
        a -= f;
        if (a == 0) break;
      }
    }
    return flow;
  }

  int Maxflow(int s, int t) {
    this->s = s;
    this->t = t;
    int flow = 0;
    while (BFS()) {
      memset(cur, 0, sizeof(cur));
      flow += DFS(s, INF);
    }
    return flow;
  }
};
```

### ISAP

这个是 SAP 算法的加强版 (Improved)。

```cpp
struct Edge {
  int from, to, cap, flow;
  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}
};

bool operator<(const Edge& a, const Edge& b) {
  return a.from < b.from || (a.from == b.from && a.to < b.to);
}

struct ISAP {
  int n, m, s, t;
  vector<Edge> edges;
  vector<int> G[maxn];
  bool vis[maxn];
  int d[maxn];
  int cur[maxn];
  int p[maxn];
  int num[maxn];

  void AddEdge(int from, int to, int cap) {
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    m = edges.size();
    G[from].push_back(m - 2);
    G[to].push_back(m - 1);
  }

  bool BFS() {
    memset(vis, 0, sizeof(vis));
    queue<int> Q;
    Q.push(t);
    vis[t] = 1;
    d[t] = 0;
    while (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!Q.empty()) {
      int x = Q.front();
      Q.pop();
      for (int i = 0; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i] ^ 1];
        if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!vis[e.from] && e.cap > e.flow) {
          vis[e.from] = 1;
          d[e.from] = d[x] + 1;
          Q.push(e.from);
        }
      }
    }
    return vis[s];
  }

  void init(int n) {
    this->n = n;
    for (int i = 0; i < n; i++) G[i].clear();
    edges.clear();
  }

  int Augment() {
    int x = t, a = INF;
    while (x /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= s) {
      Edge& e = edges[p[x]];
      a = min(a, e.cap - e.flow);
      x = edges[p[x]].from;
    }
    x = t;
    while (x /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= s) {
      edges[p[x]].flow += a;
      edges[p[x] ^ 1].flow -= a;
      x = edges[p[x]].from;
    }
    return a;
  }

  int Maxflow(int s, int t) {
    this->s = s;
    this->t = t;
    int flow = 0;
    BFS();
    memset(num, 0, sizeof(num));
    for (int i = 0; i < n; i++) num[d[i]]++;
    int x = s;
    memset(cur, 0, sizeof(cur));
    while (d[s] < n) {
      if (x == t) {
        flow += Augment();
        x = s;
      }
      int ok = 0;
      for (int i = cur[x]; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i]];
        if (e.cap > e.flow && d[x] == d[e.to] + 1) {
          ok = 1;
          p[e.to] = G[x][i];
          cur[x] = i;
          x = e.to;
          break;
        }
      }
      if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!ok) {
        int m = n - 1;
        for (int i = 0; i < G[x].size(); i++) {
          Edge& e = edges[G[x][i]];
          if (e.cap > e.flow) m = min(m, d[e.to]);
        }
        if (--num[d[x]] == 0) break;
        num[d[x] = m + 1]++;
        cur[x] = 0;
        if (x /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= s) x = edges[p[x]].from;
      }
    }
    return flow;
  }
};
```

## Push-Relabel 预流推进算法

该方法在求解过程中忽略流守恒性，并每次对一个结点更新信息，以求解最大流。

### 通用的预流推进算法

首先我们介绍预流推进算法的主要思想，以及一个可行的暴力实现算法。

预流推进算法通过对单个结点的更新操作，直到没有结点需要更新来求解最大流。

算法过程维护的流函数不一定保持流守恒性，对于一个结点，我们允许进入结点的流超过流出结点的流，超过的部分被称为结点 $u(u\in V-\{s,t\})$ 的 **超额流**  $e(u)$ ：

$$
e(u)=\sum_{(x,u)\in E}f(x,u)-\sum_{(u,y)\in E}f(u,y)
$$

若 $e(u)>0$ ，称结点 $u$  **溢出** 。

预流推进算法维护每个结点的高度 $h(u)$ ，并且规定溢出的结点 $u$ 如果要推送超额流，只能向高度小于 $u$ 的结点推送；如果 $u$ 没有相邻的高度小于 $u$ 的结点，就修改 $u$ 的高度（重贴标签）。

#### 高度函数

准确地说，预流推进维护以下的一个映射 $h:V\to \mathbf{N}$ ：

-    $h(s)=|V|,h(t)=0$ 
-    $\forall (u,v)\in E_f,h(u)\leq h(v)+1$ 

称 $h$ 是残存网络 $G_f=(V_f,E_f)$ 的高度函数。

引理 1：设 $G_f$ 上的高度函数为 $h$ ，对于任意两个结点 $u,v\in V$ ，如果 $h(u)>h(v)+1$ ，则 $(u,v)$ 不是 $G_f$ 中的边。

算法只会在 $h(u)=h(v)+1$ 的边执行推送。

#### 推送（Push）

适用条件：结点 $u$ 溢出，且存在结点 $v((u,v)\in E_f,c(u,v)-f(u,v)>0,h(u)=h(v)+1)$ ，则 push 操作适用于 $(u,v)$ 。

于是，我们尽可能将超额流从 $u$ 推送到 $v$ ，推送过程中我们只关心超额流和 $c(u,v)-f(u,v)$ 的最小值，不关心 $v$ 是否溢出。

如果 $(u,v)$ 在推送完之后满流，将其从残存网络中删除。

#### 重贴标签（Relabel）

适用条件：如果结点 $u$ 溢出，且 $\forall (u,v)\in E_f,h(u)\leq h(v)$ ，则 relabel 操作适用于 $u$ 。

则将 $h(u)$ 更新为 $min_{(u,v)\in E_f}h(v)+1$ 即可。

#### 初始化

$$
\begin{split}
&\forall (u,v)\in E,&f(u,v)=\left\{\begin{split}
&c(u,v)&,u=s\\
&0&,u\neq s\\
\end{split}\right.
\\
&\forall u\in V,&h(u)=\left\{\begin{split}
&|V|&,u=s\\
&0&,u\neq s\\
\end{split}\right.
,e(u)=\sum_{(x,u)\in E}f(x,u)-\sum_{(u,y)\in E}f(u,y)
\end{split}
$$

上述将 $(s,v)\in E$ 充满流，并将 $h(s)$ 抬高，使得 $(s,v)\notin E_f$ ，因为 $h(s)>h(v)$ ，而且 $(s,v)$ 毕竟满流，没必要留在残存网络中；上述还将 $e(s)$ 初始化为 $\sum_{(s,v)\in E}f(s,v)$ 的相反数。

#### 通用算法

我们每次扫描整个图，只要存在结点 $u$ 满足 push 或 relabel 操作的条件，就执行对应的操作。

如图，每个结点中间表示编号，左下表示高度值 $h(u)$ ，右下表示超额流 $e(u)$ ，结点颜色的深度也表示结点的高度；边权表示 $c(u,v)-f(u,v)$ ，绿色的边表示满足 $h(u)=h(v)+1$ 的边 $(u,v)$ （即残存网络的边 $E_f$ ）：

/home/llj/Desktop/OI-wiki-master/docs/graph/flow/![p1](./images/2148.png)

整个算法我们大致浏览一下过程，这里笔者使用的是一个暴力算法，即暴力扫描是否有溢出的结点，有就更新

/home/llj/Desktop/OI-wiki-master/docs/graph/flow/![p2](./images/2149.gif)

最后的结果

/home/llj/Desktop/OI-wiki-master/docs/graph/flow/![p3](./images/2150.png)

可以发现，最后的超额流一部分回到了 $s$ ，且除了源点汇点，其他结点都没有溢出；这时的流函数 $f$ 满足流守恒性，为最大流，即 $e(t)$ 。

???+ "核心代码"
    ```cpp
    const int N = 1e4 + 4, M = 1e5 + 5, INF = 0x3f3f3f3f;
    int n, m, s, t, maxflow, tot;
    int ht[N], ex[N];
    void init() {  // 初始化
      for (int i = h[s]; i; i = e[i].nex) {
        const int &v = e[i].t;
        ex[v] = e[i].v, ex[s] -= ex[v], e[i ^ 1].v = e[i].v, e[i].v = 0;
      }
      ht[s] = n;
    }
    bool push(int ed) {
      const int &u = e[ed ^ 1].t, &v = e[ed].t;
      int flow = min(ex[u], e[ed].v);
      ex[u] -= flow, ex[v] += flow, e[ed].v -= flow, e[ed ^ 1].v += flow;
      return ex[u];  // 如果 u 仍溢出，返回 1
    }
    void relabel(int u) {
      ht[u] = INF;
      for (int i = h[u]; i; i = e[i].nex)
        if (e[i].v) ht[u] = min(ht[u], ht[e[i].t]);
      ++ht[u];
    }
    ```

### HLPP 算法

最高标号预流推进算法（High Level Preflow Push）是基于预流推进算法的优先队列实现，该算法优先推送高度高的溢出的结点，算法算法复杂度 $O(n^2\sqrt m)$ 。

具体地说，HLPP 算法过程如下：

1.  初始化（基于预流推进算法）；
2.  选择溢出结点（除 $s,t$ ）中高度最高的结点 $u$ ，并对它所有可以推送的边进行推送；
3.  如果 $u$ 仍溢出，对它重贴标签，回到步骤 2；
4.  如果没有溢出的结点，算法结束。

#### BFS 优化

HLPP 的上界为 $O(n^2\sqrt m)$ ，但在使用时卡得比较紧；我们可以在初始化高度的时候进行优化。具体来说，我们初始化 $h(u)$ 为 $u$ 到 $t$ 的最短距离；特别地， $h(s)=n$ 。

在 BFS 的同时我们顺便检查图的连通性，排除无解的情况。

#### GAP 优化

HLPP 推送的条件是 $h(u)=h(v)+1$ ，而如果在算法的某一时刻， $h(u)=t$ 的结点个数为 $0$ ，那么对于 $h(u)>t$ 的结点就永远无法推送超额流到 $t$ ，因此只能送回 $s$ ，那么我们就在这时直接让他们的高度变成 $n+1$ ，以尽快推送回 $s$ ，减少重贴标签的操作。

??? "LuoguP4722【模板】最大流 加强版/预流推进"
    ```cpp
    #include <cstdio>
    #include <cstring>
    #include <queue>
    using namespace std;
    const int N = 1e4 + 4, M = 2e5 + 5, INF = 0x3f3f3f3f;
    int n, m, s, t;
    
    struct qxx {
      int nex, t, v;
    };
    qxx e[M * 2];
    int h[N], cnt = 1;
    void add_path(int f, int t, int v) { e[++cnt] = (qxx){h[f], t, v}, h[f] = cnt; }
    void add_flow(int f, int t, int v) {
      add_path(f, t, v);
      add_path(t, f, 0);
    }
    
    int ht[N], ex[N], gap[N];  // 高度；超额流；gap 优化
    bool bfs_init() {
      memset(ht, 0x3f, sizeof(ht));
      queue<int> q;
      q.push(t), ht[t] = 0;
      while (q.size()) {  // 反向 BFS, 遇到没有访问过的结点就入队
        int u = q.front();
        q.pop();
        for (int i = h[u]; i; i = e[i].nex) {
          const int &v = e[i].t;
          if (e[i ^ 1].v && ht[v] > ht[u] + 1) ht[v] = ht[u] + 1, q.push(v);
        }
      }
      return ht[s] /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= INF;  // 如果图不连通，返回 0
    }
    struct cmp {
      bool operator()(int a, int b) const { return ht[a] < ht[b]; }
    };                                         // 伪装排序函数
    priority_queue<int, vector<int>, cmp> pq;  // 将需要推送的结点以高度高的优先
    bool vis[N];                               // 是否在优先队列中
    int push(int u) {  // 尽可能通过能够推送的边推送超额流
      for (int i = h[u]; i; i = e[i].nex) {
        const int &v = e[i].t, &w = e[i].v;
        if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!w || ht[u] /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= ht[v] + 1) continue;
        int k = min(w, ex[u]);  // 取到剩余容量和超额流的最小值
        ex[u] -= k, ex[v] += k, e[i].v -= k, e[i ^ 1].v += k;  // push
        if (v /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= s && v /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= t && /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!vis[v])
          pq.push(v), vis[v] = 1;  // 推送之后，v 必然溢出，则入堆，等待被推送
        if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!ex[u]) return 0;  // 如果已经推送完就返回
      }
      return 1;
    }
    void relabel(int u) {  // 重贴标签（高度）
      ht[u] = INF;
      for (int i = h[u]; i; i = e[i].nex)
        if (e[i].v) ht[u] = min(ht[u], ht[e[i].t]);
      ++ht[u];
    }
    int hlpp() {                  // 返回最大流
      if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!bfs_init()) return 0;  // 图不连通
      ht[s] = n;
      memset(gap, 0, sizeof(gap));
      for (int i = 1; i <= n; i++)
        if (ht[i] /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= INF) gap[ht[i]]++;  // 初始化 gap
      for (int i = h[s]; i; i = e[i].nex) {
        const int v = e[i].t, w = e[i].v;  // 队列初始化
        if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!w) continue;
        ex[s] -= w, ex[v] += w, e[i].v -= w, e[i ^ 1].v += w;  // 注意取消 w 的引用
        if (v /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= s && v /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= t && /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!vis[v]) pq.push(v), vis[v] = 1;  // 入队
      }
      while (pq.size()) {
        int u = pq.top();
        pq.pop(), vis[u] = 0;
        while (push(u)) {  // 仍然溢出
          // 如果 u 结点原来所在的高度没有结点了，相当于出现断层
          if (/home/llj/Desktop/OI-wiki-master/docs/graph/flow/!--gap[ht[u]])
            for (int i = 1; i <= n; i++)
              if (i /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= s && i /home/llj/Desktop/OI-wiki-master/docs/graph/flow/!= t && ht[i] > ht[u] && ht[i] < n + 1) ht[i] = n + 1;
          relabel(u);
          ++gap[ht[u]];  // 新的高度，更新 gap
        }
      }
      return ex[t];
    }
    int main() {
      scanf("%d%d%d%d", &n, &m, &s, &t);
      for (int i = 1, u, v, w; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &w);
        add_flow(u, v, w);
      }
      printf("%d", hlpp());
      return 0;
    }
    ```

感受一下运行过程

/home/llj/Desktop/OI-wiki-master/docs/graph/flow/![HLPP](./images/1152.png)

其中 pic13 到 pic14 执行了 Relabel(4)，并进行了 GAP 优化。

# math
# linear-equation
## 介绍

形如 $ax \equiv b \pmod c$ 的方程被称为 **线性同余方程** (Congruence Equation)。

 [「NOIP2012」同余方程](https://loj.ac/problem/2605) 

## 求解方法

根据以下两个定理，我们可以求出同余方程 $ax \equiv b \pmod c$ 的解。

定理 1：

> 方程 $ax+by=c$ 与方程 $ax \equiv c \pmod b$ 是等价的，有整数解的充要条件为 $\gcd(a,b) \mid c$ 。

根据定理 1，方程 $ax+by=c$ ，我们可以先用扩展欧几里得算法求出一组 $x_0,y_0$ ，也就是 $ax_0+by_0=\gcd(a,b)$ ，然后两边同时除以 $\gcd(a,b)$ ，再乘 $c$ 。然后就得到了方程 $acx_0/\gcd(a,b)+bcy_0/\gcd(a,b)=c$ ，然后我们就找到了方程的一个解。

定理 2：

> 若 $\gcd(a,b)=1$ ，且 $x_0,y_0$ 为方程 $ax+by=c$ 的一组解，则该方程的任意解可表示为： $x=x_0+bt,y=y_0-at$ , 且对任意整数 $t$ 都成立。

根据定理 2，可以求出方程的所有解。但在实际问题中，我们往往被要求求出一个最小整数解，也就是一个特解 $x,t=b/\gcd(a,b),x=(x \bmod t+t) \bmod t$ 。

代码：

```cpp
int ex_gcd(int a, int b, int& x, int& y) {
  if (b == 0) {
    x = 1;
    y = 0;
    return a;
  }
  int d = ex_gcd(b, a % b, x, y);
  int temp = x;
  x = y;
  y = temp - a / b * y;
  return d;
}
bool liEu(int a, int b, int c, int& x, int& y) {
  int d = ex_gcd(a, b, x, y);
  if (c % d != 0) return 0;
  int k = c / d;
  x *= k;
  y *= k;
  return 1;
}
```

# expectation
## 事件

### 单位事件、事件空间、随机事件

在一次随机试验中可能发生的不能再细分的结果被称为单位事件，用 $E$ 表示。在随机试验中可能发生的所有单位事件的集合称为事件空间，用 $S$ 来表示。例如在一次掷骰子的随机试验中，如果用获得的点数来表示单位事件，那么一共可能出现 $6$ 个单位事件，则事件空间可以表示为 $S=\{1,2,3,4,5,6\}$ 。

随机事件是事件空间 $S$ 的子集，它由事件空间 $S$ 中的单位元素构成，用大写字母 $A, B, C,\ldots$ 表示。例如在掷两个骰子的随机试验中，设随机事件 $A$ 为“获得的点数和大于 $10$ ”，则 $A$ 可以由下面 $3$ 个单位事件组成： $A = \{ (5,6),(6,5),(6,6)\}$ 。

### 事件的计算

因为事件在一定程度上是以集合的含义定义的，因此可以把集合计算方法直接应用于事件的计算，也就是说，在计算过程中，可以把事件当作集合来对待。

 **和事件** ：相当于 **并集** 。只需其中之一发生，就发生了。

 **积事件** ：相当于 **交集** 。必须要全都发生，才计算概率。

## 概率

### 定义

如果在相同条件下，进行了 n 次试验，事件 A 发生了 $N_A$ 次，那么 $\frac{N_A}{n}$ 称为事件 A 发生的概率。

### 公理

 **非负性** ：对于一个事件 $A$ ，有概率 $P(A)\in [0,1]$ 。

 **规范性** ：事件空间的概率值为 $1$ ， $P(S)=1$ .

 **容斥性** ：若 $P(A+B) = P(A)+P(B)$ ，则 $A$ 和 $B$ 互为独立事件。

### 计算

 **全概率公式** ：若事件 $A_1,A_2,\ldots,A_n$ 构成一个完备的事件且都有正概率，即 $\forall i,j, A_i\cap A_j=\varnothing$ 且 $\displaystyle \sum_{i=1}^n A_i=1$ ，有 $\displaystyle P(B)=\sum_{i=1}^n P(A_i)P(B|A_i)$ 。

 **贝叶斯定理** ： $\displaystyle P(B_i|A)=\frac{P(B_i)P(A|B_i)}{\displaystyle \sum_{j=1}^n P(B_j)P(A|B_j)}$ 

公式中，事件 $B_i$ 的概率为 $P(B_i)$ ，事件 $B_i$ 已发生条件下事件 $A$ 的概率为 $P(A|B_i)$ ，事件 $A$ 发生条件下事件 $B_i$ 的概率为 $P(B_i|A)$ 。

## 期望

### 定义

在一定区间内变量取值为有限个，或数值可以一一列举出来的变量称为离散型随机变量。一个离散性随机变量的数学期望是试验中每次可能的结果乘以其结果概率的总和。

### 性质

 **全期望公式** ： $E(Y)=E[E(Y|X)]$ 。可由全概率公式证明。

 **线性性质** : 对于任意两个随机事件 $x,y$ （ **不要求相互独立** ），有 $E(X+Y)=E(X)+E(Y)$ 。

## 例题

 [NOIP2017 初赛 T14, T15](https://ti.luogu.com.cn/problemset/1022) 

 [NOIP2016 换教室](https://uoj.ac/problem/262) （概率期望 DP）

# fermat
## 费马小定理

若 $p$ 为素数， $\gcd(a, p) = 1$ ，则 $a^{p - 1} \equiv 1 \pmod{p}$ 。

另一个形式：对于任意整数 $a$ ，有 $a^p \equiv a \pmod{p}$ 。

### 证明

设一个质数为 $p$ ，我们取一个不为 $p$ 倍数的数 $a$ 。

构造一个序列： $A=\{1,2,3\dots,p-1\}$ ，这个序列有着这样一个性质：

$$
\prod_{i=1}^{n}\space A_i\equiv\prod_{i=1}^{n} (A_i\times a) \pmod p
$$

证明：

$$
\because (A_i,p)=1,(A_i\times a,p)=1
$$

又因为每一个 $A_i\times a \pmod p$ 都是独一无二的，且 $A_i\times a \pmod p < p$ 

得证（每一个 $A_i\times a$ 都对应了一个 $A_i$ )

设 $f=(p-1)!$ , 则 $f\equiv a\times A_1\times a\times A_2\times a \times A_3 \dots \times  A_{p-1} \pmod p$ 

$$
a^{p-1}\times f \equiv f \pmod p \\ 	a^{p-1} \equiv 1 \pmod p
$$

证毕。

## 欧拉定理

在了解欧拉定理（Euler's theorem）之前，请先了解 [欧拉函数](./euler.md) 。定理内容如下：

若 $\gcd(a, m) = 1$ ，则 $a^{\varphi(m)} \equiv 1 \pmod{m}$ 。

### 证明

实际上这个证明过程跟上文费马小定理的证明过程是非常相似的： **构造一个与 $m$ 互质的数列** ，再进行操作。

设 $r_1, r_2, \cdots, r_{\varphi(m)}$ 为模 $m$ 意义下的一个简化剩余系，则 $ar_1, ar_2, \cdots, ar_{\varphi(m)}$ 也为模 $m$ 意义下的一个简化剩余系。所以 $r_1r_2 \cdots r_{\varphi(m)} \equiv ar_1 \cdot ar_2 \cdots ar_{\varphi(m)} \equiv a^{\varphi(m)}r_1r_2 \cdots r_{\varphi(m)} \pmod{m}$ ，可约去 $r_1r_2 \cdots r_{\varphi(m)}$ ，即得 $a^{\varphi(m)} \equiv 1 \pmod{m}$ 。

当 $m$ 为素数时，由于 $\varphi(m) = m - 1$ ，代入欧拉定理可立即得到费马小定理。

## 扩展欧拉定理

$$
a^b\equiv
\begin{cases}
a^{b\bmod\varphi(p)},\,&\gcd(a,\,p)=1\\
a^b,&\gcd(a,\,p)\ne1,\,b<\varphi(p)\\
a^{b\bmod\varphi(p)+\varphi(p)},&\gcd(a,\,p)\ne1,\,b\ge\varphi(p)
\end{cases}
\pmod p
$$

### 证明

证明转载自 [synapse7](http://blog.csdn.net/synapse7/article/details/19610361) 

1.  在 $a$ 的 $0$ 次， $1$ 次，。。。， $b$ 次幂模 $m$ 的序列中，前 $r$ 个数（ $a^0$ 到 $a^{r-1}$ ) 互不相同，从第 $r$ 个数开始，每 $s$ 个数就循环一次。

    证明：由鸽巢定理易证。

    我们把 $r$ 称为 $a$ 幂次模 $m$ 的循环起始点， $s$ 称为循环长度。（注意： $r$ 可以为 $0$ ）

    用公式表述为： $a^r\equiv a^{r+s}\pmod{m}$ 

2.   $a$ 为素数的情况

    令 $m=p^rm'$ ，则 $\gcd(p,m')=1$ ，所以 $p^{\varphi(m')}\equiv 1\pmod{m'}$ 

    又由于 $\gcd(p^r,m')=1$ ，所以 $\varphi(m') \mid \varphi(m)$ ，所以 $p^{\varphi(m)}\equiv 1 \pmod {m'}$ ，即 $p^\varphi(m)=km'+1$ ，两边同时乘以 $p^r$ ，得 $p^{r+\varphi(m)}=km+p^r$ （因为 $m=p^rm'$ ）

    所以 $p^r\equiv p^{r+s}\pmod m$ ，这里 $s=\varphi(m)$ 

3.  推论： $p^b\equiv p^{r+(b-r) \mod \varphi(m)}\pmod m$ 

4.  又由于 $m=p^rm'$ ，所以 $\varphi(m) \ge  \varphi(p^r)=p^{r-1}(p-1) \ge r$ 

    所以 $p^r\equiv p^{r+\varphi(m)}\equiv p^{r \mod \varphi(m)+\varphi(m)}\pmod m$ 

    所以 $p^b\equiv p^{r+(b-r) \mod \varphi(m)}\equiv p^{r \mod \varphi(m)+\varphi(m)+(b-r) \mod \varphi(m)}\equiv p^{\varphi(m)+b \mod \varphi(m)}\pmod m$ 

    即 $p^b\equiv p^{b \mod \varphi(m)+\varphi(m)}\pmod m$ 

5.   $a$ 为素数的幂的情况

    是否依然有 $a^{r'}\equiv a^{r'+s'}\pmod m$ ？（其中 $s'=\varphi(m),a=p^k$ )

    答案是肯定的，由 2 知 $p^s\equiv 1 \pmod m'$ ，所以 $p^{s \times \frac{k}{\gcd(s,k)}} \equiv 1\pmod {m'}$ ，所以当 $s'=\frac{s}{\gcd(s,k)}$ 时才能有 $p^{s'k}\equiv 1\pmod {m'}$ ，此时 $s' \mid s \mid \varphi(m)$ ，且 $r'= \lceil \frac{r}{k}\rceil \le r \le \varphi(m)$ ，由 $r',s'$ 与 $\varphi(m)$ 的关系，依然可以得到 $a^b\equiv a^{b \mod \varphi(m)+\varphi(m)}\pmod m$ 

6.   $a$ 为合数的情况

    只证 $a$ 拆成两个素数的幂的情况，大于两个的用数学归纳法可证。

    设 $a=a_1a_2,a_i=p_i^{k_i}$ ， $a_i$ 的循环长度为 $s_i$ ；

    则 $s \mid lcm(s_1,s_2)$ ，由于 $s_1 \mid \varphi(m),s_2 \mid \varphi(m)$ ，那么 $lcm(s_1,s_2) \mid \varphi(m)$ ，所以 $s \mid \varphi(m)$ ， $r=\max(\lceil \frac{r_i}{k_i} \rceil) \le \max(r_i) \le \varphi(m)$ ；

    由 $r,s$ 与 $\varphi(m)$ 的关系，依然可以得到 $a^b\equiv a^{b \mod \varphi(m)+\varphi(m)}\pmod m$ ；

    证毕。

## 习题

1.   [SPOJ #4141 "Euler Totient Function"\[Difficulty: CakeWalk\]](http://www.spoj.com/problems/ETF/) 
2.   [UVA #10179 "Irreducible Basic Fractions"\[Difficulty: Easy\]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1120) 
3.   [UVA #10299 "Relatives"\[Difficulty: Easy\]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1240) 
4.   [UVA #11327 "Enumerating Rational Numbers"\[Difficulty: Medium\]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2302) 
5.   [TIMUS #1673 "Admission to Exam"\[Difficulty: High\]](http://acm.timus.ru/problem.aspx?space=1&num=1673) 

# game-theory
author: cutekibry, zj713300

 **博弈论** ，是经济学的一个分支，主要研究具有竞争或对抗性质的对象，在一定规则下产生的各种行为。博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。

通俗地讲，博弈论主要研究的是：在一个游戏中，进行游戏的多位玩家的策略。

## 公平组合游戏

公平组合游戏的定义如下：

-   游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息；

-   任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关；

-   游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。

大部分的棋类游戏都 **不是** 公平组合游戏，如国际象棋、中国象棋、围棋、五子棋等（因为双方都不能使用对方的棋子）。

## Nim 游戏

 $n$ 堆物品，每堆有 $a_i$ 个，两个玩家轮流取走任意一堆的任意个物品，但不能不取。

取走最后一个物品的人获胜。

例如，如果现在有 $n=3$ 堆物品，而每堆分别有 $2, 5, 4$ 个，那么可以取走第 $1$ 堆中的 $2$ 个物品，局面就变成了 $0, 5, 4$ ；或者也可以取走第 $2$ 堆的 $4$ 个物品，局面就变成了 $2, 1, 4$ 。

如果现在的局面为 $0, 0, 5$ ，甲取走了第 $3$ 堆的 $5$ 个物品，也就是取走了最后一个物品，此时甲获胜。

## 博弈图和状态

如果将每个状态视为一个节点，再从每个状态向它的后继状态连边，我们就可以得到一个博弈状态图。

例如，如果节点 $(i, j, k)$ 表示局面为 $i, j, k$ 时的状态，则我们可以画出下面的博弈图（由于篇幅有限，故仅显示部分状态节点和部分边）：

![博弈图的例子](./images/game1.png)

定义 **必胜状态** 为 **先手必胜的状态** ， **必败状态** 为 **先手必败的状态** 。

通过推理，我们可以得出下面三条定理：

-   定理 1：没有后继状态的状态是必败状态。
-   定理 2：一个状态是必胜状态当且仅当存在至少一个必败状态为它的后继状态。
-   定理 3：一个状态是必败状态当且仅当它的所有后继状态均为必胜状态。

对于定理 1，如果游戏进行不下去了，那么这个玩家就输掉了游戏。

对于定理 2，如果该状态至少有一个后继状态为必败状态，那么玩家可以通过操作到该必败状态；此时对手的状态为必败状态——对手必定是失败的，而相反地，自己就获得了胜利。

对于定理 3，如果不存在一个后继状态为必败状态，那么无论如何，玩家只能操作到必胜状态；此时对手的状态为必胜状态——对手必定是胜利的，自己就输掉了游戏。

如果博弈图是一个有向无环图，则通过这三个定理，我们可以在绘出博弈图的情况下用 $O(N+M)$ 的时间（其中 $N$ 为状态种数， $M$ 为边数）得出每个状态是必胜状态还是必败状态。

## Nim 和

让我们再次回顾 Nim 游戏。

通过绘画博弈图，我们可以在 $O(\prod_{i=1}^n a_i)$ 的时间里求出该局面是否先手必赢。

但是，这样的时间复杂度实在太高。有没有什么巧妙而快速的方法呢？

定义 Nim 和 $=a_1 \oplus a_2 \oplus \ldots \oplus a_n$ 。

当且仅当 Nim 和为 $0$ 时，该状态为必败状态；否则该状态为必胜状态。

### 证明

为什么异或值会和状态的胜负有关？下面给出了这个定理的证明过程。

为了证明该定理，只需要证明下面三个定理：

-   定理 1：没有后继状态的状态是必败状态。
-   定理 2：对于 $a_1 \oplus a_2 \oplus \ldots \oplus a_n \neq 0$ 的局面，一定存在某种移动使得 $a_1 \oplus a_2 \oplus \ldots \oplus a_n = 0$ 。
-   定理 3：对于 $a_1 \oplus a_2 \oplus \ldots \oplus a_n = 0$ 的局面，一定不存在某种移动使得 $a_1 \oplus a_2 \oplus \ldots \oplus a_n = 0$ 。

对于定理 1，没有后继状态的状态只有一个，即全 $0$ 局面。此时 $a_1 \oplus a_2 \oplus \ldots \oplus a_n = 0$ 。

对于定理 2，不放假设 $a_1 \oplus a_2 \oplus \ldots a_n = k \neq 0$ 。如果我们要将 $a_i$ 改为 $a_i'$ ，则 $a_i'=a_i \oplus k$ 。

根据异或定义，一定有奇数个 $a_i$ 在 $k$ 在二进制下的最高位为 $1$ 。满足这个条件的 $a_i$ 一定也满足 $a_i > a_i \oplus k$ ，因而这也是个合法的移动。

对于定理 3，如果我们要将 $a_i$ 改为 $a_i'$ ，则根据异或运算律可以得出 $a_i=a_i'$ ，因而这不是个合法的移动。

## 有向图游戏与 SG 函数

有向图游戏是一个经典的博弈游戏——实际上，大部分的公平组合游戏都可以转换为有向图游戏。

在一个有向无环图中，只有一个起点，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，不能走的玩家判负。

定义 $\operatorname{mex}$ 函数的值为不属于集合 $S$ 中的最小非负整数，即：

$$
\operatorname{mex}(S)=\min\{x\} \quad (x \notin S, x \in N)
$$

例如 $\operatorname{mex}(\{0, 2, 4\})=1$ ， $\operatorname{mex}(\{1, 2\})=0$ 。

对于状态 $x$ 和它的所有 $k$ 个后继状态 $y_1, y_2, \ldots, y_k$ ，定义 $\operatorname{SG}$ 函数：

$$
\operatorname{SG}(x)=\operatorname{mex}\{\operatorname{SG}(y_1), \operatorname{SG}(y_2), \ldots, \operatorname{SG}(y_k)\}
$$

而对于由 $n$ 个有向图游戏组成的组合游戏，设它们的起点分别为 $s_1, s_2, \ldots, s_n$ ，则有定理： **当且仅当 $\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \ldots \oplus \operatorname{SG}(s_n) \neq 0$ 时，这个游戏是先手必胜的。** 

这一定理被称作 SG 定理。

## 将 Nim 游戏转换为有向图游戏

我们可以将一个有 $x$ 个物品的堆视为节点 $x$ ，则当且仅当 $y<x$ 时，节点 $x$ 可以到达 $y$ 。

那么，由 $n$ 个堆组成的 Nim 游戏，就可以视为 $n$ 个有向图游戏了。

根据上面的推论，可以得出 $\operatorname{SG}(x)=x$ 。再根据 SG 定理，就可以得出 Nim 和的结论了。

## 参考文献

 [（转载）Nim 游戏博弈（收集完全版）- exponent - 博客园](http://www.cnblogs.com/exponent/articles/2141477.html) 

 [\[组合游戏与博弈论\]【学习笔记】- Candy? - 博客园](https://www.cnblogs.com/candy99/p/6548836.html) 

# basis
线性基是向量空间的一组基，通常可以解决有关异或的一些题目。

通俗一点的讲法就是由一个集合构造出来的另一个集合，它有以下几个性质：

-   线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。

-   线性基是满足性质 1 的最小的集合。

-   线性基没有异或和为 0 的子集。

-   线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。

-   线性基中每个元素的二进制最高位互不相同。

构造线性基的方法如下：

对原集合的每个数 p 转为二进制，从高位向低位扫，对于第 $x$ 位是 1 的，如果 $a_x$ 不存在，那么令 $a_x=p$ 并结束扫描，如果存在，令 $p=p~\text{xor}~a_x$ 。

代码：

```cpp
inline void insert(long long x) {
  for (int i = 55; i + 1; i--) {
    if (!(x >> i))  // x的第i位是0
      continue;
    if (!p[i]) {
      p[i] = x;
      break;
    }
    x ^= p[i];
  }
}
```

查询原集合内任意几个元素 xor 的最大值，就可以用线性基解决。

将线性基从高位向低位扫，若 xor 上当前扫到的 $a_x$ 答案变大，就把答案异或上 $a_x$ 。

为什么能行呢？因为从高往低位扫，若当前扫到第 $i$ 位，意味着可以保证答案的第 $i$ 位为 1，且后面没有机会改变第 $i$ 位。

查询原集合内任意几个元素 xor 的最小值，就是线性基集合所有元素中最小的那个。

查询某个数是否能被异或出来，类似于插入，如果最后插入的数 $p$ 被异或成了 0，则能被异或出来。

## 线性基练习题

 [SGU 275 to xor or not xor](https://vjudge.net/problem/SGU-275) 

 [HDU 3949 XOR](https://loj.ac/problem/161) 

 [Luogu P4151\[WC2011\]最大 XOR 和路径](https://www.luogu.com.cn/problem/P4151) 

# matrix
本文介绍线性代数中一个非常重要的内容——矩阵（Matrix），主要讲解矩阵的性质、运算以及在常系数齐次递推式上的应用。

## 定义

对于矩阵 $A$ ，主对角线是指 $A_{i,i}$ 的元素。

一般用 $I$ 来表示单位矩阵，就是主对角线上为 1，其余位置为 0。

## 性质

### 矩阵的逆

 $A$ 的逆矩阵 $P$ 是使得 $A \times P = I$ 的矩阵。

逆矩阵可以用 [高斯消元](./gauss.md) 的方式来求。

## 运算

矩阵的加减法是逐个元素进行的。

### 矩阵乘法

矩阵相乘只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。

设 $A$ 为 $P \times M$ 的矩阵， $B$ 为 $M \times Q$ 的矩阵，设矩阵 $C$ 为矩阵 $A$ 与 $B$ 的乘积，

其中矩阵 $C$ 中的第 $i$ 行第 $j$ 列元素可以表示为：

$$
C_{i,j} = \sum_{k=1}^MA_{i,k}B_{k,j}
$$

如果没看懂上面的式子，没关系。通俗的讲，在矩阵乘法中，结果 $C$ 矩阵的第 $i$ 行第 $j$ 列的数，就是由矩阵 $A$ 第 $i$ 行 $M$ 个数与矩阵 $B$ 第 $j$ 列 $M$ 个数分别相乘再相加得到的。

矩阵乘法满足结合律，不满足一般的交换律。

利用结合律，矩阵乘法可以利用 [快速幂](./quick-pow.md) 的思想来优化。

在比赛中，由于线性递推式可以表示成矩阵乘法的形式，也通常用矩阵快速幂来求线性递推数列的某一项。

#### 优化

首先对于比较小的矩阵，可以考虑直接手动展开循环以减小常数。

可以重新排列循环以提高空间局部性，这样的优化不会改变矩阵乘法的时间复杂度，但是会在得到常数级别的提升。

```cpp
// 以下文的参考代码为例
inline mat operator*(const mat& T) const {
  mat res;
  for (int i = 0; i < sz; ++i)
    for (int j = 0; j < sz; ++j)
      for (int k = 0; k < sz; ++k) {
        res.a[i][j] += mul(a[i][k], T.a[k][j]);
        res.a[i][j] %= MOD;
      }
  return res;
}
// 不如
inline mat operator*(const mat& T) const {
  mat res;
  int r;
  for (int i = 0; i < sz; ++i)
    for (int k = 0; k < sz; ++k) {
      r = a[i][k];
      for (int j = 0; j < sz; ++j) res.a[i][j] += T.a[k][j] * r;
      res.a[i][j] %= MOD;
    }
  return res;
}
```

## 参考代码

一般来说，可以用一个二维数组来模拟矩阵。

```cpp
struct mat {
  LL a[sz][sz];
  inline mat() { memset(a, 0, sizeof a); }
  inline mat operator+(const mat& T) const {
    mat res;
    for (int i = 0; i < sz; ++i)
      for (int j = 0; j < sz; ++j)
        res.a[i][j] = (a[i][j] - T.a[i][j] + MOD) % MOD;
    return res;
  }
  inline mat operator-(const mat& T) const {
    mat res;
    for (int i = 0; i < sz; ++i)
      for (int j = 0; j < sz; ++j) res.a[i][j] = (a[i][j] + T.a[i][j]) % MOD;
    return res;
  }
  inline mat operator*(const mat& T) const {
    mat res;
    int r;
    for (int i = 0; i < sz; ++i)
      for (int k = 0; k < sz; ++k) {
        r = a[i][k];
        for (int j = 0; j < sz; ++j)
          res.a[i][j] += T.a[k][j] * r, res.a[i][j] %= MOD;
      }
    return res;
  }
  inline mat operator^(LL x) const {
    mat res, bas;
    for (int i = 0; i < sz; ++i) res.a[i][i] = 1;
    for (int i = 0; i < sz; ++i)
      for (int j = 0; j < sz; ++j) bas.a[i][j] = a[i][j];
    while (x) {
      if (x & 1) res = res * bas;
      bas = bas * bas;
      x >>= 1;
    }
    return res;
  }
};
```

## 应用

### 矩阵加速递推

斐波那契数列（Fibonacci Sequence）大家应该都非常的熟悉了。在斐波那契数列当中， $F_1 = F_2 = 1$ ， $F_i = F_{i - 1} + F_{i - 2}(i \geq 3)$ 。

如果有一道题目让你求斐波那契数列第 $n$ 项的值，最简单的方法莫过于直接递推了。但是如果 $n$ 的范围达到了 $10^{18}$ 级别，递推就不行了，稳 TLE。考虑矩阵加速递推。

设 $Fib(n)$ 表示一个 $1 \times 2$ 的矩阵 $\left[ \begin{array}{ccc}F_n & F_{n-1} \end{array}\right]$ 。我们希望根据 $Fib(n-1)=\left[ \begin{array}{ccc}F_{n-1} & F_{n-2} \end{array}\right]$ 推出 $Fib(n)$ 。

试推导一个矩阵 $\text{base}$ ，使 $Fib(n-1) \times \text{base} = Fib(n)$ ，即 $\left[\begin{array}{ccc}F_{n-1} & F_{n-2}\end{array}\right] \times \text{base} = \left[ \begin{array}{ccc}F_n & F_{n-1} \end{array}\right]$ 。

怎么推呢？因为 $F_n=F_{n-1}+F_{n-2}$ ，所以 $\text{base}$ 矩阵第一列应该是 $\left[\begin{array}{ccc} 1 \\ 1 \end{array}\right]$ ，这样在进行矩阵乘法运算的时候才能令 $F_{n-1}$ 与 $F_{n-2}$ 相加，从而得出 $F_n$ 。同理，为了得出 $F_{n-1}$ ，矩阵 $\text{base}$ 的第二列应该为 $\left[\begin{array}{ccc} 1 \\ 0 \end{array}\right]$ 。

综上所述： $\text{base} = \left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]$ 原式化为 $\left[\begin{array}{ccc}F_{n-1} & F_{n-2}\end{array}\right] \times \left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right] = \left[ \begin{array}{ccc}F_n & F_{n-1} \end{array}\right]$ 

转化为代码，应该怎么求呢？

定义初始矩阵 $\text{ans} = \left[\begin{array}{ccc}F_2 & F_1\end{array}\right] = \left[\begin{array}{ccc}1 & 1\end{array}\right], \text{base} = \left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]$ 。那么， $F_n$ 就等于 $\text{ans} \times \text{base}^{n-2}$ 这个矩阵的第一行第一列元素，也就是 $\left[\begin{array}{ccc}1 & 1\end{array}\right] \times \left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]^{n-2}$ 的第一行第一列元素。

注意，矩阵乘法不满足交换律，所以一定不能写成 $\left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]^{n-2} \times \left[\begin{array}{ccc}1 & 1\end{array}\right]$ 的第一行第一列元素。另外，对于 $n \leq 2$ 的情况，直接输出 $1$ 即可，不需要执行矩阵快速幂。

为什么要乘上 $\text{base}$ 矩阵的 $n-2$ 次方而不是 $n$ 次方呢？因为 $F_1, F_2$ 是不需要进行矩阵乘法就能求的。也就是说，如果只进行一次乘法，就已经求出 $F_3$ 了。如果还不是很理解为什么幂是 $n-2$ ，建议手算一下。

下面是求斐波那契数列第 $n$ 项对 $10^9+7$ 取模的示例代码（核心部分）。

```cpp
const int mod = 1000000007;

struct Matrix {
  int a[3][3];
  Matrix() { memset(a, 0, sizeof a); }
  Matrix operator*(const Matrix &b) const {
    Matrix res;
    for (int i = 1; i <= 2; ++i)
      for (int j = 1; j <= 2; ++j)
        for (int k = 1; k <= 2; ++k)
          res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;
    return res;
  }
} ans, base;

void init() {
  base.a[1][1] = base.a[1][2] = base.a[2][1] = 1;
  ans.a[1][1] = ans.a[1][2] = 1;
}

void qpow(int b) {
  while (b) {
    if (b & 1) ans = ans * base;
    base = base * base;
    b >>= 1;
  }
}

int main() {
  int n = read();
  if (n <= 2) return puts("1"), 0;
  init();
  qpow(n - 2);
  println(ans.a[1][1] % mod);
}
```

* * *

这是一个稍微复杂一些的例子。

$$
f_{1} = f_{2} = 0\\
f_{n} = 7f_{n-1}+6f_{n-2}+5n+4\times 3^n
$$

我们发现， $f_n$ 和 $f_{n-1}, f_{n-2}, n$ 有关，于是考虑构造一个矩阵描述状态。

但是发现如果矩阵仅有这三个元素 $\begin{bmatrix}f_n& f_{n-1}& n\end{bmatrix}$ 是难以构造出转移方程的，因为乘方运算和 $+1$ 无法用矩阵描述。

于是考虑构造一个更大的矩阵。

$$
\begin{bmatrix}f_n& f_{n-1}& n& 3^n & 1\end{bmatrix}
$$

我们希望构造一个递推矩阵可以转移到

$$
\begin{bmatrix}
f_{n+1}& f_{n}& n+1& 3^{n+1} & 1
\end{bmatrix}
$$

转移矩阵即为

$$
\begin{bmatrix}
7 & 1 & 0 & 0 & 0\\
6 & 0 & 0 & 0 & 0\\
5 & 0 & 1 & 0 & 0\\
12 & 0 & 0 & 3 & 0\\
5 & 0 & 1 & 0 & 1
\end{bmatrix}
$$

### 矩阵表达修改

???+note "「THUSCH 2017」大魔法师"
    ~~中二病患者~~大魔法师小 L 制作了 $n$ 个魔力水晶球，每个水晶球有水、火、土三个属性的能量值。小 L 把这 $n$ 个水晶球在地上从前向后排成一行，然后开始今天的魔法表演。

    我们用 $A_i,\ B_i,\ C_i$ 分别表示从前向后第 $i$ 个水晶球（下标从 $1$ 开始）的水、火、土的能量值。

    小 L 计划施展 $m$ 次魔法。每次，他会选择一个区间 $[l, r]$，然后施展以下 $3$ 大类、$7$ 种魔法之一：

    1. 魔力激发：令区间里每个水晶球中**特定属性**的能量爆发，从而使另一个**特定属性**的能量增强。具体来说，有以下三种可能的表现形式：

       - 火元素激发水元素能量：令 $A_i = A_i + B_i$。
       - 土元素激发火元素能量：令 $B_i = B_i + C_i$。
       - 水元素激发土元素能量：令 $C_i = C_i + A_i$。

       **需要注意的是，增强一种属性的能量并不会改变另一种属性的能量，例如 $A_i = A_i + B_i$ 并不会使 $B_i$ 增加或减少。**

    2. 魔力增强：小 L 挥舞法杖，消耗自身 $v$ 点法力值，来改变区间里每个水晶球的**特定属性**的能量。具体来说，有以下三种可能的表现形式：

       - 火元素能量定值增强：令 $A_i = A_i + v$。
       - 水元素能量翻倍增强：令 $B_i=B_i \cdot v$。
       - 土元素能量吸收融合：令 $C_i = v$。

    3. 魔力释放：小L将区间里所有水晶球的能量聚集在一起，融合成一个新的水晶球，然后送给场外观众。生成的水晶球每种属性的能量值等于区间内所有水晶球对应能量值的代数和。**需要注意的是，魔力释放的过程不会真正改变区间内水晶球的能量**。

    值得一提的是，小 L 制造和融合的水晶球的原材料都是定制版的 OI 工厂水晶，所以这些水晶球有一个能量阈值 $998244353$。当水晶球中某种属性的能量值大于等于这个阈值时，能量值会自动对阈值取模，从而避免水晶球爆炸。

    小 W 为小 L（唯一的）观众，围观了整个表演，并且收到了小 L 在表演中融合的每个水晶球。小 W 想知道，这些水晶球蕴涵的三种属性的能量值分别是多少。

由于矩阵的结合律和分配律成立，单点修改可以自然地推广到区间，即推出矩阵后直接用线段树维护区间矩阵乘积即可。

下面将举几个例子。

 $A_i = A_i + v$ 的转移

$$
\begin{bmatrix}
A & B & C & 1
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
v & 0 & 0 & 1\\
\end{bmatrix}=
\begin{bmatrix}
A+v & B & C & 1\\
\end{bmatrix}
$$

 $B_i=B_i \cdot v$ 的转移

$$
\begin{bmatrix}
A & B & C & 1
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & v & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1\\
\end{bmatrix}=
\begin{bmatrix}
A & B \cdot v & C & 1\\
\end{bmatrix}
$$

* * *

???+note "「LibreOJ 6208」树上询问"
    有一棵 $n$ 节点的树，根为 $1$ 号节点。每个节点有两个权值 $k_i, t_i$ ，初始值均为 $0$ 。

    给出三种操作：
    1. $\operatorname{Add}( x , d )$ 操作：将 $x$ 到根的路径上所有点的 $k_i\leftarrow k_i + d$
    2. $\operatorname{Mul}( x , d )$ 操作：将 $x$ 到根的路径上所有点的 $t_i\leftarrow t_i + d \times k_i$
    3. $\operatorname{Query}( x )$ 操作：询问点 $x$ 的权值 $t_x$ 

    $n,~m \leq 100000, ~-10 \leq d \leq 10$

若直接思考，下放操作和维护信息并不是很好想。但是矩阵可以轻松地表达。

$$
\begin{aligned}
\begin{bmatrix}k & t & 1 \end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
d & 0 & 1
\end{bmatrix}
&=
\begin{bmatrix}k+d & t & 1 \end{bmatrix}\\
\begin{bmatrix}k & t & 1 \end{bmatrix}
\begin{bmatrix}
1 & d & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}
&=
\begin{bmatrix}k & t+d \times k & 1 \end{bmatrix}
\end{aligned}
$$

### 定长路径统计

???+note "问题描述"
    给一个 $n$ 阶有向图，每条边的边权均为 $1$ ，然后给一个整数 $k$ ，你的任务是对于所有点对 $(u,v)$ 求出从 $u$ 到 $v$ 长度为 $k$ 的路径的数量（不一定是简单路径，即路径上的点或者边可能走多次）。

我们将这个图用邻接矩阵 $G$ （对于图中的边 $(u\to v)$ ，令 $G[u,v]=1$ ，其余为 $0$ 的矩阵；如果有重边，则设 $G[u,v]$ 为重边的数量）表示这个有向图。下述算法同样适用于图有自环的情况。

显然，该邻接矩阵对应 $k=1$ 时的答案。

假设我们知道长度为 $k$ 的路径条数构成的矩阵，记为矩阵 $C_k$ ，我们想求 $C_{k+1}$ 。显然有 DP 转移方程

$$
C_{k+1}[i,j] = \sum_{p = 1}^{n} C_k[i,p] \cdot G[p,j]
$$

我们可以把它看作矩阵乘法的运算，于是上述转移可以描述为

$$
C_{k+1} = C_k \cdot G
$$

那么把这个递推式展开可以得到

$$
C_k = \underbrace{G \cdot G \cdots G}_{k \text{ 次}} = G^k
$$

要计算这个矩阵幂，我们可以使用快速幂（二进制取幂）的思想，在 $O(n^3 \log k)$ 的复杂度内计算结果。

### 定长最短路

???+note "问题描述"
    给你一个 $n$ 阶加权有向图和一个整数 $k$ 。对于每个点对 $(u,v)$ 找到从 $u$ 到 $v$ 的恰好包含 $k$ 条边的最短路的长度。（不一定是简单路径，即路径上的点或者边可能走多次）

我们仍构造这个图的邻接矩阵 $G$ ， $G[i,j]$ 表示从 $i$ 到 $j$ 的边权。如果 $i,j$ 两点之间没有边，那么 $G[i,j]=\infty$ 。（有重边的情况取边权的最小值）

显然上述矩阵对应 $k=1$ 时问题的答案。我们仍假设我们知道 $k$ 的答案，记为矩阵 $L_k$ 。现在我们想求 $k+1$ 的答案。显然有转移方程

$$
L_{k+1}[i,j] = \min_{1\le p \le n} \left\{L_k[i,p] + G[p,j]\right\}
$$

事实上我们可以类比矩阵乘法，你发现上述转移只是把矩阵乘法的乘积求和变成相加取最小值，于是我们定义这个运算为 $\odot$ ，即

$$
A \odot B = C~~\Longleftrightarrow~~C[i,j]=\min_{1\le p \le n}\left\{A[i,p] + B[p,j]\right\}
$$

于是得到

$$
L_{k+1} = L_k \odot G
$$

展开递推式得到

$$
L_k = \underbrace{G \odot \ldots \odot G}_{k\text{ 次}} = G^{\odot k}
$$

我们仍然可以用矩阵快速幂的方法计算上式，因为它显然是具有结合律的。时间复杂度 $O(n^3 \log k)$ 。

### 限长路径计数/最短路

上述算法只适用于边数固定的情况。然而我们可以改进算法以解决边数小于等于 $k$ 的情况。具体地，考虑以下问题：

???+note "问题描述"
    给一个 $n$ 阶有向图，边权为 $1$ ，然后给一个整数 $k$ ，你的任务是对于每个点对 $(u,v)$ 找到从 $u$ 到 $v$ 长度小于等于 $k$ 的路径的数量（不一定是简单路径，即路径上的点或者边可能走多次）。

我们简单修改一下这个图，我们给每一个结点加一个权值为 $1$ 的自环。这样走的时侯就可以走自环，相当于原地走。这样就包含了小于等于 $k$ 的情况。修改后再做矩阵快速幂即可。（即使这个图在修改之前就有自环，该算法仍是成立的）。

同样的方法可以用于求边数小于等于 $k$ 的最短路，即加一个边权为 $0$ 的自环。

## 习题

-    [洛谷 P1962 斐波那契数列](https://www.luogu.org/problemnew/show/P1962) ，即上面的例题，同题 POJ3070
-    [洛谷 P1349 广义斐波那契数列](https://www.luogu.org/problemnew/show/P1349) ， $\text{base}$ 矩阵需要变化一下
-    [洛谷 P1939【模板】矩阵加速（数列）](https://www.luogu.org/problemnew/show/P1939) ， $\text{base}$ 矩阵变成了 $3 \times 3$ 的矩阵，推导过程与上面差不多。

     **本页面部分内容译自博文 [Кратчайшие пути фиксированной длины, количества путей фиксированной длины](http://e-maxx.ru/algo/fixed_length_paths) 与其英文翻译版 [Number of paths of fixed length/Shortest paths of fixed length](https://cp-algorithms.com/graph/fixed_length_paths.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# bit
位运算就是基于整数的二进制表示进行的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。

常用的运算符共 6 种，分别为与（ `&` ）、或（ `|` ）、异或（ `^` ）、取反（ `~` ）、左移（ `<<` ）和右移（ `>>` ）。

## 与、或、异或

与（ `&` ）或（ `|` ）和异或（ `^` ）这三者都是两数间的运算，因此在这里一起讲解。

它们都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。

|  运算符  |          解释         |
| :---: | :-----------------: |
|  `&`  |  只有两个对应位都为 1 时才为 1  |
|  `|`  | 只要两个对应位中有一个 1 时就为 1 |
|  `^`  |    只有两个对应位不同时才为 1   |

异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 $a \text{^} b \text{^} b = a$ 。

举例：

$$
\begin{aligned}
5 &=(101)_2\\
6 &=(110)_2\\
5\&6 &=(100)_2 =\ 4\\
5|6 &=(111)_2 =\ 7\\
5\text{^}6 &=(011)_2 =\ 3\\
\end{aligned}
$$

## 取反

取反是对一个数 $num$ 进行的计算，即单目运算。

 `~` 把 $num$ 的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）。

补码：在二进制表示下，正数的补码为其本身，负数的补码是其按位取反后加一，符号位（即第一位）不变。有符号整数的符号位在 `~` 运算中同样会取反。

举例（有符号整数）：

$$
\begin{aligned}
5&=(00000101)_2\\
\text{~}5&=(11111010)_2=-6\\
-5\text{ 的补码}&=(11111011)_2\\
\text{~}(-5)&=(00000100)_2=4
\end{aligned}
$$

## 左移和右移

 `num << i` 表示将 $num$ 的二进制表示向左移动 $i$ 位所得的值。

 `num >> i` 表示将 $num$ 的二进制表示向右移动 $i$ 位所得的值。

举例：

$$
\begin{aligned}
11&=(00001011)_2\\
11<<3&=(01011000)_2=88\\
11>>2&=(00000010)_2=2
\end{aligned}
$$

在 C++ 中，右移操作中右侧多余的位将会被舍弃，而左侧较为复杂：对于无符号数，会在左侧补 0；而对于有符号数，则会用最高位的数（其实就是符号位，非负数为 0，负数为 1）补齐。左移操作总是在右侧补 0。

## 复合赋值位运算符

和 `+=` , `-=` 等运算符类似，位运算也有复合赋值运算符： `&=` , `|=` , `^=` , `<<=` , `>>=` 。（取反是单目运算，所以没有。）

## 关于优先级

位运算的优先级低于算术运算符（除了取反），而按位与、按位或及异或低于比较运算符（详见 [运算页面](../lang/op.md) ），所以使用时需多加注意，在必要时添加括号。

## 位运算的应用

位运算一般有三种作用：

1.  高效地进行某些运算，代替其它低效的方式。

2.  表示集合。（常用于 [状压 DP](../dp/state.md) 。）

3.  题目本来就要求进行位运算。

需要注意的是，用位运算代替其它运算方式（即第一种应用）在很多时候并不能带来太大的优化，反而会使代码变得复杂，使用时需要斟酌。（但像“乘 2 的非负整数次幂”和“除以 2 的非负整数次幂”就最好使用位运算，因为此时使用位运算可以优化复杂度。）

### 乘 2 的非负整数次幂

```cpp
int mulPowerOfTwo(int n, int m) {  // 计算 n*(2^m)
  return n << m;
}
```

### 除以 2 的非负整数次幂

```cpp
int divPowerOfTwo(int n, int m) {  // 计算 n/(2^m)
  return n >> m;
}
```

!!! warning
    我们平常写的除法是向 0 取整，而这里的右移是向下取整（注意这里的区别），即当数大于等于 0 时两种方法等价，当数小于 0 时会有区别，如： `-1 / 2` 的值为 $0$ ，而 `-1 >> 1` 的值为 $-1$ 。

### 判断一个数是不是 2 的正整数次幂

```cpp
bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; }
```

### 对 2 的非负整数次幂取模

```cpp
int modPowerOfTwo(int x, int mod) { return x & (mod - 1); }
```

### 取绝对值

在某些机器上，效率比 `n > 0 ? n : -n` 高。

```cpp
int Abs(int n) {
  return (n ^ (n >> 31)) - (n >> 31);
  /* n>>31 取得 n 的符号，若 n 为正数，n>>31 等于 0，若 n 为负数，n>>31 等于 -1
     若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1)
     需要计算 n 和 -1 的补码，然后进行异或运算，
     结果 n 变号并且为 n 的绝对值减 1，再减去 -1 就是绝对值 */
}
```

### 取两个数的最大/最小值

在某些机器上，效率比 `a > b ? a : b` 高。

```cpp
// 如果 a>=b,(a-b)>>31 为 0，否则为 -1
int max(int a, int b) { return b & ((a - b) >> 31) | a & (~(a - b) >> 31); }
int min(int a, int b) { return a & ((a - b) >> 31) | b & (~(a - b) >> 31); }
```

### 判断符号是否相同

```cpp
bool isSameSign(int x, int y) {  // 有 0 的情况例外
  return (x ^ y) >= 0;
}
```

### 交换两个数

```cpp
void swap(int &a, int &b) { a ^= b ^= a ^= b; }
```

### 获取一个数二进制的某一位

```cpp
// 获取 a 的第 b 位，最低位编号为 0
int getBit(int a, int b) { return (a >> b) & 1; }
```

### 表示集合

一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。比如集合 `{1, 3, 4, 8}` ，可以表示成 $(100011010)_2$ 。而对应的位运算也就可以看作是对集合进行的操作。

| 操作  |        集合表示       |        位运算语句       |
| --- | :---------------: | :----------------: |
| 交集  |     $a \cap b$    |       `a & b`      |
| 并集  |     $a \cup b$    |        `a|b`       |
| 补集  |     $\bar{a}$     |  `~a` （全集为二进制都是 1） |
| 差集  |  $a \setminus b$  |     `a & (~b)`     |
| 对称差 |   $a\triangle b$  |       `a ^ b`      |

### 遍历某个集合的子集

```cpp
// 遍历 u 的非空子集
for (int s = u; s; s = (s - 1) & u) {
  // s 是 u 的一个非空子集
}
```

用这种方法可以在 $O(2^{popcount(u)})$ （ $popcount(u)$ 表示 $u$ 二进制中 1 的个数）的时间复杂度内遍历 $u$ 的子集，进而可以在 $O(3^n)$ 的时间复杂度内遍历大小为 $n$ 的集合的每个子集的子集。（复杂度为 $O(3^n)$ 是因为每个元素都有 不在大子集中/只在大子集中/同时在大小子集中 三种状态。）

## 内建函数

GCC 中还有一些用于位运算的内建函数：

1.   `int __builtin_ffs(int x)` ：返回 $x$ 的二进制末尾最后一个 $1$ 的位置，位置的编号从 $1$ 开始（最低位编号为 $1$ ）。当 $x$ 为 $0$ 时返回 $0$ 。

2.   `int __builtin_clz(unsigned int x)` ：返回 $x$ 的二进制的前导 $0$ 的个数。当 $x$ 为 $0$ 时，结果未定义。

3.   `int __builtin_ctz(unsigned int x)` ：返回 $x$ 的二进制末尾连续 $0$ 的个数。当 $x$ 为 $0$ 时，结果未定义。

4.   `int __builtin_clrsb(int x)` ：当 $x$ 的符号位为 $0$ 时返回 $x$ 的二进制的前导 $0$ 的个数减一，否则返回 $x$ 的二进制的前导 $1$ 的个数减一。

5.   `int __builtin_popcount(unsigned int x)` ：返回 $x$ 的二进制中 $1$ 的个数。

6.   `int __builtin_parity(unsigned int x)` ：判断 $x$ 的二进制中 $1$ 的个数的奇偶性。

这些函数都可以在函数名末尾添加 `l` 或 `ll` （如 `__builtin_popcountll` ）来使参数类型变为 ( `unsigned` ) `long` 或 ( `unsigned` ) `long long` （返回值仍然是 `int` 类型）。
例如，我们有时候希望求出一个数以二为底的对数，如果不考虑 `0` 的特殊情况，就相当于这个数二进制的位数 `-1` ，而一个数 `n` 的二进制表示的位数可以使用 `32-__builtin_clz(n)` 表示，因此 `31-__builtin_clz(n)` 就可以求出 `n` 以二为底的对数。

由于这些函数是内建函数，经过了编译器的高度优化，运行速度十分快（有些甚至只需要一条指令）。

## 更多位数

如果需要操作的集合非常大，可以使用 [bitset](../lang/csl/bitset.md) 。

## 题目推荐

 [Luogu P1225 黑白棋游戏](https://www.luogu.com.cn/problem/P1225) 

## 参考

位运算技巧： <https://graphics.stanford.edu/~seander/bithacks.html> 

Other Builtins of GCC： <https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html> 

# stirling
## 第一类斯特林数（Stirling Number）

设有多项式 $x(x-1)(x-2) \cdots (x-n+1)$ ，它的展开式形如 $s_nx^n - s_{n-1}x^{n-1}+s_{n-2}x^{n-2}-\cdots$ 。

不考虑各项系数的符号，将 $x^r$ 的系数的绝对值记做 $s(n, r)$ ，称为第一类 Stirling 数。

 $s(n, r)$ 也是把 $n$ 个不同的球排成 $r$ 个非空循环排列的方法数。

关于第一类斯特林数的性质可以阅读 [Stirling Number of the First Kind](http://mathworld.wolfram.com/StirlingNumberoftheFirstKind.html) 。

### 递推形式

$$
s(n,r) = (n-1)s(n-1,r)+s(n-1,r-1),\ n > r \geq 1
$$

考虑最后一个球，它可以单独构成一个非空循环排列，也可以插入到前面的某一个球的一侧。

若单独放，则有 $s(n-1,r-1)$ 种放法；若放在某个球的一侧，则有 $(n-1)s(n-1,r)$ 种放法。

## 第二类斯特林数（Stirling Number）

把 $n$ 个不同的球放到 $r$ 个相同的盒子里，假设没有空盒，则放球方案数记做 $S(n, r)$ ，称为第二类 Stirling 数。

关于第二类斯特林数的性质可以阅读 [Stirling Number of the Second Kind](http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html) 。

### 递推形式

$$
S(n,r) = r S(n-1,r) + S(n-1,r-1),\ n > r \geq 1
$$

考虑最后一个球，若它单独放一个盒子，有 $S(n-1,r-1)$ 种放法；若是和前面的某一个球放在同一个盒子里，则有 $r S(n-1,r)$ 种放法。

## 例题

（2007 普及）将 $n$ 个数 $（1，2，…，n）$ 分成 $r$ 个部分。每个部分至少一个数。将不同划分方法的总数记为 $S_n^r$ 。例如， $S_4^2=7$ ，这 7 种不同的划分方法依次为 $\{\ (1) , (234) \}\,\{\ (2) ,  (134) \}\,\{\ (3) , (124) \}\,\{\ (4) , (123) \}\,\{\ (12) , (34) \}\,\{\ (13) , (24) \}\,\{\ (14) , (23) \}$ 。当 $n=6，r=3$ 时， $S_6^3$ =（）

> 提示：先固定一个数，对于其余的 5 个数考虑 $S_5^3$ 与 $S_5^2$ ，再分这两种情况对原固定的数进行分析。

题解：在近几年算法竞赛中，递推算法越来越重要：

$$
S_6^3=3 \times S_5^3 + S_5^2
$$

$$
S_5^3=3 \times S_4^3 + S_4^2
$$

$$
S_5^2=2 \times S_4^2 + S_4^1
$$

第二类 stirling 数，显然拥有这样的性质：

$$
S_n^m = m \times S_{n-1}^{m} + S_{n-1}^{m-1}
$$

$$
S_n^1 = 1,S_n^0 = 0,S_n^n = 1
$$

而这些性质就可以总结成：

$$
S_n^3 = \frac{1}{2} \times (3^{n-1}+1) - 2^{n-1}
$$

## 习题

 [HDU3625](http://acm.hdu.edu.cn/showproblem.php?pid=3625) 

# primitive-root
## 阶

若 $(a,m)=1$ ，使 $a^l \equiv 1 \pmod m$ 成立的最小的 $l$ ，称为 $a$ 关于模 $m$ 的阶，记为 $\text{ord}_ma$ 。

若 $\text{ord}_ma=l$ ，则 $\text{ord}_m{a^t} = \frac{l}{(t,l)}$ 

由欧拉定理，设 $\text{ord}_ma=l$ ，则 $a^n \equiv 1 \pmod m$ 当且仅当 $l \mid n$ ，特别地， $l \mid \varphi(m)$ 。

-   设 $p$ 是素数， $\text{ord}_pa=l$ ，那么有且仅有 $\varphi(l)$ 个关于模 $p$ 的阶为 $l$ 且两两互不同余的数。
-   设 $\text{ord}_ma=l$ ，则 $1, a, a^2, \cdots, a^{l-1}$ 关于模 $m$ 两两互不同余。
-   设 $p$ 是素数， $l \mid p-1$ ，则存在 $\varphi(l)$ 个关于模 $p$ 的阶为 $l$ 且两两互不同余的数。
-   若 $m=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}$ ，则 $\text{ord}_ma = [\text{ord}_{p_1}^{a_1}, \text{ord}_{p_2}^{a_2}, \cdots, \text{ord}_{p_k}^{a_k}]$ 

## 原根

 $(g, m)=1$ ，若 $\text{ord}_mg = \varphi(m)$ ，则称 $g$ 为 $m$ 的一个原根。

 $g$ 为 $m$ 的一个原根当且仅当 $\{g, g^2, \cdots, g^{\varphi(m)}\}$ 构成模 $m$ 的一个既约剩余系。

### 判断是否有原根

若 $m$ 有原根，则 $m$ 一定是下列形式： $2, 4, p^a, 2p^a$ 。这里 $p$ 为奇素数， $a$ 为正整数。

### 求所有原根

设 $g$ 为 $m$ 的一个原根，则集合 $S = \{g^s \mid 1 \leq s \leq \varphi(m), (s, \varphi(m)) = 1\}$ 给出 $m$ 的全部原根。因此，若 $m$ 有原根，则 $m$ 有 $\varphi(\varphi(m))$ 个关于模 $m$ 两两互不同余的原根。

## 求一个原根

对 $p-1$ 进行质因数分解得到不同的质因子 $d_{1},d_{2},\ldots,d_{m}$ ，对于任意的 $1<a<p$ ，要判定 $a$ 是否是模 $p$ 的原根，只需要检验 $a^{\frac{p-1}{d_{1}}},a^{\frac{p-1}{d_{2}}},\ldots,a^{\frac{p-1}{d_{m}}}$ 这 $m$ 个数中是否存在一个数在模 $p$ 意义下与 $1$ 同余。若存在，则 $a$ 不是 $p$ 的原根；若不存在，则 $a$ 是 $p$ 的原根。

另一种表达形式：

 $(g,m) =1$ ，设 $p_1, p_2, \cdots, p_k$ 是 $\varphi(m)$ 的所有不同的素因数，则 $g$ 是 $m$ 的原根，当且仅当对任意 $1 \leq i \leq k$ ，都有 $g^{\frac{\varphi(m)}{p_i}} \not\equiv 1 \pmod m$ 

### 证明

假设存在一个 $t<\varphi(p)=p-1$ 使得 $a^t\equiv 1\pmod{p}$ 且 $\forall i\in\left[1,m\right]:a^{\frac{p-1}{d_{i}}}\not\equiv 1\pmod{p}$ 。

由裴蜀定理得，一定存在一组 $k,x$ 满足 $kt=x(p-1)+\gcd(t,p-1)$ ；由欧拉定理/费马小定理得 $a^{p-1}\equiv 1\pmod{p}$ ；故有：

$$
1\equiv a^{kt}\equiv a^{x(p-1)+\gcd(t,p-1)}\equiv a^{\gcd(t,p-1)}\pmod{p}
$$

又有 $t<p-1$ ，故 $\gcd(t,p-1)\leqslant t<p-1$ 。

又 $\gcd(t,p-1)\mid(p-1)$ ，故 $\gcd(t,p-1)$ 必至少整除 $a^{\frac{p-1}{d_{1}}},a^{\frac{p-1}{d_{2}}},\ldots,a^{\frac{p-1}{d_{m}}}$ 中的至少一个，设 $\gcd(t,p-1)\mid a^{\frac{p-1}{d_{i}}}$ ，则 $a^{\frac{p-1}{d_{i}}}\equiv a^{\gcd(t,p-1)}\equiv 1\pmod{p}$ 。

故假设不成立。

## 用途

我们发现原根 $g$ 拥有所有 DFT 所需的单位根 $\omega$ 的性质，于是我们用 $g^{\frac{p-1}{n}}\bmod{p}$ 来代替 $\omega_{n}$ ，理论上就能把复数对应到一个整数，在模 $p$ 意义下进行快速变换了。

但实际上由于快速傅里叶变换（FFT）实现的多项式乘法的过程中要求序列长度是 $2$ 的幂次，因此这里模数 $p$ 还需要保证 $p-1$ 的标准分解式中素因子 $2$ 的幂次足够大，参见 [快速数论变换](./poly/ntt.md) ，

# quick-pow
快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $\Theta(\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $\Theta(n)$ 的时间。而这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。

## 算法描述

计算 $a$ 的 $n$ 次方表示将 $n$ 个 $a$ 乘在一起： $a^{n} = \underbrace{a \times a \cdots \times a}_{n\text{ 个 a}}$ 。然而当 $a,n$ 太大的时侯，这种方法就不太适用了。不过我们知道： $a^{b+c} = a^b \cdot a^c,\,\,a^{2b} = a^b \cdot a^b = (a^b)^2$ 。二进制取幂的想法是，我们将取幂的任务按照指数的 **二进制表示** 来分割成更小的任务。

首先我们将 $n$ 表示为 2 进制，举一个例子：

$$
3^{13} = 3^{(1101)_2} = 3^8 \cdot 3^4 \cdot 3^1
$$

因为 $n$ 有 $\lfloor \log_2 n \rfloor + 1$ 个二进制位，因此当我们知道了 $a^1, a^2, a^4, a^8, \dots, a^{2^{\lfloor \log_2 n \rfloor}}$ 后，我们只用计算 $\Theta(\log n)$ 次乘法就可以计算出 $a^n$ 。

于是我们只需要知道一个快速的方法来计算上述 3 的 $2^k$ 次幂的序列。这个问题很简单，因为序列中（除第一个）任意一个元素就是其前一个元素的平方。举一个例子：

$$
\begin{align}
3^1 &= 3 \\
3^2 &= \left(3^1\right)^2 = 3^2 = 9 \\
3^4 &= \left(3^2\right)^2 = 9^2 = 81 \\
3^8 &= \left(3^4\right)^2 = 81^2 = 6561
\end{align}
$$

因此为了计算 $3^{13}$ ，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了：

$$
3^{13} = 6561 \cdot 81 \cdot 3 = 1594323
$$

将上述过程说得形式化一些，如果把 $n$ 写作二进制为 $(n_tn_{t-1}\cdots n_1n_0)_2$ ，那么有：

$$
n = n_t2^t + n_{t-1}2^{t-1} + n_{t-2}2^{t-2} + \cdots + n_12^1 + n_02^0
$$

其中 $n_i\in\{0,1\}$ 。那么就有

$$
\begin{aligned}
a^n & = (a^{n_t 2^t + \cdots + n_0 2^0})\\\\
& = a^{n_0 2^0} \times a^{n_1 2^1}\times \cdots \times a^{n_t2^t}
\end{aligned}
$$

根据上式我们发现，原问题被我们转化成了形式相同的子问题的乘积，并且我们可以在常数时间内从 $2^i$ 项推出 $2^{i+1}$ 项。

这个算法的复杂度是 $\Theta(\log n)$ 的，我们计算了 $\Theta(\log n)$ 个 $2^k$ 次幂的数，然后花费 $\Theta(\log n)$ 的时间选择二进制为 1 对应的幂来相乘。

## 代码实现

首先我们可以直接按照上述递归方法实现：

```cpp
long long binpow(long long a, long long b) {
  if (b == 0) return 1;
  long long res = binpow(a, b / 2);
  if (b % 2)
    return res * res * a;
  else
    return res * res;
}
```

第二种实现方法是非递归式的。它在循环的过程中将二进制位为 1 时对应的幂累乘到答案中。尽管两者的理论复杂度是相同的，但第二种在实践过程中的速度是比第一种更快的，因为递归会花费一定的开销。

```cpp
long long binpow(long long a, long long b) {
  long long res = 1;
  while (b > 0) {
    if (b & 1) res = res * a;
    a = a * a;
    b >>= 1;
  }
  return res;
}
```

模板： [Luogu P1226](https://www.luogu.org/problemnew/show/P1226) 

## 应用

### 模意义下取幂

???+note "问题描述"
    计算 $x^n\bmod m$ 。

这是一个非常常见的应用，例如它可以用于计算模意义下的乘法逆元。

既然我们知道取模的运算不会干涉乘法运算，因此我们只需要在计算的过程中取模即可。

```cpp
long long binpow(long long a, long long b, long long m) {
  a %= m;
  long long res = 1;
  while (b > 0) {
    if (b & 1) res = res * a % m;
    a = a * a % m;
    b >>= 1;
  }
  return res;
}
```

注意：根据费马小定理，如果 $m$ 是一个质数，我们可以计算 $x^{n\bmod (m-1)}$ 来加速算法过程。

### 计算斐波那契数

???+note "问题描述"
    计算斐波那契数列第 $n$ 项 $F_n$ 。

根据斐波那契数列的递推式 $F_n = F_{n-1} + F_{n-2}$ ，我们可以构建一个 $2\times 2$ 的矩阵来表示从 $F_i,F_{i+1}$ 到 $F_{i+1},F_{i+2}$ 的变换。于是在计算这个矩阵的 $n$ 次幂的时侯，我们使用快速幂的思想，可以在 $\Theta(\log n)$ 的时间内计算出结果。对于更多的细节参见 [斐波那契数列](./fibonacci.md) 。

### 多次置换

???+note "问题描述"
    给你一个长度为 $n$ 的序列和一个置换，把这个序列置换 $k$ 次。

简单地把这个置换取 $k$ 次幂，然后把它应用到序列 $n$ 上即可。时间复杂度是 $O(n \log k)$ 的。

注意：给这个置换建图，然后在每一个环上分别做 $k$ 次幂（事实上做一下 $k$ 对环长取模的运算即可）可以取得更高效的算法，达到 $O(n)$ 的复杂度。

### 加速几何中对点集的操作

> 三维空间中， $n$ 个点 $p_i$ ，要求将 $m$ 个操作都应用于这些点。包含 3 种操作：
>
> 1.  沿某个向量移动点的位置（Shift）。
> 2.  按比例缩放这个点的坐标（Scale）。
> 3.  绕某个坐标轴旋转（Rotate）。
>
> 还有一个特殊的操作，就是将一个操作序列重复 $k$ 次（Loop），这个序列中也可能有 Loop 操作（Loop 操作可以嵌套）。现在要求你在低于 $O(n \cdot length)$ 的时间内将这些变换应用到这个 $n$ 个点，其中 $length$ 表示把所有的 Loop 操作展开后的操作序列的长度。

让我们来观察一下这三种操作对坐标的影响：

1.  Shift 操作：将每一维的坐标分别加上一个常量；
2.  Scale 操作：把每一维坐标分别乘上一个常量；
3.  Rotate 操作：这个有点复杂，我们不打算深入探究，不过我们仍然可以使用一个线性组合来表示新的坐标。

可以看到，每一个变换可以被表示为对坐标的线性运算，因此，一个变换可以用一个 $4\times 4$ 的矩阵来表示：

$$
\begin{bmatrix}
a_{11} & a_ {12} & a_ {13} & a_ {14} \\
a_{21} & a_ {22} & a_ {23} & a_ {24} \\
a_{31} & a_ {32} & a_ {33} & a_ {34} \\
a_{41} & a_ {42} & a_ {43} & a_ {44} \\
\end{bmatrix}
$$

使用这个矩阵就可以将一个坐标（向量）进行变换，得到新的坐标（向量）：

$$
\begin{bmatrix}
a_{11} & a_ {12} & a_ {13} & a_ {14} \\
a_{21} & a_ {22} & a_ {23} & a_ {24} \\
a_{31} & a_ {32} & a_ {33} & a_ {34} \\
a_{41} & a_ {42} & a_ {43} & a_ {44} \\
\end{bmatrix}\cdot
\begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix}
 = \begin{bmatrix} x' \\ y' \\ z' \\ 1 \end{bmatrix}
$$

你可能会问，为什么一个三维坐标会多一个 1 出来？原因在于，如果没有这个多出来的 1，我们没法使用矩阵的线性变换来描述 Shift 操作。

接下来举一些简单的例子来说明我们的思路：

1.  Shift 操作：让 $x$ 坐标方向的位移为 $5$ ， $y$ 坐标的位移为 $7$ ， $z$ 坐标的位移为 $9$ ：

    $$
    \begin{bmatrix}
    1 & 0 & 0 & 5 \\
    0 & 1 & 0 & 7 \\
    0 & 0 & 1 & 9 \\
    0 & 0 & 0 & 1 \\
    \end{bmatrix}
    $$

2.  Scale 操作：把 $x$ 坐标拉伸 10 倍， $y,z$ 坐标拉伸 5 倍：

    $$
    \begin{bmatrix}
    10 & 0 & 0 & 0 \\
    0 & 5 & 0 & 0 \\
    0 & 0 & 5 & 0 \\
    0 & 0 & 0 & 1 \\
    \end{bmatrix}
    $$

3.  Rotate 操作：绕 $x$ 轴旋转 $\theta$ 弧度，遵循右手定则（逆时针方向）

    $$
    \begin{bmatrix}
    1 & 0 & 0 & 0 \\
    0 & \cos \theta & \sin \theta & 0 \\
    0 & -\sin \theta & \cos \theta & 0 \\
    0 & 0 & 0 & 1 \\
    \end{bmatrix}
    $$

现在，每一种操作都被表示为了一个矩阵，变换序列可以用矩阵的乘积来表示，而一个 Loop 操作相当于取一个矩阵的 k 次幂。这样可以用 $O(m \log k)$ 计算出整个变换序列最终形成的矩阵。最后将它应用到 $n$ 个点上，总复杂度 $O(n + m \log k)$ 。

### 定长路径计数

???+note "问题描述"
    给一个有向图（边权为 1），求任意两点 $u,v$ 间从 $u$ 到 $v$ ，长度为 $k$ 的路径的条数。

我们把该图的邻接矩阵 M 取 k 次幂，那么 $M_{i,j}$ 就表示从 $i$ 到 $j$ 长度为 $k$ 的路径的数目。该算法的复杂度是 $O(n^3 \log k)$ 。有关该算法的细节请参见 [矩阵](./matrix.md) 页面。

### 模意义下大整数乘法

> 计算 $a\times b\bmod m,\,\,a,b\le m\le 10^{18}$ 。

与二进制取幂的思想一样，这次我们将其中的一个乘数表示为若干个 2 的整数次幂的和的形式。因为在对一个数做乘 2 并取模的运算的时侯，我们可以转化为加减操作防止溢出。这样仍可以在 $O (\log_2 m)$ 的时内解决问题。递归方法如下：

$$
a \cdot b = \begin{cases}
0 &\text{if }a = 0 \\\\
2 \cdot \frac{a}{2} \cdot b &\text{if }a > 0 \text{ and }a \text{ even} \\\\
2 \cdot \frac{a-1}{2} \cdot b + b &\text{if }a > 0 \text{ and }a \text{ odd}
\end{cases}
$$

注意：你也可以利用双精度浮点数在常数时间内计算大整数乘法。因为 $a\times b\bmod m=a\times b-\left\lfloor\frac{a\times b}{m}\right\rfloor m$ 。由于 $a,b<m$ ，因此 $\left\lfloor\frac{a\times b}{m}\right\rfloor<m$ ，于是可以用双精度浮点数计算这个分式。作差的时侯直接自然溢出。因为两者的差是一定小于 $m$ 的，我们只关心低位。这样再调整一下正负性就行了。更多信息参见 [这里](https://cs.stackexchange.com/questions/77016/modular-multiplication) 。

### 高精度快速幂

??? note "前置技能"
    请先学习 [高精度](./bignum.md) 

???+note " 例题【NOIP2003 普及组改编·麦森数】（[原题在此](https://www.luogu.org/problemnew/show/P1045)）"
    题目大意：从文件中输入 P（1000&lt;P&lt;3100000），计算 $2^P−1$ 的最后 100 位数字（用十进制高精度数表示），不足 100 位时高位补 0。

代码实现如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[505], b[505], t[505], i, j;
int mult(int x[], int y[])  // 高精度乘法
{
  memset(t, 0, sizeof(t));
  for (i = 1; i <= x[0]; i++) {
    for (j = 1; j <= y[0]; j++) {
      if (i + j - 1 > 100) continue;
      t[i + j - 1] += x[i] * y[j];
      t[i + j] += t[i + j - 1] / 10;
      t[i + j - 1] %= 10;
      t[0] = i + j;
    }
  }
  memcpy(b, t, sizeof(b));
}
void ksm(int p)  // 快速幂
{
  if (p == 1) {
    memcpy(b, a, sizeof(b));
    return;
  }
  ksm(p / 2);
  mult(b, b);
  if (p % 2 == 1) mult(b, a);
}
int main() {
  int p;
  scanf("%d", &p);
  a[0] = 1;
  a[1] = 2;
  b[0] = 1;
  b[1] = 1;
  ksm(p);
  for (i = 100; i >= 1; i--) {
    if (i == 1) {
      printf("%d\n", b[i] - 1);
    } else
      printf("%d", b[i]);
  }
}
```

## 习题

-    [UVa 1230 - MODEX](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3671) 
-    [UVa 374 - Big Mod](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=310) 
-    [UVa 11029 - Leading and Trailing](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1970) 
-    [Codeforces - Parking Lot](http://codeforces.com/problemset/problem/630/I) 
-    [SPOJ - The last digit](http://www.spoj.com/problems/LASTDIG/) 
-    [SPOJ - Locker](http://www.spoj.com/problems/LOCKER/) 
-    [LA - 3722 Jewel-eating Monsters](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1723) 
-    [SPOJ - Just add it](http://www.spoj.com/problems/ZSUM/) 

     **本页面部分内容译自博文 [Бинарное возведение в степень](http://e-maxx.ru/algo/binary_pow) 与其英文翻译版 [Binary Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# gcd
## 最大公约数

最大公约数即为 Greatest Common Divisor，常缩写为 gcd。

在 [素数](./prime.md) 一节中，我们已经介绍了约数的概念。

一组数的公约数，是指同时是这组数中每一个数的约数的数。而最大公约数，则是指所有公约数里面最大的一个。

那么如何求最大公约数呢？我们先考虑两个数的情况。

### 欧几里德算法

如果我们已知两个数 $a$ 和 $b$ ，如何求出二者的最大公约数呢？

不妨设 $a > b$ 

我们发现如果 $b$ 是 $a$ 的约数，那么 $b$ 就是二者的最大公约数。
下面讨论不能整除的情况，即 $a = b \times q + r$ ，其中 $r < b$ 。

我们通过证明可以得到 $\gcd(a,b)=\gcd(b,a \bmod b)$ ，过程如下：

* * *

设 $a=bk+c$ ，显然有 $c=a \bmod b$ 。设 $d \mid a\ \ \ d \mid b$ ，则 $c=a-bk$  $\frac{c}{d}=\frac{a}{d}-\frac{b}{d}k$ 由右边的式子可知 $\frac{c}{d}$ 为整数，即 $d \mid c$ 所以对于 $a,b$ 的公约数，它也会是 $a \bmod b$ 的公约数。

反过来也需要证明

设 $d \mid b\ \ \ d \mid (a \bmod b)$ ，我们还是可以像之前一样得到以下式子 $\frac{a\bmod b}{d}=\frac{a}{d}-\frac{b}{d}k$  $\frac{a\bmod b}{d}+\frac{b}{d}k=\frac{a}{d}$ 因为左边式子显然为整数，所以 $\frac{a}{d}$ 也为整数，即 $d \mid a$ ，所以 $b,a\bmod b$ 的公约数也是 $a,b$ 的公约数。

既然两式公约数都是相同的，那么最大公约数也会相同。

所以得到式子 $\gcd(a,b)=\gcd(b,a\bmod b)$ 

既然得到了 $\gcd(a, b) = \gcd(b, r)$ ，这里两个数的大小是不会增大的，那么我们也就得到了关于两个数的最大公约数的一个递归求法。

```cpp
int gcd(int a, int b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}
```

递归至 `b==0` （即上一步的 `a%b==0` ) 的情况再返回值即可。

上述算法被称作欧几里德算法（Euclidean algorithm）。

如果两个数 $a$ 和 $b$ 满足 $\gcd(a, b) = 1$ ，我们称 $a$ 和 $b$ 互质。

### 多个数的最大公约数

那怎么求多个数的最大公约数呢？显然答案一定是每个数的约数，那么也一定是每相邻两个数的约数。我们采用归纳法，可以证明，每次取出两个数求出答案后再放回去，不会对所需要的答案造成影响。

## 最小公倍数

接下来我们介绍如何求解最小公倍数（Least Common Multiple, LCM）。

### 两个数的

首先我们介绍这样一个定理——算术基本定理：

> 每一个正整数都可以表示成若干整数的乘积，这种分解方式在忽略排列次序的条件下是唯一的。

用数学公式来表示就是 $x = p_1^{k_1}p_2^{k_2} \cdots p_s^{k_s}$ 

设 $a = p_1^{k_{a_1}}p_2^{k_{a_2}} \cdots p_s^{k_{a_s}}$ , $b = p_1^{k_{b_1}}p_2^{k_{b_2}} \cdots p_s^{k_{b_s}}$ 

我们发现，对于 $a$ 和 $b$ 的情况，二者的最大公约数等于

 $p_1^{\min(k_{a_1}, k_{b_1})}p_2^{\min(k_{a_2}, k_{b_2})} \cdots p_s^{\min(k_{a_s}, k_{b_s})}$ 

最小公倍数等于

 $p_1^{\max(k_{a_1}, k_{b_1})}p_2^{\max(k_{a_2}, k_{b_2})} \cdots p_s^{\max(k_{a_s}, k_{b_s})}$ 

由于 $k_a + k_b = \max(k_a, k_b) + \min(k_a, k_b)$ 

所以得到结论是 $\gcd(a, b) \times \operatorname{lcm}(a, b) = a \times b$ 

要求两个数的最小公倍数，先求出最大公约数即可。

### 多个数的

可以发现，当我们求出两个数的 $gcd$ 时，求最小公倍数是 $O(1)$ 的复杂度。那么对于多个数，我们其实没有必要求一个共同的最大公约数再去处理，最直接的方法就是，当我们算出两个数的 $gcd$ ，或许在求多个数的 $gcd$ 时候，我们将它放入序列对后面的数继续求解，那么，我们转换一下，直接将最小公倍数放入序列即可。

## 扩展欧几里得定理

扩展欧几里德定理（Extended Euclidean algorithm, EXGCD），常用于求 $ax+by=\gcd(a,b)$ 的一组可行解。

## 证明

设

 $ax_1+by_1=\gcd(a,b)$ 

 $bx_2+(a\bmod b)y_2=\gcd(b,a\bmod b)$ 

由欧几里得定理可知： $\gcd(a,b)=\gcd(b,a\bmod b)$ 

所以 $ax_1+by_1=bx_2+(a\bmod b)y_2$ 

又因为 $a\bmod b=a-(\lfloor\frac{a}{b}\rfloor\times b)$ 

所以 $ax_1+by_1=bx_2+(a-(\lfloor\frac{a}{b}\rfloor\times b))y_2$ 

 $ax_1+by_1=ay_2+bx_2-\lfloor\frac{a}{b}\rfloor\times by_2=ay_2+b(x_2-\lfloor\frac{a}{b}\rfloor y_2)$ 

因为 $a=a,b=b$ ，所以 $x_1=y_2,y_1=x_2-\lfloor\frac{a}{b}\rfloor y_2$ 

将 $x_2,y_2$ 不断代入递归求解直至 GCD（最大公约数，下同）为 `0` 递归 `x=1,y=0` 回去求解。

```cpp
int Exgcd(int a, int b, int &x, int &y) {
  if (!b) {
    x = 1;
    y = 0;
    return a;
  }
  int d = Exgcd(b, a % b, x, y);
  int t = x;
  x = y;
  y = t - (a / b) * y;
  return d;
}
```

函数返回的值为 GCD，在这个过程中计算 $x,y$ 即可。

# du
author: hsfzLZH1, sshwy, StudyingFather, TrisolarisHD

## 积性函数

在数论题目中，常常需要根据一些 **积性函数** 的性质，求出一些式子的值。

 **积性函数** ：对于所有互质的 $a$ 和 $b$ ，总有 $f(ab)=f(a)f(b)$ ，则称 $f(x)$ 为积性函数。

常见的积性函数有：

 $d(x)=\sum_{i \mid n} 1$ 

 $\sigma(x)=\sum_{i \mid n} i$ 

 $\varphi(x)=\sum_{i=1}^x 1[\gcd(x,i)=1]$ 

 $\mu(x)=\begin{cases}1&\ x=1 \\(-1)^k& \ \prod_{i=1}^k q_i=1\\0 &\ \max\{q_i\}>1\end{cases}$ 

积性函数有如下性质：

若 $f(x)$ ， $g(x)$ 为积性函数，则

 $h(x)=f(x^p)$ 

 $h(x)=f^p(x)$ 

 $h(x)=f(x)g(x)$ 

 $h(x)=\sum_{d \mid x} f(d)g(\frac x d)$ 

中的 $h(x)$ 也为积性函数。

在莫比乌斯反演的题目中，往往要求出一些数论函数的前缀和，利用 **杜教筛** 可以快速求出这些前缀和。

## 杜教筛

杜教筛被用来处理数论函数的前缀和问题。对于求解一个前缀和，杜教筛可以在低于线性时间的复杂度内求解

对于数论函数 $f$ ，要求我们计算 $S(n)=\sum_{i=1}^{n}f(i)$ .

我们想办法构造一个 $S(n)$ 关于 $S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)$ 的递推式

对于任意一个数论函数 $g$ ，必满足

$$
\sum_{i=1}^{n}\sum_{d \mid i}f(d)g\left(\frac{i}{d}\right)=\sum_{i=1}^{n}g(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
\Leftrightarrow
\sum_{i=1}^{n}(f\ast g)(i)=\sum_{i=1}^{n}g(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
$$

略证：

 $f(d)g\left(\frac{i}{d}\right)$ 就是对所有 $i\leq n$ 的做贡献，因此变换枚举顺序，枚举 $d,\frac{i}{d}$ （分别对应新的 $i,j$ ）

$$
\begin{split}
&\sum_{i=1}^n\sum_{d \mid i}f(d)g\left(\frac{i}{d}\right)\\
=&\sum_{i=1}^n\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}g(i)f(j)\\
=&\sum_{i=1}^ng(i)\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}f(j)\\
=&\sum_{i=1}^ng(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
\end{split}
$$

那么可以得到递推式

$$
g(1)S(n)=\sum_{i=1}^n(f\ast g)(i)-\sum_{i=2}^ng(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
$$

那么假如我们可以快速对 $\sum_{i=1}^n(f \ast g)(i)$ 求和，并用数论分块求解 $\sum_{i=2}^ng(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)$ 就可以在较短时间内求得 $g(1)S(n)$ .

## 问题一

???+note "[P4213【模板】杜教筛（Sum）](https://www.luogu.org/problemnew/show/P4213)"
    题目大意：求 $S_1(n)= \sum_{i=1}^{n} \mu(i)$ 和 $S_2(n)= \sum_{i=1}^{n} \varphi(i)$ 的值， $n\le 2^{31} -1$ 。

### 莫比乌斯函数前缀和

由 **狄利克雷卷积** ，我们知道：

 $\because \epsilon =\mu \ast 1$ （ $\epsilon(n)=~[n=1]$ ）

 $\therefore \epsilon (n)=\sum_{d \mid n} \mu(d)$ 

 $S_1(n)=\sum_{i=1}^n \epsilon (i)-\sum_{i=2}^n S_1(\lfloor \frac n i \rfloor)$ 

 $= 1-\sum_{i=2}^n S_1(\lfloor \frac n i \rfloor)$ 

观察到 $\lfloor \frac n i \rfloor$ 最多只有 $O(\sqrt n)$ 种取值，我们就可以应用 **整除分块** （或称数论分块）来计算每一项的值了。

直接计算的时间复杂度为 $O(n^{\frac 3 4})$ 。考虑先线性筛预处理出前 $n^{\frac 2 3}$ 项，剩余部分的时间复杂度为

 $O(\int_{0}^{n^{\frac 1 3}} \sqrt{\frac{n}{x}} ~ dx)=O(n^{\frac 2 3})$ 

对于较大的值，需要用 `map` 存下其对应的值，方便以后使用时直接使用之前计算的结果。

### 欧拉函数前缀和

当然也可以用杜教筛求出 $\varphi (x)$ 的前缀和，但是更好的方法是应用莫比乌斯反演：

 $\sum_{i=1}^n \sum_{j=1}^n 1[\gcd(i,j)=1]=\sum_{i=1}^n \sum_{j=1}^n \sum_{d \mid i,d \mid j} \mu(d)$ 

 $=\sum_{d=1}^n \mu(d) {\lfloor \frac n d \rfloor}^2$ 

由于题目所求的是 $\sum_{i=1}^n \sum_{j=1}^i 1[\gcd(i,j)=1]$ ，所以我们排除掉 $i=1,j=1$ 的情况，并将结果除以 $2$ 即可。

观察到，只需求出莫比乌斯函数的前缀和，就可以快速计算出欧拉函数的前缀和了。时间复杂度 $O(n^{\frac 2 3})$ 。

#### 使用杜教筛求解

求 $S(i)=\sum_{i=1}^n\varphi(i)$ .

同样的， $\varphi\ast 1=ID$ 

$$
\begin{split}
&\sum_{i=1}^n(\varphi\ast 1)(i)=\sum_{i=1}^n1\cdot S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
&\sum_{i=1}^nID(i)=\sum_{i=1}^n1\cdot S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
&\frac{1}{2}n(n+1)=\sum_{i=1}^nS\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
&S(n)=\frac{1}{2}n(n+1)-\sum_{i=2}^nS\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
\end{split}
$$

??? note "代码实现"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <map>
    using namespace std;
    const int maxn = 2000010;
    typedef long long ll;
    ll T, n, pri[maxn], cur, mu[maxn], sum_mu[maxn];
    bool vis[maxn];
    map<ll, ll> mp_mu;
    ll S_mu(ll x) {
      if (x < maxn) return sum_mu[x];
      if (mp_mu[x]) return mp_mu[x];
      ll ret = 1ll;
      for (ll i = 2, j; i <= x; i = j + 1) {
        j = x / (x / i);
        ret -= S_mu(x / i) * (j - i + 1);
      }
      return mp_mu[x] = ret;
    }
    ll S_phi(ll x) {
      ll ret = 0ll;
      for (ll i = 1, j; i <= x; i = j + 1) {
        j = x / (x / i);
        ret += (S_mu(j) - S_mu(i - 1)) * (x / i) * (x / i);
      }
      return ((ret - 1) >> 1) + 1;
    }
    int main() {
      scanf("%lld", &T);
      mu[1] = 1;
      for (int i = 2; i < maxn; i++) {
        if (!vis[i]) {
          pri[++cur] = i;
          mu[i] = -1;
        }
        for (int j = 1; j <= cur && i * pri[j] < maxn; j++) {
          vis[i * pri[j]] = true;
          if (i % pri[j])
            mu[i * pri[j]] = -mu[i];
          else {
            mu[i * pri[j]] = 0;
            break;
          }
        }
      }
      for (int i = 1; i < maxn; i++) sum_mu[i] = sum_mu[i - 1] + mu[i];
      while (T--) {
        scanf("%lld", &n);
        printf("%lld %lld\n", S_phi(n), S_mu(n));
      }
      return 0;
    }
    ```

## 问题二

???+note "[「LuoguP3768」简单的数学题](https://www.luogu.org/problemnew/show/P3768)"
    大意：求
    
    $$
    \sum_{i=1}^n\sum_{j=1}^ni\cdot j\cdot\gcd(i,j)\pmod p
    $$
    
    其中 $n\leq 10^{10},5\times 10^8\leq p\leq 1.1\times 10^9$ , $p$ 是质数。

利用 $\varphi\ast1=ID$ 做莫比乌斯反演化为

$$
\sum_{d=1}^nF^2\left(\left\lfloor\frac{n}{d}\right\rfloor\right)\cdot d^2\varphi(d)
\left(F(n)=\frac{1}{2}n\left(n+1\right)\right)\\
$$

对 $\sum_{d=1}^nF\left(\left\lfloor\frac{n}{d}\right\rfloor\right)^2​$ 做数论分块， $d^2\varphi(d)​$ 的前缀和用杜教筛处理：

$$
\begin{split}
&f(n)=n^2\varphi(n)=(ID^2\varphi)(n)\\
&S(n)=\sum_{i=1}^nf(i)=\sum_{i=1}^n(ID^2\varphi)(i)
\end{split}
$$

需要构造积性函数 $g$ ，使得 $f\times g$ 和 $g$ 能快速求和

单纯的 $\varphi$ 的前缀和可以用 $\varphi\ast1$ 的杜教筛处理，但是这里的 $f$ 多了一个 $ID^2$ ，那么我们就卷一个 $ID^2$ 上去，让它变成常数：

$$
S(n)=\sum_{i=1}^n\left((ID^2\varphi)\ast ID^2\right)(i)-\sum_{i=2}^nID^2(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
$$

化一下卷积

$$
\begin{split}
&(ID^2\varphi)\ast ID^2)(i)\\
=&\sum_{d \mid i}(ID^2\varphi)(d)ID^2\left(\frac{i}{d}\right)\\
=&\sum_{d \mid i}d^2\varphi(d)\left(\frac{i}{d}\right)^2\\
=&\sum_{d \mid i}i^2\varphi(d)=i^2\sum_{d \mid i}\varphi(d)\\
=&i^2(\varphi\ast1)(i)=i^3
\end{split}
$$

再化一下 $S(n)$ 

$$
\begin{split}
S(n)&=\sum_{i=1}^n\left((ID^2\varphi)\ast ID^2\right)(i)-\sum_{i=2}^nID^2(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
&=\sum_{i=1}^ni^3-\sum_{i=2}^ni^2S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
&=\left(\frac{1}{2}n(n+1)\right)^2-\sum_{i=2}^ni^2S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
\end{split}
$$

分块求解即可

??? note "代码实现"
    ```cpp
    #include <cmath>
    #include <cstdio>
    #include <map>
    using namespace std;
    const int N = 5e6, NP = 5e6, SZ = N;
    long long n, P, inv2, inv6, s[N];
    int phi[N], p[NP], cnt, pn;
    bool bp[N];
    map<long long, long long> s_map;
    long long ksm(long long a, long long m) {  // 求逆元用
      long long res = 1;
      while (m) {
        if (m & 1) res = res * a % P;
        a = a * a % P, m >>= 1;
      }
      return res;
    }
    void prime_work(int k) {  // 线性筛 phi，s
      bp[0] = bp[1] = 1, phi[1] = 1;
      for (int i = 2; i <= k; i++) {
        if (!bp[i]) p[++cnt] = i, phi[i] = i - 1;
        for (int j = 1; j <= cnt && i * p[j] <= k; j++) {
          bp[i * p[j]] = 1;
          if (i % p[j] == 0) {
            phi[i * p[j]] = phi[i] * p[j];
            break;
          } else
            phi[i * p[j]] = phi[i] * phi[p[j]];
        }
      }
      for (int i = 1; i <= k; i++)
        s[i] = (1ll * i * i % P * phi[i] % P + s[i - 1]) % P;
    }
    long long s3(long long k) {
      return k %= P, (k * (k + 1) / 2) % P * ((k * (k + 1) / 2) % P) % P;
    }  // 立方和
    long long s2(long long k) {
      return k %= P, k * (k + 1) % P * (k * 2 + 1) % P * inv6 % P;
    }  // 平方和
    long long calc(long long k) {  // 计算 S(k)
      if (k <= pn) return s[k];
      if (s_map[k]) return s_map[k];  // 对于超过 pn 的用 map 离散存储
      long long res = s3(k), pre = 1, cur;
      for (long long i = 2, j; i <= k; i = j + 1)
        j = k / (k / i), cur = s2(j),
        res = (res - calc(k / i) * (cur - pre) % P) % P, pre = cur;
      return s_map[k] = (res + P) % P;
    }
    long long solve() {
      long long res = 0, pre = 0, cur;
      for (long long i = 1, j; i <= n; i = j + 1)
        j = n / (n / i), cur = calc(j),
        res = (res + (s3(n / i) * (cur - pre)) % P) % P, pre = cur;
      return (res + P) % P;
    }
    int main() {
      scanf("%lld%lld", &P, &n);
      inv2 = ksm(2, P - 2), inv6 = ksm(6, P - 2);
      pn = (long long)pow(n, 0.666667);  // n^(2/3)
      prime_work(pn);
      printf("%lld", solve());
      return 0;
    }  // 不要为了省什么内存把数组开小...... 卡了好几次 80
    ```

# inverse
本文介绍模意义下乘法运算的逆元（Modular Multiplicative Inverse），并介绍如何使用扩展欧几里德算法（Extended Euclidean algorithm）求解乘法逆元

## 逆元简介

如果一个线性同余方程 $ax \equiv 1 \pmod b$ ，则 $x$ 称为 $a \bmod b$ 的逆元，记作 $a^{-1}$ 。

## 如何求逆元

### 扩展欧几里得法

```cpp
void exgcd(int a, int b, int& x, int& y) {
  if (b == 0) {
    x = 1, y = 0;
    return;
  }
  exgcd(b, a % b, y, x);
  y -= a / b * x;
}
```

扩展欧几里得法和求解 [线性同余方程](./linear-equation.md) 是一个原理，在这里不展开解释。

### 快速幂法

这个要运用 [费马小定理](./fermat.md) ：

> 若 $p$ 为质数， $a$ 为正整数，且 $a$ 、 $p$ 互质，则 $a^{p-1} \equiv 1 \pmod p$ 。

因为 $ax \equiv 1 \pmod b$ ；

所以 $ax \equiv a^{b-1} \pmod b$ （根据费马小定理）；

所以 $x \equiv a^{b-2} \pmod b$ ；

然后我们就可以用快速幂来求了。

代码：

```cpp
inline int qpow(long long a, int b) {
  int ans = 1;
  a = (a % p + p) % p;
  for (; b; b >>= 1) {
    if (b & 1) ans = (a * ans) % p;
    a = (a * a) % p;
  }
  return ans;
}
```

### 线性求逆元

求出 $1,2,...,n$ 中每个数关于 $p$ 的逆元。

如果对于每个数进行单次求解，以上两种方法就显得慢了，很有可能超时，所以下面来讲一下如何线性（ $O(n)$ ）求逆元。

首先，很显然的 $1^{-1} \equiv 1 \pmod p$ ；

然后，设 $p=ki+j,j<i,1<i<p$ ，再放到 $\mod p$ 意义下就会得到： $ki+j \equiv 0 \pmod p$ ；

两边同时乘 $i^{-1},j^{-1}$ ：

 $kj^{-1}+i^{-1} \equiv 0 \pmod p$ ；

 $i^{-1} \equiv -kj^{-1} \pmod p$ ；

 $i^{-1} \equiv -(\frac{p}{i}) (p \bmod i)^{-1}$ ；

然后我们就可以推出逆元了，实现代码极短：

```cpp
inv[1] = 1;
for (int i = 2; i <= n; ++i) inv[i] = (long long)-(p / i) * inv[p % i] % p;
```

但是有些情况下这样做会出现负数，所以我们要改改代码，让它只求正整数：

```cpp
inv[1] = 1;
for (int i = 2; i <= n; ++i) inv[i] = (long long)(p - p / i) * inv[p % i] % p;
```

这就是线性求逆元。

另外，根据线性求逆元方法的式子： $i^{-1} \equiv -kj^{-1} \pmod p$ 

递归求解 $j^-1$ , 直到 $j=1$ 返回 $1$ 。

中间优化可以加入一个记忆化来避免多次递归导致的重复，这样求 $1,2,...,n$ 中所有数的逆元的时间复杂度仍是 $O(n)$ 。

 **注意** ：如果用以上给出的式子递归进行单个数的逆元求解，目前已知的时间复杂度的上界为 $O(n^{\frac 1 3})$ ，具体请看 [知乎讨论](https://www.zhihu.com/question/59033693) 。算法竞赛中更好地求单个数的逆元的方法有扩展欧几里得法和快速幂法。

### 线性求任意 n 个数的逆元

上面的方法只能求 $1$ 到 $n$ 的逆元，如果需要求任意给定 $n$ 个数（ $1 \le a_i < p$ ）的逆元，就需要下面的方法：

首先计算 $n$ 个数的前缀积，记为 $s_i$ ，然后使用快速幂或扩展欧几里得法计算 $s_n$ 的逆元，记为 $sv_n$ 。

因为 $sv_n$ 是 $n$ 个数的积的逆元，所以当我们把它乘上 $a_n$ 时，就会和 $a_n$ 的逆元抵消，于是就得到了 $a_1$ 到 $a_{n-1}$ 的积逆元，记为 $sv_{n-1}$ 。

同理我们可以依次计算出所有的 $sv_i$ ，于是 $a_i^{-1}$ 就可以用 $s_{i-1} \times sv_i$ 求得。

所以我们就在 $O(n + \log p)$ 的时间内计算出了 $n$ 个数的逆元。

参考代码：

```cpp
s[0] = 1;
for (int i = 1; i <= n; ++i) s[i] = s[i - 1] * a[i] % p;
sv[n] = qpow(s[n], p - 2);
// 当然这里也可以用 exgcd 来求逆元,视个人喜好而定.
for (int i = n; i >= 1; --i) sv[i - 1] = sv[i] * a[i] % p;
for (int i = 1; i <= n; ++i) inv[i] = sv[i] * s[i - 1] % p;
```

## 逆元练习题

 [乘法逆元](https://loj.ac/problem/110) 

 [乘法逆元 2](https://loj.ac/problem/161) 

 [「NOIP2012」同余方程](https://loj.ac/problem/2605) 

 [「AHOI2005」洗牌](https://www.luogu.org/problem/P2054) 

 [「SDOI2016」排列计数](https://loj.ac/problem/2034) 

# inclusion-exclusion-principle
## 入门

???+note "入门例题"
    假设班里有 $10$ 个学生喜欢数学， $15$ 个学生喜欢语文， $21$ 个学生喜欢编程，班里至少喜欢一门学科的有多少个学生呢？

是 $10+15+21=46$ 个吗？不是的，因为有些学生可能同时喜欢数学和语文，或者语文和编程，甚至还有可能三者都喜欢。

为了叙述方便，我们把喜欢语文、数学、编程的学生集合分别用 $A,B,C$ 表示，则学生总数等于 $|A\cup B\cup C|$ 。刚才已经讲过，如果把这三个集合的元素个数 $|A|,|B|,|C|$ 直接加起来，会有一些元素重复统计了，因此需要扣掉 $|A\cap B|,|B\cap C|,|C\cap A|$ ，但这样一来，又有一小部分多扣了，需要加回来，即 $|A\cap B\cap C|$ 。即

$$
|A\cup B\cup C|=|A|+|B|+|C|-|A\cap B|-|B\cap C|-|C\cap A|+|A\cap B\cap C|
$$

![容斥原理 - venn 图示例](./images/incexcp.png)

把上述问题推广到一般情况，就是我们熟知的容斥原理。

## 容斥原理

设 U 中元素有 n 种不同的属性，而第 i 种属性称为 $P_i$ ，拥有属性 $P_i$ 的元素构成集合 $S_i$ ，那么

$$
\begin{split}
\left|\bigcup_{i=1}^{n}S_i\right|=&\sum_{i}|S_i|-\sum_{i<j}|S_i\cap S_j|+\sum_{i<j<k}|S_i\cap S_j\cap S_k|-\cdots\\
&+(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^{m}S_{a_i}\right|+\cdots+(-1)^{n-1}|S_1\cap\cdots\cap S_n|
\end{split}
$$

即

$$
\left|\bigcup_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^mS_{a_i}\right|
$$

### 证明

对于每个元素使用二项式定理计算其出现的次数。对于元素 x，假设它出现在 $T_1,T_2,\cdots,T_m$ 的集合中，那么它的出现次数为

$$
\begin{split}
Cnt=&|\{T_i\}|-|\{T_i\cap T_j|i<j\}|+\cdots+(-1)^{k-1}\left|\left\{\bigcap_{i=1}^{k}T_{a_i}|a_i<a_{i+1}\right\}\right|\\
&+\cdots+(-1)^{m-1}|\{T_1\cap\cdots\cap T_m\}|\\
=&C_m^1-C_m^2+\cdots+(-1)^{m-1}C_m^m\\
=&C_m^0-\sum_{i=0}^m(-1)^iC_m^i\\
=&1-(1-1)^m=1
\end{split}
$$

于是每个元素出现的次数为 1，那么合并起来就是并集。证毕。

### 补集

对于全集 U 下的 **集合的并** 可以使用容斥原理计算，而集合的交则用全集减去 **补集的并集** 求得：

$$
\left|\bigcap_{i=1}^{n}S_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|
$$

右边使用容斥即可。

可能接触过容斥的读者都清楚上述内容，而更关心的是容斥的应用

那么接下来我们给出 3 个层次不同的例题来为大家展示容斥原理的应用。

## 不定方程非负整数解计数

???+note "不定方程非负整数解计数"
    给出不定方程 $\sum_{i=1}^nx_i=m$ 和 $n$ 个限制条件 $x_i\leq b_i$ ，其中 $m,b_i\leq \mathbb{N}$ . 求方程的非负整数解的个数。

### 没有限制时

如果没有 $x_i<b_i$ 的限制，那么不定方程 $\sum_{i=1}^nx_i=m$ 的非负整数解的数目为 $C_{m+n-1}^{n-1}$ .

略证：插板法。

相当于你有 $m$ 个球要分给 $n$ 个盒子，允许某个盒子是空的。这个问题不能直接用组合数解决。

于是我们再加入 $n-1$ 个球，于是问题就变成了在一个长度为 $m+n-1$ 的球序列中选择 $n-1$ 个球，然后这个 $n-1$ 个球把这个序列隔成了 $n$ 份，恰好可以一一对应放到 $n$ 个盒子中。那么在 $m+n-1$ 个球中选择 $n-1$ 个球的方案数就是 $C_{m+n-1}^{n-1}$ 。

### 容斥模型

接着我们尝试抽象出容斥原理的模型：

1.  全集 U：不定方程 $\sum_{i=1}^nx_i=m$ 的非负整数解
2.  元素：变量 $x_i$ .
3.  属性： $x_i$ 的属性即 $x_i$ 满足的条件，即 $x_i\leq b_i$ 的条件

目标：所有变量满足对应属性时集合的大小，即 $|\bigcap_{i=1}^nS_i|$ .

这个东西可以用 $\left|\bigcap_{i=1}^{n}S_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|$ 求解。 $|U|$ 可以用组合数计算，后半部分自然使用容斥原理展开。

那么问题变成，对于一些 $\overline{S_{a_i}}$ 的交集求大小。考虑 $\overline{S_{a_i} }$ 的含义，表示 $x_{a_i}\geq b_{a_i}+1$ 的解的数目。而交集表示同时满足这些条件。因此这个交集对应的不定方程中，有些变量有 **下界限制** ，而有些则没有限制。

能否消除这些下界限制呢？既然要求的是非负整数解，而有些变量的下界又大于 $0$ ，那么我们直接 **把这个下界减掉** ，就可以使得这些变量的下界变成 $0$ ，即没有下界啦。因此对于

$$
\left|\bigcap_{a_i<a_{i+1} }^{1\leq i\leq k}S_{a_i}\right|
$$

的不定方程形式为

$$
\sum_{i=1}^nx_i=m-\sum_{i=1}^k(b_{a_i}+1)
$$

于是这个也可以组合数计算啦。这个长度为 $k$ 的 $a$ 数组相当于在枚举子集。

## HAOI2008 硬币购物

???+note "HAOI2008 硬币购物"
    4 种面值的硬币，第 i 种的面值是 $C_i$ 。 $n$ 次询问，每次询问给出每种硬币的数量 $D_i$ 和一个价格 $S$ ，问付款方式。
    
     $n\leq 10^3,S\leq 10^5$ .

如果用背包做的话复杂度是 $O(4nS)$ ，无法承受。这道题最明显的特点就是硬币一共只有四种。抽象模型，其实就是让我们求方程 $\sum_{i=1}^4C_ix_i=S,x_i\leq D_i$ 的非负整数解的个数。

采用同样的容斥方式， $x_i$ 的属性为 $x_i\leq D_i$ . 套用容斥原理的公式，最后我们要求解

$$
\sum_{i=1}^4C_ix_i=S-\sum_{i=1}^kC_{a_i}(D_{a_i}+1)
$$

也就是无限背包问题。这个问题可以预处理，算上询问，总复杂度 $O(4S+2^4n)$ 。

??? note "代码实现"
    ```cpp
    #include <bits/stdc++.h>
    #define int long long
    using namespace std;
    const int S = 1e5 + 5;
    int c[5], d[5], n, s;
    int f[S];
    signed main() {
      scanf("%lld%lld%lld%lld%lld", &c[1], &c[2], &c[3], &c[4], &n);
      f[0] = 1;
      for (int j = 1; j <= 4; j++)
        for (int i = 1; i < S; i++)
          if (i >= c[j]) f[i] += f[i - c[j]];
      for (int i = 1; i <= n; i++) {
        scanf("%lld%lld%lld%lld%lld", &d[1], &d[2], &d[3], &d[4], &s);
        int ans = 0;
        for (int i = 1; i < 16; i++) {
          int m = s, bit = 0;
          for (int j = 1; j <= 4; j++)
            if ((i >> (j - 1)) & 1) m -= (d[j] + 1) * c[j], bit++;
          if (m >= 0) ans += (bit % 2 * 2 - 1) * f[m];
        }
        printf("%lld\n", f[s] - ans);
      }
      return 0;
    }
    ```

## 错位排列计数

???+note "错位排列计数"
    对于 $1\sim n$ 的排列 $P$ 如果满足 $P_i\neq i$ ，则称 $P$ 是 $n$ 的错位排列。求 $n$ 的错位排列数。

全集 $U$ 即为 $1\sim n$ 的排列， $|U|=n!$ ；属性就是 $P_i\neq i$ . 套用补集的公式，问题变成求 $\left|\bigcup_{i=1}^n\overline{S_i}\right|$ .

我们知道 $\overline{S_i}$ 的含义是满足 $P_i=i$ 的排列的数量。用容斥原理把问题式子展开，我们需要对若干个特定的集合的交集求大小，即

$$
\left|\bigcap_{i=1}^{k}S_{a_i}\right|
$$

其中我们省略了 $a_i<a_{i+1}$ 的条件以方便表示。上述 $k$ 个集合的交集表示有 $k$ 个变量满足 $P_{a_i}=a_i$ 的排列数，而剩下 $n-k$ 个数的位置任意，因此排列数

$$
\left|\bigcap_{i=1}^{k}S_{a_i}\right|=(n-k)!
$$

那么选择 $k$ 个元素的方案数为 $C_n^k$ ，因此有

$$
\begin{split}
\left|\bigcup_{i=1}^n\overline{S_i}\right|
&=\sum_{k=1}^n(-1)^{k-1}\sum_{a_{1,\cdots,k} }\left|\bigcap_{i=1}^{k}S_{a_i}\right|\\
&=\sum_{k=1}^n(-1)^{k-1}C_n^k(n-k)!\\
&=\sum_{k=1}^n(-1)^{k-1}\frac{n!}{k!}\\
&=n!\sum_{k=1}^n\frac{(-1)^{k-1} }{k!}
\end{split}
$$

因此 $n$ 的错位排列数为

$$
D_n=n!-n!\sum_{k=1}^n\frac{(-1)^{k-1} }{k!}=n!\sum_{k=0}^n\frac{(-1)^k}{k!}
$$

## 完全图子图染色问题

前面的三道题都是容斥原理的正向运用，这道题则需要用到容斥原理逆向分析。

???+note "完全图子图染色问题"
    A 和 B 喜欢对图（不一定连通）进行染色，而他们的规则是，相邻的结点必须染同一种颜色。今天 A 和 B 玩游戏，对于 $n$ 阶 **完全图**  $G=(V,E)$ 。他们定义一个估价函数 $F(S)$ ，其中 S 是边集， $S\subseteq E$ . $F(S)$ 的值是对图 $G'=(V,S)$ 用 $m$ 种颜色染色的总方案数。他们的另一个规则是，如果 $|S|$ 是奇数，那么 A 的得分增加 $F(S)$ ，否则 B 的得分增加 $F(S)$ . 问 A 和 B 的得分差值。

### 数学形式

一看这道题的算法趋向并不明显，因此对于棘手的题目首先抽象出数学形式。得分差即为奇偶对称差，可以用 -1 的幂次来作为系数。我们求的是

$$
Ans=\sum_{S\subseteq E}(-1)^{|S|-1}F(S)
$$

### 容斥模型

相邻结点染同一种颜色，我们把它当作属性。在这里我们先不遵守染色的规则，假定我们用 m 种颜色直接对图染色。对于图 $G'=(V,S)$ ，我们把它当作 **元素** 。 **属性**  $x_i=x_j$ 的含义是结点 i,j 染同色（注意，并未要求 i,j 之间有连边）。

而属性 $x_i=x_j$ 对应的 **集合** 定义为 $Q_{i,j}$ ，其含义是所有满足该属性的图 $G'$ 的染色方案，集合的大小就是满足该属性的染色方案数，集合内的元素相当于所有满足该属性的图 $G'$ 的染色图。

回到题目，“相邻的结点必须染同一种颜色”，可以理解为若干个 $Q$ 集合的交集。因此可以写出

$$
F(S)=\left|\bigcap_{(i,j)\in S}Q_{i,j}\right|
$$

上述式子右边的含义就是说对于 S 内的每一条边 $(i,j)$ 都满足 $x_i=x_j$ 的染色方案数，也就是 $F(S)$ .

是不是很有容斥的味道了？由于容斥原理本身没有二元组的形式，因此我们把 **所有** 的边 $(i,j)$ 映射到 $T=\frac{n(n+1)}{2}$ 个整数上，假设将 $(i,j)$ 映射为 $k,1\leq k\leq T$ ，同时 $Q_{i,j}$ 映射为 $Q_k$ . 那么属性 $x_i=x_j$ 则定义为 $P_k$ .

同时 S 可以表示为若干个 k 组成的集合，即 $S\Leftrightarrow K=\{k_1,k_2,\cdots,k_m\}$ .（也就是说我们在边集与数集间建立了等价关系）。

而 E 对应集合 $M=\left\{1,2,\cdots,\frac{n(n+1)}{2}\right\}$ . 于是乎

$$
F(S)\Leftrightarrow F(\{ {k_i}\})=\left|\bigcap_{k_i}Q_{k_i}\right|
$$

### 逆向分析

那么要求的式子展开

$$
\begin{split}
Ans &= \sum_{K\subseteq M}(-1)^{|K|-1}\left|\bigcap_{k_i\in K}Q_{k_i}\right|\\
    &= \sum_{i}|Q_i|-\sum_{i<j}|Q_i\cap Q_j|+\sum_{i<j<k}|Q_i\cap Q_j\cap Q_k|-\cdots+(-1)^{T-1}\left|\bigcap_{i=1}^TQ_i\right|
\end{split}
$$

于是就出现了容斥原理的展开形式，因此对这个式子逆向推导

$$
Ans=\left|\bigcup_{i=1}^TQ_i\right|
$$

再考虑等式右边的含义，只要满足 $1\sim T$ 任一条件即可，也就是存在两个点同色（不一定相邻）的染色方案数！而我们知道染色方案的全集是 $U$ ，显然 $|U|=m^n$ . 而转化为补集，就是求两两异色的染色方案数，即 $A_m^n=\frac{m!}{n!}$ . 因此

$$
Ans=m^n-A_m^n
$$

解决这道题，我们首先抽象出题目数学形式，然后从题目中信息量最大的条件， $F(S)$ 函数的定义入手，将其转化为集合的交并补。然后将式子转化为容斥原理的形式，并 **逆向推导** 出最终的结果。这道题体现的正是容斥原理的逆用。

## 数论中的容斥

考虑这样一个经典问题

???+note "欧拉函数公式"
    求欧拉函数 $\varphi(n)$ . 其中 $\varphi(n)=|\{1\leq x\leq n|\gcd(x,n)=1\}|$ 。

直接计算是 $O(n\log n)$ 的，用线性筛是 $O(n)$ 的，杜教筛是 $O(n^{\frac{2}{3}})$ 的（话说一道数论入门题用容斥做为什么还要扯到杜教筛上），接下来考虑用容斥推出欧拉函数的公式

判断两个数是否互质，首先分解质因数

$$
n=\prod_{i=1}^k{p_i}^{c_i}
$$

那么就要求对于任意 $p_i$ ， $x$ 都不是 $p_i$ 的倍数，即 $p_i\nmid x$ . 把它当作属性，对应的集合为 $S_i$ ，因此有

$$
\varphi(n)=\left|\bigcap_{i=1}^kS_i\right|=|U|-\left|\bigcup_{i=1}^k\overline{S_i}\right|
$$

全集大小 $|U|=n$ ，而 $\overline{S_i}$ 表示的是 $p_i\mid x$ 构成的集合，显然 $|\overline{S_i}|=\frac{n}{p_i}$ ，并由此推出

$$
\left|\bigcap_{a_i<a_{i+1}}S_{a_i}\right|=\frac{n}{\prod p_{a_i}}
$$

因此可得

$$
\begin{split}
\varphi(n)=&n-\sum_{i}\frac{n}{p_i}+\sum_{i<j}\frac{n}{p_ip_j}-\cdots+(-1)^k\frac{n}{p_1p_2\cdots p_n}\\
=&n\left(1-\frac{1}{p_1}\right)\left(1-\frac{1}{p_2}\right)\cdots\left(1-\frac{1}{p_k}\right)\\
=&n\prod_{i=1}^k\left(1-\frac{1}{p_i}\right)
\end{split}
$$

这就是欧拉函数的数学表示啦

## 容斥原理一般化

容斥原理常用于集合的计数问题，而对于两个集合的函数 $f(S),g(S)$ ，若

$$
f(S)=\sum_{T\subseteq S}g(T)
$$

那么就有

$$
g(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}f(T)
$$

### 证明

接下来我们简单证明一下。我们从等式的右边开始推：

$$
\begin{split}
&\sum_{T\subseteq S}(-1)^{|S|-|T|}f(T)\\
=&\sum_{T\subseteq S}(-1)^{|S|-|T|}\sum_{Q\subseteq T}g(Q)\\
=&\sum_{Q}g(Q)\sum_{Q\subseteq T\subseteq S}(-1)^{|S|-|T|}\\
\end{split}
$$

我们发现后半部分的求和与 $Q$ 无关，因此把后半部分的 Q 剔除：

$$
=\sum_{Q}g(Q)\sum_{T\subseteq (S\setminus Q)}(-1)^{|S\setminus Q|-|T|}\\
$$

记关于集合 $P$ 的函数 $F(P)=\sum_{T\subseteq P}(-1)^{|P|-|T|}$ ，并化简这个函数：

$$
\begin{split}
F(P)=&\sum_{T\subseteq P}(-1)^{|P|-|T|}\\
=&\sum_{i=0}^{|P|}C_{|P|}^i(-1)^{|P|-i}=\sum_{i=0}^{|P|}C_{|P|}^i1^i(-1)^{|P|-i}\\
=&(1-1)^{|P|}=0^{|P|}
\end{split}
$$

因此原来的式子的值是

$$
\sum_{Q}g(Q)\sum_{T\subseteq (S\setminus Q)}(-1)^{|S\setminus Q|-|T|}=\sum_{Q}g(Q)F(S\setminus Q)=\sum_{Q}g(Q)\cdot 0^{|S\setminus Q|}
$$

分析发现，仅当 $|S\setminus Q|=0$ 时有 $0^0=1$ ，这时 $Q=S$ ，对答案的贡献就是 $g(S)$ ，其他时侯 $0^{|S\setminus Q|}=0$ ，则对答案无贡献。于是得到

$$
\sum_{Q}g(Q)\cdot 0^{|S\setminus Q|}=g(S)
$$

综上所述，得证。

### 推论

该形式还有这样一个推论。在全集 $U$ 下，对于函数 $f(S),g(S)$ ，如果

$$
f(S)=\sum_{S\subseteq T}g(T)
$$

那么

$$
g(S)=\sum_{S\subseteq T}(-1)^{|T|-|S|}f(T)
$$

这个推论其实就是补集形式，证法类似。

## DAG 计数

???+note "DAG 计数"
    对 $n$ 个点带标号的有向无环图进行计数，对 $10^9+7$ 取模。 $n\leq 5\times 10^3$ 。

### 直接 DP

考虑 DP，定义 $f[i,j]$ 表示 $i$ 个点的 DAG，有 $j$ 点个入度为 $0$ 的图的个数。假设去掉这 $j$ 个点后，有 $k$ 个点入度为 $0$ ，那么在去掉前这 $k$ 个点至少与这 $j$ 个点中的某几个有连边，即 $2^j-1$ 种情况；而这 $j$ 个点除了与 $k$ 个点连边，还可以与剩下的点任意连边，有 $2^{i-j-k}$ 种情况。因此方程如下：

$$
f[i,j]=\binom{i}{j}\sum_{k=1}^{i-j}(2^j-1)^k2^{i-j-k}f[i-j,k]
$$

计算上式的复杂度是 $O(n^3)$ 的。

### 放宽限制

上述 DP 的定义是恰好 $j$ 个点入度为 $0$ , 太过于严格，可以放宽为至少 $j$ 个点入度为 $0$ 。直接定义 $f[i]$ 表示 $i$ 个点的 DAG 个数。可以直接容斥。考虑选出的 $j$ 个点，这 $j$ 个点可以和剩下的 $i-j$ 个点有任意的连边，即 $\left(2^{i-j}\right)^j=2^{(i-j)j}$ 种情况：

$$
f[i]=\sum_{j=1}^i(-1)^{j-1}\binom{i}{j}2^{(i-j)j}f[i-j]
$$

计算上式的复杂度是 $O(n^2)$ 的。

## Min-max 容斥

对于全序集合 $S$ ，有：

$$
\begin{split}
\max S &= \sum_{T\subseteq S}(-1)^{|T|-1} \min T\\
\min S &= \sum_{T\subseteq S}(-1)^{|T|-1} \max T
\end{split}
$$

??? note "全序集合"
    在介绍全序集合之前，首先介绍全序关系。对于集合 $X$ ，若 $X$ 满足全序关系，则下列陈述对于任意 $a,b,c\in X$ 都成立：

    - 反对称性：若$a\le b$且$b\le a$，则$a=b$; 
    - 传递性：若$a\le b$且$b\le c$，则$a\le c$；
    - 完全性：$a\le b$或者$b\le a$。

    满足全序关系的集合就是全序集合。

    不严谨地说，全序集合就是每一个元素都有确定的排名的集合（可以求第k大/第k小）。比如正整数集合。

### 证明

考虑做一个到一般容斥原理的映射。对于 $x\in S$ ，假设 $x$ 是第 $k$ 大的元素。那么我们定义一一映射 $f:x\mapsto \{1,2,\cdots,k\}$ 。

容易发现， $x$ ， $k$ ， $f(x)$ 两两都是一一映射的关系。

那么容易发现，对于 $x,y\in S$ ， $f(\min(x,y))=f(x)\cap f(y)$ ， $f(\max(x,y))=f(x)\cup f(y)$ 。因此我们得到：

$$
\begin{split}
|f(\max S )|
&= \left| \bigcup_{x\in S} f(x) \right|\\
&= \sum_{T\subseteq S}(-1)^{|T|-1} \left|\bigcap_{x\in T}f(x)\right|\\
&= \sum_{T\subseteq S}(-1)^{|T|-1} |f(\min T)|\\
\end{split}
$$

然后再把 $|f(\max S)|$ 映射回 $\max S$ ，我们就证明了原式。

## PKUWC2018 随机游走

???+note "[PKUWC2018 随机游走](https://loj.ac/problem/2542)"
    给定一棵 $n$ 个点的树，你从 $x$ 出发，每次等概率随机选择一条与所在点相邻的边走过去。

    有$Q$次询问。每次询问给出一个集合$S$，求如果从$x$出发一直随机游走，直到点集$S$中的点都至少经过一次的话，期望游走几步。

    特别地，点$x$（即起点）视为一开始就被经过了一次。

    对$998244353$取模。

    $1\le n\le 18,1\le Q\le 5000,1\le |S|\le n$。

期望游走的步数也就是游走的时间。那么设随机变量 $x_i$ 表示第一次走到结点 $i$ 的时间。那么我们要求的就是

$$
E\left(\max_{i\in S}x_i\right)
$$

使用 min-max 容斥可以得到

$$
E\left(\max_{i\in S}x_i\right)
=E\left(\sum_{T\subseteq S}(-1)^{|T|-1}\min_{i\in T}x_i\right)
=\sum_{T\subseteq S}(-1)^{|T|-1}E\left(\min_{i\in T}x_i\right)
$$

对于一个集合 $T\in[n]$ ，考虑求出 $F(T)=E(\min_{i\in T}x_i)$ 。

考虑 $E(\min_{i\in T}x_i)$ 的含义，是第一次走到 $T$ 中某一个点的期望时间。不妨设 $f(i)$ 表示从结点 $i$ 出发，第一次走到 $T$ 中某个结点的期望时间。

-   对于 $i\in T$ ，有 $f(i)=0$ 。
-   对于 $i\notin T$ ，有 $f(i)=1+\frac{1}{\text{deg}(i)}\sum_{(i,j)\in E}f(j)$ 。

如果直接高斯消元，复杂度 $O(n^3)$ 。那么我们对每个 $T$ 都计算 $F(T)$ 的总复杂度就是 $O(2^nn^3)$ ，不能接受。我们使用树上消元的技巧。

不妨设根结点是 $1$ ，结点 $u$ 的父亲是 $p_u$ 。对于叶子结点 $i$ ， $f(i)$ 只会和 $i$ 的父亲有关（也可能 $f(i)=0$ ，那样更好）。因此我们可以把 $f(i)$ 表示成 $f(i)=A_i+B_if(p_i)$ 的形式，其中 $A_i,B_i$ 可以快速计算。

对于非叶结点 $i$ ，考虑它的儿子序列 $j_1,\cdots,j_k$ 。由于 $f(j_e)=A_{j_e}+B_{j_e}f(i)$ 。因此可以得到

$$
f(i)=1+\frac{1}{\deg(i)}\sum_{e=1}^k\left(A_{j_e}+B_{j_e}f(i)\right)+\frac{f(p_i)}{\deg(i)}
$$

那么变换一下可以得到

$$
f(i)=\frac{\deg(i)+\sum_{e=1}^kA_{j_e}}{\deg(i)-\sum_{e=1}^kB_{j_e}}+
\frac{f(p_i)}{\deg(i)-\sum_{e=1}^kB_{j_e}}
$$

于是我们把 $f(i)$ 也写成了 $A_i+B_if(p_i)$ 的形式。这样可以一直倒推到根结点。而根结点没有父亲。也就是说

$$
f(1)=\frac{\deg(1)+\sum_{e=1}^kA_{j_e}}{\deg(1)-\sum_{e=1}^kB_{j_e}}
$$

解一下这个方程我们就得到了 $f(1)$ ，再从上往下推一次就得到了每个点的 $f(i)$ 。那么 $F(T)=f(x)$ 。时间复杂度 $O(n)$ 。

这样，我们可以对于每一个 $T$ 计算出 $F(T)$ ，时间复杂度 $O(2^nn)$ 。

回到容斥的部分，我们知道 $E(\max_{i\in S}x_i)=\sum_{T\subseteq S}(-1)^{|T|-1}F(T)$ 。

不妨设 $F'(T)=(-1)^{|T|-1}F(T)$ ，那么进一步得到 $E(\max_{i\in S}x_i)=\sum_{T\subseteq S}F'(T)$ 。因此可以使用 FMT（也叫子集前缀和，或者 FWT 或变换）在 $O(2^nn)$ 的时间内对每个 $S$ 计算出 $E(\max_{i\in S}x_i)$ ，这样就可以 $O(1)$ 回答询问了。

## 参考文献

王迪《容斥原理》，2013 年信息学奥林匹克中国国家队候选队员论文集

 [Cyhlnj《有标号的 DAG 计数系列问题》](https://blog.csdn.net/oi_konnyaku/article/details/84862271) 

 [Wikipedia - 全序关系](https://en.wikipedia.org/wiki/Total_order) 

# euclidean
author: sshwy, FFjet

类欧几里德算法由洪华敦在 2016 年冬令营营员交流中提出的内容，其本质可以理解为，使用一个类似辗转相除法来做函数求和的过程。

## 引入

设

$$
f(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor
$$

其中 $a,b,c,n$ 是常数。需要一个 $O(\log n)$ 的算法。

这个式子和我们以前见过的式子都长得不太一样。带向下取整的式子容易让人想到数论分块，然而数论分块似乎不适用于这个求和。但是我们是可以做一些预处理的。

如果说 $a\ge c$ 或者 $b\ge c$ ，意味着可以将 $a,b$ 对 $c$ 取模以简化问题：

$$
\begin{split}
f(a,b,c,n)&=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor\\
&=\sum_{i=0}^n\left\lfloor
\frac{\left(\left\lfloor\frac{a}{c}\right\rfloor c+a\bmod c\right)i+\left(\left\lfloor\frac{b}{c}\right\rfloor c+b\bmod c\right)}{c}\right\rfloor\\
&=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+
\sum_{i=0}^n\left\lfloor\frac{\left(a\bmod c\right)i+\left(b\bmod c\right)}{c}
\right\rfloor\\
&=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor
+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+f(a\bmod c,b\bmod c,c,n)
\end{split}
$$

那么问题转化为了 $a<c,b<c$ 的情况。观察式子，你发现只有 $i$ 这一个变量。因此要推就只能从 $i$ 下手。在推求和式子中有一个常见的技巧，就是条件与贡献的放缩与转化。具体地说，在原式 $\displaystyle f(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor$ 中， $0\le i\le n$ 是条件，而 $\left\lfloor \dfrac{ai+b}{c} \right\rfloor$ 是对总和的贡献。

要加快一个和式的计算过程，所有的方法都可以归约为 **贡献合并计算** 。但你发现这个式子的贡献难以合并，怎么办？ **将贡献与条件做转化** 得到另一个形式的和式。具体地，我们直接把原式的贡献变成条件：

$$
\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor
=\sum_{i=0}^n\sum_{j=0}^{\left\lfloor \frac{ai+b}{c} \right\rfloor-1}1\\
$$

现在多了一个变量 $j$ ，既然算 $i$ 的贡献不方便，我们就想办法算 $j$ 的贡献。因此想办法搞一个和 $j$ 有关的贡献式。这里有另一个家喻户晓的变换方法，笔者概括为限制转移。具体来说，在上面的和式中 $n$ 限制 $i$ 的上界，而 $i$ 限制 $j$ 的上界。为了搞 $j$ ，就先把 j 放到贡献的式子里，于是我们~~神仙地~~交换一下 $i,j$ 的求和算子，强制用 $n$ 限制 $j$ 的上界。

$$
\begin{split}
&=\sum_{j=0}^{\left\lfloor \frac{an+b}{c} \right\rfloor-1}
\sum_{i=0}^n\left[j<\left\lfloor \frac{ai+b}{c} \right\rfloor\right]\\
\end{split}
$$

这样做的目的是让 $j$ 摆脱 $i$ 的限制，现在 $i,j$ 都被 $n$ 限制，而贡献式看上去是一个条件，但是我们仍把它叫作贡献式，再对贡献式做变换后就可以改变 $i,j$ 的限制关系。于是我们做一些放缩的处理。首先把向下取整的符号拿掉

$$
j<\left\lfloor \frac{ai+b}{c} \right\rfloor
\Leftrightarrow j+1\leq \left\lfloor \frac{ai+b}{c} \right\rfloor
\Leftrightarrow j+1\leq \frac{ai+b}{c}\\
$$

然后可以做一些变换

$$
j+1\leq \frac{ai+b}{c} \Leftrightarrow jc+c\le ai+b \Leftrightarrow jc+c-b-1< ai
$$

最后一步，向下取整得到：

$$
jc+c-b-1< ai\Leftrightarrow \left\lfloor\frac{jc+c-b-1}{a}\right\rfloor< i
$$

这一步的重要意义在于，我们可以把变量 $i$ 消掉了！具体地，令 $m=\left\lfloor \frac{an+b}{c} \right\rfloor$ ，那么原式化为

$$
\begin{split}
f(a,b,c,n)&=\sum_{j=0}^{m-1}
\sum_{i=0}^n\left[i>\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor \right]\\
&=\sum_{j=0}^{m-1}
n-\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor\\
&=nm-f\left(c,c-b-1,a,m-1\right)
\end{split}
$$

这是一个递归的式子。并且你发现 $a,c$ 分子分母换了位置，又可以重复上述过程。先取模，再递归。这就是一个辗转相除的过程，这也是类欧几里德算法的得名。

容易发现时间复杂度为 $O(\log n)$ 。

## 扩展

理解了最基础的类欧几里德算法，我们再来思考以下两个变种求和式：

$$
g(a,b,c,n)=\sum_{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor\\
h(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2
$$

### 推导 g

我们先考虑 $g$ ，类似地，首先取模：

$$
g(a,b,c,n)
=g(a\bmod c,b\bmod c,c,n)+\left\lfloor\frac{a}{c}\right\rfloor\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor\frac{n(n+1)}{2}
$$

接下来考虑 $a<c,b<c$ 的情况，令 $m=\left\lfloor\frac{an+b}{c}\right\rfloor$ 。之后的过程我会写得很简略，因为方法和上文略同：

$$
\begin{split}
&g(a,b,c,n)=\sum_{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor\\
&=\sum_{j=0}^{m-1}
\sum_{i=0}^n\left[j<\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\cdot i
\end{split}
$$

这时我们设 $t=\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor$ ，可以得到

$$
\begin{split}
&=\sum_{j=0}^{m-1}\sum_{i=0}^n[i>t]\cdot i\\
&=\sum_{j=0}^{m-1}\frac{1}{2}(t+n+1)(n-t)\\
&=\frac{1}{2}\left[mn(n+1)-\sum_{j=0}^{m-1}t^2-\sum_{j=0}^{m-1}t\right]\\
&=\frac{1}{2}[mn(n+1)-h(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)]
\end{split}
$$

### 推导 h

同样的，首先取模：

$$
\begin{split}
h(a,b,c,n)&=h(a\bmod c,b\bmod c,c,n)\\
&+2\left\lfloor\frac{b}{c}\right\rfloor f(a\bmod c,b\bmod c,c,n)
+2\left\lfloor\frac{a}{c}\right\rfloor g(a\bmod c,b\bmod c,c,n)\\
&+\left\lfloor\frac{a}{c}\right\rfloor^2\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor^2(n+1)
+\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor n(n+1)
\end{split}
$$

考虑 $a<c,b<c$ 的情况， $m=\left\lfloor\dfrac{an+b}{c}\right\rfloor, t=\left\lfloor\dfrac{jc+c-b-1}{a}\right\rfloor$ .

我们发现这个平方不太好处理，于是可以这样把它拆成两部分：

$$
n^2=2\dfrac{n(n+1)}{2}-n=\left(2\sum_{i=0}^ni\right)-n
$$

这样做的意义在于，添加变量 $j$ 的时侯就只会变成一个求和算子，不会出现 $\sum\times \sum$ 的形式：

$$
\begin{split}
&h(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2
=\sum_{i=0}^n\left[\left(2\sum_{j=1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j \right)-\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\\
=&\left(2\sum_{i=0}^n\sum_{j=1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j\right) -f(a,b,c,n)\\
\end{split}
$$

接下来考虑化简前一部分：

$$
\begin{split}
&\sum_{i=0}^n\sum_{j=1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j\\
=&\sum_{i=0}^n\sum_{j=0}^{\left\lfloor \frac{ai+b}{c} \right\rfloor-1}(j+1)\\
=&\sum_{j=0}^{m-1}(j+1)
\sum_{i=0}^n\left[j<\left\lfloor \frac{ai+b}{c} \right\rfloor\right]\\
=&\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^n[i>t]\\
=&\sum_{j=0}^{m-1}(j+1)(n-t)\\
=&\frac{1}{2}nm(m+1)-\sum_{j=0}^{m-1}(j+1)\left\lfloor \frac{jc+c-b-1}{a} \right\rfloor\\
=&\frac{1}{2}nm(m+1)-g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)
\end{split}
$$

因此

$$
h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)
$$

## 模板与实现

在计算的时侯，因为 $3$ 个函数各有交错递归，因此可以考虑三个一起整体递归，同步计算，否则有很多项会被多次计算。这样实现的复杂度是 $O(\log n)$ 的。

模板： [luogu5170](https://www.luogu.org/problemnew/show/P5170) 

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int P = 998244353;
int i2 = 499122177, i6 = 166374059;
struct data {
  data() { f = g = h = 0; }
  int f, g, h;
};  // 三个函数打包
data calc(int n, int a, int b, int c) {
  int ac = a / c, bc = b / c, m = (a * n + b) / c, n1 = n + 1, n21 = n * 2 + 1;
  data d;
  if (a == 0)  // 迭代到最底层
  {
    d.f = bc * n1 % P;
    d.g = bc * n % P * n1 % P * i2 % P;
    d.h = bc * bc % P * n1 % P;
    return d;
  }
  if (a >= c || b >= c)  // 取模
  {
    d.f = n * n1 % P * i2 % P * ac % P + bc * n1 % P;
    d.g = ac * n % P * n1 % P * n21 % P * i6 % P + bc * n % P * n1 % P * i2 % P;
    d.h = ac * ac % P * n % P * n1 % P * n21 % P * i6 % P +
          bc * bc % P * n1 % P + ac * bc % P * n % P * n1 % P;
    d.f %= P, d.g %= P, d.h %= P;

    data e = calc(n, a % c, b % c, c);  // 迭代

    d.h += e.h + 2 * bc % P * e.f % P + 2 * ac % P * e.g % P;
    d.g += e.g, d.f += e.f;
    d.f %= P, d.g %= P, d.h %= P;
    return d;
  }
  data e = calc(m - 1, c, c - b - 1, a);
  d.f = n * m % P - e.f, d.f = (d.f % P + P) % P;
  d.g = m * n % P * n1 % P - e.h - e.f, d.g = (d.g * i2 % P + P) % P;
  d.h = n * m % P * (m + 1) % P - 2 * e.g - 2 * e.f - d.f;
  d.h = (d.h % P + P) % P;
  return d;
}
int T, n, a, b, c;
signed main() {
  scanf("%lld", &T);
  while (T--) {
    scanf("%lld%lld%lld%lld", &n, &a, &b, &c);
    data ans = calc(n, a, b, c);
    printf("%lld %lld %lld\n", ans.f, ans.h, ans.g);
  }
  return 0;
}
```

# base
在计算机中，除了二进制，比较常用的还有八进制和十六进制。

## 二进制

二进制是计算机内部运算中采用的进制，在这样的进制系统下，只有 $0,1$ 两个数字，计算机内部的所有运算（包括位运算）都是在二进制的基础上进行的。

但用二进制表示数字会让数字过长，因此为了方便表示的需要，通常会把二进制数转换为八进制或十六进制表示。

## 八进制

在八进制下，有 $0,1,2,3,4,5,6,7$ 八个数字。

一般情况下，八进制数以 `oxx` （其中 `o` 为八进制的前缀， `xx` 代表八进制数）的形式来表示。

## 十六进制

在十六进制下，有 $0,1,2,3,4,5,6,7,8,9,A(10),B(11),C(12),D(13),E(14),F(15)$ 十六个数字。

十六进制与二进制相比，最大的优点就是表示的数字长度较短，一位十六进制数可以表示 4 位二进制数。

一般情况下，十六进制数以 `0xdbf` （其中 `0x` 为十六进制数的前缀）的形式来表示。

## 进制间的相互转化

### 十进制转二进制/八进制/十六进制

这里以二进制为例来演示，其他进制的原理与其类似。

整数部分，把十进制数不断执行除 2 操作，直至商数为 0。读余数从下读到上，即是二进制的整数部分数字。小数部分，则用其乘 2，取其整数部分的结果，再用计算后的小数部分依此重复计算，算到小数部分全为 0 为止，之后从上到下，读所有计算后整数部分的数字，即为二进制的小数部分数字。

```text
将33.25转化为二进制数
整数部分：
33/2=16	......1
16/2=8	......0
8/2=4	......0
4/2=2	......0
2/2=1	......0
1/2=0	......1
小数部分：
0.25*2=0.5	0
0.5*2=1		1
```

即 $33.25 = (100001.01)_2$ 

### 二进制/八进制/十六进制转十进制

还是以二进制为例。

二进制数转换为十进制数，只需将每个位的值，乘以 $2^i$ 次即可，其中 $i$ 为当前位的位数，个位的位数为 0。

```text
将11010.01(2)转换为十进制数
11010.01(2)=1*2^4+1*2^3+0*2^2+1*2^1+0*2^0+0*2^(-1)+1*2(-2)
        =26.25
```

即 $(11010)_2 = (26.25)_{10}$ 

### 二进制/八进制/十六进制间的相互转换

一个八进制位可以用 3 个二进制位来表示（因为 $2^3 =8$ ），一个十六进制位可以用 4 个二进制位来表示（ $2^4 = 16$ ），反之同理。

# combination
排列组合是组合数学中的基础。排列就是指从给定个数的元素中取出指定个数的元素进行排序；组合则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。排列组合的中心问题是研究给定要求的排列和组合可能出现的情况总数。排列组合与古典概率论关系密切。

在高中初等数学中，排列组合多是利用列表、枚举等方法解题。

* * *

## 加法 & 乘法原理

### 加法原理

完成一个工程可以有 $n$ 类办法， $a_i(1 \le i \le n)$ 代表第 $i$ 类方法的数目。那么完成这件事共有 $S=a_1+a_2+\cdots +a_n$ 种不同的方法。

### 乘法原理

完成一个工程需要分 $n$ 个步骤， $a_i(1 \le i \le n)$ 代表第 $i$ 个步骤的不同方法数目。那么完成这件事共有 $S = a_1 \times a_2 \times \cdots \times a_n$ 种不同的方法。

## 排列与组合基础

### 排列数

从 $n$ 个不同元素中，任取 $m$ （ $m\leq n$ ， $m$ 与 $n$ 均为自然数，下同）个元素按照一定的顺序排成一列，叫做从 $n$ 个不同元素中取出 $m$ 个元素的一个排列；从 $n$ 个不同元素中取出 $m$ ( $m\leq n$ ) 个元素的所有排列的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的排列数，用符号 $\mathrm A_n^m$ （或者是 $\mathrm P_n^m$ ）表示。

排列的计算公式如下：

$$
\mathrm A_n^m = n(n-1)(n-2) \cdots (n-m+1) = \frac{n!}{(n - m)!}
$$

 $n!$ 代表 $n$ 的阶乘，即 $6! = 1 \times 2 \times 3 \times 4 \times 5 \times 6$ 。

公式可以这样理解： $n$ 个人选 $m$ 个来排队 ( $m \le n$ )。第一个位置可以选 $n$ 个，第二位置可以选 $n-1$ 个，以此类推，第 $m$ 个（最后一个）可以选 $n-m+1$ 个，得：

$$
\mathrm A_n^m = n(n-1)(n-2) \cdots (n-m+1) = \frac{n!}{(n - m)!}
$$

全排列： $n$ 个人全部来排队，队长为 $n$ 。第一个位置可以选 $n$ 个，第二位置可以选 $n-1$ 个，以此类推得：

$$
\mathrm A_n^n = n(n-1)(n-2) \cdots 3 × 2 × 1 = n!
$$

全排列是排列数的一个特殊情况。

### 组合数

从 $n$ 个不同元素中，任取 $m$ ( $m\leq n$ ) 个元素组成一个集合，叫做从 $n$ 个不同元素中取出 $m$ 个元素的一个组合；从 $n$ 个不同元素中取出 $m$ ( $m\leq n$ ) 个元素的所有组合的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的组合数。用符号 $\mathrm C_n^m$ 来表示。

组合数计算公式

$$
\mathrm C_n^m = \frac{\mathrm A_n^m}{m!} = \frac{n!}{m!(n - m)!}
$$

如何理解上述公式？我们考虑 $n$ 个人 $m$ ( $m \le n$ ) 个出来，不排队，不在乎顺序 $C_n^m$ 。如果在乎排列那么就是 $A_n^m$ ，如果不在乎那么就要除掉重复，那么重复了多少？同样选出的来的 $m$ 个人，他们还要“全排”得 $A_n^m$ ，所以得：

$$
\mathrm C_n^m \times m! = \mathrm A_n^m\\
\mathrm C_n^m = \frac{\mathrm A_n^m}{m!} = \frac{n!}{m!(n-m)!}
$$

组合数也常用 $\displaystyle \binom{n}{m}$ 表示，读作「 $n$ 选 $m$ 」，即 $\displaystyle \mathrm C_n^m=\binom{n}{m}$ 。实际上，后者表意清晰明了，美观简洁，因此现在数学界普遍采用 $\displaystyle \binom{n}{m}$ 的记号而非 $\mathrm C_n^m$ 。

组合数也被称为「二项式系数」，下文二项式定理将会阐述其中的联系。

特别地，规定当 $m>n$ 时， $\mathrm A_n^m=\mathrm C_n^m=0$ 。

## 二项式定理

在进入排列组合进阶篇之前，我们先介绍一个与组合数密切相关的定理——二项式定理。

二项式定理阐明了一个展开式的系数：

$$
(a+b)^n=\sum_{i=0}^n\binom{n}{i}a^{n-i}b^i
$$

证明可以采用数学归纳法，利用 $\displaystyle \binom{n}{k}+\binom{n}{k-1}=\binom{n+1}{k}$ 做归纳。

二项式定理也可以很容易扩展为多项式的形式：

设 n 为正整数， $x_i$ 为实数，

$$
(x_1 + x_2 + \cdots + x_t)^n = \sum_{满足 n_1 + \cdots + n_t=n 的非负整数解} \binom{n}{n_1n_2\cdots n_t} x_1^{n_1}x_2^{n_2}\cdots x_t^{n_t}
$$

其中的 $\binom{n}{n_1n_2\cdots n_t}$ 是多项式系数，它的性质也很相似：

$$
\sum{\binom{n}{n_1n_2\cdots n_t}} = t^n
$$

## 排列与组合进阶篇

接下来我们介绍一些排列组合的变种。

### 多重集的排列数 | 多重组合数

请大家一定要区分 **多重组合数** 与 **多重集的组合数** ！两者是完全不同的概念！

多重集是指包含重复元素的广义集合。设 $S=\{n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k,\}$ 表示由 $n_1$ 个 $a_1$ ， $n_2$ 个 $a_2$ ，…， $n_k$ 个 $a_k$ 组成的多重集， $S$ 的全排列个数为

$$
\frac{n!}{\prod_{i=1}^kn_i!}=\frac{n!}{n_1!n_2!\cdots n_k!}
$$

相当于把相同元素的排列数除掉了。具体地，你可以认为你有 $k$ 种不一样的球，每种球的个数分别是 $n_1,n_2,\cdots,n_k$ ，且 $n=n_1+n_2+\ldots+n_k$ 。这 $n$ 个球的全排列数就是 **多重集的排列数** 。多重集的排列数常被称作 **多重组合数** 。我们可以用多重组合数的符号表示上式：

$$
\binom{n}{n_1,n_2,\cdots,n_k}=\frac{n!}{\prod_{i=1}^kn_i!}
$$

可以看出， $\displaystyle \binom{n}{m}$ 等价于 $\displaystyle \binom{n}{m,n-m}$ ，只不过后者较为繁琐，因而不采用。

### 多重集的组合数 1

设 $S=\{n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k,\}$ 表示由 $n_1$ 个 $a_1$ ， $n_2$ 个 $a_2$ ，…， $n_k$ 个 $a_k$ 组成的多重集。那么对于整数 $r(r<n_i,\forall i\in[1,k])$ ，从 $S$ 中选择 $r$ 个元素组成一个多重集的方案数就是 **多重集的组合数** 。这个问题等价于 $x_1+x_2+\cdots+x_k=r$ 的非负整数解的数目，可以用插板法解决，答案为

$$
\binom{r+k-1}{k-1}
$$

### 多重集的组合数 2

考虑这个问题：设 $S=\{n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k,\}$ 表示由 $n_1$ 个 $a_1$ ， $n_2$ 个 $a_2$ ，…， $n_k$ 个 $a_k$ 组成的多重集。那么对于正整数 $r$ ，从 $S$ 中选择 $r$ 个元素组成一个多重集的方案数。

这样就限制了每种元素的取的个数。同样的，我们可以把这个问题转化为带限制的线性方程求解：

$$
\forall i\in [1,k],\ x_i\le n_i,\ \sum_{i=1}^kx_i=r
$$

于是很自然地想到了容斥原理。容斥的模型如下：

1.  全集： $\displaystyle \sum_{i=1}^kx_i=r$ 的非负整数解。
2.  属性： $x_i\le n_i$ 。

于是设满足属性 $i$ 的集合是 $S_i$ ， $\overline{S_i}$ 表示不满足属性 $i$ 的集合，即满足 $x_i\ge n_i+1$ 的集合。那么答案即为

$$
\left|\bigcap_{i=1}^kS_i\right|=|U|-\left|\bigcup_{i=1}^k\overline{S_i}\right|
$$

根据容斥原理，有：

$$
\begin{split}
\left|\bigcup_{i=1}^k\overline{S_i}\right|
&=&\sum_i\left|\overline{S_i}\right|
-\sum_{i,j}\left|\overline{S_i}\cap\overline{S_j}\right|
+\sum_{i,j,k}\left|\overline{S_i}\cap\overline{S_j}\cap\overline{S_k}\right|
-\cdots\\
&&+(-1)^{k-1}\left|\bigcap_{i=1}^k\overline{S_i}\right|\\
&=&\sum_i\binom{k+r-n_i-2}{k-1}
-\sum_{i,j}\binom{k+r-n_i-n_j-3}{k-1}+\sum_{i,j,k}\binom{k+r-n_i-n_j-n_k-4}{k-1}
-\cdots\\
&&+(-1)^{k-1}\binom{k+r-\sum_{i=1}^kn_i-k-1}{k-1}
\end{split}
$$

拿全集 $\displaystyle |U|=\binom{k+r-1}{k-1}$ 减去上式，得到多重集的组合数

$$
Ans=\sum_{p=0}^k(-1)^p\sum_{A}\binom{k+r-1-\sum_{A} n_{A_i}-p}{k-1}
$$

其中 A 是充当枚举子集的作用，满足 $|A|=p,\ A_i<A_{i+1}$ 。

### 不相邻的排列

 $1 \sim n$ 这 $n$ 个自然数中选 $k$ 个，这 $k$ 个数中任何两个数不相邻数的组合有 $\displaystyle \binom {n-k+1}{k}$ 种。

### 错位排列

我们把错位排列问题具体化，考虑这样一个问题：

 $n$ 封不同的信，编号分别是 $1,2,3,4,5$ ，现在要把这 5 封信放在编号 $1,2,3,4,5$ 的信封中，要求信封的编号与信的编号不一样。问有多少种不同的放置方法？

假设我们考虑到第 $n$ 个信封，初始时我们暂时把第 n 封信放在第 n 个信封中，然后考虑两种情况的递推：

-   前面 $n-1$ 个信封全部装错；
-   前面 $n-1$ 个信封有一个没有装错其余全部装错。

对于第一种情况，前面 $n-1$ 个信封全部装错：因为前面 $n-1$ 个已经全部装错了，所以第 n 封只需要与前面任一一个位置交换即可，总共有 $f(n-1)\times (n-1)$ 种情况。

对于第二种情况，前面 $n-1$ 个信封有一个没有装错其余全部装错：考虑这种情况的目的在于，若 $n-1$ 个信封中如果有一个没装错，那么我们把那个没装错的与 $n$ 交换，即可得到一个全错位排列情况。

其他情况，我们不可能通过一次操作来把它变成一个长度为 n 的错排。

于是可得错位排列的递推式为 $f(n)=(n-1)(f(n-1)+f(n-2))$ 。

错位排列数列的前几项为 $0,1,2,9,44,265$ 。

### 圆排列

 $n$ 个人全部来围成一圈，所有的排列数记为 $\mathrm Q_n^n$ 。考虑其中已经排好的一圈，从不同位置断开，又变成不同的队列。
所以有

$$
\mathrm Q_n^n \times n = \mathrm A_n^n \Longrightarrow \mathrm Q_n = \frac{\mathrm A_n^n}{n} = (n-1)!
$$

由此可知部分圆排列的公式：

$$
\mathrm Q_n^r = \frac{\mathrm A_n^r}{r} = \frac{n!}{r \times (n-r)!}
$$

## 组合数性质 | 二项式推论

由于组合数在 OI 中十分重要，因此在此介绍一些组合数的性质。

$$
\binom{n}{m}=\binom{n}{n-m}\tag{1}
$$

相当于将选出的集合对全集取补集，故数值不变。（对称性）

$$
\binom{n}{k} = \frac{n}{k} \binom{n-1}{k-1}\tag{2}
$$

由定义导出的递推式。

$$
\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}\tag{3}
$$

组合数的递推式（杨辉三角的公式表达）。我们可以利用这个式子，在 $O(n^2)$ 的复杂度下推导组合数。

$$
\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n}=\sum_{i=0}^n\binom{n}{i}=2^n\tag{4}
$$

这是二项式定理的特殊情况。取 $a=b=1$ 就得到上式。

$$
\sum_{i=0}^n(-1)^i\binom{n}{i}=0\tag{5}
$$

二项式定理的另一种特殊情况，可取 $a=1, b=-1$ 。

$$
\sum_{i=0}^m \binom{n}{i}\binom{m}{m-i} = \binom{m+n}{m}\ \ \ (n \geq m)\tag{6}
$$

拆组合数的式子，在处理某些数据结构题时会用到。

$$
\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}\tag{7}
$$

这是 $(6)$ 的特殊情况，取 $n=m$ 即可。

$$
\sum_{i=0}^ni\binom{n}{i}=n2^{n-1}\tag{8}
$$

带权和的一个式子，通过对 $(3)$ 对应的多项式函数求导可以得证。

$$
\sum_{i=0}^ni^2\binom{n}{i}=n(n+1)2^{n-2}\tag{9}
$$

与上式类似，可以通过对多项式函数求导证明。

$$
\sum_{l=0}^n\binom{l}{k} = \binom{n+1}{k+1}\tag{10}
$$

可以通过组合意义证明，在恒等式证明中较常用。

$$
\binom{n}{r}\binom{r}{k} = \binom{n}{k}\binom{n-k}{r-k}\tag{11}
$$

通过定义可以证明。

$$
\sum_{i=0}^n\binom{n-i}{i}=F_{n+1}\tag{12}
$$

其中 $F$ 是斐波那契数列。

$$
\sum_{l=0}^n \binom{l}{k} = \binom{n+1}{k+1}\tag{13}
$$

通过组合分析——考虑 $S={a_1, a_2, \cdots, a_{n+1}}$ 的 $k+1$ 子集数可以得证。

# catalan
## Catalan 数列

以下问题属于 Catalan 数列：

1.  有 $2n$ 个人排成一行进入剧场。入场费 5 元。其中只有 $n$ 个人有一张 5 元钞票，另外 $n$ 人只有 10 元钞票，剧院无其它钞票，问有多少中方法使得只要有 10 元的人买票，售票处就有 5 元的钞票找零？
2.  一位大城市的律师在她住所以北 $n$ 个街区和以东 $n$ 个街区处工作。每天她走 $2n$ 个街区去上班。如果他从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？
3.  在圆上选择 $2n$ 个点，将这些点成对连接起来使得所得到的 $n$ 条线段不相交的方法数？
4.  对角线不相交的情况下，将一个凸多边形区域分成三角形区域的方法数？
5.  一个栈（无穷大）的进栈序列为 $1,2,3, \cdots ,n$ 有多少个不同的出栈序列？
6.   $n$ 个结点可够造多少个不同的二叉树？
7.   $n$ 个不同的数依次进栈，求不同的出栈结果的种数？
8.   $n$ 个 $+1$ 和 $n$ 个 $-1$ 构成 $2n$ 项 $a_1,a_2, \cdots ,a_{2n}$ ，其部分和满足 $a_1+a_2+ \cdots +a_k \geq 0(k=1,2,3, \cdots ,2n)$ 对与 $n$ 该数列为？

其对应的序列为：

|  $H_0$  |  $H_1$  |  $H_2$  |  $H_3$  |  $H_4$  |  $H_5$  |  $H_6$  | ... |
| :-----: | :-----: | :-----: | :-----: | :-----: | :-----: | :-----: | :-: |
|    1    |    1    |    2    |    5    |    14   |    42   |   132   | ... |

(Catalan 数列）

## 递推式

该递推关系的解为：

$$
H_n = \frac{\binom{2n}{n}}{n+1}(n \geq 2, n \in \mathbf{N_{+}})
$$

关于 Catalan 数的常见公式：

$$
H_n = \begin{cases}
    \sum_{i=1}^{n} H_{i-1} H_{n-i} & n \geq 2, n \in \mathbf{N_{+}}\\
    1 & n = 0, 1
\end{cases}
$$

$$
H_n = \frac{H_{n-1} (4n-2)}{n+1}
$$

$$
H_n = \binom{2n}{n} - \binom{2n}{n-1}
$$

??? note " 例题[洛谷 P1044 栈](https://www.luogu.org/problem/P1044)"
    题目大意：入栈顺序为 $1,2,\ldots ,n$ ，求所有可能的出栈顺序的总数。

```cpp
#include <iostream>
using namespace std;
int n;
long long f[25];
int main() {
  f[0] = 1;
  cin >> n;
  for (int i = 1; i <= n; i++) f[i] = f[i - 1] * (4 * i - 2) / (i + 1);
  //这里用的是常见公式2
  cout << f[n] << endl;
  return 0;
}
```

## 路径计数问题

非降路径是指只能向上或向右走的路径。

1.  从 $(0,0)$ 到 $(m,n)$ 的非降路径数等于 $m$ 个 $x$ 和 $n$ 个 $y$ 的排列数，即 ${n + m \choose m}$ 。

2.  从 $(0,0)$ 到 $(n,n)$ 的除端点外不接触直线 $y=x$ 的非降路径数：

    先考虑 $y=x$ 下方的路径，都是从 $(0, 0)$ 出发，经过 $(1, 0)$ 及 $(n, n-1)$ 到 $(n,n)$ ，可以看做是 $(1,0)$ 到 $(n,n-1)$ 不接触 $y=x$ 的非降路径数。

    所有的的非降路径有 ${2n-2 \choose n-1}$ 条。对于这里面任意一条接触了 $y=x$ 的路径，可以把它最后离开这条线的点到 $(1,0)$ 之间的部分关于 $y=x$ 对称变换，就得到从 $(0,1)$ 到 $(n,n-1)$ 的一条非降路径。反之也成立。从而 $y=x$ 下方的非降路径数是 ${2n-2 \choose n-1} - {2n-2 \choose n}$ 。根据对称性可知所求答案为 $2{2n-2 \choose n-1} - 2{2n-2 \choose n}$ 。

3.  从 $(0,0)$ 到 $(n,n)$ 的除端点外不穿过直线 $y=x$ 的非降路径数：

    用类似的方法可以得到： $\frac{2}{n+1} {2n \choose n}$ 

# prime
我们说，如果存在一个整数 $k$ ，使得 $a = kd$ ，则称 $d$ 整除 $a$ ，记做 $d \mid a$ ，称 $a$ 是 $d$ 的倍数，如果 $d > 0$ ，称 $d$ 是 $a$ 的约数。特别地，任何整数都整除 $0$ 。

显然大于 $1$ 的正整数 $a$ 可以被 $1$ 和 $a$ 整除，如果除此之外 $a$ 没有其他的约数，则称 $a$ 是素数，又称质数。任何一个大于 $1$ 的整数如果不是素数，也就是有其他约数，就称为是合数。 $1$ 既不是合数也不是素数。

素数计数函数：小于或等于 $x$ 的素数的个数，用 $\pi(x)$ 表示。随着 $x$ 的增大，有这样的近似结果： $\pi(x) \sim \frac{x}{\ln(x)}$ 

## 素数判定

我们自然地会想到，如何用计算机来判断一个数是不是素数呢？

### 暴力做法

自然可以枚举从小到大的每个数看是否能整除

```cpp
bool isPrime(a) {
  if (a < 2) return 0;
  for (int i = 2; i < a; ++i)
    if (a % i == 0) return 0;
  return 1;
}
```

这样做是十分稳妥了，但是真的有必要每个数都去判断吗？

很容易发现这样一个事实：如果 $x$ 是 $a$ 的约数，那么 $\frac{a}{x}$ 也是 $a$ 的约数。

这个结论告诉我们，对于每一对 $(x, \frac{a}{x} )$ ，只需要检验其中的一个就好了。为了方便起见，我们之考察每一对里面小的那个数。不难发现，所有这些较小数就是 $[1, \sqrt{a}]$ 这个区间里的数。

由于 $1$ 肯定是约数，所以不检验它。

```cpp
bool isPrime(a) {
  if (a < 2) return 0;
  for (int i = 2; i * i <= a; ++i)
    if (a % i) return 0;
  return 1;
}
```

### Miller-Rabin 素性测试

Miller-Rabin 素性测试（Miller–Rabin primality test）是进阶的素数判定方法。
对数 n 进行 k 轮测试的时间复杂度是 $O(k \log^3n)$ ，利用 FFT 等技术可以优化到 [ $O(k \log^2n \log \log n \log \log \log n)$ ](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Complexity) 。

#### Fermat 素性测试

我们可以根据 [费马小定理](./fermat.md#_1) 得出一种检验素数的思路：

它的基本思想是不断地选取在 $[2, n-1]$ 中的基 $a$ ，并检验是否每次都有 $a^{n-1} \equiv 1 \pmod n$ 

```cpp
bool millerRabin(int n) {
  if (n < 3) return n == 2;
  // test_time 为测试次数,建议设为不小于 8
  // 的整数以保证正确率,但也不宜过大,否则会影响效率
  for (int i = 1; i <= test_time; ++i) {
    int a = rand() % (n - 2) + 2;
    if (quickPow(a, n - 1, n) != 1) return 0;
  }
  return 1;
}
```

很遗憾，费马小定理的逆定理并不成立，换言之，满足了 $a^{n-1} \equiv 1 \pmod n$ ， $n$ 也不一定是素数。

#### 卡迈克尔数

上面的做法中随机地选择 $a$ ，很大程度地降低了犯错的概率。但是仍有一类数，上面的做法并不能准确地判断。

对于合数 $n$ ，如果对于所有正整数 $a$ ， $a$ 和 $n$ 互素，都有同余式 $a^{n-1} \equiv 1 \pmod n$ 成立，则合数 $n$ 为卡迈克尔数（Carmichael Number），又称为费马伪素数。

比如， $561 = 3 \times 11 \times 17$ 就是一个卡迈克尔数。

而且我们知道，若 $n$ 为卡迈克尔数，则 $m=2^{n}-1$ 也是一个卡迈克尔数，从而卡迈克尔数的个数是无穷的。 [（OEIS:A006931）](https://oeis.org/A006931) 

#### 二次探测定理

如果 $p$ 是奇素数，则 $x^2 \equiv 1 \bmod p$ 的解为 $x = 1$ 或者 $x = p - 1 (\bmod p)$ ;

### 实现

根据卡迈克尔数的性质，可知其一定不是 $p^e$ 。

不妨将费马小定理和二次探测定理结合起来使用：

将 $n−1$ 分解为 $n−1=u \times 2^t$ ，不断地对 $u$ 进行平方操作，若发现非平凡平方根时即可判断出其不是素数。

比较正确的 Miller Rabin：（来自 fjzzq2002）

```cpp
bool millerRabbin(int n) {
  if (n < 3) return n == 2;
  int a = n - 1, b = 0;
  while (a % 2 == 0) a /= 2, ++b;
  // test_time 为测试次数,建议设为不小于 8
  // 的整数以保证正确率,但也不宜过大,否则会影响效率
  for (int i = 1, j; i <= test_time; ++i) {
    int x = rand() % (n - 2) + 2, v = quickPow(x, a, n);
    if (v == 1 || v == n - 1) continue;
    for (j = 0; j < b; ++j) {
      v = (long long)v * v % n;
      if (v == n - 1) break;
    }
    if (j >= b) return 0;
  }
  return 1;
}
```

### 参考

 <http://www.matrix67.com/blog/archives/234> 

 <https://blog.bill.moe/miller-rabin-notes/> 

## 反素数

### 定义

如果某个正整数 $n$ 满足如下条件，则称为是反素数：
  任何小于 $n$ 的正数的约数个数都小于 $n$ 的约数个数

注：注意区分 [emirp](https://en.wikipedia.org/wiki/Emirp) ，它是用来表示从后向前写读是素数的数。

### 简介

（本段转载自 [桃酱的算法笔记](https://zhuanlan.zhihu.com/c_1005817911142838272) ，原文戳 [链接](https://zhuanlan.zhihu.com/p/41759808) ，已获得作者授权）

其实顾名思义，素数就是因子只有两个的数，那么反素数，就是因子最多的数（并且因子个数相同的时候值最小），所以反素数是相对于一个集合来说的。

我所理解的反素数定义就是，在一个集合中，因素最多并且值最小的数，就是反素数。

那么，如何来求解反素数呢？

首先，既然要求因子数，我首先想到的就是素因子分解。把 $n$ 分解成 $n=p_{1}^{k_{1}}p_{2}^{k_{2}} \cdots p_{n}^{k_{n}}$ 的形式，其中 $p$ 是素数， $k$ 为他的指数。这样的话总因子个数就是 $(k_1+1) \times (k_2+1) \times (k_3+1) \cdots \times (k_n+1)$ 。

但是显然质因子分解的复杂度是很高的，并且前一个数的结果不能被后面利用。所以要换个方法。

我们来观察一下反素数的特点。

1.  反素数肯定是从 $2$ 开始的连续素数的幂次形式的乘积。

2.  数值小的素数的幂次大于等于数值大的素数，即 $n=p_{1}^{k_{1}}p_{2}^{k_{2}} \cdots p_{n}^{k_{n}}$ 中，有 $k_1 \geq k_2 \geq k_3 \geq \cdots \geq k_n$ 

解释：

1.  如果不是从 $2$ 开始的连续素数，那么如果幂次不变，把素数变成数值更小的素数，那么此时因子个数不变，但是 $n$ 的数值变小了。交换到从 $2$ 开始的连续素数的时候 $n$ 值最小。

2.  如果数值小的素数的幂次小于数值大的素数的幂，那么如果把这两个素数交换位置（幂次不变），那么所得的 $n$ 因子数量不变，但是 $n$ 的值变小。

另外还有两个问题，

1.  对于给定的 $n$ ，要枚举到哪一个素数呢？

    最极端的情况大不了就是 $n=p_{1}p_{2} \cdots p_{n}$ ，所以只要连续素数连乘到刚好小于等于 $n$ 就可以的呢。再大了，连全都一次幂，都用不了，当然就是用不到的啦！

2.  我们要枚举到多少次幂呢？

    我们考虑一个极端情况，当我们最小的素数的某个幂次已经比所给的 $n$ （的最大值）大的话，那么展开成其他的形式，最大幂次一定小于这个幂次。unsigned long long 的最大值是 2 的 64 次方，所以我这边习惯展开成 2 的 64 次方。

细节有了，那么我们具体如何具体实现呢？

我们可以把当前走到每一个素数前面的时候列举成一棵树的根节点，然后一层层的去找。找到什么时候停止呢？

1.  当前走到的数字已经大于我们想要的数字了

2.  当前枚举的因子已经用不到了（和 $1$ 重复了嘻嘻嘻）

3.  当前因子大于我们想要的因子了

4.  当前因子正好是我们想要的因子（此时判断是否需要更新最小 $ans$ ）

然后 dfs 里面不断一层一层枚举次数继续往下迭代就好啦\~~

### 常见题型

#### 求因子数一定的最小数

题目链接： <https://codeforces.com/problemset/problem/27/E> 

对于这种题，我们只要以因子数为 dfs 的返回条件基准，不断更新找到的最小值就可以了

上代码：

```cpp
#include <stdio.h>
#define ULL unsigned long long
#define INF ~0ULL
ULL p[16] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};

ULL ans;
ULL n;

// depth: 当前在枚举第几个素数。num: 当前因子数。
// temp: 当前因子数量为 num
// 的时候的数值。up：上一个素数的幂，这次应该小于等于这个幂次嘛
void dfs(ULL depth, ULL temp, ULL num, ULL up) {
  if (num > n || depth >= 16) return;
  if (num == n && ans > temp) {
    ans = temp;
    return;
  }
  for (int i = 1; i <= up; i++) {
    if (temp / p[depth] > ans) break;
    dfs(depth + 1, temp = temp * p[depth], num * (i + 1), i);
  }
}

int main() {
  while (scanf("%llu", &n) != EOF) {
    ans = INF;
    dfs(0, 1, 1, 64);
    printf("%llu\n", ans);
  }
  return 0;
}
```

#### 求 n 以内因子数最多的数

 <http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1562> 

思路同上，只不过要改改 dfs 的返回条件。注意这样的题目的数据范围，我一开始用了 int，应该是溢出了，在循环里可能就出不来了就超时了。上代码，0ms 过。注释就没必要写了上面写的很清楚了。

```cpp
#include <cstdio>
#include <iostream>
#define ULL unsigned long long

int p[16] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};
ULL n;
ULL ans, ans_num;  // ans 为 n 以内的最大反素数（会持续更新），ans_sum 为 ans
                   // 的因子数。

void dfs(int depth, ULL temp, ULL num, int up) {
  if (depth >= 16 || temp > n) return;
  if (num > ans_num) {
    ans = temp;
    ans_num = num;
  }
  if (num == ans_num && ans > temp) ans = temp;
  for (int i = 1; i <= up; i++) {
    if (temp * p[depth] > n) break;
    dfs(depth + 1, temp *= p[depth], num * (i + 1), i);
  }
  return;
}

int main() {
  while (scanf("%llu", &n) != EOF) {
    ans_num = 0;
    dfs(0, 1, 1, 60);
    printf("%llu\n", ans);
  }
  return 0;
}
```

# cantor
康托展开可以用来求一个 $1\sim n$ 的任意排列的排名。

## 什么是排列的排名？

把 $1\sim n$ 的所有排列按字典序排序，这个排列的位次就是它的排名。

## 时间复杂度？

康托展开可以在 $O(n^2)$ 的复杂度内求出一个排列的排名，在用到树状数组优化时可以做到 $O(n\log n)$ 。

## 怎么实现？

因为排列是按字典序排名的，因此越靠前的数字优先级越高。也就是说如果两个排列的某一位之前的数字都相同，那么如果这一位如果不相同，就按这一位排序。

比如 $4$ 的排列， $[2,3,1,4]<[2,3,4,1]$ ，因为在第 $3$ 位出现不同，则 $[2,3,1,4]$ 的排名在 $[2,3,4,1]$ 前面。

## 举个栗子

我们知道长为 $5$ 的排列 $[2,5,3,4,1]$ 大于以 $1$ 为第一位的任何排列，以 $1$ 为第一位的 $5$ 的排列有 $4!$ 种。这是非常好理解的。但是我们对第二位的 $5$ 而言，它大于 **第一位与这个排列相同的，而这一位比 $5$ 小的** 所有排列。不过我们要注意的是，这一位不仅要比 $5$ 小，还要满足没有在当前排列的前面出现过，不然统计就重复了。因此这一位为 $1,3$ 或 $4$ ，第一位为 $2$ 的所有排列都比它要小，数量为 $3\times 3!$ 。

按照这样统计下去，答案就是 $1+4!+3\times 3!+2!+1=46$ 。注意我们统计的是排名，因此最前面要 $+1$ 。

注意到我们每次要用到 **当前有多少个小于它的数还没有出现** ，这里用树状数组统计比它小的数出现过的次数就可以了。

## 逆康托展开

因为排列的排名和排列是一一对应的，所以康托展开满足双射关系，是可逆的。可以通过类似上面的过程倒推回来。

如果我们知道一个排列的排名，就可以推出这个排列。因为 $4!$ 是严格大于 $3\times 3!+2\times 2!+1\times 1!$ 的，所以可以认为对于长度为 $5$ 的排列，排名 $x$ 除以 $4!$ 向下取整就是有多少个数小于这个排列的第一位。

## 引用上面展开的例子

首先让 $46-1=45$ ， $45$ 代表着有多少个排列比这个排列小。 $\lfloor\frac {45}{4!}\rfloor=1$ ，有一个数小于它，所以第一位是 $2$ 。

此时让排名减去 $1\times 4!$ 得到 $21$ ， $\lfloor\frac {21}{3!}\rfloor=3$ ，有 $3$ 个数小于它，去掉已经存在的 $2$ ，这一位是 $5$ 。

 $21-3\times 3!=3$ ， $\lfloor\frac {3}{2!}\rfloor=1$ ，有一个数小于它，那么这一位就是 $3$ 。

让 $3-1\times 2!=1$ ，有一个数小于它，这一位是剩下来的第二位， $4$ ，剩下一位就是 $1$ 。即 $[2,5,3,4,1]$ 。

实际上我们得到了形如 **有两个数小于它** 这一结论，就知道它是当前第 $3$ 个没有被选上的数，这里也可以用线段树维护，时间复杂度为 $O(n\log n)$ 。

# euler
欧拉函数（Euler's totient function），即 $\varphi(n)$ ，表示的是小于等于 $n$ 和 $n$ 互质的数的个数。

比如说 $\varphi(1) = 1$ 。

当 n 是质数的时候，显然有 $\varphi(n) = n - 1$ 。

利用唯一分解定理，我们可以把一个整数唯一地分解为质数幂次的乘积，

设 $n = \prod_{i=1}^{n}p_i^{k_i}$ ，其中 $p_i$ 是质数，那么 $\varphi(n) = n \times \prod_{i = 1}^s{\dfrac{p_i - 1}{p_i}}$ 

#### 证明：

引理（1）：设 $x=p^k$ , 那么 $\varphi(x)=p^{k-1}\times(p-1)$ 

证明：

容易发现 $x\perp y (y\bmod p \ne 0)$ 。我们试着将 $x$ 划分为长度为 $p$ 的 $\dfrac{p^k}{p}=p^{k-1}$ 段，每一段都有 $p-1$ 个数与 $x$ 互质。所以与 $x$ 互质的数个数即为： $p^{k-1}\times(p-1)$ 

接下来我们证明 $\varphi(n) = n \times \prod_{i = 1}^s{\dfrac{p_i - 1}{p_i}}$ 

$$
\because n=\prod_{i=1}^{n} p_i^{k_i} \\ 	\begin{align}\therefore \varphi(x) &= \prod_{i=1}^{n} \varphi(p_i^{k_i}) \\&= \prod_{i=1}^{n} (p_i-1)\times {p_i}^{k_i-1}\\&=\prod_{i=1}^{n} {p_i}^{k_i} \times(1 - \frac{1}{p_i})\\&=x~ \prod_{i=1}^{n} (1- \frac{1}{p_i})\end{align}
$$

## 欧拉函数的一些性质

-   欧拉函数是积性函数。

    积性是什么意思呢？如果有 $\gcd(a, b) = 1$ ，那么 $\varphi(a \times b) = \varphi(a) \times \varphi(b)$ 。

    特别地，当 $n$ 是奇数时 $\varphi(2n) = \varphi(n)$ 。

-    $n = \sum_{d \mid n}{\varphi(d)}$ 

    利用 [莫比乌斯反演](./mobius.md) 相关知识可以得出。

    也可以这样考虑：如果 $\gcd(k, n) = d$ ，那么 $\gcd(\frac{k}{d},\frac{n}{d}) = 1$ 。（ $k < n$ ）

    如果我们设 $f(x)$ 表示 $\gcd(k, n) = x$ 的数的个数，那么 $n = \sum_{i = 1}^n{f(i)}$ 。

    根据上面的证明，我们发现， $f(x) = \varphi(\frac{n}{x})$ ，从而 $n = \sum_{d \mid n}\varphi(\frac{n}{d})$ 。注意到约数 $d$ 和 $\frac{n}{d}$ 具有对称性，所以上式化为 $n = \sum_{d \mid n}\varphi(d)$ 。

-   若 $n = p^k$ ，其中 $p$ 是质数，那么 $\varphi(n) = p^k - p^{k - 1}$ 。
    （根据定义可知）

## 如何求欧拉函数值

如果只要求一个数的欧拉函数值，那么直接根据定义质因数分解的同时求就好了。这个过程可以用_Pollard Rho_算法优化。

```cpp
int euler_phi(int n) {
  int m = int(sqrt(n + 0.5));
  int ans = n;
  for (int i = 2; i <= m; i++)
    if (n % i == 0) {
      ans = ans / i * (i - 1);
      while (n % i == 0) n /= i;
    }
  if (n > 1) ans = ans / n * (n - 1);
  return ans;
}
```

如果是多个数的欧拉函数值，可以利用后面会提到的线性筛法来求得。
详见： [筛法求欧拉函数](./sieve.md#_2) 

## 欧拉定理

与欧拉函数紧密相关的一个定理就是欧拉定理。其描述如下：

若 $\gcd(a, m) = 1$ ，则 $a^{\varphi(m)} \equiv 1 \pmod{m}$ 。

## 扩展欧拉定理

当然也有扩展欧拉定理

$$
a^b\equiv
\begin{cases}
a^{b\bmod\varphi(p)},\,&\gcd(a,\,p)=1\\
a^b,&\gcd(a,\,p)\ne1,\,b<\varphi(p)\\
a^{b\bmod\varphi(p)+\varphi(p)},&\gcd(a,\,p)\ne1,\,b\ge\varphi(p)
\end{cases}
\pmod p
$$

证明和 **习题** 详见 [欧拉定理](./fermat.md) 

# dictionary
前置知识： [分块](../ds/decompose.md) 。

朴素的打表，指的是在比赛时把所有可能的输入对应的答案都计算出来并保存下来，然后在代码里开个数组把答案放里面，直接输出即可。

注意这个技巧只适用于输入的值域不大（如，输入只有一个数，而且范围很小）的问题，否则可能会导致代码过长、MLE、打表需要的时间过长等问题。

???+note "例题"

    规定 $f(x)$ 为整数 $x$ 的二进制表示中 $1$ 的个数。输入一个正整数 $n$ ( $n\leq 10^9$ )，输出 $\sum_{i=1}^n f^2(i)$ 。

如果对于每一个 $n$ ，都输出 $f(n)$ 的话，除了可能会 MLE 外，还有可能代码超过最大代码长度限制，导致编译不通过。

我们考虑优化这个答案表。采用 [分块](../ds/decompose/) 的思想，我们设置一个合理的步长 $m$ （这个步长一般视代码长度而定），对于第 $i$ 块，计算出：

$$
\sum_{k=\frac{n}{m}(i-1)+1}^{\frac{ni}{m}} f^2(k)
$$

的值。

然后输出答案时采用分块思想处理即可。即，整块的答案用预处理的值计算，非整块的答案暴力计算。

一般来说，这样的问题对于处理单个函数值 $f(x)$ 很快，但是需要大量函数值求和（求积或某些可以快速合并的操作），枚举会超出时间限制，在找不到标准做法的情况下，分段打表是一个不错的选择。

???+note "注意事项"

    当上题中指数不是定值，但是范围较小，也可以考虑打表。

### 例题

 [「BZOJ 3798」特殊的质数](https://www.lydsy.com/JudgeOnline/problem.php?id=3798) ：求 $[l,r]$ 区间内有多少个质数可以分解为两个正整数的平方和。

 [「Luogu P1822」魔法指纹](https://www.luogu.org/problem/show?pid=P1822) 

# index
在 OI/ACM 的各种比赛中，常常会用到数学知识，尤其是离散、具体的数学，以数论、排列组合、概率期望、多项式为代表，可以出现在几乎任何类别的题目中。

举几个例子：

1.  多项式可以优化卷积形式的背包，可以做一些字符串题。
2.  很多 DP 类型的题都可以结合排列组合/概率期望。

另外，建议学好高中数学，这样的话在学习本部分时会有所帮助。

# mobius
author: hydingsy, hyp1231

## 简介

莫比乌斯反演是数论中的重要内容。对于一些函数 $f(n)$ ，如果很难直接求出它的值，而容易求出其倍数和或约数和 $g(n)$ ，那么可以通过莫比乌斯反演简化运算，求得 $f(n)$ 的值。

开始学习莫比乌斯反演前，我们需要一些前置知识： **积性函数** 、 **Dirichlet 卷积** 、 **莫比乌斯函数** 。

* * *

## 前置知识

### 引理 1

$$
\forall a,b,c\in\mathbb{Z},\left\lfloor\frac{a}{bc}\right\rfloor=\left\lfloor\frac{\left\lfloor\frac{a}{b}\right\rfloor}{c}\right\rfloor
$$

略证：

$$
\begin{split}
&\frac{a}{b}=\left\lfloor\frac{a}{b}\right\rfloor+r(0\leq r<1)\\
\implies
&\left\lfloor\frac{a}{bc}\right\rfloor
=\left\lfloor\frac{a}{b}\cdot\frac{1}{c}\right\rfloor
=\left\lfloor \frac{1}{c}\left(\left\lfloor\frac{a}{b}\right\rfloor+r\right)\right\rfloor
=\left\lfloor \frac{\left\lfloor\frac{a}{b}\right\rfloor}{c} +\frac{r}{c}\right\rfloor
=\left\lfloor \frac{\left\lfloor\frac{a}{b}\right\rfloor}{c}\right\rfloor\\
&&\square
\end{split}
$$

### 引理 2

$$
\forall n \in N,  \left|\left\{ \lfloor \frac{n}{d} \rfloor \mid d \in N \right\}\right| \leq \lfloor 2\sqrt{n} \rfloor
$$

 $|V|$ 表示集合 $V$ 的元素个数

略证：

对于 $d\leq \left\lfloor\sqrt{n}\right\rfloor$ ， $\left\lfloor\frac{n}{d}\right\rfloor$ 有 $\left\lfloor\sqrt{n}\right\rfloor$ 种取值

对于 $d> \left\lfloor\sqrt{n}\right\rfloor$ ，有 $\left\lfloor\frac{n}{d}\right\rfloor\leq\left\lfloor\sqrt{n}\right\rfloor$ ，也只有 $\left\lfloor\sqrt{n}\right\rfloor$ 种取值

综上，得证

### 数论分块

数论分块的过程大概如下：考虑含有 $\left\lfloor\frac{n}{i}\right\rfloor$ 的求和式子（ $n$ 为常数）

对于任意一个 $i(i\leq n)$ ，我们需要找到一个最大的 $j(i\leq j\leq n)$ ，使得 $\left\lfloor\frac{n}{i}\right\rfloor = \left\lfloor\frac{n}{j}\right\rfloor$ .

而 $j=\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$ .

略证：

$$
\begin{split}
&\left\lfloor\frac{n}{i}\right\rfloor \leq \frac{n}{i}\\
\implies
&\left\lfloor\frac{n}{ \left\lfloor\frac{n}{i}\right\rfloor }\right\rfloor
\geq \left\lfloor\frac{n}{ \frac{n}{i} }\right\rfloor
= \left\lfloor i \right\rfloor=i \\
\implies
&i\leq \left\lfloor\frac{n}{ \left\lfloor\frac{n}{i}\right\rfloor }\right\rfloor\\
&&\square
\end{split}
$$

即 $j=\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$ .

利用上述结论，我们每次以 $[i,j]$ 为一块，分块求和即可

* * *

## 积性函数

### 定义

若 $\gcd(x,y)=1$ 且 $f(xy)=f(x)f(y)$ ，则 $f(n)$ 为积性函数。

### 性质

若 $f(x)$ 和 $g(x)$ 均为积性函数，则以下函数也为积性函数：

$$
\begin{aligned}
h(x)&=f(x^p)\\
h(x)&=f^p(x)\\
h(x)&=f(x)g(x)\\
h(x)&=\sum_{d\mid x}f(d)g(\frac{x}{d})
\end{aligned}
$$

### 例子

-   单位函数： $\epsilon(n)=[n=1]$ 
-   恒等函数： $\operatorname{id}_k(n)=n^k$  $\operatorname{id}_{1}(n)$ 通常简记作 $\operatorname{id}(n)$ 。
-   常数函数： $1(n)=1$ 
-   除数函数： $\sigma_{k}(n)=\sum_{d\mid n}d^{k}$  $\sigma_{0}(n)$ 通常简记作 $\operatorname{d}(n)$ 或 $\tau(n)$ ， $\sigma_{1}(n)$ 通常简记作 $\sigma(n)$ 。
-   欧拉函数： $\varphi(n)=\sum_{i=1}^n [\gcd(i,n)=1]$ 
-   莫比乌斯函数： $\mu(n) = \begin{cases}1 & n=1 \\ 0 & \exists d:d^{2} \mid n \\ (-1)^{\omega(n)} & otherwise\end{cases}$ 其中 $\omega(n)$ 表示 $n$ 的本质不同质因子个数，是一个加性函数。

* * *

## Dirichlet 卷积

### 定义

定义两个数论函数 $f,g$ 的 Dirichlet 卷积为

$$
(f\ast g)(n)=\sum_{d\mid n}f(d)g(\frac{n}{d})
$$

### 性质

Dirichlet 卷积满足交换律和结合律。

其中 $\varepsilon$ 为 Dirichlet 卷积的单位元（任何函数卷 $\varepsilon$ 都为其本身）

### 例子

$$
\begin{aligned}
\varepsilon=\mu \ast 1&\iff\varepsilon(n)=\sum_{d\mid n}\mu(d)\\
d=1 \ast 1&\iff d(n)=\sum_{d\mid n}1\\
\sigma=d \ast 1&\iff\sigma(n)=\sum_{d\mid n}d\\
\varphi=\mu \ast \text{ID}&\iff\varphi(n)=\sum_{d\mid n}d\cdot\mu(\frac{n}{d})
\end{aligned}
$$

* * *

## 莫比乌斯函数

### 定义

 $\mu$ 为莫比乌斯函数，定义为

$$
\mu(n)=
\begin{cases}
1&n=1\\
0&n\text{ 含有平方因子}\\
(-1)^k&k\text{ 为 }n\text{ 的本质不同质因子个数}\\
\end{cases}
$$

详细解释一下：

令 $n=\prod_{i=1}^kp_i^{c_i}$ ，其中 $p_i$ 为质因子， $c_i\ge 1$ 。上述定义表示：

1.   $n=1$ 时， $\mu(n)=1$ ；
2.  对于 $n\not= 1$ 时：
    1.  当存在 $i\in [1,k]$ ，使得 $c_i > 1$ 时， $\mu(n)=0$ ，也就是说只要某个质因子出现的次数超过一次， $\mu(n)$ 就等于 $0$ ；
    2.  当任意 $i\in[1,k]$ ，都有 $c_i=1$ 时， $\mu(n)=(-1)^k$ ，也就是说每个质因子都仅仅只出现过一次时，即 $n=\prod_{i=1}^kp_i$ ， $\{p_i\}_{i=1}^k$ 中个元素唯一时， $\mu(n)$ 等于 $-1$ 的 $k$ 次幂，此处 $k$ 指的便是仅仅只出现过一次的质因子的总个数。

### 性质

莫比乌斯函数不但是积性函数，还有如下性质：

$$
\sum_{d\mid n}\mu(d)=
\begin{cases}
1&n=1\\
0&n\neq 1\\
\end{cases}
$$

即 $\sum_{d\mid n}\mu(d)=\varepsilon(n)$ ，即 $\mu * 1 =\varepsilon$ 

### 证明

设 $\displaystyle n=\prod_{i=1}^k{p_i}^{c_i},n'=\prod_{i=1}^k p_i$ 

那么 $\displaystyle\sum_{d\mid n}\mu(d)=\sum_{d\mid n'}\mu(d)=\sum_{i=0}^k C_k^i\cdot(-1)^i=(1+(-1))^k$ 

根据二项式定理，易知该式子的值在 $k=0$ 即 $n=1$ 时值为 $1$ 否则为 $0$ ，这也同时证明了 $\displaystyle\sum_{d\mid n}\mu(d)=[n=1]=\varepsilon(n)$ 以及 $\mu\ast 1=\varepsilon$ 

### 补充结论

反演结论： $\displaystyle [\gcd(i,j)=1] \iff\sum_{d\mid\gcd(i,j)}\mu(d)$ 

 **直接推导** ：如果看懂了上一个结论，这个结论稍加思考便可以推出：如果 $\gcd(i,j)=1$ 的话，那么代表着我们按上个结论中枚举的那个 $n$ 是 $1$ ，也就是式子的值是 $1$ ，反之，有一个与 $[\gcd(i,j)=1]$ 相同的值： $0$ 

 **利用 $\varepsilon$ 函数** ：根据上一结论， $[\gcd(i,j)=1]\implies \varepsilon(\gcd(i,j))$ ，将 $\varepsilon$ 展开即可。

### 线性筛

由于 $\mu$ 函数为积性函数，因此可以线性筛莫比乌斯函数（线性筛基本可以求所有的积性函数，尽管方法不尽相同）。

???+ note "线性筛实现"
    ```cpp
    void getMu() {
      mu[1] = 1;
      for (int i = 2; i <= n; ++i) {
        if (!flg[i]) p[++tot] = i, mu[i] = -1;
        for (int j = 1; j <= tot && i * p[j] <= n; ++j) {
          flg[i * p[j]] = 1;
          if (i % p[j] == 0) {
            mu[i * p[j]] = 0;
            break;
          }
          mu[i * p[j]] = -mu[i];
        }
      }
    }
    ```

### 拓展

证明

$$
\varphi \ast 1=\text{ID}\text{（ID 函数即 } f(x)=x\text{）}
$$

将 $n$ 分解质因数： $\displaystyle n=\prod_{i=1}^k {p_i}^{c_i}$ 

首先，因为 $\varphi$ 是积性函数，故只要证明当 $n'=p^c$ 时 $\displaystyle\varphi \ast 1=\sum_{d\mid n'}\varphi(\frac{n'}{d})=\text{ID}$ 成立即可。

因为 $p$ 是质数，于是 $d=p^0,p^1,p^2,\cdots,p^c$ 

易知如下过程：

$$
\begin{aligned}
\varphi \ast 1&=\sum_{d\mid n}\varphi(\frac{n}{d})\\
&=\sum_{i=0}^c\varphi(p^i)\\
&=1+p^0\cdot(p-1)+p^1\cdot(p-1)+\cdots+p^{c-1}\cdot(p-1)\\
&=p^c\\
&=\text{ID}\\
\end{aligned}
$$

该式子两侧同时卷 $\mu$ 可得 $\displaystyle\varphi(n)=\sum_{d\mid n}d\cdot\mu(\frac{n}{d})$ 

* * *

## 莫比乌斯反演

### 公式

设 $f(n),g(n)$ 为两个数论函数。

如果有

$$
f(n)=\sum_{d\mid n}g(d)
$$

那么有

$$
g(n)=\sum_{d\mid n}\mu(d)f(\frac{n}{d})
$$

### 证明

方法一：对原式做数论变换。

$$
\sum_{d\mid n}\mu(d)f(\frac{n}{d})=\sum_{d\mid n}\mu(d)\sum_{k\mid \frac{n}{d}}g(k)=\sum_{k\mid n}g(k)\sum_{d\mid \frac{n}{k}}\mu(d)=g(n)
$$

用 $\displaystyle\sum_{d\mid n}g(d)$ 来替换 $f(\dfrac{n}{d})$ ，再变换求和顺序。最后一步变换的依据： $\displaystyle\sum_{d\mid n}\mu(d)=[n=1]$ ，因此在 $\dfrac{n}{k}=1$ 时第二个和式的值才为 $1$ 。此时 $n=k$ ，故原式等价于 $\displaystyle\sum_{k\mid n}[n=k]\cdot g(k)=g(n)$ 

方法二：运用卷积。

原问题为：已知 $f=g\ast1$ ，证明 $g=f\ast\mu$ 

易知如下转化： $f\ast\mu=g*1*\mu\implies f\ast\mu=g$ （其中 $1\ast\mu=\varepsilon$ ）。

* * *

## 问题形式

###  [「HAOI 2011」Problem b](https://www.luogu.org/problem/P2522) 

求值（多组数据）

$$
\sum_{i=x}^{n}\sum_{j=y}^{m}[\gcd(i,j)=k]\qquad (1\leqslant T,x,y,n,m,k\leqslant 5\times 10^4)
$$

根据容斥原理，原式可以分成 $4$ 块来处理，每一块的式子都为

$$
\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=k]
$$

考虑化简该式子

$$
\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[\gcd(i,j)=1]
$$

因为 $\gcd(i,j)=1$ 时对答案才用贡献，于是我们可以将其替换为 $\varepsilon(\gcd(i,j))$ （ $\varepsilon(n)$ 当且仅当 $n=1$ 时值为 $1$ 否则为 $0$ ），故原式化为

$$
\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\varepsilon(\gcd(i,j))
$$

将 $\varepsilon$ 函数展开得到

$$
\displaystyle\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d\mid  \gcd(i,j)}\mu(d)
$$

变换求和顺序，先枚举 $d\mid \gcd(i,j)$ 可得

$$
\displaystyle\sum_{d=1}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}[d\mid i]\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[d\mid j]
$$

易知 $1\sim\lfloor\dfrac{n}{k}\rfloor$ 中 $d$ 的倍数有 $\lfloor\dfrac{n}{kd}\rfloor$ 个，故原式化为

$$
\displaystyle\sum_{d=1}\mu(d)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor
$$

很显然，式子可以数论分块求解。

 **时间复杂度 $\Theta(N+T\sqrt{n})$ ** 

??? note "代码实现"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    const int N = 50000;
    int mu[N + 5], p[N + 5];
    bool flg[N + 5];
    void init() {
      int tot = 0;
      mu[1] = 1;
      for (int i = 2; i <= N; ++i) {
        if (!flg[i]) {
          p[++tot] = i;
          mu[i] = -1;
        }
        for (int j = 1; j <= tot && i * p[j] <= N; ++j) {
          flg[i * p[j]] = 1;
          if (i % p[j] == 0) {
            mu[i * p[j]] = 0;
            break;
          }
          mu[i * p[j]] = -mu[i];
        }
      }
      for (int i = 1; i <= N; ++i) mu[i] += mu[i - 1];
    }
    int solve(int n, int m) {
      int res = 0;
      for (int i = 1, j; i <= std::min(n, m); i = j + 1) {
        j = std::min(n / (n / i), m / (m / i));
        res += (mu[j] - mu[i - 1]) * (n / i) * (m / i);
      }
      return res;
    }
    int main() {
      int T, a, b, c, d, k;
      init();
      for (scanf("%d", &T); T; --T) {
        scanf("%d%d%d%d%d", &a, &b, &c, &d, &k);
        printf("%d\n", solve(b / k, d / k) - solve(b / k, (c - 1) / k) -
                           solve((a - 1) / k, d / k) +
                           solve((a - 1) / k, (c - 1) / k));
      }
      return 0;
    }
    ```

###  [「SPOJ 5971」LCMSUM](https://www.spoj.com/problems/LCMSUM/) 

求值（多组数据）

$$
\sum_{i=1}^n \text{lcm}(i,n)\quad  \text{s.t.}\ 1\leqslant T\leqslant 3\times 10^5,1\leqslant n\leqslant 10^6
$$

易得原式即

$$
\sum_{i=1}^n \frac{i\cdot n}{\gcd(i,n)}
$$

将原式复制一份并且颠倒顺序，然后将 n 一项单独提出，可得

$$
\frac{1}{2}\cdot \left(\sum_{i=1}^{n-1}\frac{i\cdot n}{\gcd(i,n)}+\sum_{i=n-1}^{1}\frac{i\cdot n}{\gcd(i,n)}\right)+n
$$

根据 $\gcd(i,n)=\gcd(n-i,n)$ ，可将原式化为

$$
\frac{1}{2}\cdot \left(\sum_{i=1}^{n-1}\frac{i\cdot n}{\gcd(i,n)}+\sum_{i=n-1}^{1}\frac{i\cdot n}{\gcd(n-i,n)}\right)+n
$$

两个求和式中分母相同的项可以合并。

$$
\frac{1}{2}\cdot \sum_{i=1}^{n-1}\frac{n^2}{\gcd(i,n)}+n
$$

即

$$
\frac{1}{2}\cdot \sum_{i=1}^{n}\frac{n^2}{\gcd(i,n)}+\frac{n}{2}
$$

可以将相同的 $\gcd(i,n)$ 合并在一起计算，故只需要统计 $\gcd(i,n)=d$ 的个数。当 $\gcd(i,n)=d$ 时， $\displaystyle\gcd(\frac{i}{d},\frac{n}{d})=1$ ，所以 $\gcd(i,n)=d$ 的个数有 $\displaystyle\varphi(\frac{n}{d})$ 个。

故答案为

$$
 \frac{1}{2}\cdot\sum_{d\mid n}\frac{n^2\cdot\varphi(\frac{n}{d})}{d}+\frac{n}{2}
$$

变换求和顺序，设 $\displaystyle d'=\frac{n}{d}$ ，合并公因式，式子化为

$$
\frac{1}{2}n\cdot\left(\sum_{d'\mid n}d'\cdot\varphi(d')+1\right)
$$

设 $\displaystyle \text{g}(n)=\sum_{d\mid n} d\cdot\varphi(d)$ ，已知 $\text{g}$ 为积性函数，于是可以 $\Theta(n)$ 筛出。每次询问 $\Theta(1)$ 计算即可。

这个函数筛的时候比较特殊，当 $p_j\mid i$ 的时候，需要根据 $p_j\mid\dfrac{i}{p_j}$ 进行分类讨论。具体可以见代码。

 **时间复杂度** ： $\Theta(n+T)$ 

??? note "代码实现"
    ```cpp
    #include <cstdio>
    const int N = 1000000;
    int tot, p[N + 5];
    long long g[N + 5];
    bool flg[N + 5];
    
    void solve() {
      g[1] = 1;
      for (int i = 2; i <= N; ++i) {
        if (!flg[i]) p[++tot] = i, g[i] = i * (i - 1) + 1;
        for (int j = 1; j <= tot && i * p[j] <= N; ++j) {
          flg[i * p[j]] = 1;
          if (i % p[j] == 0) {
            if ((i / p[j]) % p[j] == 0) {
              g[i * p[j]] = g[i] + (g[i] - g[i / p[j]]) * p[j] * p[j];
            } else {
              g[i * p[j]] = g[i] + g[i / p[j]] * (p[j] - 1) * p[j] * p[j] * p[j];
            }
            break;
          }
          g[i * p[j]] = g[i] * g[p[j]];
        }
      }
    }
    int main() {
      int T, n;
      solve();
      for (scanf("%d", &T); T; --T) {
        scanf("%d", &n);
        printf("%lld\n", (g[n] + 1) * n / 2);
      }
      return 0;
    }
    ```

###  [「BZOJ 2154」Crash 的数字表格](https://www.luogu.org/problem/P1829) 

求值（对 $20101009$ 取模）

$$
\sum_{i=1}^n\sum_{j=1}^m\text{lcm}(i,j)\qquad (n,m\leqslant 10^7)
$$

易知原式等价于

$$
\sum_{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{\gcd(i,j)}
$$

枚举最大公因数 $d$ ，显然两个数除以 $d$ 得到的数互质

$$
\sum_{i=1}^n\sum_{j=1}^m\sum_{d\mid i,d\mid j,\gcd(\frac{i}{d},\frac{j}{d})=1}\frac{i\cdot j}{d}
$$

非常经典的 $\gcd$ 式子的化法

$$
\sum_{d=1}^n d\cdot\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)=1]\ i\cdot j
$$

后半段式子中，出现了互质数对之积的和，为了让式子更简洁就把它拿出来单独计算。于是我们记

$$
\text{sum}(n,m)=\sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=1]\  i\cdot j
$$

接下来对 $\text{sum}(n,m)$ 进行化简。首先枚举约数，并将 $[\gcd(i,j)=1]$ 表示为 $\varepsilon(\gcd(i,j))$ 

$$
\sum_{d=1}^n\sum_{d\mid i}^n\sum_{d\mid j}^m\mu(d)\cdot i\cdot j
$$

设 $i=i'\cdot d$ ， $j=j'\cdot d$ ，显然式子可以变为

$$
\sum_{d=1}^n\mu(d)\cdot d^2\cdot\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}i\cdot j
$$

观察上式，前半段可以预处理前缀和；后半段又是一个范围内数对之和，记

$$
g(n,m)=\sum_{i=1}^n\sum_{j=1}^m i\cdot j=\frac{n\cdot(n+1)}{2}\times\frac{m\cdot(m+1)}{2}
$$

可以 $\Theta(1)$ 求解

至此

$$
\text{sum}(n,m)=\sum_{d=1}^n\mu(d)\cdot d^2\cdot g(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)
$$

我们可以 $\lfloor\frac{n}{\lfloor\frac{n}{d}\rfloor}\rfloor$ 数论分块求解 $\text{sum}(n,m)$ 函数。

在求出 $\text{sum}(n,m)$ 后，回到定义 $\text{sum}$ 的地方，可得原式为

$$
\sum_{d=1}^n d\cdot\text{sum}(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)
$$

可见这又是一个可以数论分块求解的式子！

本题除了推式子比较复杂、代码细节较多之外，是一道很好的莫比乌斯反演练习题！（上述过程中，默认 $n\leqslant m$ ）

时间复杂度： $\Theta(n+m)$ （瓶颈为线性筛）

??? note "代码实现"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    using std::min;
    
    const int N = 1e7;
    const int mod = 20101009;
    int n, m, mu[N + 5], p[N / 10 + 5], sum[N + 5];
    bool flg[N + 5];
    
    void init() {
      mu[1] = 1;
      int tot = 0, k = min(n, m);
      for (int i = 2; i <= k; ++i) {
        if (!flg[i]) p[++tot] = i, mu[i] = -1;
        for (int j = 1; j <= tot && i * p[j] <= k; ++j) {
          flg[i * p[j]] = 1;
          if (i % p[j] == 0) {
            mu[i * p[j]] = 0;
            break;
          }
          mu[i * p[j]] = -mu[i];
        }
      }
      for (int i = 1; i <= k; ++i)
        sum[i] = (sum[i - 1] + 1LL * i * i % mod * (mu[i] + mod)) % mod;
    }
    int Sum(int x, int y) {
      return (1LL * x * (x + 1) / 2 % mod) * (1LL * y * (y + 1) / 2 % mod) % mod;
    }
    int func(int x, int y) {
      int res = 0;
      for (int i = 1, j; i <= min(x, y); i = j + 1) {
        j = min(x / (x / i), y / (y / i));
        res = (res + 1LL * (sum[j] - sum[i - 1] + mod) * Sum(x / i, y / i) % mod) %
              mod;
      }
      return res;
    }
    int solve(int x, int y) {
      int res = 0;
      for (int i = 1, j; i <= min(x, y); i = j + 1) {
        j = min(x / (x / i), y / (y / i));
        res = (res +
               1LL * (j - i + 1) * (i + j) / 2 % mod * func(x / i, y / i) % mod) %
              mod;
      }
      return res;
    }
    int main() {
      scanf("%d%d", &n, &m);
      init();
      printf("%d\n", solve(n, m));
    }
    ```

###  [「SDOI2015」约数个数和](https://loj.ac/problem/2185) 

多组数据，求

$$
\sum_{i=1}^n\sum_{j=1}^md(i\cdot j)\\
\left(d(n)=\sum_{i \mid n}1\right)
n,m,T\leq5\times10^4
$$

其中 $d(n)$ 表示 $n$ 的约数个数

要推这道题首先要了解 $d$ 函数的一个特殊性质

$$
d(i\cdot j)=\sum_{x \mid i}\sum_{y \mid j}[\gcd(x,y)=1]
$$

再化一下这个式子

$$
\begin{split}
d(i\cdot j)=&\sum_{x \mid i}\sum_{y \mid j}[\gcd(x,y)=1]\\
=&\sum_{x \mid i}\sum_{y \mid j}\sum_{p \mid \gcd(x,y)}\mu(p)\\
=&\sum_{p=1}^{min(i,j)}\sum_{x \mid i}\sum_{y \mid j}[p \mid \gcd(x,y)]\cdot\mu(p)\\
=&\sum_{p \mid i,p \mid j}\mu(p)\sum_{x \mid i}\sum_{y \mid j}[p \mid \gcd(x,y)]\\
=&\sum_{p \mid i,p \mid j}\mu(p)\sum_{x \mid \frac{i}{p}}\sum_{y \mid \frac{j}{p}}1\\
=&\sum_{p \mid i,p \mid j}\mu(p)d\left(\frac{i}{p}\right)d\left(\frac{j}{p}\right)\\
\end{split}
$$

将上述式子代回原式

$$
\begin{split}
&\sum_{i=1}^n\sum_{j=1}^md(i\cdot j)\\
=&\sum_{i=1}^n\sum_{j=1}^m\sum_{p \mid i,p \mid j}\mu(p)d\left(\frac{i}{p}\right)d\left(\frac{j}{p}\right)\\
=&\sum_{p=1}^{min(n,m)}
\sum_{i=1}^n\sum_{j=1}^m
[p \mid i,p \mid j]\cdot\mu(p)d\left(\frac{i}{p}\right)d\left(\frac{j}{p}\right)\\
=&\sum_{p=1}^{min(n,m)}
\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{p}\right\rfloor}
\mu(p)d(i)d(j)\\
=&\sum_{p=1}^{min(n,m)}\mu(p)
\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}d(i)
\sum_{j=1}^{\left\lfloor\frac{m}{p}\right\rfloor}d(j)\\
=&\sum_{p=1}^{min(n,m)}\mu(p)
S\left(\left\lfloor\frac{n}{p}\right\rfloor\right)
S\left(\left\lfloor\frac{m}{p}\right\rfloor\right)
\left(S(n)=\sum_{i=1}^{n}d(i)\right)\\
\end{split}
$$

那么 $O(n)$ 预处理 $\mu,d$ 的前缀和， $O(\sqrt{n})$ 分块处理询问，总复杂度 $O(n+T\sqrt{n})$ .

??? note "代码实现"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #define int long long
    using namespace std;
    const int N = 5e4 + 5;
    int n, m, T, pr[N], mu[N], d[N], t[N], cnt;  // t 表示 i 的最小质因子出现的次数
    bool bp[N];
    void prime_work(int k) {
      bp[0] = bp[1] = 1, mu[1] = 1, d[1] = 1;
      for (int i = 2; i <= k; i++) {
        if (!bp[i]) pr[++cnt] = i, mu[i] = -1, d[i] = 2, t[i] = 1;
        for (int j = 1; j <= cnt && i * pr[j] <= k; j++) {
          bp[i * pr[j]] = 1;
          if (i % pr[j] == 0) {
            mu[i * pr[j]] = 0, d[i * pr[j]] = d[i] / (t[i] + 1) * (t[i] + 2),
                   t[i * pr[j]] = t[i] + 1;
            break;
          } else
            mu[i * pr[j]] = -mu[i], d[i * pr[j]] = d[i] << 1, t[i * pr[j]] = 1;
        }
      }
      for (int i = 2; i <= k; i++) mu[i] += mu[i - 1], d[i] += d[i - 1];
    }
    int solve() {
      int res = 0, mxi = min(n, m);
      for (int i = 1, j; i <= mxi; i = j + 1)
        j = min(n / (n / i), m / (m / i)),
        res += d[n / i] * d[m / i] * (mu[j] - mu[i - 1]);
      return res;
    }
    signed main() {
      scanf("%lld", &T);
      prime_work(50000);
      while (T--) {
        scanf("%lld%lld", &n, &m);
        printf("%lld\n", solve());
      }
      return 0;
    }
    ```

###  [「luogu 3768」简单的数学题](https://www.luogu.org/problemnew/show/P3768) 

求

$$
\sum_{i=1}^n\sum_{j=1}^ni\cdot j\cdot \gcd(i,j)\bmod p\\
n\leq10^{10},5\times10^8\leq p\leq1.1\times10^9,\text{p 是质数}
$$

看似是一道和 $\gcd$ 有关的题，不过由于带有系数，并不容易化简

我们利用 $\varphi\ast1=ID$ 反演

$$
\begin{eqnarray}
&& \sum_{i=1}^n\sum_{j=1}^ni\cdot j\cdot \gcd(i,j)\\
&=&\sum_{i=1}^n\sum_{j=1}^ni\cdot j
\sum_{d \mid i,d \mid j}\varphi(d)\\
&=&\sum_{d=1}^n\sum_{i=1}^n
\sum_{j=1}^n[d \mid i,d \mid j]\cdot i\cdot j
\cdot\varphi(d)\\
&=&\sum_{d=1}^n
\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}
d^2\cdot i\cdot j\cdot\varphi(d)\\
&=&\sum_{d=1}^nd^2\cdot\varphi(d)
\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}i
\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}j\\
&=&\sum_{d=1}^nF^2\left(\left\lfloor\frac{n}{d}\right\rfloor\right)\cdot d^2\varphi(d)
\left(F(n)=\frac{1}{2}n\left(n+1\right)\right)\\
\end{eqnarray}
$$

对 $\sum_{d=1}^nF\left(\left\lfloor\frac{n}{d}\right\rfloor\right)^2$ 做数论分块， $d^2\varphi(d)$ 的前缀和用杜教筛处理：

$$
\begin{split}
&f(n)=n^2\varphi(n)=(ID^2\varphi)(n)\\
&S(n)=\sum_{i=1}^nf(i)=\sum_{i=1}^n(ID^2\varphi)(i)
\end{split}
$$

杜教筛（见 [杜教筛 - 例 3](../du/#_8) ）完了是这样的

$$
S(n)=\left(\frac{1}{2}n(n+1)\right)^2-\sum_{i=2}^ni^2S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
$$

分块递归求解即可，复杂度 $O(n^{\frac{2}{3}})$ .

??? note "代码实现"
    ```cpp
    #include <cmath>
    #include <cstdio>
    #include <map>
    #define int long long
    using namespace std;
    const signed N = 5e6, NP = 5e6, SZ = N;
    int n, P, inv2, inv6, s[N];
    signed phi[N], p[NP], cnt, pn;
    bool bp[N];
    map<int, int> s_map;
    int ksm(int a, int m) {  //求逆元用
      int res = 1;
      while (m) {
        if (m & 1) res = res * a % P;
        a = a * a % P, m >>= 1;
      }
      return res;
    }
    void prime_work(signed k) {  //线性筛phi，s
      bp[0] = bp[1] = 1, phi[1] = 1;
      for (signed i = 2; i <= k; i++) {
        if (!bp[i]) p[++cnt] = i, phi[i] = i - 1;
        for (signed j = 1; j <= cnt && i * p[j] <= k; j++) {
          bp[i * p[j]] = 1;
          if (i % p[j] == 0) {
            phi[i * p[j]] = phi[i] * p[j];
            break;
          } else
            phi[i * p[j]] = phi[i] * phi[p[j]];
        }
      }
      for (signed i = 1; i <= k; i++)
        s[i] = (1ll * i * i % P * phi[i] % P + s[i - 1]) % P;
    }
    int s3(int k) {
      return k %= P, (k * (k + 1) / 2) % P * ((k * (k + 1) / 2) % P) % P;
    }  //立方和
    int s2(int k) {
      return k %= P, k * (k + 1) % P * (k * 2 + 1) % P * inv6 % P;
    }  //平方和
    int calc(int k) {  //计算S(k)
      if (k <= pn) return s[k];
      if (s_map[k]) return s_map[k];  //对于超过pn的用map离散存储
      int res = s3(k), pre = 1, cur;
      for (int i = 2, j; i <= k; i = j + 1)
        j = k / (k / i), cur = s2(j),
        res = (res - calc(k / i) * (cur - pre) % P) % P, pre = cur;
      return s_map[k] = (res + P) % P;
    }
    int solve() {
      int res = 0, pre = 0, cur;
      for (int i = 1, j; i <= n; i = j + 1)
        j = n / (n / i), cur = calc(j),
        res = (res + (s3(n / i) * (cur - pre)) % P) % P, pre = cur;
      return (res + P) % P;
    }
    signed main() {
      scanf("%lld%lld", &P, &n);
      inv2 = ksm(2, P - 2), inv6 = ksm(6, P - 2);
      pn = (int)pow(n, 0.666667);  // n^(2/3)
      prime_work(pn);
      printf("%lld", solve());
      return 0;
    }  //不要为了省什么内存把数组开小。。。卡了好几次80
    ```

 **解法二** 

转化一下，可以将式子写成

$$
\begin{eqnarray}
&&\sum_{d=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}ijd\cdot[\gcd(i,j)=1]\\
&=&\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}ij\sum_{t\mid \gcd(i,j)}\mu(t)\\
&=&\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}ij\sum_{t=1}^{\lfloor\frac{n}{d}\rfloor}\mu(t)[t\mid \gcd(i,j)]\\
&=&\sum_{d=1}^{n}d\sum_{t=1}^{\lfloor\frac{n}{d}\rfloor}t^2 \mu(t)\sum_{i=1}^{\lfloor\frac{n}{td}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{td}\rfloor}ij[1\mid \gcd(i,j)]\\
&=&\sum_{d=1}^{n}d\sum_{t=1}^{\lfloor\frac{n}{d}\rfloor}t^2 \mu(t)\sum_{i=1}^{\lfloor\frac{n}{td}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{td}\rfloor}ij
\end{eqnarray}
$$

容易知道

$$
\sum_{i=1}^{n}\sum_{j=1}^{m}ij=\frac{n(n+1)}{2}\cdot \frac{m(m+1)}{2}
$$

设 $sum(n,m)=\sum_{i=1}^{n}\sum_{j=1}^{m}ij$ ，继续接着前面的往下推

$$
\begin{eqnarray}
&&\sum_{d=1}^{n}d\sum_{t=1}^{\lfloor\frac{n}{d}\rfloor}t^2 \mu(t)\sum_{i=1}^{\lfloor\frac{n}{td}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{td}\rfloor}ij\\
&=&\sum_{d=1}^{n}d\sum_{t=1}^{\lfloor\frac{n}{d}\rfloor}t^2 \mu(t)\cdot sum(\lfloor\frac{n}{td}\rfloor,\lfloor\frac{m}{td}\rfloor)\\
&=&\sum_{T=1}^{n}sum(\lfloor\frac{n}{T}\rfloor,\lfloor\frac{m}{T}\rfloor)\sum_{d\mid T}d\cdot (\frac{T}{d})^2\mu(\frac{T}{d})\\
&=&\sum_{T=1}^{n}sum(\lfloor\frac{n}{T}\rfloor,\lfloor\frac{m}{T}\rfloor)(T\sum_{d\mid T}d\cdot\mu(d))
\end{eqnarray}
$$

这时我们只要对每个 $T$ 预处理出 $T\sum_{d\mid T}d\cdot\mu(d)$ 的值就行了，考虑如何快速求解

设 $f(n)=\sum_{d\mid n}d\cdot\mu(d)$ 

实际上 $f$ 可以用线性筛筛出，具体的是

$$
f(n)=
\begin{cases}
1-n &,n\in primes \\
f(\frac{x}{p}) &,p^2\mid n\\
f(\frac{x}{p})\cdot f(p) &,p^2\nmid n
\end{cases}
$$

其中 $p$ 表示 $n$ 的最小质因子，总时间复杂度 $O(n+\sqrt n)$ 。

## 莫比乌斯反演扩展

结尾补充一个莫比乌斯反演的非卷积形式。

对于数论函数 $f,g$ 和完全积性函数 $t$ 且 $t(1)=1$ ：

$$
f(n)=\sum_{i=1}^nt(i)g\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
\iff g(n)=\sum_{i=1}^n\mu(i)t(i)f\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
$$

我们证明一下

$$
\begin{eqnarray}
&&g(n)=\sum_{i=1}^n\mu(i)t(i)f\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\
&=&\sum_{i=1}^n\mu(i)t(i)
\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}t(j)
g\left(\left\lfloor\frac{\left\lfloor\frac{n}{i}\right\rfloor}{j}\right\rfloor\right)\\
&=&\sum_{i=1}^n\mu(i)t(i)
\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}t(j)
g\left(\left\lfloor\frac{n}{ij}\right\rfloor\right)\\
&=&\sum_{T=1}^n
\sum_{i=1}^n\mu(i)t(i)
\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}[ij=T]
t(j)g\left(\left\lfloor\frac{n}{T}\right\rfloor\right)
&&\text{【先枚举 ij 乘积】}\\
&=&\sum_{T=1}^n
\sum_{i \mid T}\mu(i)t(i)
t\left(\frac{T}{i}\right)g\left(\left\lfloor\frac{n}{T}\right\rfloor\right)
&&\text{【}\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}[ij=T] \text{对答案的贡献为 1，于是省略】}\\
&=&\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)
\sum_{i \mid T}\mu(i)t(i)t\left(\frac{T}{i}\right)\\
&=&\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)
\sum_{i \mid T}\mu(i)t(T)
&&\text{【t 是完全积性函数】}\\
&=&\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)t(T)
\sum_{i \mid T}\mu(i)\\
&=&\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)t(T)
\varepsilon(T)
&&\text{【}\mu\ast 1= \varepsilon\text{】}\\
&=&g(n)t(1)
&&\text{【当且仅当 T=1,}\varepsilon(T)=1\text{时】}\\
&=&g(n)
&& \square
\end{eqnarray}
$$

## 参考文献

 [algocode 算法博客](https://algocode.net) 

# permutation-group
author: Wajov

置换群通常用来解决一些涉及“本质不同”的计数问题，例如用 3 种颜色给一个立方体染色，求本质不同的方案数（经过翻转后相同的两种方案视为同一种）。

## 群

### 群的定义

若集合 $S\neq\varnothing$ 和 $S$ 上的运算 $\cdot$ 构成的代数结构 $(S,\cdot)$ 满足以下性质：

-   封闭性： $\forall a,b\in S,a\cdot b\in S$ 

-   结合律： $\forall a,b,c\in S,(a\cdot b)\cdot c=a\cdot(b\cdot c)$ 

-   单位元： $\exists e\in S,\forall a\in S,e\cdot a=a\cdot e=a$ 

-   逆元： $\forall a\in S,\exists b\in S,a\cdot b=b\cdot a=e$ ，称 $b$ 为 $a$ 的逆元，记为 $a^{-1}$ 

则称 $(S,\cdot)$ 为一个 **群** 。例如，整数集和整数间的加法 $(\mathbb{Z},+)$ 构成一个群，单位元是 0，一个整数的逆元是它的相反数。

### 子群的定义

若 $(S,\cdot)$ 是群， $T$ 是 $S$ 的非空子集，且 $(T,\cdot)$ 也是群，则称 $(T,\cdot)$ 是 $(S,\cdot)$ 的 **子群** 。

## 置换

### 置换的定义

有限集合到自身的双射（即一一对应）称为置换。集合 $S=\{a_1,a_2,\dots,a_n\}$ 上的置换可以表示为

$$
f=\pmatrix{a_1,a_2,\dots,a_n\\
a_{p_1},a_{p_2},\dots,a_{p_n}}
$$

意为将 $a_i$ 映射为 $a_{p_i}$ ，其中 $p_1,p_2,\dots,p_n$ 是 $1,2,\dots,n$ 的一个排列。显然 $S$ 上所有置换的数量为 $n/home/llj/Desktop/OI-wiki-master/docs/math/!$ 。

### 置换的乘法

对于两个置换 $f=\pmatrix{a_1,a_2,\dots,a_n\\a_{p_1},a_{p_2},\dots,a_{p_n}}$ 和 $g=\pmatrix{a_{p_1},a_{p_2},\dots,a_{p_n}\\a_{q_1},a_{q_2},\dots,a_{q_n}}$ ， $f$ 和 $g$ 的乘积记为 $f\circ g$ ，其值为

$$
f\circ g=\pmatrix{a_1,a_2,\dots,a_n\\
a_{q_1},a_{q_2},\dots,a_{q_n}}
$$

简单来说就是先后经过 $f$ 的映射，再经过 $g$ 的映射。

### 置换群

易证，集合 $S$ 上的所有置换关于置换的乘法满足封闭性、结合律、有单位元（恒等置换，即每个元素映射成它自己）、有逆元（交换置换表示中的上下两行），因此构成一个群。这个群的任意一个 **子群** 即称为 **置换群** 。

### 循环置换

循环置换是一类特殊的置换，可表示为

$$
(a_1,a_2,\dots,a_m)=\pmatrix{a_1,a_2,\dots,a_{m-1},a_m\\
a_2,a_3,\dots,a_m,a_1}
$$

若两个循环置换不含有相同的元素，则称它们是 **不相交** 的。有如下定理：

任意一个置换都可以分解为若干不相交的循环置换的乘积，例如

$$
\pmatrix{a_1,a_2,a_3,a_4,a_5\\
a_3,a_1,a_2,a_5,a_4}=(a_1,a_3,a_2)\circ(a_4,a_5)
$$

该定理的证明也非常简单。如果把元素视为图的节点，映射关系视为有向边，则每个节点的入度和出度都为 1，因此形成的图形必定是若干个环的集合，而一个环即可用一个循环置换表示。

## Burnside 引理

前面的都算是铺垫，接下来我们进入正题。

### 描述

设 $A$ 和 $B$ 为有限集合， $X=B^A$ 表示所有从 $A$ 到 $B$ 的映射。 $G$ 是 $A$ 上的置换群， $X/G$ 表示 $G$ 作用在 $X$ 上产生的所有等价类的集合（若 $X$ 中的两个映射经过 $G$ 中的置换作用后相等，则它们在同一等价类中），则

$$
|X/G|=\frac{1}{|G|}\sum_{g\in G}|X^g|
$$

其中 $|S|$ 表示集合 $S$ 中元素的个数，且

$$
X^g=\{x|x\in X,g(x)=x\}
$$

是不是觉得很难懂？别急，请看下面的例子。

### 举例

我们还是以给立方体染色为例子，则上面式子中一些符号的解释如下：

-    $A$ ：立方体 6 个面的集合
-    $B$ ：3 种颜色的集合
-    $X$ ：直接给每个面染色，不考虑本质不同的方案的集合，共有 $3^6$ 种
-    $G$ ：各种翻转操作构成的置换群
-    $X/G$ ：本质不同的染色方案的集合
-    $X^g$ ：对于某一种翻转操作 $g$ ，所有直接染色方案中，经过 $g$ 这种翻转后保持不变的染色方案的集合

/home/llj/Desktop/OI-wiki-master/docs/math/![](./images/cube.png)

接下来我们需要对 $G$ 中的所有置换进行分析，它们可以分为以下几类（方便起见，将立方体的 6 个面分别称为前、后、上、下、左、右）：

-   不动：即恒等变换，因为所有直接染色方案经过恒等变换都不变，因此它对应的 $|X^g|=3^6$ 
-   以两个相对面的中心连线为轴的 $90^\circ$ 旋转：相对面有 3 种选择，旋转的方向有两种选择，因此这类共有 6 个置换。假设选择了前、后两个面中心的连线为轴，则必须要满足上、下、左、右 4 个面的颜色一样，才能使旋转后不变，因此它对应的 $|X^g|=3^3$ 
-   以两个相对面的中心连线为轴的 $180^\circ$ 旋转：相对面有 3 种选择，旋转方向的选择对置换不再有影响，因此这类共有 3 个置换。假设选择了前、后两个面中心的连线为轴，则必须要满足上、下两个面的颜色一样，左、右两个面的颜色一样，才能使旋转后不变，因此它对应的 $|X^g|=3^4$ 
-   以两条相对棱的中点连线为轴的 $180^\circ$ 旋转：相对棱有 6 种选择，旋转方向对置换依然没有影响，因此这类共有 6 个置换。假设选择了前、上两个面的边界和下、后两个面的边界作为相对棱，则必须要满足前、上两个面的颜色一样，下、后两个面的颜色一样，左、右两个面的颜色一样，才能使旋转后不变，因此它对应的 $|X^g|=3^3$ 
-   以两个相对顶点的连线为轴的 $120^\circ$ 旋转：相对顶点有 4 种选择，旋转的方向有两种选择，因此这类共有 8 个置换。假设选择了前面的右上角和后面的左下角作为相对顶点，则必须满足前、上、右三个面的颜色一样，后、下、左三个面的颜色一样，才能使旋转后不变，因此它对应的 $|X^g|=3^2$ 

因此，所有本质不同的方案数为

$$
\frac{1}{1+6+3+6+8}(3^6+6\times3^3+3\times3^4+6\times3^3+8\times3^2)=57
$$

### 证明

看懂本部分需要群论的相关知识，如果你没有学习过群论或者对证明过程没有兴趣，建议直接跳过本部分。

为了证明 Burnside 引理，需要先引入轨道稳定子定理（Orbit-Stabilizer Theorem，也称轨道 - 稳定集定理）。

 **轨道稳定子定理**  $G$ 和 $X$ 的定义同上， $\forall x\in X,G^x=\{g|g(x)=x,g\in G\},G(x)=\{g(x)|g\in G\}$ ，其中 $G^x$ 称为 $x$ 的 **稳定子** ， $G(x)$ 称为 $x$ 的 **轨道** ，则有

$$
|G|=|G^x||G(x)|
$$

 **轨道稳定子定理的证明** 首先可以证明 $G^x$ 是 $G$ 的子群，因为

-   封闭性：若 $f,g\in G$ ，则 $f\circ g(x)=f(g(x))=f(x)=x$ ，所以 $f\circ g\in G^x$ 
-   结合律：显然置换的乘法满足结合律
-   单位元：因为 $I(x)=x$ ，所以 $I\in G^x$ （ $I$ 为恒等置换）
-   逆元：若 $g\in G^x$ ，则 $g^{-1}(x)=g^{-1}(g(x))=g^{-1}\circ g(x)=I(x)=x$ ，所以 $g^{-1}\in G^x$ 

则由群论中的拉格朗日定理，可得

$$
|G|=|G^x|[G:G^x]
$$

其中 $[G:G^x]$ 为 $G^x$ 不同的左陪集个数。接下来只需证明 $|G(x)|=[G:G^x]$ ，我们将其转化为证明存在一个从 $G(x)$ 到 $G^x$ 所有不同左陪集的双射。令 $\varphi(g(x))=gG^x$ ，下证 $\varphi$ 为双射

-   若 $g(x)=f(x)$ ，两边同时左乘 $f^{-1}$ ，可得 $f^{-1}\circ g(x)=I(x)=x$ ，所以 $f^{-1}\circ g\in G^x$ ，由陪集的性质可得 $(f^{-1}\circ g)G^x=G^x$ ，即 $gG^x=fG^x$ 
-   反过来可证，若 $gG^x=fG^x$ ，则有 $g(x)=f(x)$ 
-   以上两点说明对于一个 $g(x)$ ，只有一个左陪集与其对应，即 $\varphi$ 是一个从 $G(x)$ 到左陪集的映射
-   又显然 $\varphi$ 有逆映射，因此 $\varphi$ 是一个双射

     **Burnside 引理的证明** 

$$
\begin{align}
\sum_{g\in G}|X^g|&=|\{(g,x)|(g,x)\in G\times X,g(x)=x\}|\\
&=\sum_{x\in X}|G^x|\\
&=\sum_{x\in X}\frac{|G|}{|G(x)|}\quad\quad\quad（轨道稳定子定理）\\
&=|G|\sum_{x\in X}\frac{1}{|G(x)|}\\
&=|G|\sum_{Y\in X/G}\sum_{x\in Y}\frac{1}{|G(x)|}\\
&=|G|\sum_{Y\in X/G}\sum_{x\in Y}\frac{1}{|Y|}\\
&=|G|\sum_{Y\in X/G}1\\
&=|G||X/G|
\end{align}
$$

所以有

$$
|X/G|=\frac{1}{|G|}\sum_{g\in G}|X^g|
$$

## Pólya 定理

### 描述

前置条件与 Burnside 引理相同，内容修改为

$$
|X/G|=\frac{1}{|G|}\sum_{g\in G}|B|^{c(g)}
$$

其中 $c(g)$ 表示置换 $g$ 能拆分成的不相交的循环置换的数量。

### 举例

依然考虑立方体染色问题。分析刚才提到的以相对棱的中点连线为轴的 $180^\circ$ 旋转，如果将前、后、上、下、左、右 6 个面依次编号为 1 到 6，则该置换可以表示为（翻转后原来编号为 1 的面的位置变为了编号为 3 的面，以此类推）

$$
\pmatrix{1,3,2,4,5,6\\
3,1,4,2,6,5}=(1,3)\circ(2,4)\circ(5,6)
$$

因此 $c(g)=3,|B|^{c(g)}=3^3$ ，与刚才在 Burnside 引理中分析的结果相同。

### 证明

在 Burnside 引理中，显然 $g(x)=x$ 的充要条件是 $x$ 将 $g$ 中每个循环置换的元素都映射到了 $B$ 中的同一元素，所以 $|X^g|=|B|^{c(g)}$ ，即可得 Pólya 定理。

# crt
## 「物不知数」问题

> 有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？

即求满足以下条件的整数：除以 $3$ 余 $2$ ，除以 $5$ 余 $3$ ，除以 $7$ 余 $2$ 。

该问题最早见于《孙子算经》中，并有该问题的具体解法。宋朝数学家秦九韶于 1247 年《数书九章》卷一、二《大衍类》对「物不知数」问题做出了完整系统的解答。上面具体问题的解答口诀由明朝数学家程大位在《算法统宗》中给出：

> 三人同行七十希，五树梅花廿一支，七子团圆正半月，除百零五便得知。

 $2\times 70+3\times 21+2\times 15=233=2\times 105+23$ ，故答案为 $23$ 。

## 算法简介及过程

中国剩余定理 (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中 $n_1, n_2, \cdots, n_k$ 两两互质）：

$$
\left \{
\begin{array}{ccc}
x &\equiv& a_1 \pmod {n_1} \\
x &\equiv& a_2 \pmod {n_2} \\
  &\vdots& \\
x &\equiv& a_n \pmod {n_k} \\
\end{array}
\right.
$$

上面的「物不知数」问题就是一元线性同余方程组的一个实例。

### 算法流程

1.  计算所有模数的积 $n$ ；
2.  对于第 $i$ 个方程：
    1.  计算 $m_i=\frac{n}{n_i}$ ；
    2.  计算 $m_i$ 在模 $n_i$ 意义下的 [逆元](./inverse.md)  $m_i^{-1}$ ；
    3.  计算 $c_i=m_im_i^{-1}$ （ **不要对 $n_i$ 取模** ）。
3.  方程组的唯一解为： $a=\sum_{i=1}^k a_ic_i \pmod n$ 。

### 伪代码

```text
1 → n
0 → ans
for i = 1 to k
	n * n[i] → n
for i = 1 to k
	n / n[i] → m
	inv(m, n[i]) → b               // b * m mod n[i] = 1
	(ans + a[i] * m * b) mod n → ans
return ans
```

## 算法的证明

我们需要证明上面算法计算所得的 $a$ 对于任意 $i=1,2,\cdots,k$ 满足 $a\equiv a_i \pmod {n_i}$ 。

当 $i\neq j$ 时，有 $m_j\equiv 0 \pmod {n_i}$ ，故 $c_j\equiv m_j\equiv 0 \pmod {n_i}$ 。又有 $c_i\equiv m_i(m_i^{-1}\bmod {n_i})\equiv 1 \pmod {n_i}$ ，所以我们有：

$$
\begin{aligned}
a&\equiv \sum_{j=1}^k a_jc_j        &\pmod {n_i} \\
 &\equiv a_ic_i                     &\pmod {n_i} \\
 &\equiv a_im_i(m^{-1}_i \bmod n_i) &\pmod {n_i} \\
 &\equiv a_i                        &\pmod {n_i}
\end{aligned}
$$

 **即对于任意 $i=1,2,\cdots,k$ ，上面算法得到的 $a$ 总是满足 $a\equiv a_i \pmod{n_i}$ ，即证明了解同余方程组的算法的正确性。** 

因为我们没有对输入的 $a_i$ 作特殊限制，所以任何一组输入 $\{a_i\}$ 都对应一个解 $a$ 。

另外，若 $x\neq y$ ，则总存在 $i$ 使得 $x$ 和 $y$ 在模 $n_i$ 下不同余。

 **故系数列表 $\{a_i\}$ 与解 $a$ 之间是一一映射关系，方程组总是有唯一解。** 

## 例

下面演示 CRT 如何解「物不知数」问题。

1.   $n=3\times 5\times 7=105$ ；
2.  三人同行 **七十** 希： $n_1=3, m_1=n/n_1=35, m_1^{-1}\equiv 2\pmod 3$ ，故 $c_1=35\times 2=70$ ；
3.  五树梅花 **廿一** 支： $n_2=5, m_2=n/n_2=21, m_2^{-1}\equiv 1\pmod 5$ ，故 $c_2=21\times 1=21$ ；
4.  七子团圆正 **半月** ： $n_3=7, m_3=n/n_3=15, m_3^{-1}\equiv 1\pmod 7$ ，故 $c_3=15\times 1=15$ ；
5.  所以方程组的唯一解为 $a\equiv 2\times 70+3\times 21+2\times 15\equiv 233\equiv 23 \pmod {105}$ 。（除 **百零五** 便得知）

## 应用

某些计数问题或数论问题出于加长代码、增加难度、或者是一些其他不可告人的原因，给出的模数： **不是质数** ！

但是对其质因数分解会发现它没有平方因子，也就是该模数是由一些不重复的质数相乘得到。

那么我们可以分别对这些模数进行计算，最后用 CRT 合并答案。

推荐练习：BZOJ 1951

## 比较两 CRT 下整数

考虑 CRT, 不妨假设 $n_1\leq n_2 \leq ... \leq n_k$ 

$$
\left\{ \begin{array} { r l } { x } & { \equiv a _ { 1 } \left( \bmod n _ { 1 } \right) } \\ { x } & { \equiv a _ { 2 } \left( \bmod n _ { 2 } \right) } \\ { } & { \vdots } \\ { x } & { \equiv a _ { n } \left( \bmod n _ { k } \right) } \end{array} \right.
$$

与 PMR(Primorial Mixed Radix) 表示

 $x=b_1+b_2n_1+b_3n_1n_2...+b_kn_1n_2...n_{k-1} ,b_i\in [0,n_i)$ 

将数字转化到 PMR 下，逐位比较即可

转化方法考虑依次对 PMR 取模

$$
\begin{aligned}
b_1&=a_1 \bmod n_1\\
b_2&=(a_2-b_1)c_{1,2} \bmod n_2\\
b_3&=((a_3-b_1')c_{1,3}-x_2')c_{2,3} \bmod n_3\\
&...\\
b_k&=(...((a_k-b_1)c_{1,k}-b_2)c_{2,k})-...)c_{k-1,k} \bmod n_k
\end{aligned}
$$

其中 $c_{i,j}$ 表示 $n_i$ 对 $n_j$ 的逆元， $c_{i,j}n_i \equiv 1 \pmod {n_j}$ 

## 扩展：模数不互质的情况

### 两个方程

设两个方程分别是 $x\equiv a_1 \pmod {m_1}$ 、 $x\equiv a_2 \pmod {m_2}$ ；

将它们转化为不定方程： $x=m_1p+a_1=m_2q+a_2$ ，其中 $p, q$ 是整数，则有 $m_1p-m_2q=a_2-a_1$ 。

由裴蜀定理，当 $a_2-a_1$ 不能被 $\gcd(m_1,m_2)$ 整除时，无解；

其他情况下，可以通过扩展欧几里得算法解出来一组可行解 $(p, q)$ ；

则原来的两方程组成的模方程组的解为 $x\equiv b\pmod M$ ，其中 $b=m_1p+a_1$ ， $M=\text{lcm}(m_1, m_2)$ 。

### 多个方程

用上面的方法两两合并就可以了……

推荐练习：POJ 2891

 [【模板】扩展中国剩余定理](https://www.luogu.org/problemnew/show/P4777) 

 [「NOI2018」屠龙勇士](https://uoj.ac/problem/396) 

 [「TJOI2009」猜数字](https://www.luogu.org/problemnew/show/P3868) 

 [「SDOI2010」古代猪文](https://loj.ac/problem/10229) 

# fibonacci
斐波那契数列（The Fibonacci sequence， [OEIS A000045](http://oeis.org/A000045) ）的定义如下：

$$
F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}
$$

该数列的前几项如下：

$$
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
$$

## 性质

斐波那契数列拥有许多有趣的性质，这里列举出一部分简单的性质：

1.  卡西尼性质（Cassini's identity）： $F_{n-1} F_{n+1} - F_n^2 = (-1)^n$ 。
2.  附加性质： $F_{n+k} = F_k F_{n+1} + F_{k-1} F_n$ 。
3.  取上一条性质中 $k = n$ ，我们得到 $F_{2n} = F_n (F_{n+1} + F_{n-1})$ 。
4.  由上一条性质可以归纳证明， $\forall k\in \mathbb{N},F_n|F_{nk}$ 。
5.  上述性质可逆，即 $\forall F_a|F_b,a|b$ 。
6.  GCD 性质： $(F_m, F_n) = F_{(m, n)}$ 。
7.  以斐波那契数列相邻两项作为输入会使欧几里德算法达到最坏复杂度（具体参见 [维基 - 拉梅](https://en.wikipedia.org/wiki/Gabriel_Lam%C3%A9) ）。

## 斐波那契编码

我们可以利用斐波那契数列为正整数编码。根据 [齐肯多夫定理](https://zh.wikipedia.org/wiki/%E9%BD%8A%E8%82%AF%E5%A4%9A%E5%A4%AB%E5%AE%9A%E7%90%86) ，任何自然数 $n$ 可以被唯一地表示成一些斐波那契数的和：

$$
N = F_{k_1} + F_{k_2} + \ldots + F_{k_r}
$$

并且 $k_1 \ge k_2 + 2,\ k_2 \ge k_3 + 2,\  \ldots,\  k_r \ge 2$ （即不能使用两个相邻的斐波那契数）

于是我们可以用 $d_0 d_1 d_2 \dots d_s 1$ 的编码表示一个正整数，其中 $d_i=1$ 则表示 $F_{i+2}$ 被使用。编码末位我们强制给它加一个 1（这样会出现两个相邻的 1），表示这一串编码结束。举几个例子：

$$
\begin{eqnarray}
1 &=& 1 &=& F_2 &=& (11)_F \\
2 &=& 2 &=& F_3 &=& (011)_F \\
6 &=& 5 + 1 &=& F_5 + F_2 &=& (10011)_F \\
8 &=& 8 &=& F_6 &=& (000011)_F \\
9 &=& 8 + 1 &=& F_6 + F_2 &=& (100011)_F \\
19 &=& 13 + 5 + 1 &=& F_7 + F_5 + F_2 &=& (1001011)_F
\end{eqnarray}
$$

给 $n$ 编码的过程可以使用贪心算法解决：

1.  从大到小枚举斐波那契数 $F_i$ ，直到 $F_i\le n$ 。
2.  把 $n$ 减掉 $F_i$ ，在编码的 $i-2$ 的位置上放一个 1（编码从左到右以 0 为起点）。
3.  如果 $n$ 为正，回到步骤 1。
4.  最后在编码末位添加一个 1，表示编码的结束位置。

解码过程同理，先删掉末位的 1，对于编码为 1 的位置 $i$ （编码从左到右以 0 为起点），累加一个 $F_{i+2}$ 到答案。最后的答案就是原数字。

## 斐波那契数列通项公式

第 $n$ 个斐波那契数可以在 $\Theta (n)$ 的时间内使用递推公式计算。但我们仍有更快速的方法计算。

### 解析解

解析解即公式解。我们有斐波那契数列的通项公式（Binet's Formula）：

$$
F_n = \frac{\left(\frac{1 + \sqrt{5}}{2}\right)^n - \left(\frac{1 - \sqrt{5}}{2}\right)^n}{\sqrt{5}}
$$

这个公式可以很容易地用归纳法证明，当然也可以通过生成函数的概念推导，或者解一个方程得到。

当然你可能发现，这个公式分子的第二项总是小于 $1$ ，并且它以指数级的速度减小。因此我们可以把这个公式写成

$$
F_n = \left[\frac{\left(\frac{1 + \sqrt{5}}{2}\right)^n}{\sqrt{5}}\right]
$$

这里的中括号表示取离它最近的整数。

这两个公式在计算的时侯要求极高的精确度，因此在实践中很少用到。但是请不要忽视！结合模意义下二次剩余和逆元的概念，在 OI 中使用这个公式仍是有用的。

### 矩阵形式

斐波那契数列的递推可以用矩阵乘法的形式表达：

$$
\begin{bmatrix}F_{n-1} & F_{n} \cr\end{bmatrix} = \begin{bmatrix}F_{n-2} & F_{n-1} \cr\end{bmatrix} \cdot \begin{bmatrix}0 & 1 \cr 1 & 1 \cr\end{bmatrix}
$$

设 $P = \begin{bmatrix}0 & 1 \cr 1 & 1 \cr\end{bmatrix}$ ，我们得到

$$
\begin{bmatrix}F_n & F_{n+1} \cr\end{bmatrix} = \begin{bmatrix}F_0 & F_1 \cr\end{bmatrix} \cdot P^n
$$

于是我们可以用矩阵乘法在 $\Theta(\log n)$ 的时间内计算斐波那契数列。此外，前一节讲述的公式也可通过矩阵对角化的技巧来得到。

### 快速倍增法

使用上面的方法我们可以得到以下等式：

$$
\begin{array}{rll}
F_{2k} &= F_k \left( 2F_{k+1} - F_{k} \right)\\
F_{2k+1} &= F_{k+1}^2 + F_{k}^2
\end{array}
$$

于是可以通过这样的方法快速计算两个相邻的斐波那契数（常数比矩乘小）。代码如下，返回值是一个二元组 $(F_n,F_{n+1})$ 。

```cpp
pair<int, int> fib(int n) {
  if (n == 0) return {0, 1};
  auto p = fib(n >> 1);
  int c = p.first * (2 * p.second - p.first);
  int d = p.first * p.first + p.second * p.second;
  if (n & 1)
    return {d, c + d};
  else
    return {c, d};
}
```

## 模意义下周期性

考虑模 $p$ 意义下的斐波那契数列，可以容易地使用抽屉原理证明，该数列是有周期性的。考虑模意义下前 $p^2+1$ 个斐波那契数对（两个相邻数配对）：

$$
(F_1,\ F_2),\ (F_2,\ F_3),\ \ldots,\ (F_{p^2 + 1},\ F_{p^2 + 2})
$$

 $p$ 的剩余系大小为 $p$ ，意味着在前 $p^2+1$ 个数对中必有两个相同的数对，于是这两个数对可以往后生成相同的斐波那契数列，那么他们就是周期性的。

事实上，我们有一个远比它要强的结论。模 $n$ 意义下斐波那契数列的周期被称为 [皮萨诺周期](https://en.wikipedia.org/wiki/Pisano_period) （ [OEIS A001175](http://oeis.org/A001175) ），该数可以证明总是不超过 $6n$ ，且只有在满足 $n=2\times 5^k$ 的形式时才取到等号。

## 习题

-    [SPOJ - Euclid Algorithm Revisited](http://www.spoj.com/problems/MAIN74/) 
-    [SPOJ - Fibonacci Sum](http://www.spoj.com/problems/FIBOSUM/) 
-    [HackerRank - Is Fibo](https://www.hackerrank.com/contests/codesprint5/challenges/is-fibo/problem) 
-    [Project Euler - Even Fibonacci numbers](https://www.hackerrank.com/contests/projecteuler/challenges/euler002/problem) 

     **本页面主要译自博文 [Числа Фибоначчи](http://e-maxx.ru/algo/fibonacci_numbers) 与其英文翻译版 [Fibonacci Numbers](https://cp-algorithms.com/algebra/fibonacci-numbers.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# linear-programming
## 定义

研究线性约束条件下线性目标函数极值问题的方法总称，是运筹学的一个分支，在多方面均有应用。线性规划的某些特殊情况，如网络流、多商品流量等问题都有可能在 OI 题目中出现

## 线性规划问题的描述

一个问题要能转化为线性规划问题，首先要有若干个线性约束条件，并且所求的目标函数也应该是线性的。那么，最容易也最常用的描述方法就是标准型。

我们以 [《算法导论》](https://mitpress.ublish.com/ereader/1/?preview#page/Cover) 中线性规划一节提出的问题为例：

> 假如你是一位政治家，试图赢得一场选举，你的选区有三种：市区，郊区和乡村，这些选区分别有 100000、200000 和 50000 个选民，尽管并不是所有人都有足够的社会责任感去投票，你还是希望每个选区至少有半数选民投票以确保你可以当选
>
> 显而易见的，你是一个正直、可敬的人，然而你意识到，在某些选区，某些议题可以更有效的赢取选票。你的首要议题是修筑更多的道路、枪支管制、农场补贴以及调整汽油税。你的竞选班子可以为你估测每花费 $1000 做广告，在每个选区可以赢取或者失去的选票的数量（千人），如下表所示：

| 政策   | 市区  | 郊区  | 乡村  |
| ---- | --- | --- | --- |
| 修路   | -2  | 5   | 3   |
| 枪支管制 | 8   | 2   | -5  |
| 农场补贴 | 0   | 0   | 10  |
| 汽油税  | 10  | 0   | -2  |

你的目标是计算出要在市区，郊区和乡村分别获得至少 50000，100000 和 25000 张选票所花费的最少钱数。

我们可以使用数学语言来描述它：

​	设 $x_1$ 为花费在修路广告上的钱（千美元）

​	设 $x_2$ 为花费在枪支管制广告上的钱（千美元）

​	设 $x_3$ 为花费在农场补贴广告上的钱​（千美元）

​	设 $x_4$ 为花费在汽油税广告上的钱（千美元）

那么我们可以将“在市区获得至少 50000 张市区选票”表述为

​ $-2x_1+8x_2+0x_3+10x_4 \geq 50​$ 

同样的，“在郊区获得至少 100000 张选票和在乡村获得至少 25000 张选票”可以表示为

​ $5x_1+2x_2+0x_3+0x_4 \geq 100​$ 

​ $3x_1-5x_2+10x_3-2x_4 \geq 25​$ 

显而易见的，广告服务提供商不会倒贴钱给你然后做反向广告，由此可得

​ $x_1,x_2,x_3,x_4 \geq 0​$ 

又因为我们的目标是使总费用最小，综上所述，原问题可以表述为：

最小化 $x_1+x_2+x_3+x_4$ ,

满足

​ $-2x_1+8x_2+0x_3+10x_4\geq50​$ 

​ $5x_1+2x_2+0x_3+0x_4\geq100$ 

​ $3x_1-5x_2+10x_3-2x_4\geq25​$ 

​ $x_1,x_2,x_3,x_4\geq0$ 

这个线性规划的解就是这个问题的最优策略

用更具有普遍性的语言说：

已知一组实数 $[a_1..a_n]​$ 和一组变量 $[x_1..x_n]​$ , 在定义上有函数 $f(x_1..x_n)=\sum_{i=1}^na_ix_i​$ 

显而易见的，这个函数是线性的。如果 b 是一个实数而满足 $f(x_1..x_n)=b$ , 则这个等式被称为线性等式，同样的，满足 $f(x_1..x_n)\leq b$ 或者 $f(x_1..x_n)\geq b$ 则称之为线性不等式

在线性规划问题中，线性等式和线性不等式统称为线性约束。

一个线性规划问题是一个线性函数的极值问题，而这个线性函数应该服从于一个或者多个线性约束。

## 图解法

上面那个问题中变量较多，不便于使用图解法，所以用下面的问题来介绍图解法：

最小化 $x,y$ 

满足

​ $x+2y\leq8 ​$ 

​ $x\leq4 ​$ 

​ $y\geq3 ​$ 

​ $x,y\in N​$ 

知道这些约束条件以后，我们需要将它们在平面直角坐标系中画出来

 $x\leq4$ （红色区域）

![img](images/linear-programming1.png)

 $y\geq3$ （黑色区域）

![img](images/linear-programming2.png)

 $x+2y\leq8$ （深红色区域以及包含于 $\geq4$ 区域的浅红色区域）

![img](images/linear-programming3.png)

显而易见的，打了蓝色斜线的区域为三块区域的交集，这就是这个线性规划的所有可行解。因为题目中说明，需要最小化 x 和 y，观察图像可知，点（2,3）为可行解中 x 和 y 最小的一个。因此， $x_{min}=2,y_{min}=3$ 

把求解线性规划的图解法总结起来，就是先在坐标系中作出所有的约束条件，然后作出需要求极值的线性函数的定义域。定义域与约束条件的交集就是这个线性规划的解集，而所需求的极值由观察可以轻易得出。

# complex
如果您已经学习过复数相关知识，请跳过本页面。

学习复数知识需要一部分向量基础，如果并未学习过向量知识请移步 [向量页面](../math/vector.md) 。

## 复数的引入，定义和分类

### 复数的引入

注：下面的引入方法来自人教版高中数学 A 版选修 2-2。

我们在实数域中，说 $x^2+1=0$ 这个二次方程无解。这个方程无解，那么我们能不能强行让它有解？如果让它有解的话，确实我们解决了问题，但是这个解的意义是什么？

我们尝试一下，定义一个新数 $\text{i}$ ， $\text{i}^2+1=0$ ，那么 $x^2+1=0$ 就有一个解 $x=\text{i}$ 了。

我们希望引入的这个新数与实数域中的数一样，能与实数进行加法和乘法运算，还保留各种运算律。

那么我们很容易想到 $a+b\text{i}$ 这种形式，当然其中 $a,b$ 都是实数。把 $\text{i}$ 看做类似变量的东西，验证其运算性质。我们可以发现，得到的结果全部有着 $a+b\text{i}$ 的类似形式。

那么这样的性质就与实数域类似了，我们把所有有着 $a+b\text{i}$ 形式的数放入一个集合中，就出现了复数集 $\mathbb{C}=\{a+b\text{i} \mid a,b\in \mathbb{R}\}$ 。

我们可以发现，这个集合中的数和实数集中的数类似，都有在集合中任选两个数进行四则运算，得到的数都是原集合中的数的性质。我们说复数集对于四则运算是 **封闭的** 。

### 复数的定义和分类

> 哇哦我们定义的数的性质这么好！

我们定义形如 $a+b\text{i}$ ，其中 $a,b\in \mathbb{R}$ 的数叫做 **复数** ，其中 $\text{i}$ 被称为 **虚数单位** ，全体复数的集合叫做 **复数集** 。

复数通常用 $z$ 表示，即 $z=a+b\text{i}$ 。这种形式被称为 **复数的代数形式** 。其中 $a$ 称为复数 $z$ 的 **实部** ， $b$ 称为复数 $z$ 的 **虚部** 。如无特殊说明，都有 $a,b\in \mathbb{R}$ 。

对于一个复数 $z$ ，当且仅当 $b=0$ 时，它是实数，当 $b\not = 0$ 时，它是虚数，当 $a=0$ 且 $b\not = 0$ 时，它是纯虚数。

纯虚数，虚数，实数，复数的关系如下图所示。

/home/llj/Desktop/OI-wiki-master/docs/math/![](./images/complex-1.png)

<div style='text-align: center; color: #999'>图片来自：人教版高中数学 A 
版选修 2-2 第 103 页</div>

## 复数的性质与运算

### 复数的几何意义

我们知道了 $a+b\text{i}$ 这样类似的形式的数被称为复数，并且给出了定义和分类，我们还可以挖掘一下更深层的性质。

我们把所有实数都放在了数轴上，并且发现数轴上的点与实数一一对应。我们考虑对复数也这样处理。

首先我们定义 **复数相等** ：两个复数 $z_1=a+b\text{i},z_2=c+d\text{i}$ 是相等的，当且仅当 $a=c$ 且 $b=d$ 。

这么定义是十分自然的，在此不做过多解释。

也就是说，我们可以用唯一的有序实数对 $(a,b)$ 表示一个复数 $z=a+b\text{i}$ 。这样，联想到平面直角坐标系，我们可以发现 **复数集与平面直角坐标系中的点集一一对应** 。好了，我们找到了复数的一种几何意义。

那么这个平面直角坐标系就不再一般，因为平面直角坐标系中的点具有了特殊意义——表示一个复数，所以我们把这样的平面直角坐标系称为 **复平面** ， $x$ 轴称为 **实轴** ， $y$ 轴称为 **虚轴** 。我们进一步地说： **复数集与复平面内所有的点所构成的集合是一一对应的** 。

我们考虑到学过的平面向量的知识，发现向量的坐标表示也是一个有序实数对 $(a,b)$ ，显然，复数 $z=a+b\text{i}$ 对应复平面内的点 $Z(a,b)$ ，那么它还对应平面向量 $\overrightarrow{OZ}=(a,b)$ ，于是我们又找到了复数的另一种几何意义： **复数集与复平面内的向量所构成的集合是一一对应的（实数 $0$ 与零向量对应）** 。

于是，我们由向量的知识迁移到复数上来，定义 **复数的模** 就是复数所对应的向量的模。复数 $z=a+b\text{i}$ 的模 $|z|=\sqrt{a^2+b^2}$ 。

于是为了方便，我们常把复数 $z=a+b\text{i}$ 称为点 $Z$ 或向量 $\overrightarrow {OZ}$ ，并规定相等的向量表示同一个复数。

并且由向量的知识我们发现，虚数不可以比较大小（但是实数是可以的）。

### 复数的运算

#### 复数的加法与减法

我们规定，复数的加法规则如下：

设 $z_1=a+b\text{i},z_2=c+d\text{i}$ ，那么

$$
z_1+z_2=(a+c)+(b+d)\text{i}
$$

很明显，两个复数的和仍为复数。

考虑到向量的加法运算，我们发现复数的加法运算符合向量的加法运算法则，这同样证明了复数的几何意义的正确性。

同样可以验证， **复数的加法满足交换律和结合律** 。即：

$$
z_1+z_2=z_2+z_1\\
(z_1+z_2)+z_3=z_1+(z_2+z_3)
$$

减法作为加法的逆运算，我们可以通过加法法则与复数相等的定义来推导出减法法则：

$$
z_1-z_2=(a-c)+(b-d)\text{i}
$$

这同样符合向量的减法运算。

#### 复数的乘法与除法

我们规定，复数的乘法规则如下：

设 $z_1=a+b\text{i},z_2=c+d\text{i}$ ，那么

$$
\begin{aligned}
z_1z_2&=(a+b\text{i})(c+d\text{i})\\
&=ac+bc\text{i}+ad\text{i}+bd\text{i}^2\\
&=(ac-bd)+(bc+ad)\text{i}
\end{aligned}
$$

可以看出，两个复数相乘类似于两个多项式相乘，只需要把 $\text{i}^2$ 换成 $-1$ ，并将实部与虚部分别合并即可。

复数确实与多项式有关，因为复数域是实系数多项式环模掉 $x^2+1$ 生成的理想。（这句话不明白其实也没有关系）

复数的乘法与向量的向量积形式类似，是由于复数集是数环。

于是容易知道， **复数乘法满足交换律，结合律和对加法的分配律** ，即：

$$
z_1z_2=z_2z_1\\
(z_1z_2)z_3=z_1(z_2z_3)\\
z_1(z_2+z_3)=z_1z_2+z_1z_3
$$

由于满足运算律，我们可以发现实数域中的 **乘法公式在复数域中同样适用** 。

除法运算是乘法运算的逆运算，我们可以推导一下：

$$
\begin{aligned}
\frac{a+b\text{i}}{c+d\text{i}}&=\frac{(a+b\text{i})(c-d\text{i})}{(c+d\text{i})(c-d\text{i})}\\
&=\frac{ac+bd}{c^2+d^2}+\frac{bc-ad}{c^2+d^2}\text{i} &(c+d\text{i}\not =0)
\end{aligned}
$$

为了分母实数化，我们乘了一个 $c-d\text{i}$ ，这个式子很有意义。

我们定义，当两个虚数实部相等，虚部互为相反数时，这两个复数互为 **共轭复数** 。通常记 $z=a+b\text{i}$ 的共轭复数为 $\bar z=a-b\text{i}$ 。我们可以发现，两个复数互为共轭复数，那么它们 **关于实轴对称** 。

由于向量没有除法，这里不讨论与向量的关系。

# drawer-principle
就比如说，你有 $n+1$ 个苹果，想要放到 $n$ 个抽屉里，那么必然会有至少一个抽屉里有两个（或以上）的苹果。

这个定理看起来比较显然，证明方法考虑反证法：假如所有抽屉都至多放了一个苹果，那么 $n$ 个抽屉至多只能放 $n$ 个苹果，矛盾。

# sieve
## 素数筛法

如果我们想要知道小于等于 $n$ 有多少个素数呢？

一个自然的想法是我们对于小于等于 $n$ 的每个数进行一次判定。这种暴力的做法显然不能达到最优复杂度，考虑如何优化。

考虑这样一件事情：如果 $x$ 是合数，那么 $x$ 的倍数也一定是合数。利用这个结论，我们可以避免很多次不必要的检测。

如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。

```cpp
int Eratosthenes(int n) {
  int p = 0;
  for (int i = 0; i <= n; ++i) is_prime[i] = 1;
  is_prime[0] = is_prime[1] = 0;
  for (int i = 2; i <= n; ++i) {
    if (is_prime[i]) {
      prime[p++] = i;  // prime[p]是i,后置自增运算代表当前素数数量
      for (int j = i * i; j <= n;
           j += i)  // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i
                    // 的倍数开始，提高了运行速度
        is_prime[j] = 0;  //是i的倍数的均不是素数
    }
  }
  return p;
}
```

以上为 **Eratosthenes 筛法** （埃拉托斯特尼筛法），时间复杂度是 $O(n\log\log n)$ 。

以上做法仍有优化空间，我们发现这里面似乎会对某些数标记了很多次其为合数。有没有什么办法省掉无意义的步骤呢？

答案当然是：有！

如果能让每个合数都只被标记一次，那么时间复杂度就可以降到 $O(n)$ 了

```cpp
void init() {
  phi[1] = 1;
  for (int i = 2; i < MAXN; ++i) {
    if (!vis[i]) {
      phi[i] = i - 1;
      pri[cnt++] = i;
    }
    for (int j = 0; j < cnt; ++j) {
      if (1ll * i * pri[j] >= MAXN) break;
      vis[i * pri[j]] = 1;
      if (i % pri[j]) {
        phi[i * pri[j]] = phi[i] * (pri[j] - 1);
      } else {
        // i % pri[j] == 0
        // 换言之，i 之前被 pri[j] 筛过了
        // 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定也是
        // pri[j] 的倍数 它们都被筛过了，就不需要再筛了，所以这里直接 break
        // 掉就好了
        phi[i * pri[j]] = phi[i] * pri[j];
        break;
      }
    }
  }
}
```

上面代码中的 $phi$ 数组，会在下面提到。

上面的这种 **线性筛法** 也称为 **Euler 筛法** （欧拉筛法）。

??? note
    注意到筛法求素数的同时也得到了每个数的最小质因子

## 筛法求欧拉函数

注意到在线性筛中，每一个合数都是被最小的质因子筛掉。比如设 $p_1$ 是 $n$ 的最小质因子， $n' = \frac{n}{p_1}$ ，那么线性筛的过程中 $n$ 通过 $n' \times p_1$ 筛掉。

观察线性筛的过程，我们还需要处理两个部分，下面对 $n' \bmod p_1$ 分情况讨论。

如果 $n' \bmod p_1 = 0$ ，那么 $n'$ 包含了 $n$ 的所有质因子。

$$
\begin{aligned}
\varphi(n) & = n \times \prod_{i = 1}^s{\frac{p_i - 1}{p_i}} \\\\
& = p_1 \times n' \times \prod_{i = 1}^s{\frac{p_i - 1}{p_i}} \\\\
& = p_1 \times \varphi(n')
\end{aligned}
$$

那如果 $n' \bmod p_1 \neq 0$ 呢，这时 $n'$ 和 $n$ 是互质的，根据欧拉函数性质，我们有：

$$
\begin{aligned}
\varphi(n) & = \varphi(p_1) \times \varphi(n') \\\\
& = (p_1 - 1) \times \varphi(n')
\end{aligned}
$$

```cpp
void phi_table(int n, int* phi) {
  for (int i = 2; i <= n; i++) phi[i] = 0;
  phi[1] = 1;
  for (int i = 2; i <= n; i++)
    if (!phi[i])
      for (int j = i; j <= n; j += i) {
        if (!phi[j]) phi[j] = j;
        phi[j] = phi[j] / i * (i - 1);
      }
}
```

## 筛法求莫比乌斯函数

#### 线性筛

```cpp
void pre() {
  mu[1] = 1;
  for (int i = 2; i <= 1e7; ++i) {
    if (!v[i]) mu[i] = -1, p[++tot] = i;
    for (int j = 1; j <= tot && i <= 1e7 / p[j]; ++j) {
      v[i * p[j]] = 1;
      if (i % p[j] == 0) {
        mu[i * p[j]] = 0;
        break;
      }
      mu[i * p[j]] = -mu[i];
    }
  }
```

## 筛法求约数个数

用 $d_i$ 表示 $i$ 的约数个数， $num_i$ 表示 $i$ 的最小质因子出现次数。

#### 约数个数定理

定理：若 $n=\prod_{i=1}^mp_i^{c_i}$ 则 $d_i=\prod_{i=1}^mc_i+1$ .

证明：我们知道 $p_i^{c_i}$ 的约数有 $p_i^0,p_i^1,\dots ,p_i^{c_i}$ 共 $c_i+1$ 个，根据乘法原理， $n$ 的约数个数就是 $\prod_{i=1}^mc_i+1$ .

#### 实现

因为 $d_i$ 是积性函数，所以可以使用线性筛。

```cpp
void pre() {
  d[1] = 1;
  for (int i = 2; i <= n; ++i) {
    if (!v[i]) v[i] = 1, p[++tot] = i, d[i] = 2, num[i] = 1;
    for (int j = 1; j <= tot && i <= n / p[j]; ++j) {
      v[p[j] * i] = 1;
      if (i % p[j] == 0) {
        num[i * p[j]] = num[i] + 1;
        d[i * p[j]] = d[i] / num[i * p[j]] * (num[i * p[j]] + 1);
        break;
      } else {
        num[i * p[j]] = 1;
        d[i * p[j]] = d[i] * 2;
      }
    }
  }
}
```

## 筛法求约数和

 $f_i$ 表示 $i$ 的约数和， $g_i$ 表示 $i$ 的最小质因子的 $p+p^1+p^2+\dots p^k$ .

```cpp
void pre() {
  g[1] = f[1] = 1;
  for (int i = 2; i <= n; ++i) {
    if (!v[i]) v[i] = 1, p[++tot] = i, g[i] = i + 1, f[i] = i + 1;
    for (int j = 1; j <= tot && i <= n / p[j]; ++j) {
      v[p[j] * i] = 1;
      if (i % p[j] == 0) {
        g[i * p[j]] = g[i] * p[j] + 1;
        f[i * p[j]] = f[i] / g[i] * g[i * p[j]];
        break;
      } else {
        f[i * p[j]] = f[i] * f[p[j]];
        g[i * p[j]] = 1 + p[j];
      }
    }
  }
  for (int i = 1; i <= n; ++i) f[i] = (f[i - 1] + f[i]) % Mod;
}
```

## 其他线性函数

# bsgs
## 基础篇

BSGS（baby-step gaint-step），即大步小步算法。常用于求解离散对数问题。形式化地说，该算法可以在 $O(\sqrt{p})$ 的时间内求解

$$
a^x \equiv b \pmod p
$$

其中 $a\perp p$ 。方程的解 $x$ 满足 $0 \le x < p$ 。（在这里需要注意，只要 $a\perp p$ 就行了，不要求 $p$ 是素数）

### 算法描述

令 $x = A \left \lceil \sqrt p \right \rceil - B$ ，其中 $0\le A,B \le \left \lceil \sqrt p \right \rceil$ ，则有 $a^{A\left \lceil \sqrt p \right \rceil -B} \equiv b \pmod p$ ，稍加变换，则有 $a^{A\left \lceil \sqrt p \right \rceil} \equiv ba^B \pmod p$ 。

我们已知的是 $a,b$ ，所以我们可以先算出等式右边的 $ba^B$ 的所有取值，枚举 $B$ ，用 `hash` / `map` 存下来，然后逐一计算 $a^{A\left \lceil \sqrt p \right \rceil}$ ，枚举 $A$ ，寻找是否有与之相等的 $ba^B$ ，从而我们可以得到所有的 $x$ ， $x=A \left \lceil \sqrt p \right \rceil - B$ 。

注意到 $A,B$ 均小于 $\left \lceil \sqrt p \right \rceil$ ，所以时间复杂度为 $\Theta\left  (\sqrt p\right )$ ，用 `map` 则多一个 $\log$ 。

## 进阶篇

求解

$$
x^a \equiv b \pmod p
$$

其中 $p$ 是个质数。

该模型可以通过一系列的转化为成 **基础篇** 中的模型，你可能需要了解关于 [阶与原根](./primitive-root.md) 的知识。

由于式子中的模数 $p$ 是一个质数，那么 $p$ 一定存在一个原根 $g$ 。因此对于模 $p$ 意义下的任意的数 $x\ (0\le x<p)$ 有且仅有一个数 $i\ (0\le i<p-1)$ 满足 $x = g^i$ 。

### 方法一

我们令 $x=g^c$ ， $g$ 是 $p$ 的原根（我们一定可以找到这个 $g$ 和 $c$ ），问题转化为求解 $(g^c)^a \equiv b \pmod p$ 。稍加变换，得到

$$
(g^a)^c \equiv b \pmod p
$$

于是就转换成了我们熟知的 **BSGS** 的基本模型了，可以在 $O(\sqrt p)$ 解出 $c$ ，这样可以得到原方程的一个特解 $x_0\equiv g^c\pmod p$ 。

### 方法二

我们仍令 $x=g^c$ ，并且设 $b=g^t$ ，于是我们得到

$$
g^{ac}\equiv g^t\pmod p
$$

方程两边同时取离散对数得到

$$
ac\equiv t\pmod{\varphi(p)}
$$

我们可以通过 BSGS 求解 $g^t\equiv b\pmod p$ 得到 $t$ ，于是这就转化成了一个线性同余方程的问题。这样也可以解出 $c$ ，求出 $x$ 的一个特解 $x_0\equiv g^c\pmod p$ 。

### 找到所有解

在知道 $x_0\equiv g^{c}\pmod p$ 的情况下，我们想得到原问题的所有解。首先我们知道 $g^{\varphi(p)}\equiv 1\pmod p$ ，于是可以得到

$$
\forall\ t \in \mathbb{Z},\ x^a \equiv g^{ c \cdot a + t\cdot\varphi(p)}\equiv b \pmod p
$$

于是得到所有解为

$$
\forall\ t\in \mathbb{Z},a\mid t\cdot\varphi(p),\ x\equiv g^{c+\frac{t\cdot\varphi(p)}{a}}\pmod p
$$

对于上面这个式子，显然有 $\frac{a}{\gcd(a,\varphi(p))}  \mid t$ 。因此我们设 $t=\frac{a}{\gcd(a,\varphi(p))}\cdot i$ ，得到

$$
\forall \ i\in \mathbb{Z},x\equiv g^{c+\frac{\varphi(p)}{\gcd(a,\varphi(p))}\cdot i}\pmod p
$$

这就是原问题的所有解。

### 实现

下面的代码实现的找原根、离散对数解和原问题所有解的过程。

??? "参考代码"
    ```cpp
    int gcd(int a, int b) { return a ? gcd(b % a, a) : b; }
    int powmod(int a, int b, int p) {
      int res = 1;
      while (b > 0) {
        if (b & 1) res = res * a % p;
        a = a * a % p, b >>= 1;
      }
      return res;
    }
    // Finds the primitive root modulo p
    int generator(int p) {
      vector<int> fact;
      int phi = p - 1, n = phi;
      for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
          fact.push_back(i);
          while (n % i == 0) n /= i;
        }
      }
      if (n > 1) fact.push_back(n);
      for (int res = 2; res <= p; ++res) {
        bool ok = true;
        for (int factor : fact) {
          if (powmod(res, phi / factor, p) == 1) {
            ok = false;
            break;
          }
        }
        if (ok) return res;
      }
      return -1;
    }
    // This program finds all numbers x such that x^k=a (mod n)
    int main() {
      int n, k, a;
      scanf("%d %d %d", &n, &k, &a);
      if (a == 0) return puts("1\n0"), 0;
      int g = generator(n);
      // Baby-step giant-step discrete logarithm algorithm
      int sq = (int)sqrt(n + .0) + 1;
      vector<pair<int, int>> dec(sq);
      for (int i = 1; i <= sq; ++i)
        dec[i - 1] = {powmod(g, i * sq * k % (n - 1), n), i};
      sort(dec.begin(), dec.end());
      int any_ans = -1;
      for (int i = 0; i < sq; ++i) {
        int my = powmod(g, i * k % (n - 1), n) * a % n;
        auto it = lower_bound(dec.begin(), dec.end(), make_pair(my, 0));
        if (it != dec.end() && it->first == my) {
          any_ans = it->second * sq - i;
          break;
        }
      }
      if (any_ans == -1) return puts("0"), 0;
      // Print all possible answers
      int delta = (n - 1) / gcd(k, n - 1);
      vector<int> ans;
      for (int cur = any_ans % delta; cur < n - 1; cur += delta)
        ans.push_back(powmod(g, cur, n));
      sort(ans.begin(), ans.end());
      printf("%d\n", ans.size());
      for (int answer : ans) printf("%d ", answer);
    }
    ```

## 扩展篇

接下来我们求解

$$
a^x\equiv b\pmod p
$$

其中 $a,p$ 不一定互质。

当 $a\perp p$ 时，在模 $p$ 意义下 $a$ 存在逆元，因此可以使用 BSGS 算法求解。于是我们想办法让他们变得互质。

具体地，设 $d_1=\gcd(a,p)$ 。如果 $d_1\nmid b$ ，则原方程无解。否则我们把方程同时除以 $d_1$ ，得到

$$
\frac{a}{d_1}\cdot a^{x-1}\equiv \frac{b}{d_1}\pmod{\frac{p}{d_1}}
$$

如果 $a$ 和 $\frac{p}{d_1}$ 仍不互质就再除，设 $d_2=\gcd\left(a,\frac{p}{d_1}\right)$ 。如果 $d_2\nmid \frac{b}{d_1}$ ，则方程无解；否则同时除以 $d_2$ 得到

$$
\frac{a^2}{d_1d_2}\cdot a^{x-2}≡\frac{b}{d_1d_2} \pmod{\frac{p}{d_1d_2}}
$$

同理，这样不停的判断下去。直到 $a\perp \frac{p}{d_1d_2\cdots d_k}$ 。

记 $D=\prod_{i=1}^kd_i$ ，于是方程就变成了这样：

$$
\frac{a^k}{D}\cdot a^{x-k}\equiv\frac{b}{D} \pmod{\frac{p}{D}}
$$

由于 $a\perp\frac{p}{D}$ ，于是推出 $\frac{a^k}{D}\perp \frac{p}{D}$ 。这样 $\frac{a^k}{D}$ 就有逆元了，于是把它丢到方程右边，这就是一个普通的 BSGS 问题了，于是求解 $x-k$ 后再加上 $k$ 就是原方程的解啦。

注意，不排除解小于等于 $k$ 的情况，所以在消因子之前做一下 $\Theta(k)$ 枚举，直接验证 $a^i\equiv b \pmod p$ ，这样就能避免这种情况。

## 习题

-    [SPOJ MOD](https://www.spoj.com/problems/MOD/) 模板
-    [SDOI2013 随机数生成器](https://www.luogu.org/problem/P3306) 
-    [BZOJ1319 Discrete Roots](http://www.lydsy.com/JudgeOnline/problem.php?id=1319) 模板
-    [SDOI2011 计算器](https://loj.ac/problem/10214) 模板
-    [Luogu4195【模板】exBSGS/Spoj3105 Mod](https://www.luogu.org/problemnew/show/P4195) 模板
-    [Codeforces - Lunar New Year and a Recursive Sequence](https://codeforces.com/contest/1106/problem/F) 

     **本页面部分内容以及代码译自博文 [Дискретное извлечение корня](http://e-maxx.ru/algo/discrete_root) 与其英文翻译版 [Discrete Root](https://cp-algorithms.com/algebra/discrete-root.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# bignum
## 前言

> 太长不看版：结尾自取模板……

高精度计算（Arbitrary-Precision Arithmetic），也被称作大整数（bignum）计算，运用了一些算法结构来支持更大整数间的运算（数字大小超过语言内建整型）。

高精度问题包含很多小的细节，实现上也有很多讲究。

所以今天就来一起实现一个简单的计算器吧。

???+ note "任务"
    输入：一个形如 `a <op> b` 的表达式。

    -    `a` 、 `b` 分别是长度不超过 $1000$ 的十进制非负整数；
    -    `<op>` 是一个字符（ `+` 、 `-` 、 `*` 或 `/` ），表示运算。
    -   整数与运算符之间由一个空格分隔。

    输出：运算结果。

    -   对于 `+` 、 `-` 、 `*` 运算，输出一行表示结果；
    -   对于 `/` 运算，输出两行分别表示商和余数。
    -   保证结果均为非负整数。

## 存储

在平常的实现中，高精度数字利用字符串表示，每一个字符表示数字的一个十进制位。因此可以说，高精度数值计算实际上是一种特别的字符串处理。

读入字符串时，数字最高位在字符串首（下标小的位置）。但是习惯上，下标最小的位置存放的是数字的 **最低位** ，即存储反转的字符串。这么做的原因在于，数字的长度可能发生变化，但我们希望同样权值位始终保持对齐（例如，希望所有的个位都在下标 `[0]` ，所有的十位都在下标 `[1]` ……）；同时，加、减、乘的运算一般都从个位开始进行（回想小学的竖式运算～），这都给了「反转存储」以充分的理由。

此后我们将一直沿用这一约定。定义一个常数 `LEN = 1004` 表示程序所容纳的最大长度。

由此不难写出读入高精度数字的代码：

```cpp
void clear(int a[]) {
  for (int i = 0; i < LEN; ++i) a[i] = 0;
}

void read(int a[]) {
  static char s[LEN + 1];
  scanf("%s", s);

  clear(a);

  int len = strlen(s);
  // 如上所述，反转
  for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';
  // s[i] - '0' 就是 s[i] 所表示的数码
  // 有些同学可能更习惯用 ord(s[i]) - ord('0') 的方式理解
}
```

输出也按照存储的逆序输出。由于不希望输出前导零，故这里从最高位开始向下寻找第一个非零位，从此处开始输出；终止条件 `i >= 1` 而不是 `i >= 0` 是因为当整个数字等于 $0$ 时仍希望输出一个字符 `0` 。

```cpp
void print(int a[]) {
  int i;
  for (i = LEN - 1; i >= 1; --i)
    if (a[i] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) break;
  for (; i >= 0; --i) putchar(a[i] + '0');
  putchar('\n');
}
```

拼起来就是一个完整的复读机程序咯。

??? " `copycat.cpp` "
    ```cpp
    #include <cstdio>
    #include <cstring>
    
    static const int LEN = 1004;
    
    int a[LEN], b[LEN];
    
    void clear(int a[]) {
      for (int i = 0; i < LEN; ++i) a[i] = 0;
    }
    
    void read(int a[]) {
      static char s[LEN + 1];
      scanf("%s", s);
    
      clear(a);
    
      int len = strlen(s);
      for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';
    }
    
    void print(int a[]) {
      int i;
      for (i = LEN - 1; i >= 1; --i)
        if (a[i] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) break;
      for (; i >= 0; --i) putchar(a[i] + '0');
      putchar('\n');
    }
    
    int main() {
      read(a);
      print(a);
    
      return 0;
    }
    ```

## 四则运算

四则运算中难度也各不相同。最简单的是高精度加减法，其次是高精度—单精度（普通的 `int` ）乘法和高精度—高精度乘法，最后是高精度—高精度除法。

我们将按这个顺序分别实现所有要求的功能。

### 加法

高精度加法，其实就是竖式加法啦。

/home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/![](./images/plus.png)

也就是从最低位开始，将两个加数对应位置上的数码相加，并判断是否达到或超过 $10$ 。如果达到，那么处理进位：将更高一位的结果上增加 $1$ ，当前位的结果减少 $10$ 。

```cpp
void add(int a[], int b[], int c[]) {
  clear(c);

  // 高精度实现中，一般令数组的最大长度 LEN 比可能的输入大一些
  // 然后略去末尾的几次循环，这样一来可以省去不少边界情况的处理
  // 因为实际输入不会超过 1000 位，故在此循环到 LEN - 1 = 1003 已经足够
  for (int i = 0; i < LEN - 1; ++i) {
    // 将相应位上的数码相加
    c[i] += a[i] + b[i];
    if (c[i] >= 10) {
      // 进位
      c[i + 1] += 1;
      c[i] -= 10;
    }
  }
}
```

试着和上一部分结合，可以得到一个加法计算器。

??? " `adder.cpp` "
    ```cpp
    #include <cstdio>
    #include <cstring>
    
    static const int LEN = 1004;
    
    int a[LEN], b[LEN], c[LEN];
    
    void clear(int a[]) {
      for (int i = 0; i < LEN; ++i) a[i] = 0;
    }
    
    void read(int a[]) {
      static char s[LEN + 1];
      scanf("%s", s);
    
      clear(a);
    
      int len = strlen(s);
      for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';
    }
    
    void print(int a[]) {
      int i;
      for (i = LEN - 1; i >= 1; --i)
        if (a[i] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) break;
      for (; i >= 0; --i) putchar(a[i] + '0');
      putchar('\n');
    }
    
    void add(int a[], int b[], int c[]) {
      clear(c);
    
      for (int i = 0; i < LEN - 1; ++i) {
        c[i] += a[i] + b[i];
        if (c[i] >= 10) {
          c[i + 1] += 1;
          c[i] -= 10;
        }
      }
    }
    
    int main() {
      read(a);
      read(b);
    
      add(a, b, c);
      print(c);
    
      return 0;
    }
    ```

### 减法

高精度加法，也就是竖式减法啦。

/home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/![](./images/subtraction.png)

从个位起逐位相减，遇到负的情况则向上一位借 $1$ 。整体思路与加法完全一致。

```cpp
void sub(int a[], int b[], int c[]) {
  clear(c);

  for (int i = 0; i < LEN - 1; ++i) {
    // 逐位相减
    c[i] += a[i] - b[i];
    if (c[i] < 0) {
      // 借位
      c[i + 1] -= 1;
      c[i] += 10;
    }
  }
}
```

将上一个程序中的 `add()` 替换成 `sub()` ，就有了一个减法计算器。

??? " `subtractor.cpp` "
    ```cpp
    #include <cstdio>
    #include <cstring>
    
    static const int LEN = 1004;
    
    int a[LEN], b[LEN], c[LEN];
    
    void clear(int a[]) {
      for (int i = 0; i < LEN; ++i) a[i] = 0;
    }
    
    void read(int a[]) {
      static char s[LEN + 1];
      scanf("%s", s);
    
      clear(a);
    
      int len = strlen(s);
      for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';
    }
    
    void print(int a[]) {
      int i;
      for (i = LEN - 1; i >= 1; --i)
        if (a[i] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) break;
      for (; i >= 0; --i) putchar(a[i] + '0');
      putchar('\n');
    }
    
    void sub(int a[], int b[], int c[]) {
      clear(c);
    
      for (int i = 0; i < LEN - 1; ++i) {
        c[i] += a[i] - b[i];
        if (c[i] < 0) {
          c[i + 1] -= 1;
          c[i] += 10;
        }
      }
    }
    
    int main() {
      read(a);
      read(b);
    
      sub(a, b, c);
      print(c);
    
      return 0;
    }
    ```

试一试，输入 `1 2` ——输出 `/9999999` ，诶这个 OI Wiki 怎么给了我一份假的代码啊……

事实上，上面的代码只能处理减数 $a$ 大于等于被减数 $b$ 的情况。处理被减数比减数小，即 $a<b$ 时的情况很简单。

 $a-b=-(b-a)$ 

要计算 $b-a$ 的值，因为有 $b>a$ ，可以调用以上代码中的 `sub` 函数，写法为 `sub(b,a,c)` 。要得到 $a-b$ 的值，在得数前加上负号即可。

### 乘法

#### 高精度—单精度

高精度乘法，也就是竖……等会儿等会儿！

先考虑一个简单的情况：乘数中的一个是普通的 `int` 类型。有没有简单的处理方法呢？

一个直观的思路是直接将 $a$ 每一位上的数字乘以 $b$ 。从数值上来说，这个方法是正确的，但它并不符合十进制表示法，因此需要将它重新整理成正常的样子。

重整的方式，也是从个位开始逐位向上处理进位。但是这里的进位可能非常大，甚至远大于 $9$ ，因为每一位被乘上之后都可能达到 $9b$ 的数量级。所以这里的进位不能再简单地进行 $-10$ 运算，而是要通过除以 $10$ 的商以及余数计算。详见代码注释，也可以参考下图展示的一个计算高精度数 $1337$ 乘以单精度数 $42$ 的过程。

/home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/![](./images/multiplication-short.png)

当然，也是出于这个原因，这个方法需要特别关注乘数 $b$ 的范围。若它和 $10^9$ （或相应整型的取值上界）属于同一数量级，那么需要慎用高精度—单精度乘法。

```cpp
void mul_short(int a[], int b, int c[]) {
  clear(c);

  for (int i = 0; i < LEN - 1; ++i) {
    // 直接把 a 的第 i 位数码乘以乘数，加入结果
    c[i] += a[i] * b;

    if (c[i] >= 10) {
      // 处理进位
      // c[i] / 10 即除法的商数成为进位的增量值
      c[i + 1] += c[i] / 10;
      // 而 c[i] % 10 即除法的余数成为在当前位留下的值
      c[i] %= 10;
    }
  }
}
```

#### 高精度—高精度

如果两个乘数都是高精度，那么竖式乘法又可以大显身手了。

回想竖式乘法的每一步，实际上是计算了若干 $a \times b_i \times 10^i$ 的和。例如计算 $1337 \times 42$ ，计算的就是 $1337 \times 2 \times 10^0 + 1337 \times 4 \times 10^1$ 。

于是可以将 $b$ 分解为它的所有数码，其中每个数码都是单精度数，将它们分别与 $a$ 相乘，再向左移动到各自的位置上相加即得答案。当然，最后也需要用与上例相同的方式处理进位。

/home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/![](./images/multiplication-long.png)

注意这个过程与竖式乘法不尽相同，我们的算法在每一步乘的过程中并不进位，而是将所有的结果保留在对应的位置上，到最后再统一处理进位，但这不会影响结果。

```cpp
void mul(int a[], int b[], int c[]) {
  clear(c);

  for (int i = 0; i < LEN - 1; ++i) {
    // 这里直接计算结果中的从低到高第 i 位，且一并处理了进位
    // 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和
    // 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式
    for (int j = 0; j <= i; ++j) c[i] += a[j] * b[i - j];

    if (c[i] >= 10) {
      c[i + 1] += c[i] / 10;
      c[i] %= 10;
    }
  }
}
```

### 除法

高精度除法，也就是竖～～～～竖式长除法啦！

/home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/![](./images/division.png)

竖式长除法实际上可以看作一个逐次减法的过程。例如上图中商数十位的计算可以这样理解：将 $45$ 减去三次 $12$ 后变得小于 $12$ ，不能再减，故此位为 $3$ 。

为了减少冗余运算，我们提前得到被除数的长度 $l_a$ 与除数的长度 $l_b$ ，从下标 $l_a - l_b$ 开始，从高位到低位来计算商。这和手工计算时将第一次乘法的最高位与被除数最高位对齐的做法是一样的。

参考程序实现了一个函数 `greater_eq()` 用于判断被除数以下标 `last_dg` 为最低位，是否可以再减去除数而保持非负。此后对于商的每一位，不断调用 `greater_eq()` ，并在成立的时候用高精度减法从余数中减去除数，也即模拟了竖式除法的过程。

```cpp
// 被除数 a 以下标 last_dg 为最低位，是否可以再减去除数 b 而保持非负
// len 是除数 b 的长度，避免反复计算
inline bool greater_eq(int a[], int b[], int last_dg, int len) {
  // 有可能被除数剩余的部分比除数长，这个情况下最多多出 1 位，故如此判断即可
  if (a[last_dg + len] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) return true;
  // 从高位到低位，逐位比较
  for (int i = len - 1; i >= 0; --i) {
    if (a[last_dg + i] > b[i]) return true;
    if (a[last_dg + i] < b[i]) return false;
  }
  // 相等的情形下也是可行的
  return true;
}

void div(int a[], int b[], int c[], int d[]) {
  clear(c);
  clear(d);

  int la, lb;
  for (la = LEN - 1; la > 0; --la)
    if (a[la - 1] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) break;
  for (lb = LEN - 1; lb > 0; --lb)
    if (b[lb - 1] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) break;
  if (lb == 0) {
    puts("> <");
    return;
  }  // 除数不能为零

  // c 是商
  // d 是被除数的剩余部分，算法结束后自然成为余数
  for (int i = 0; i < la; ++i) d[i] = a[i];
  for (int i = la - lb; i >= 0; --i) {
    // 计算商的第 i 位
    while (greater_eq(d, b, i, lb)) {
      // 若可以减，则减
      // 这一段是一个高精度减法
      for (int j = 0; j < lb; ++j) {
        d[i + j] -= b[j];
        if (d[i + j] < 0) {
          d[i + j + 1] -= 1;
          d[i + j] += 10;
        }
      }
      // 使商的这一位增加 1
      c[i] += 1;
      // 返回循环开头，重新检查
    }
  }
}
```

## 入门篇完成！

将上面介绍的四则运算的实现结合，即可完成开头提到的计算器程序。

??? " `calculator.cpp` "
    ```cpp
    #include <cstdio>
    #include <cstring>
    
    static const int LEN = 1004;
    
    int a[LEN], b[LEN], c[LEN], d[LEN];
    
    void clear(int a[]) {
      for (int i = 0; i < LEN; ++i) a[i] = 0;
    }
    
    void read(int a[]) {
      static char s[LEN + 1];
      scanf("%s", s);
    
      clear(a);
    
      int len = strlen(s);
      for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';
    }
    
    void print(int a[]) {
      int i;
      for (i = LEN - 1; i >= 1; --i)
        if (a[i] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) break;
      for (; i >= 0; --i) putchar(a[i] + '0');
      putchar('\n');
    }
    
    void add(int a[], int b[], int c[]) {
      clear(c);
    
      for (int i = 0; i < LEN - 1; ++i) {
        c[i] += a[i] + b[i];
        if (c[i] >= 10) {
          c[i + 1] += 1;
          c[i] -= 10;
        }
      }
    }
    
    void sub(int a[], int b[], int c[]) {
      clear(c);
    
      for (int i = 0; i < LEN - 1; ++i) {
        c[i] += a[i] - b[i];
        if (c[i] < 0) {
          c[i + 1] -= 1;
          c[i] += 10;
        }
      }
    }
    
    void mul(int a[], int b[], int c[]) {
      clear(c);
    
      for (int i = 0; i < LEN - 1; ++i) {
        for (int j = 0; j <= i; ++j) c[i] += a[j] * b[i - j];
    
        if (c[i] >= 10) {
          c[i + 1] += c[i] / 10;
          c[i] %= 10;
        }
      }
    }
    
    inline bool greater_eq(int a[], int b[], int last_dg, int len) {
      if (a[last_dg + len] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) return true;
      for (int i = len - 1; i >= 0; --i) {
        if (a[last_dg + i] > b[i]) return true;
        if (a[last_dg + i] < b[i]) return false;
      }
      return true;
    }
    
    void div(int a[], int b[], int c[], int d[]) {
      clear(c);
      clear(d);
    
      int la, lb;
      for (la = LEN - 1; la > 0; --la)
        if (a[la - 1] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) break;
      for (lb = LEN - 1; lb > 0; --lb)
        if (b[lb - 1] /home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math//home/llj/Desktop/OI-wiki-master/docs/math/!= 0) break;
      if (lb == 0) {
        puts("> <");
        return;
      }
    
      for (int i = 0; i < la; ++i) d[i] = a[i];
      for (int i = la - lb; i >= 0; --i) {
        while (greater_eq(d, b, i, lb)) {
          for (int j = 0; j < lb; ++j) {
            d[i + j] -= b[j];
            if (d[i + j] < 0) {
              d[i + j + 1] -= 1;
              d[i + j] += 10;
            }
          }
          c[i] += 1;
        }
      }
    }
    
    int main() {
      read(a);
    
      char op[4];
      scanf("%s", op);
    
      read(b);
    
      switch (op[0]) {
        case '+':
          add(a, b, c);
          print(c);
          break;
        case '-':
          sub(a, b, c);
          print(c);
          break;
        case '*':
          mul(a, b, c);
          print(c);
          break;
        case '/':
          div(a, b, c, d);
          print(c);
          print(d);
          break;
        default:
          puts("> <");
      }
    
      return 0;
    }
    ```

## Karatsuba 乘法

记高精度数字的位数为 $n$ ，那么高精度—高精度竖式乘法需要花费 $O(n^2)$ 的时间。本节介绍一个时间复杂度更为优秀的算法，由前苏联（俄罗斯）数学家 Anatoly Karatsuba 提出，是一种分治算法。

考虑两个十进制大整数 $x$ 和 $y$ ，均包含 $n$ 个数码（可以有前导零）。任取 $0 < m < n$ ，记

$$
\begin{aligned}
x &= x_1 \cdot 10^m + x_0, \\
y &= y_1 \cdot 10^m + y_0, \\
x \cdot y &= z_2 \cdot 10^{2m} + z_1 \cdot 10^m + z_0,
\end{aligned}
$$

其中 $x_0, y_0, z_0, z_1 < 10^m$ 。可得

$$
\begin{aligned}
z_2 &= x_1 \cdot y_1, \\
z_1 &= x_1 \cdot y_0 + x_0 \cdot y_1, \\
z_0 &= x_0 \cdot y_0.
\end{aligned}
$$

观察知

$$
z_1 = (x_1 + x_0) \cdot (y_1 + y_0) - z_2 - z_0,
$$

于是要计算 $z_1$ ，只需计算 $(x_1 + x_0) \cdot (y_1 + y_0)$ ，再与 $z_0$ 、 $z_2$ 相减即可。

上式实际上是 Karatsuba 算法的核心，它将长度为 $n$ 的乘法问题转化为了 $3$ 个长度更小的子问题。若令 $m = \left\lceil \frac n 2 \right\rceil$ ，记 Karatsuba 算法计算两个 $n$ 位整数乘法的耗时为 $T(n)$ ，则有 $T(n) = 3 \cdot T \left(\left\lceil \frac n 2 \right\rceil\right) + O(n)$ ，由主定理可得 $T(n) = \Theta(n^{\log_2 3}) \approx \Theta(n^{1.585})$ 。

整个过程可以递归实现。为清晰起见，下面的代码通过 Karatsuba 算法实现了多项式乘法，最后再处理所有的进位问题。

??? "karatsuba_mulc.cpp"
    ```cpp
    int *karatsuba_polymul(int n, int *a, int *b) {
      if (n <= 32) {
        // 规模较小时直接计算，避免继续递归带来的效率损失
        int *r = new int[n * 2 + 1]();
        for (int i = 0; i <= n; ++i)
          for (int j = 0; j <= n; ++j) r[i + j] += a[i] * b[j];
        return r;
      }
    
      int m = n / 2 + 1;
      int *r = new int[m * 4 + 1]();
      int *z0, *z1, *z2;
    
      z0 = karatsuba_polymul(m - 1, a, b);
      z2 = karatsuba_polymul(n - m, a + m, b + m);
    
      // 计算 z1
      // 临时更改，计算完毕后恢复
      for (int i = 0; i + m <= n; ++i) a[i] += a[i + m];
      for (int i = 0; i + m <= n; ++i) b[i] += b[i + m];
      z1 = karatsuba_polymul(m - 1, a, b);
      for (int i = 0; i + m <= n; ++i) a[i] -= a[i + m];
      for (int i = 0; i + m <= n; ++i) b[i] -= b[i + m];
      for (int i = 0; i <= (m - 1) * 2; ++i) z1[i] -= z0[i];
      for (int i = 0; i <= (n - m) * 2; ++i) z1[i] -= z2[i];
    
      // 由 z0、z1、z2 组合获得结果
      for (int i = 0; i <= (m - 1) * 2; ++i) r[i] += z0[i];
      for (int i = 0; i <= (m - 1) * 2; ++i) r[i + m] += z1[i];
      for (int i = 0; i <= (n - m) * 2; ++i) r[i + m * 2] += z2[i];
    
      delete[] z0;
      delete[] z1;
      delete[] z2;
      return r;
    }
    
    void karatsuba_mul(int a[], int b[], int c[]) {
      int *r = karatsuba_polymul(LEN - 1, a, b);
      memcpy(c, r, sizeof(int) * LEN);
      for (int i = 0; i < LEN - 1; ++i)
        if (c[i] >= 10) {
          c[i + 1] += c[i] / 10;
          c[i] %= 10;
        }
      delete[] r;
    }
    ```

??? " 关于 `new` 和 `delete` "
    见 [内存池](../intro/common-tricks.md#_5) 。

但是这样的实现存在一个问题：在 $b$ 进制下，多项式的每一个系数都有可能达到 $n \cdot b^2$ 量级，在压位高精度实现（即 $b > 10$ ，下文介绍）中可能造成整数溢出；而若在多项式乘法的过程中处理进位问题，则 $x_1 + x_0$ 与 $y_1 + y_0$ 的结果可能达到 $2 \cdot b^m$ ，增加一个位（如果采用 $x_1 - x_0$ 的计算方式，则不得不特殊处理负数的情况）。因此，需要依照实际的应用场景来决定采用何种实现方式。

### Reference

 <https://en.wikipedia.org/wiki/Karatsuba_algorithm> 

## 封装类

 [这里](https://paste.ubuntu.com/p/7VKYzpC7dn/) 有一个封装好的高精度整数类。

??? 这里是另一个模板
    ```cpp
    #define MAXN 9999
    // MAXN 是一位中最大的数字
    #define MAXSIZE 10024
    // MAXSIZE 是位数
    #define DLEN 4
    // DLEN 记录压几位
    struct Big {
      int a[MAXSIZE], len;
      bool flag;  //标记符号'-'
      Big() {
        len = 1;
        memset(a, 0, sizeof a);
        flag = 0;
      }
      Big(const int);
      Big(const char*);
      Big(const Big&);
      Big& operator=(const Big&);  //注意这里operator有&，因为赋值有修改……
      //由于OI中要求效率
      //此处不使用泛型函数
      //故不重载
      // istream& operator>>(istream&,  BigNum&);   //重载输入运算符
      // ostream& operator<<(ostream&,  BigNum&);   //重载输出运算符
      Big operator+(const Big&) const;
      Big operator-(const Big&) const;
      Big operator*(const Big&)const;
      Big operator/(const int&) const;
      // TODO: Big / Big;
      Big operator^(const int&) const;
      // TODO: Big ^ Big;
    
      // TODO: Big 位运算;
    
      int operator%(const int&) const;
      // TODO: Big ^ Big;
      bool operator<(const Big&) const;
      bool operator<(const int& t) const;
      inline void print() const;
    };
    // README::不要随随便便把参数都变成引用，那样没办法传值
    Big::Big(const int b) {
      int c, d = b;
      len = 0;
      // memset(a,0,sizeof a);
      CLR(a);
      while (d > MAXN) {
        c = d - (d / (MAXN + 1) * (MAXN + 1));
        d = d / (MAXN + 1);
        a[len++] = c;
      }
      a[len++] = d;
    }
    Big::Big(const char* s) {
      int t, k, index, l;
      CLR(a);
      l = strlen(s);
      len = l / DLEN;
      if (l % DLEN) ++len;
      index = 0;
      for (int i = l - 1; i >= 0; i -= DLEN) {
        t = 0;
        k = i - DLEN + 1;
        if (k < 0) k = 0;
        g(j, k, i) t = t * 10 + s[j] - '0';
        a[index++] = t;
      }
    }
    Big::Big(const Big& T) : len(T.len) {
      CLR(a);
      f(i, 0, len) a[i] = T.a[i];
      // TODO:重载此处？
    }
    Big& Big::operator=(const Big& T) {
      CLR(a);
      len = T.len;
      f(i, 0, len) a[i] = T.a[i];
      return *this;
    }
    Big Big::operator+(const Big& T) const {
      Big t(*this);
      int big = len;
      if (T.len > len) big = T.len;
      f(i, 0, big) {
        t.a[i] += T.a[i];
        if (t.a[i] > MAXN) {
          ++t.a[i + 1];
          t.a[i] -= MAXN + 1;
        }
      }
      if (t.a[big])
        t.len = big + 1;
      else
        t.len = big;
      return t;
    }
    Big Big::operator-(const Big& T) const {
      int big;
      bool ctf;
      Big t1, t2;
      if (*this < T) {
        t1 = T;
        t2 = *this;
        ctf = 1;
      } else {
        t1 = *this;
        t2 = T;
        ctf = 0;
      }
      big = t1.len;
      int j = 0;
      f(i, 0, big) {
        if (t1.a[i] < t2.a[i]) {
          j = i + 1;
          while (t1.a[j] == 0) ++j;
          --t1.a[j--];
          // WTF?
          while (j > i) t1.a[j--] += MAXN;
          t1.a[i] += MAXN + 1 - t2.a[i];
        } else
          t1.a[i] -= t2.a[i];
      }
      t1.len = big;
      while (t1.len > 1 && t1.a[t1.len - 1] == 0) {
        --t1.len;
        --big;
      }
      if (ctf) t1.a[big - 1] = -t1.a[big - 1];
      return t1;
    }
    Big Big::operator*(const Big& T) const {
      Big res;
      int up;
      int te, tee;
      f(i, 0, len) {
        up = 0;
        f(j, 0, T.len) {
          te = a[i] * T.a[j] + res.a[i + j] + up;
          if (te > MAXN) {
            tee = te - te / (MAXN + 1) * (MAXN + 1);
            up = te / (MAXN + 1);
            res.a[i + j] = tee;
          } else {
            up = 0;
            res.a[i + j] = te;
          }
        }
        if (up) res.a[i + T.len] = up;
      }
      res.len = len + T.len;
      while (res.len > 1 && res.a[res.len - 1] == 0) --res.len;
      return res;
    }
    Big Big::operator/(const int& b) const {
      Big res;
      int down = 0;
      gd(i, len - 1, 0) {
        res.a[i] = (a[i] + down * (MAXN + 1) / b);
        down = a[i] + down * (MAXN + 1) - res.a[i] * b;
      }
      res.len = len;
      while (res.len > 1 && res.a[res.len - 1] == 0) --res.len;
      return res;
    }
    int Big::operator%(const int& b) const {
      int d = 0;
      gd(i, len - 1, 0) d = (d * (MAXN + 1) % b + a[i]) % b;
      return d;
    }
    Big Big::operator^(const int& n) const {
      Big t(n), res(1);
      // TODO::快速幂这样写好丑= =//DONE:)
      int y = n;
      while (y) {
        if (y & 1) res = res * t;
        t = t * t;
        y >>= 1;
      }
      return res;
    }
    bool Big::operator<(const Big& T) const {
      int ln;
      if (len < T.len) return 233;
      if (len == T.len) {
        ln = len - 1;
        while (ln >= 0 && a[ln] == T.a[ln]) --ln;
        if (ln >= 0 && a[ln] < T.a[ln]) return 233;
        return 0;
      }
      return 0;
    }
    inline bool Big::operator<(const int& t) const {
      Big tee(t);
      return *this < tee;
    }
    inline void Big::print() const {
      printf("%d", a[len - 1]);
      gd(i, len - 2, 0) { printf("%04d", a[i]); }
    }
    
    inline void print(Big s) {
      // s不要是引用，要不然你怎么print(a * b);
      int len = s.len;
      printf("%d", s.a[len - 1]);
      gd(i, len - 2, 0) { printf("%04d", s.a[i]); }
    }
    char s[100024];
    ```

## 习题

-    [NOIP 2012 国王游戏](https://loj.ac/problem/2603) 
-    [SPOJ - Fast Multiplication](http://www.spoj.com/problems/MUL/en/) 
-    [SPOJ - GCD2](http://www.spoj.com/problems/GCD2/) 
-    [UVA - Division](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1024) 
-    [UVA - Fibonacci Freeze](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=436) 
-    [Codeforces - Notepad](http://codeforces.com/contest/17/problem/D) 

# integral
## 定积分的定义

简单来说，函数 $f(x)$ 在区间 $[l,r]$ 上的定积分 $\int_{l}^{r}f(x)\mathrm{d}x$ 指的是 $f(x)$ 在区间 $[l,r]$ 中与 $x$ 轴围成的区域的面积（其中 $x$ 轴上方的部分为正值， $x$ 轴下方的部分为负值）。

很多情况下，我们需要高效，准确地求出一个积分的近似值。下面介绍的 **自适应辛普森法** ，就是这样一种求数值积分的方法。

## 自适应辛普森法

这个方法的思想是将被积区间分为若干小段，每段套用二次函数的积分公式进行计算。

??? note "二次函数积分公式（辛普森公式）"

    对于一个二次函数 $f(x)=Ax^2+Bx+C$，有：

    $$
    \int_l^r f(x) {\mathrm d}x = \frac{(r-l)(f(l)+f(r)+4 f(\frac{l+r}{2}))}{6}
    $$

    推导过程较为繁琐，这里略去。

现在唯一的问题就是如何进行分段。如果段数少了计算误差就大，段数多了时间效率又会低。我们需要找到一个准确度和效率的平衡点。

我们这样考虑：假如有一段图像已经很接近二次函数的话，直接带入公式求积分，得到的值精度就很高了，不需要再继续分割这一段了。

于是我们有了这样一种分割方法：每次判断当前段和二次函数的相似程度，如果足够相似的话就直接代入公式计算，否则将当前段分割成左右两段递归求解。

现在就剩下一个问题了：如果判断每一段和二次函数是否相似？

我们把当前段直接代入公式求积分，再将当前段从中点分割成两段，把这两段再直接代入公式求积分。如果当前段的积分和分割成两段后的积分之和相差很小的话，就可以认为当前段和二次函数很相似了，不用再递归分割了。

上面就是自适应辛普森法的思想。

参考代码如下：

```cpp
double simpson(double l, double r) {
  double mid = (l + r) / 2;
  return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;  //辛普森公式
}
double asr(double l, double r, double eqs, double ans) {
  double mid = (l + r) / 2;
  double fl = simpson(l, mid), fr = simpson(mid, r);
  if (abs(fl + fr - ans) <= 15 * eqs)
    return fl + fr - (fl + fr - ans) / 15;  //足够相似的话就直接返回
  return asr(l, mid, eqs / 2, fl) +
         asr(mid, r, eqs / 2, fr);  //否则分割成两段递归求解
}
```

# lucas
## Lucas 定理

Lucas 定理用于求解大组合数取模的问题，其中 p 必须为素数。正常的组合数运算可以通过递推公式求解（详见 [排列组合](./combination.md) ），但当问题规模很大，而模数是一个不大的质数的时候，就不能简单地通过递推求解来得到答案，需要用到 Lucas 定理。

### 求解方式

Lucas 定理内容如下：对于质数 $p$ ，有

$$
\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p
$$

观察上述表达式，可知 $n\bmod p$ 和 $m\bmod p$ 一定是小于 $p$ 的数，可以直接求解， $\displaystyle\binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}$ 可以继续用 Lucas 定理求解。这也就要求 $p$ 的范围不能够太大，一般在 $10^5$ 左右。边界条件：当 $m=0$ 的时候，返回 $1$ 。

时间复杂度为 $O(f(p) + g(n)\log n)$ ，其中 $f(n)$ 为预处理组合数的复杂度， $g(n)$ 为单次求组合数的复杂度。

### 代码实现

```cpp
long long Lucas(long long n, long long m, long long p) {
  if (m == 0) return 1;
  return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;
}
```

### Lucas 定理的证明

考虑 $\displaystyle\binom{p}{n} \bmod p$ 的取值，注意到 $\displaystyle\binom{p}{n} = \frac{p!}{n!(p-n)!}$ ，分子的质因子分解中 $p$ 次项恰为 $1$ ，因此只有当 $n = 0$ 或 $n = p$ 的时候 $n!(p-n)!$ 的质因子分解中含有 $p$ ，因此 $\displaystyle\binom{p}{n} \bmod p = [n = 0 \vee n = p]$ 。进而我们可以得出

$$
\begin{align}
(a+b)^p &= \sum_{n=0}^p \binom pn a^n b^{p-n}\\
&\equiv \sum_{n=0}^p [n=0\vee n=p] a^n b^{p-n}\\
&\equiv a^p + b^p \pmod p
\end{align}
$$

注意过程中没有用到费马小定理，因此这一推导不仅适用于整数，亦适用于多项式。因此我们可以考虑二项式 $f(x)=(ax^n + bx^m)^p \bmod p$ 的结果

$$
\begin{align}
(ax^n + bx^m)^p &\equiv a^p x^{pn} + b^p x^{pm} \\
&\equiv ax^{pn} + bx^{pm}\\
&\equiv f(x^p)
\end{align}
$$

考虑二项式 $(1+x)^n \bmod p$ ，那么 $\displaystyle\binom n m$ 就是求其在 $x^m$ 次项的取值。使用上述引理，我们可以得到

$$
\begin{align}
(1+x)^n &\equiv (1+x)^{p\lfloor n/p \rfloor} (1+x)^{n\bmod p}\\
&\equiv (1+x^p)^{\lfloor n/p \rfloor} (1+x)^{n\bmod p}
\end{align}
$$

注意前者只有在 $p$ 的倍数位置才有取值，而后者最高次项为 $n\bmod p \le p-1$ ，因此这两部分的卷积在任何一个位置只有最多一种方式贡献取值，即在前者部分取 $p$ 的倍数次项，后者部分取剩余项，即 $\displaystyle\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p$ 。

## exLucas 定理

Lucas 定理中对于模数 $p$ 要求必须为素数，那么对于 $p$ 不是素数的情况，就需要用到 exLucas 定理。

### 求解方式

首先对于 p 进行质因数分解： $p=p_{1}^{k_1}p_{2}^{k_2}\cdots p_{n}^{k_n}$ ，则如果可以求出每个 $C_{n}^{m}\equiv a_i \pmod {p_{i}^{q_i}}$ ，那么对于同余方程组

$$
\begin{cases}
C_{n}^{m}\equiv a_1 \pmod {p_{1}^{q_1}}\\
C_{n}^{m}\equiv a_2 \pmod {p_{2}^{q_2}}\\
\,\,\,\,\vdots\\
C_{n}^{m}\equiv a_n  \pmod {p_{n}^{q_n}}\\
\end{cases}
$$

使用中国剩余定理即可求出 $C_{n}^{m}$ 的值。

但是可以发现 $p_{i}^{q_i}$ 也不一定是素数，接下来介绍如何计算 $C_{n}^{m}\bmod p^t$ 。

首先由求组合数的公式 $C_{n}^{m}=\frac{n!}{m!(n-m)!}$ ，如果可以分别计算出 $n!, m!, (n-m)!$ 在模 $p^t$ 意义下的值，那么就可以得到答案。

以第一个式子为例，当 $p=3,t=2,n=19$ 时，有：

$$
\begin{split}
n!&=1\cdot 2\cdot 3\cdots 19\\
&=(1\cdot 2\cdot 4\cdot 5\cdot 7\cdot 8\cdot 10\cdot 11\cdot 13\cdot 14\cdot  16\cdot 17\cdot 19)\cdot (3\cdot 6\cdot 9\cdot 12\cdot 15\cdot 18)\\
&=(1\cdot 2\cdot 4\cdot 5\cdot 7\cdot 8\cdot 10\cdot 11\cdot 13\cdot 14\cdot  16\cdot 17\cdot 19)\cdot 3^6\cdot(1\cdot2\cdot3\cdot4\cdot5\cdot6)
\end{split}
$$

可以看到后面一部分在模意义下相当于 $(n/p)!$ ，于是可以递归进行计算。

前面一部分是以 $p^t$ 为周期的，也就是 $(1\cdot 2\cdot 4\cdot 5\cdot 7\cdot 8)\equiv (10\cdot 11\cdot 13\cdot 14\cdot 16\cdot 17)\ \pmod{3^2}$ ，所以只需要计算最后不满足一个周期的数是哪些就可以了（这个例子中就只要计算 $19$ ）。显然，不满足一个周期的数的个数不超过 $p^t$ 个。

### 代码实现

其中 `int inverse(int x)` 函数返回 $x$ 在模 $p$ 意义下的逆元。

```cpp
LL CRT(int n, LL* a, LL* m) {
  LL M = 1, p = 0;
  for (int i = 1; i <= n; i++) M = M * m[i];
  for (int i = 1; i <= n; i++) {
    LL w = M / m[i], x, y;
    exgcd(w, m[i], x, y);
    p = (p + a[i] * w * x % mod) % mod;
  }
  return (p % mod + mod) % mod;
}
LL calc(LL n, LL x, LL P) {
  if (!n) return 1;
  LL s = 1;
  for (int i = 1; i <= P; i++)
    if (i % x) s = s * i % P;
  s = Pow(s, n / P, P);
  for (int i = n / P * P + 1; i <= n; i++)
    if (i % x) s = s * i % P;
  return s * calc(n / x, x, P) % P;
}
LL multilucas(LL m, LL n, LL x, LL P) {
  int cnt = 0;
  for (int i = m; i; i /= x) cnt += i / x;
  for (int i = n; i; i /= x) cnt -= i / x;
  for (int i = m - n; i; i /= x) cnt -= i / x;
  return Pow(x, cnt, P) % P * calc(m, x, P) % P * inverse(calc(n, x, P), P) %
         P * inverse(calc(m - n, x, P), P) % P;
}
LL exlucas(LL m, LL n, LL P) {
  int cnt = 0;
  LL p[20], a[20];
  for (LL i = 2; i * i <= P; i++) {
    if (P % i == 0) {
      p[++cnt] = 1;
      while (P % i == 0) p[cnt] = p[cnt] * i, P /= i;
      a[cnt] = multilucas(m, n, i, p[cnt]);
    }
  }
  if (P > 1) p[++cnt] = P, a[cnt] = multilucas(m, n, P, P);
  return CRT(cnt, a, p);
}
```

## 习题

-    [Luogu3807【模板】卢卡斯定理](https://www.luogu.org/problemnew/show/P3807) 
-    [SDOI2010 古代猪文  卢卡斯定理](https://loj.ac/problem/10229) 
-    [Luogu4720【模板】扩展卢卡斯](https://www.luogu.org/problemnew/show/P4720) 

# vector
## 向量

（为人教版高中数学必修四内容）

> 平面的向量交错生长/织成/忧伤的网
> ——《膜你抄》

### 定义及相关概念

 **向量** ：既有大小又有方向的量称为向量。数学上研究的向量为 **自由向量** ，即只要不改变它的大小和方向，起点和终点可以任意平行移动的向量。记作 $\vec a$ 或 $\boldsymbol{a}$ 。

 **有向线段** ：带有方向的线段称为有向线段。有向线段有三要素： **起点，方向，长度** ，知道了三要素，终点就唯一确定。我们用有向线段表示向量。

 **向量的模** ：有向线段 $\overrightarrow{AB}$ 的长度称为向量的模，即为这个向量的大小。记为： $|\overrightarrow{AB}|$ 或 $|\boldsymbol{a}|$ 。

 **零向量** ：模为 $0$ 的向量。零向量的方向任意。记为： $\vec 0$ 或 $\boldsymbol{0}$ 。

 **单位向量** ：模为 $1$ 的向量称为该方向上的单位向量。

 **平行向量** ：方向相同或相反的两个 **非零** 向量。记作： $\boldsymbol a\parallel \boldsymbol b$ 。对于多个互相平行的向量，可以任作一条直线与这些向量平行，那么任一组平行向量都可以平移到同一直线上，所以平行向量又叫 **共线向量** 。

 **相等向量** ：模相等且方向相同的向量。

 **相反向量** ：模相等且方向相反的向量。

 **向量的夹角** ：已知两个非零向量 $\boldsymbol a,\boldsymbol b$ ，作 $\overrightarrow{OA}=\boldsymbol a,\overrightarrow{OB}=\boldsymbol b$ ，那么 $\theta=\angle AOB$ 就是向量 $\boldsymbol a$ 与向量 $\boldsymbol b$ 的夹角。记作： $\langle \boldsymbol a,\boldsymbol b\rangle$ 。显然当 $\theta=0$ 时两向量同向， $\theta=\pi$ 时两向量反向， $\theta=\frac{\pi}{2}$ 时我们说两向量垂直，记作 $\boldsymbol a\perp \boldsymbol b$ 。并且，我们规定 $\theta \in [0,\pi]$ 。

注意到平面向量具有方向性，我们并不能比较两个向量的大小（但可以比较两向量的模长）。但是两个向量可以相等。

### 向量的线性运算

#### 向量的加减法

我们定义了一种量，就希望让它具有运算。向量的运算可以类比数的运算，但是我们从物理学的角度出发研究向量的运算。

类比物理学中的位移概念，假如一个人从 $A$ 经 $B$ 走到 $C$ ，我们说他经过的位移为 $\overrightarrow{AB}+\overrightarrow{BC}$ ，这其实等价于这个人直接从 $A$ 走到 $C$ ，即 $\overrightarrow{AB}+\overrightarrow{BC}=\overrightarrow{AC}$ 。

注意到力的合成法则——平行四边形法则，同样也可以看做一些向量相加。

所以我们整理一下向量的加法法则：

1.   **向量加法的三角形法则** ：若要求和的向量首尾顺次相连，那么这些向量的和为第一个向量的起点指向最后一个向量的终点；
2.   **向量加法的平行四边形法则** ：若要求和的两个向量 **共起点** ，那么它们的和向量为以这两个向量为邻边的平行四边形的对角线，起点为两个向量共有的起点，方向沿平行四边形对角线方向。

这样，向量的加法就具有了几何意义。并且可以验证，向量的加法满足 **交换律与结合律** 。

因为实数的减法可以写成加上相反数的形式，我们考虑在向量做减法时也这么写。即： $\boldsymbol a-\boldsymbol b=\boldsymbol a+(-\boldsymbol b)$ 。

这样，我们考虑共起点的向量，按照平行四边形法则做出它们的差，经过平移后可以发现 **「共起点向量的差向量」是由「减向量」指向「被减向量」的有向线段** 。

这也是向量减法的几何意义。

我们有时候有两点 $A,B$ ，想知道 $\overrightarrow{AB}$ ，可以利用减法运算 $\overrightarrow{AB}=\overrightarrow{OB}-\overrightarrow{OA}$ 获得。

#### 向量的数乘

规定「实数 $\lambda$ 与向量 $\boldsymbol a$ 的积」为一个向量，这种运算就是向量的 **数乘运算** ，记作 $\lambda \boldsymbol a$ ，它的长度与方向规定如下：

1.   $|\lambda \boldsymbol a|=|\lambda||\boldsymbol a|$ ；
2.  当 $\lambda >0$ 时， $\lambda\boldsymbol a$ 与 $\boldsymbol a$ 同向，当 $\lambda =0$ 时， $\lambda \boldsymbol a=\boldsymbol 0$ ，当 $\lambda<0$ 时， $\lambda \boldsymbol a$ 与 $\boldsymbol a$ 方向相反。

我们根据数乘的定义，可以验证有如下运算律：

$$
\lambda(\mu \boldsymbol a)=(\lambda \mu)\boldsymbol a\\
(\lambda+\mu)\boldsymbol a=\lambda \boldsymbol a+\mu \boldsymbol a\\
\lambda(\boldsymbol a+\boldsymbol b)=\lambda \boldsymbol a+\lambda \boldsymbol b
$$

特别地，我们有：

$$
(-\lambda)\boldsymbol a=-(\lambda \boldsymbol a)=-\lambda(\boldsymbol a)\\
\lambda(\boldsymbol a-\boldsymbol b)=\lambda \boldsymbol a-\lambda \boldsymbol b
$$

#### 判定两向量共线

两个 **非零** 向量 $\boldsymbol a$ 与 $\boldsymbol b$ 共线 $\Leftrightarrow$ 有唯一实数 $\lambda$ ，使得 $\boldsymbol b=\lambda \boldsymbol a$ 。

证明：由数乘的定义可知，对于 **非零** 向量 $\boldsymbol a$ ，如果存在实数 $\lambda$ ，使得 $\boldsymbol b=\lambda \boldsymbol a$ ，那么 $\boldsymbol a \parallel \boldsymbol b$ 。

反过来，如果 $\boldsymbol a\parallel \boldsymbol b$ ， $\boldsymbol a \not = \boldsymbol 0$ ，且 $|\boldsymbol b|=\mu |\boldsymbol a|$ ，那么当 $\boldsymbol a$ 与 $\boldsymbol b$ 同向时， $\boldsymbol b=\mu \boldsymbol a$ ，反向时 $\boldsymbol b=-\mu \boldsymbol a$ 。

最后，向量的加，减，数乘统称为向量的线性运算。

### 平面向量的基本定理及坐标表示

#### 平面向量基本定理

定理内容：如果两个向量 $\boldsymbol{e_1},\boldsymbol{e_2}$ 不共线，那么存在唯一实数对 $(x,y)$ ，使得与 $\boldsymbol{e_1},\boldsymbol{e_2}$ 共面的任意向量 $\boldsymbol p$ 满足 $\mathbf p=x\boldsymbol{e_1}+y\boldsymbol{e_2}$ 。

平面向量那么多，我们想用尽可能少的量表示出所有平面向量，怎么办呢？

只用一个向量表示出所有向量显然是不可能的，最多只能表示出某条直线上的向量。

我们再加入一个向量，用两个 **不共线** 向量表示（两个共线向量在此可以看成同一个向量），这样我们可以把任意一个平面向量分解到这两个向量的方向上了。

在同一平面内的两个不共线的向量称为 **基底** 。

如果基底相互垂直，那么我们在分解的时候就是对向量 **正交分解** 。

#### 平面向量的坐标表示

如果取与横轴与纵轴方向相同的单位向量 $i,j$ 作为一组基底，根据平面向量基本定理，平面上的所有向量与有序实数对 $(x,y)$ 一一对应。

而有序实数对 $(x,y)$ 与平面直角坐标系上的点一一对应，那么我们作 $\overrightarrow{OP}=\boldsymbol p$ ，那么终点 $P(x,y)$ 也是唯一确定的。由于我们研究的都是自由向量，可以自由平移起点，这样，在平面直角坐标系里，每一个向量都可以用有序实数对唯一表示。

### 平面向量的坐标运算

#### 平面向量线性运算

由平面向量的线性运算，我们可以推导其坐标运算，主要方法是将坐标全部化为用基底表示，然后利用运算律进行合并，之后表示出运算结果的坐标形式。

若两向量 $\boldsymbol a=(m,n)$ , $\boldsymbol b=(p,q)$ ，则：

$$
\boldsymbol a+\boldsymbol b=(m+p,n+q)\\
\boldsymbol a-\boldsymbol b=(m-p,n-q)\\
k\boldsymbol a=(km,kn)
$$

#### 求一个向量的坐标表示

已知两点 $A(a,b),B(c,d)$ ，易证 $\overrightarrow{AB}=(c-a,d-b)$ 。

#### 平移一点

有时候，我们需要将一个点 $P$ 沿一定方向平移某单位长度，这样我们把要平移的方向和距离组合成一个向量，利用向量加法的三角形法则，将 $\overrightarrow{OP}$ 加上这个向量，得到的向量终点即为平移后的点。

#### 三点共线的判定

若 $A,B,C$ 三点共线，则 $\overrightarrow{OB}=\lambda \overrightarrow{OA}+(1-\lambda)\overrightarrow{OC}$ 。

### 向量的数量积

已知两个向量 $\boldsymbol a,\boldsymbol b$ ，它们的夹角为 $\theta$ ，那么：

$$
\boldsymbol a \cdot \boldsymbol b=|\boldsymbol a||\boldsymbol b|\cos \theta
$$

就是这两个向量的 **数量积** ，也叫 **点积** 或 **内积** 。其中称 $|\boldsymbol a|\cos \theta$ 为 $\boldsymbol a$ 在 $\boldsymbol b$ 方向上的投影。数量积的几何意义即为：数量积 $\boldsymbol a \cdot \boldsymbol b$ 等于 $\boldsymbol a$ 的模与 $\boldsymbol b$ 在 $\boldsymbol a$ 方向上的投影的乘积。

我们发现，这种运算得到的结果是一个实数，为标量，并不属于向量的线性运算。

数量积运算有以下应用：

#### 判定两向量垂直

 $\boldsymbol a \perp \boldsymbol b$  $\Leftrightarrow$  $\boldsymbol a\cdot \boldsymbol b=0$ 

#### 判定两向量共线

 $\boldsymbol a = \lambda \boldsymbol b$  $\Leftrightarrow$  $\boldsymbol a\cdot \boldsymbol b=|\boldsymbol a||\boldsymbol b|$ 

#### 数量积的坐标运算

若 $\boldsymbol a=(m,n),\boldsymbol b=(p,q),$ 则 $\boldsymbol a\cdot \boldsymbol b=mp+nq$ 

#### 向量的模

 $|\boldsymbol a|=\sqrt {m^2+n^2}$ 

#### 两向量的夹角

 $\cos \theta=\cfrac{\boldsymbol a\cdot\boldsymbol b}{|\boldsymbol a||\boldsymbol b|}$ 

### 扩展

#### 向量与矩阵

（为人教版高中数学 A 版选修 4-2 内容）

我们发现，矩阵运算的相关法则与向量运算相似，于是考虑将向量写成矩阵形式，这样就将向量问题化为矩阵问题了。

详细内容请参考线性代数。

#### 向量积

我们定义向量 $\boldsymbol a,\boldsymbol b$ 的向量积为一个向量，记为 $\boldsymbol a\times \boldsymbol b$ ，其模与方向定义如下：

1.   $|\boldsymbol a\times \boldsymbol b|=|\boldsymbol a||\boldsymbol b|\sin \langle \boldsymbol a,\boldsymbol b\rangle$ ；
2.   $\boldsymbol a\times \boldsymbol b$ 与 $\boldsymbol a,\boldsymbol b$ 都垂直，且 $\boldsymbol a,\boldsymbol b,\boldsymbol a\times \boldsymbol b$ 符合右手法则。

向量积也叫外积。

由于向量积涉及到空间几何与线性代数知识，所以并未在高中课本中出现。然而注意到向量积的模，联想到三角形面积计算公式 $S=\frac{1}{2}ab\sin C$ ，我们可以发现向量积的几何意义是： ** $|\boldsymbol a\times \boldsymbol b|$ 是以 $\boldsymbol a,\boldsymbol b$ 为邻边的平行四边形的面积** 。

知道这个，多边形面积就很好算了。

我们有一个不完全的坐标表示：记 $\boldsymbol a=(m,n),\boldsymbol b=(p,q)$ ，那么两个向量的向量积的竖坐标为 $mq-np$ ，我们根据右手法则和竖坐标符号可以推断出 $\boldsymbol b$ 相对于 $\boldsymbol a$ 的方向，若在逆时针方向竖坐标为正值，反之为负值，简记为 **顺负逆正** 。

#### 向量旋转

设 $\boldsymbol a=(x,y)$ ，倾角为 $\theta$ ，长度为 $l=\sqrt{x^2+y^2}$ 。则 $x=l\cos \theta,y=l\sin\theta$ 。令其逆时针旋转 $\alpha$ 度角，得到向量 $\boldsymbol b=(l\cos(\theta+\alpha),l\sin(\theta+\alpha))$ 。

/home/llj/Desktop/OI-wiki-master/docs/math/![](./images/misc1.png)

由三角恒等变换得，

$$
\boldsymbol{b}=(l(\cos\theta\cos\alpha-\sin\theta\sin\alpha),l(\sin\theta\cos\alpha+\cos\theta\sin\alpha))
$$

化简，

$$
\boldsymbol b=(l\cos\theta\cos\alpha-l\sin\theta\sin\alpha,l\sin\theta\cos\alpha+l\cos\theta\sin\alpha)
$$

把上面的 $x,y$ 代回来得

$$
\boldsymbol b=(x\cos\alpha-y\sin\alpha,y\cos\alpha+x\sin\alpha)
$$

即使不知道三角恒等变换，这个式子也很容易记下来。

## 极坐标与极坐标系

### 任意角与弧度制

（为人教版高中数学必修四内容）

我们在初中学习过角度值，但是角度不是一个数，这给我们深入研究带来了一定的困难，还有其他的问题无法解释清，所以我们换用弧度制描述角。

首先我们用旋转的思路定义角，角可以看成平面内一条射线绕其端点从一个位置旋转到另一个位置形成的图形。开始的位置称为始边，结束的位置称为终边。

我们规定，按 **逆时针** 方向旋转形成的角叫做 **正角** ，按 **顺时针** 方向旋转所形成的角叫做 **负角** ，如果这条射线没有做任何旋转，称为 **零角** 。这样我们就把角的概念推向了 **任意角** 。

然后我们介绍 **弧度制** ，把长度等于半径长的弧所对的圆心角称为 $1$ 弧度的角，用符号 $\text{rad}$ 表示，读作：弧度。

一般地，正角的弧度数为正，负角的弧度数为负，零角的弧度数为 $0$ ，如果半径为 $r$ 的圆的圆心角 $\alpha$ 所对弧长为 $l$ ，则 $|\alpha|=\frac{l}{r}$ 。利用这个公式还可以写出弧长和扇形面积公式，在此略过。

那么，我们发现 $360^\circ$ 的角弧度数为 $2\pi$ ，这样有了对应关系之后，我们可以进行角度值和弧度制的转化了。

我们考虑一个角，将其终边再旋转一周，甚至多周，始边位置不动，那么终边位置永远是相同的，我们称这些角为 **终边位置相同的角** 。

与角 $\alpha$ 终边位置相同的角的集合很容易得出，为 $\{\theta\mid \theta=\alpha+2k\pi,k\in \mathbb{Z}\}$ 。

可以理解为：给这个角的边不停加转一圈，终边位置不变。

# simplex
## 作用

单纯形法是解决线性规划问题的一个有效的算法。线性规划就是在一组线性约束条件下，求解目标函数最优解的问题。

## 线性规划的一般形式

在约束条件下，寻找目标函数 $z$ 的最大值：

$$
\max \ z = x_1 + x_2
$$

$$
s.t \begin{cases}  
2x_1 + x_2 \leq 12 \\ 
x_1 + 2x_2 \leq 9  \\
x_1, x_2 \geq 0
\end{cases}
$$

## 线性规划的可行域

满足线性规划问题约束条件的所有点组成的集合就是线性规划的可行域。若可行域有界（以下主要考虑有界可行域），线性规划问题的目标函数最优解必然在可行域的顶点上达到最优。

单纯形法就是通过设置不同的基向量，经过矩阵的线性变换，求得基可行解（可行域顶点），并判断该解是否最优，否则继续设置另一组基向量，重复执行以上步骤，直到找到最优解。所以，单纯形法的求解过程是一个循环迭代的过程。

![kexingyu](./images/kexingyu.jpg)

<center>图1 可行域</center>

## 线性规划的标准形式

在说明单纯形法的原理之前，需要明白线性规划的标准形式。因为单纯形算法是通过线性规划的标准形来求解的。一般，规定线性规划的标准形式为：

$$
\max \ z = \sum_{j = 1}^{n}c_jx_j
$$

$$
s.t \begin{cases}  
\displaystyle \sum_{j = 1}^{n}a_{ij}x_j = b_j, i = 1,2,...,m\\ 
xj \geq 0 , j = 1,2,...,n  \\
\end{cases}
$$

写成矩阵形式：

$$
\max \ z = CX
$$

$$
AX = b
$$

$$
X \geq 0
$$

$$
A = 
\begin{bmatrix}
a_{11} & a_{12} & \ldots & a_{1n}\\
a_{21} & a_{22} & \ldots & a_{2n}\\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \ldots & a_{mn}
\end{bmatrix}
$$

标准形的形式为：

-   1）目标函数要求 $\max$ 

-   2）约束条件均为等式

-   3）决策变量为非负约束

普通线性规划化为标准形：

-   1）若目标函数为最小化，可以通过取负，求最大化
-   2）约束不等式为小于等于不等式，可以在左端加入非负变量，转变为等式，比如：

$$
x_1 + 2x_2 \leq 9 \Rightarrow 
\begin{cases}  
x_1 + 2x_2 + x_3 = 9\\ 
x_3 \geq 0
\end{cases}
$$

同理，约束不等式为大于等于不等式时，可以在左端减去一个非负松弛变量，变为等式。

-   3）若存在取值无约束的变量，可转变为两个非负变量的差，比如：

$$
-\infty \leq x_k \leq +\infty \Rightarrow
\begin{cases}  
x_k = x_m - x_n\\ 
x_m,x_n \geq 0
\end{cases}
$$

本文最开始的线性规划问题转化为标准形为：

$$
max \ z = x_1 + x_2
$$

$$
s.t \begin{cases}  
2x_1 + x_2 + x_3 = 12 \\ 
x_1 + 2x_2 + x_4 = 9  \\
x_1, x_2, x_3, x_4 \geq 0
\end{cases}
$$

## 单纯形法

### 几何意义

在标准形中，有 $m$ 个约束条件（不包括非负约束）， $n$ 个决策变量，且 $n \geq m$ 。首先选取 $m$ 个基变量 $x_j^{'}(j = 1, 2, \ldots, m )$ ，基变量对应约束系数矩阵的列向量线性无关。通过矩阵的线性变换，基变量可由非基变量表示：

$$
x_i^{'} = C_i + \sum_{j = m + 1}^{n}m_{ij}x_j^{'}(i = 1, 2, \ldots , m)
$$

如果令非基变量等于 $0$ ，可求得基变量的值：

$$
x_i^{'} = C_i
$$

如果为可行解的话， $C_i$ 大于 $0$ 。那么它的几何意义是什么呢？

还是通过上述具体的线性规划问题来说明：

$$
\max \ z = x_1 + x_2
$$

$$
s.t \begin{cases}  
2x_1 + x_2 + x_3 = 12 \\ 
x_1 + 2x_2 + x_4 = 9  \\
x_1, x_2, x_3, x_4 \geq 0
\end{cases}
$$

如果选择 $x_2​$ 、 $x_3​$ 为基变量，那么令 $x_1​$ 、 $x_4​$ 等于 $0​$ ，可以去求解基变量 $x_2​$ 、 $x_3​$ 的值。对系数矩阵做行变换，如下所示， $x_2=9/2​$ ， $x_3=15/2​$ 。

$$
\left[\begin{array}{ccccc}{\mathrm{X}} & {x_{1}} & {x_{2}} & {x_{3}} & {x_{4}} & {b} \\ {} & {2} & {1} & {1} & {0} & {12} \\ {} & {1} & {2} & {0} & {1} & {9} \\ {\mathrm{C}} & {1} & {1} & {0} & {0} & {z}\end{array}\right] \rightarrow\left[\begin{array}{ccccc}{\mathrm{X}} & {x_{1}} & {x_{2}} & {x_{3}} & {x_{4}} & {b} \\ {} & {\frac{3}{2}} & {0} & {1} & {-\frac{1}{2}} & {\frac{15}{2}} \\ {} & {\frac{1}{2}} & {1} & {0} & {\frac{1}{2}} & {\frac{9}{2}} \\ {\mathrm{C}} & {\frac{1}{2}} & {0} & {0} & {-\frac{1}{2}} & {z-\frac{9}{2}}\end{array}\right]
$$

 $X_1=0$ 表示可行解在 $x$ 轴上； $X_4=0$ 表示可行解在 $x_1+2x_2=9$ 的直线上。那么，求得的可行解即表示这两条直线的交点，也是可行域的顶点，如图所示：

![kexingyu_point](./images/kexingyu_point.jpg)

<center>图2</center>

所以，通过选择不同的基变量，可以获得不同的可行域的顶点。

### 如何判断最优

如前所述，基变量可由非基变量表示：

$$
x_i^{'} = C_i + \sum_{j = m + 1}^{n}m_{ij}x_j^{'}(i = 1, 2, \ldots , m) 
$$

目标函数 $z$ 也可以完全由非基变量表示：

$$
z = z_0 + \sum_{j = m + 1}^{n} \sigma_j x_j^{'}
$$

当达到最优解时，所有的 $\sigma_j$ 应小于等于 $0$ ，当存在 $j$ ， $\sigma_j > 0$ 时，当前解不是最优解，为什么？

当前的目标函数值为 $z_0$ ，其中所有的非基变量值均取 $0$ 。由之前分析可知， $x_j^{'} = 0$ 代表可行域的某个边界，是 $x_j^{'}$ 的最小值。如果可行解逐步离开这个边界， $x_j^{'}$ 会变大，因为 $\sigma_j > 0$ ，显然目标函数的取值也会变大，所以当前解不是最优解。我们需要寻找新的基变量。

### 如何选择新的基变量

如果存在多个 $\sigma_j > 0$ ，选择最大的 $\sigma_j > 0$ 对应的变量作为基变量，这表示目标函数随着 $x_j^{'}$ 的增加，增长的最快。

### 如何选择被替换的基变量

假如我们选择非基变量 $x_s^{'}$ 作为下一轮的基变量，那么被替换基变量 $x_j^{'}$ 在下一轮中作为非基变量，等于 $0$ 。选择 $x_j^{'}$ 的原则：替换后应该尽量使 $x_s^{'}$ 值最大（因为上面已分析过，目标函数会随着 $x_s^{'}$ 的增大而增大），但要保证替换基变量后的解仍是可行解，因此应该选择最紧的限制。

继续通过上面的例子来说明：

$$
\left[\begin{array}{ccccc}{\mathrm{X}} & {x_{1}} & {x_{2}} & {x_{3}} & {x_{4}} & {b} \\ {} & {2} & {1} & {1} & {0} & {12} \\ {} & {1} & {2} & {0} & {1} & {9} \\ {\mathrm{C}} & {1} & {1} & {0} & {0} & {z}\end{array}\right] \rightarrow\left[\begin{array}{ccccc}{\mathrm{X}} & {x_{1}} & {x_{2}} & {x_{3}} & {x_{4}} & {b} \\ {} & {\frac{3}{2}} & {0} & {1} & {-\frac{1}{2}} & {\frac{15}{2}} \\ {} & {\frac{1}{2}} & {1} & {0} & {\frac{1}{2}} & {\frac{9}{2}} \\ {\mathrm{C}} & {\frac{1}{2}} & {0} & {0} & {-\frac{1}{2}} & {z-\frac{9}{2}}\end{array}\right]
$$

从最后一行可以看到， $x_1$ 的系数为 $1/2>0$ ，所以选 $x_2$ 、 $x_3$ 为基变量并没有是目标函数达到最优。下一轮选取 $x_1$ 作为基变量，替换 $x_2$ 、 $x_3$ 中的某个变量。

第一行是符号

第二行：若 $x_1$ 替换 $x_3$ 作为基变量， $x_3=0$ 时， $x_1=\dfrac{\dfrac{15}{2}}{\dfrac{3}{2}}=5$ 

第三行：若 $x_1$ 替换 $x_2$ 作为基变量， $x_2=0$ 时， $x_1=\dfrac{\dfrac{9}{2}}{\dfrac{1}{2}}=9$ 

尽管替换 $x_2$ 后， $x_1$ 的值更大，但将它代入 $x_3$ 后会发现 $x_3$ 的值为负，不满足约束。从几何的角度来看，选择 $x_2$ 和 $x_4$ 作为非基变量，得到的解是直线 $x_2=0$ 和 $x_1 + 2x_2 = 9$ 的交点，它在可行域外。因此应该选择 $x_3$ 作为非基变量。

### 终止条件

当目标函数用非基变量的线性组合表示时，所有的系数均不大于 $0$ ，则表示目标函数达到最优。

如果，有一个非基变量的系数为 $0$ ，其他的均小于 $0$ ，表示目标函数的最优解有无穷多个。这是因为目标函数的梯度与某一边界正交，在这个边界上，目标函数的取值均相等，且为最优。

使用单纯形法来求解线性规划，输入单纯形法的松弛形式，是一个大矩阵，第一行为目标函数的系数，且最后一个数字为当前轴值下的 $z$ 值。下面每一行代表一个约束，数字代表系数每行最后一个数字代表 $b$ 值。

算法和使用单纯性表求解线性规划相同。

对于线性规划问题：

$$
\max \ x_1 + 14x_2 + 6x_3
$$

$$
s.t \begin{cases}  
x_1 + x_2 + x_3 \leq 4 \\ 
x_1 \leq 2  \\
x_3 \leq 3  \\
3x_2 + x_3 \leq 6 \\
x_1, x_2, x_3 \geq 0
\end{cases}
$$

我们可以得到其松弛形式：

$$
\max \ x_1 + 14x_2 + 6x_3
$$

$$
s.t \begin{cases}  
x_1 + x_2 + x_3 + x_4 = 4 \\ 
x_1 + x_5 = 2  \\
x_3 + x_6 = 3  \\
3x_2 + x_3 + x_7 = 6 \\
x_1, x_2, x_3, x_4, x_5, x_6, x_7 \geq 0
\end{cases}
$$

我们可以构造单纯形表，其中最后一行打星的列为轴值。

|  $x_1$    |  $x_2$     |  $x_3$    |  $x_4$    |  $x_5$    |  $x_6$    |  $x_7$    |  $b$     |
| --------- | ---------- | --------- | --------- | --------- | --------- | --------- | -------- |
|  $c_1=1$  |  $c_2=14$  |  $c_3=6$  |  $c_4=0$  |  $c_5=0$  |  $c_6=0$  |  $c_7=0$  |  $-z=0$  |
|  $1$      |  $1$       |  $1$      |  $1$      |  $0$      |  $0$      |  $0$      |  $4$     |
|  $1$      |  $0$       |  $0$      |  $0$      |  $1$      |  $0$      |  $0$      |  $2$     |
|  $0$      |  $0$       |  $1$      |  $0$      |  $0$      |  $1$      |  $0$      |  $3$     |
|  $0$      |  $3$       |  $1$      |  $0$      |  $0$      |  $0$      |  $1$      |  $6$     |
|           |            |           |  $*$      |  $*$      |  $*$      |  $*$      |          |

在单纯形表中，我们发现非轴值的 $x$ 上的系数大于零，因此可以通过增加这些个 $x$ 的值，来使目标函数增加。我们可以贪心的选择最大的 $c$ ，在上面的例子中我们选择 $c_2$ 作为新的轴，加入轴集合中，那么谁该出轴呢？

其实我们由于每个 $x$ 都大于零，对于 $x_2$ 它的增加是有所限制的，如果 $x_2$ 过大，由于其他的限制条件，就会使得其他的 $x$ 小于零，于是我们应该让 $x_2$ 一直增大，直到有一个其他的 $x$ 刚好等于 $0$ 为止，那么这个 $x$ 就被换出轴。

我们可以发现，对于约束方程 $1$ ，即第一行约束， $x_2$ 最大可以为 $4$ （ $4/1$ ），对于约束方程 $4$ ， $x_2$ 最大可以为 $2$ （ $6/3$ ），因此 $x_2$ 最大只能为他们之间最小的那个，这样才能保证每个 $x$ 都大于零。因此使用第 $4$ 行，来对各行进行高斯行变换，使得第二列第四行中的每个 $x$ 都变成零，也包括 $c_2$ 。这样我们就完成了把 $x_2$ 入轴， $x_7$ 出轴的过程。变换后的单纯形表为：

|  $x_1$    |  $x_2$    |  $x_3$       |  $x_4$    |  $x_5$    |  $x_6$    |  $x_7$        |  $b$       |
| --------- | --------- | ------------ | --------- | --------- | --------- | ------------- | ---------- |
|  $c_1=1$  |  $c_2=0$  |  $c_3=1.33$  |  $c_4=0$  |  $c_5=0$  |  $c_6=0$  |  $c_7=-4.67$  |  $-z=-28$  |
|  $1$      |  $0$      |  $0.67$      |  $1$      |  $0$      |  $0$      |  $-0.33$      |  $2$       |
|  $1$      |  $0$      |  $0$         |  $0$      |  $1$      |  $0$      |  $0$          |  $2$       |
|  $0$      |  $0$      |  $1$         |  $0$      |  $0$      |  $1$      |  $0$          |  $3$       |
|  $0$      |  $1$      |  $0.33$      |  $0$      |  $0$      |  $0$      |  $0.33$       |  $2$       |
|           |  $*$      |              |  $*$      |  $*$      |  $*$      |               |            |

继续计算，我们得到：

|  $x_1$     |  $x_2$    |  $x_3$    |  $x_4$    |  $x_5$     |  $x_6$    |  $x_7$    |  $b$       |
| ---------- | --------- | --------- | --------- | ---------- | --------- | --------- | ---------- |
|  $c_1=-1$  |  $c_2=0$  |  $c_3=0$  |  $c_4=0$  |  $c_5=-2$  |  $c_6=0$  |  $c_7=0$  |  $-z=-32$  |
|  $1.5$     |  $0$      |  $1$      |  $1.5$    |  $0$       |  $0$      |  $-0.5$   |  $3$       |
|  $1$       |  $0$      |  $0$      |  $0$      |  $1$       |  $0$      |  $0$      |  $2$       |
|  $0$       |  $0$      |  $1$      |  $0$      |  $0$       |  $1$      |  $0$      |  $3$       |
|  $0$       |  $1$      |  $0.33$   |  $0$      |  $0$       |  $0$      |  $0.33$   |  $2$       |
|            |  $*$      |           |  $*$      |  $*$       |  $*$      |           |            |

此时我们发现，所有非轴的 $x$ 的系数全部小于零，即增大任何非轴的 $x$ 值并不能使得目标函数最大，从而得到最优解 $32$ 。

整个过程代码如下所示：

```c++
#include <bits/stdc++.h>
using namespace std;
vector<vector<double> > Matrix;
double Z;
set<int> P;
size_t cn, bn;

bool Pivot(pair<size_t, size_t> &p) {  //返回0表示所有的非轴元素都小于0
  int x = 0, y = 0;
  double cmax = -INT_MAX;
  vector<double> C = Matrix[0];
  vector<double> B;

  for (size_t i = 0; i < bn; i++) {
    B.push_back(Matrix[i][cn - 1]);
  }

  for (size_t i = 0; i < C.size(); i++) {  //在非轴元素中找最大的c
    if (cmax < C[i] && P.find(i) == P.end()) {
      cmax = C[i];
      y = i;
    }
  }
  if (cmax < 0) {
    return 0;
  }

  double bmin = INT_MAX;
  for (size_t i = 1; i < bn; i++) {
    double tmp = B[i] / Matrix[i][y];
    if (Matrix[i][y] != 0 && bmin > tmp) {
      bmin = tmp;
      x = i;
    }
  }

  p = make_pair(x, y);

  for (set<int>::iterator it = P.begin(); it != P.end(); it++) {
    if (Matrix[x][*it] != 0) {
      // cout<<"erase "<<*it<<endl;
      P.erase(*it);
      break;
    }
  }
  P.insert(y);
  // cout<<"add "<<y<<endl;
  return true;
}

void pnt() {
  for (size_t i = 0; i < Matrix.size(); i++) {
    for (size_t j = 0; j < Matrix[0].size(); j++) {
      cout << Matrix[i][j] << "\t";
    }
    cout << endl;
  }
  cout << "result z:" << -Matrix[0][cn - 1] << endl;
}

void Gaussian(pair<size_t, size_t> p) {  //行变换
  size_t x = p.first;
  size_t y = p.second;
  double norm = Matrix[x][y];
  for (size_t i = 0; i < cn; i++) {  //主行归一化
    Matrix[x][i] /= norm;
  }
  for (size_t i = 0; i < bn && i != x; i++) {
    if (Matrix[i][y] != 0) {
      double tmpnorm = Matrix[i][y];
      for (size_t j = 0; j < cn; j++) {
        Matrix[i][j] = Matrix[i][j] - tmpnorm * Matrix[x][j];
      }
    }
  }
}

void solve() {
  pair<size_t, size_t> t;
  while (1) {
    pnt();
    if (Pivot(t) == 0) {
      return;
    }
    cout << t.first << " " << t.second << endl;
    for (set<int>::iterator it = P.begin(); it != P.end(); it++) {
      cout << *it << " ";
    }
    cout << endl;
    Gaussian(t);
  }
}

int main(int argc, char *argv[]) {
  // ifstream fin;
  // fin.open("./test");
  cin >> cn >> bn;
  for (size_t i = 0; i < bn; i++) {
    vector<double> vectmp;
    for (size_t j = 0; j < cn; j++) {
      double tmp = 0;
      cin >> tmp;
      vectmp.push_back(tmp);
    }
    Matrix.push_back(vectmp);
  }

  for (size_t i = 0; i < bn - 1; i++) {
    P.insert(cn - i - 2);
  }
  solve();
}
/////////////////////////////////////
// glpk input:
///* Variables */
// var x1 >= 0;
// var x2 >= 0;
// var x3 >= 0;
///* Object function */
// maximize z: x1 + 14*x2 + 6*x3;
///* Constrains */
// s.t. con1: x1 + x2 + x3 <= 4;
// s.t. con2: x1  <= 2;
// s.t. con3: x3  <= 3;
// s.t. con4: 3*x2 + x3  <= 6;
// end;
/////////////////////////////////////
// myinput:
/*
8 5
1 14 6 0 0 0 0 0
1 1 1 1 0 0 0 4
1 0 0 0 1 0 0 2
0 0 1 0 0 1 0 3
0 3 1 0 0 0 1 6
*/
/////////////////////////////////////
```

结果如下：

![answer](./images/answer.png)

## 理论罗列

### 标准型

 $m+n$ 个约束 $n$ 个变量用 $x$ 向量表示， $A$ 是一个 $m\times n$ 的矩阵， $c$ 是一个 $n$ 的向量， $b$ 是一个 $m$ 的向量，最大化 $cx$ 满足约束 $Ax \leq b,x > 0$ 。

最大化 $\sum_{j=1}^nc_jx_j$ 满足如下约束条件：

$$
\sum_{j = 1}^na_{ij}x_j \leq b_i,i = 1,2,\ldots,m
$$

$$
x_j \geq 0,j = 1,2,\ldots,n
$$

 $n$ 个变量， $m+n$ 个约束，构造 $m * n$ 的矩阵 $A$ ， $m$ 维向量 $b$ ， $n$ 维向量 $c$ 

最大化 $C^Tx$ 满足如下约束条件：

$$
Ax \leq b
$$

$$
x \geq 0
$$

### 转换为标准型

若目标函数要求取最小值，那么可以对其取相反数变成取最大值。对于限制条件 $f(x_1, x_2, \ldots ,x_n) = b$ ，可以用两个不等式 $f(x_1, x_2, \ldots, x_n) \leq b,-f(x_1,x_2,\ldots,x_n) \leq -b$ 描述，对于限制条件 $f(x_1,x_2,\ldots,x_n) \geq b$ ，可以用不等式 $-f(x_1,x_2,\ldots,x_n) \leq -b$ 描述。对于无限制的变量 $x$ ，可以将其拆为两个非负变量 $x_0,x_1$ ，使得 $x = x_0 - x_1$ 。

### 松弛型

基本变量 $B$ ， $|B|=m$ ，一个约束对应一个，表示松弛量，叫做松弛变量（基本变量）

非基变量 $N$ ， $|N|=n$ ， $x_n + i = b_i - \sum a_{ij}x_j \geq 0$ 

松弛变量 $x_{n+i}$ 

$$
\sum_{j = 1}^na_{ij}x_j \leq b_i \rightarrow x_{n + i} = b_i - \sum_{j = 1}^{n}a_{ij}x_j, x_{n+i} \geq 0
$$

等式左侧为基本变量，右侧为非基本变量。

### 变量

-   替入变量 $x_e$ （非基变量）
-   替出变量 $x_l$ （基本变量）

### 可行解

-   基本解：所有非基变量设为 $0​$ ，基本变量为右侧的常数

-   基本可行解：所有 $b_i \geq 0​$ 

> 注：单纯形法的过程中 B 和 N 不断交换，在 n 维空间中不断走，“相当于不等式上的高斯消元”。

### 转轴

选取一个非基本变量 $x_e​$ 为替入变量，基本变量 $x_l​$ 为替出变量，将其互换，为了防止循环，根据 **Bland 规则** ，选择下标最小的变量。

>  **Bland 规则** 可以参看： [最优化方法](https://github.com/AngelKitty/review_the_national_post-graduate_entrance_examination/blob/master/books_and_notes/professional_courses/data_structures_and_algorithms/sources/extra_books/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95.pdf) 

### 初始化

在所有 $b_i < 0$ 的约束中随机选一个作为 $x_l$ ，再随机选一个 $a_{le} < 0$ 作为 $x_e$ ，然后 $pivot(l,e)$ 后 $b_i$ 就变正了。

## 算法实现

每个约束定义了 $n$ 维空间中的一个半空间（超平面），交集形成的可行域是一个凸区域称为单纯形。目标函数是一个超平面，最优解在凸区域定点处取得。通过不断的转轴操作，在 $n$ 维凸区域的顶点上不断移动（转轴），使得基本解的目标值不断变大，最终达到最优解。

> 以下问题可以转换为单纯形：
>
> -   最短路
> -   最大流
> -   最小费用最大流
> -   多商品流

基本思想就是改写 $l$ 这个约束为 $x_e$ 作为基本变量，然后把这个新 $x_e$ 的值带到其他约束和目标函数中，就消去 $x_e$ 了。改写和带入时要修改 $b$ 和 $a$ ，目标函数则是 $c$ 和 $v$ 。

转动时， $l$ 和 $e$ 并没有像算法导论上一样， $a$ 矩阵用了两行分别是 $a_{l, \square}$ 和 $a_{e, \square}$ （这样占用内存大），而是用了同一行，这样 $a$ 矩阵的行数 $=|B|$ ，列数 $=|N|$ 。

也就是说，约束条件只用 $m$ 个，尽管 $B$ 和 $N$ 不断交换，但同一时间还是只有 $m$ 个约束（基本变量）， $n$ 个非基变量，注意改写成松弛型后 $a$ 矩阵实际系数为负。（一个优化为 $a_{i,e}$ 的约束没必要带入了。

 `simplex` 是主过程，基本思想是找到一个 $c_e>0$ 的，然后找对这个 $e$ 限制最紧的 $l$ ，转动这组 $l,e$ ，注意精度控制 $\epsilon$ ， $c_e>\epsilon$ ，还有找 $l$ 的时候 $a_{i,e}>\epsilon​$ 才行。

??? note " 例题[「NOI2008」志愿者招募](https://www.luogu.org/problem/P3980)"
    题目大意：长度为 $n​$ 的序列，第 $i​$ 位至少 $b_i​$ ， $m​$ 种区间使 $[l_i,r_i] + 1​$ 代价为 $a_i​$ 。

原始问题 $m​$ 个变量， $n​$ 个约束，当 $l_j \leq i \leq r_j​$ ， $a_{ij} = 1​$ 。

对偶问题 $n​$ 个变量， $m​$ 个约束

$$
\max \ \sum_{i=1}nb_iy_i
$$

$$
s.t \ \sum_{l_i \leq j \leq r_i}y_j \leq c_i, y_i \geq 0
$$

把对应出的系数矩阵代入到单纯形算法就可以求出最优解了。

```c++
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;
const int M = 10005, N = 1005, INF = 1e9;
const double eps = 1e-6;
inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  while (c < '0' || c > '9') {
    if (c == '-') f = -1;
    c = getchar();
  }
  while (c >= '0' && c <= '9') {
    x = x * 10 + c - '0';
    c = getchar();
  }
  return x * f;
}

int n, m;
double a[M][N], b[M], c[N], v;
void pivot(int l, int e) {
  b[l] /= a[l][e];
  for (int j = 1; j <= n; j++)
    if (j != e) a[l][j] /= a[l][e];
  a[l][e] = 1 / a[l][e];

  for (int i = 1; i <= m; i++)
    if (i != l && fabs(a[i][e]) > 0) {
      b[i] -= a[i][e] * b[l];
      for (int j = 1; j <= n; j++)
        if (j != e) a[i][j] -= a[i][e] * a[l][j];
      a[i][e] = -a[i][e] * a[l][e];
    }

  v += c[e] * b[l];
  for (int j = 1; j <= n; j++)
    if (j != e) c[j] -= c[e] * a[l][j];
  c[e] = -c[e] * a[l][e];

  // swap(B[l],N[e])
}

double simplex() {
  while (true) {
    int e = 0, l = 0;
    for (e = 1; e <= n; e++)
      if (c[e] > eps) break;
    if (e == n + 1) return v;
    double mn = INF;
    for (int i = 1; i <= m; i++)
      if (a[i][e] > eps && mn > b[i] / a[i][e]) mn = b[i] / a[i][e], l = i;
    if (mn == INF) return INF;  // unbounded
    pivot(l, e);
  }
}

int main() {
  n = read();
  m = read();
  for (int i = 1; i <= n; i++) c[i] = read();
  for (int i = 1; i <= m; i++) {
    int s = read(), t = read();
    for (int j = s; j <= t; j++) a[i][j] = 1;
    b[i] = read();
  }
  printf("%d", (int)(simplex() + 0.5));
}
```

## 对偶原理

最大化与最小化互换，常数与目标函数互换，改变不等号，变量与约束对应。

$$
\max \ c^T: Ax \leq b, x \geq 0
$$

$$
\min \ b^Ty: A^Ty \geq c, t \geq 0
$$

 $d_{uv}$ 表示 $u,v$ 是否匹配

$$
\max \ \sum_{(u,v) \in E}c_{uv}d_{uv}
$$

$$
s.t \begin{cases}  
\sum_{(v) \in Y} d_{uv} \leq 1, u \in X \\ 
\sum_{(u) \in X} d_{uv} \leq 1, v \in Y  \\
d_{u,v} \in \{0,1\}
\end{cases}
$$

令 $p_u,p_v$ 为两类约束对偶之后的变量

$$
\min \ \sum_{u \in x} p_u + \sum_{v \in Y} p_v
$$

$$
s.t \begin{cases}  
p_u + p_v \geq c_{uv} \\ 
u \in X, v \in Y\\
p_u, p_v \geq 0
\end{cases}
$$

## 全幺模矩阵（Totally Unimodular Matrix)

 **充分条件：** 

-   仅有 $-1,0,1$ 构成

-   每列至多两个非零数

-   行可分为两个集合：
    -   一列包含两个同号非零数，两行不在同一个集合
    -   一列包含两个异号非零数，两行在同一个集合

线性规划中 $A$ 为全幺模矩阵，则单纯形法过程中所有系数 $\in -1,0,1$ ，可以去除系数为 $0$ 的项进行优化！

> 注： **任何最大流、最小费用最大流的线性规划都是全幺模矩阵** 

更多详细的解释参看： <https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html> 

## 习题练习

-    [UOJ#179. 线性规划](http://uoj.ac/problem/179) 

## 参考资料

-    [线性规划之单纯形法【超详解 + 图解】](https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html) 
-    [2016 国家集训队论文](https://github.com/OI-wiki/libs/blob/master/%E9%9B%86%E8%AE%AD%E9%98%9F%E5%8E%86%E5%B9%B4%E8%AE%BA%E6%96%87/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2016%E8%AE%BA%E6%96%87%E9%9B%86.pdf) 
-   算法导论

# linear-recurrence
### 问题

给定一个线性递推数列 $\{f_i\}$ 的前 $k$ 项 $f_0\dots f_{k-1}$ ，和其递推式 $f_n=\sum_{i=1}^k f_{n-i}a_i$ 的各项系数 $a_i$ ，求 $f_n$ 。

### 前置知识

 [多项式取模](./poly/div-mod.md) 。

### 做法

定义 $F(\sum c_ix^i)=\sum c_if_i$ ，那么答案就是 $F(x^n)$ 。

由于 $f_n=\sum_{i=1}^{k}f_{n-i}a_i$ ，所以 $F(x^n)=F(\sum_{i=1}^{k}a_ix^{n-i})$ ，所以 $F(x^n-\sum_{i=1}^k a_ix^{n-i})=F(x^{n-k}(x^k-\sum_{i=0}^{k-1}a_{k-i}x^i))=0$ 。

设 $G(x)=x^k-\sum_{i=0}^{k-1}a_{k-i}x^i$ 。

那么 $F(A(x)+x^nG(x))=F(A(x))+F(x^nG(x))=F(A(x))$ 。

那么就可以通过多次对 $A(x)$ 加上 $x^nG(x)$ 的倍数来降低 $A(x)$ 的次数。

也就是求 $F(A(x)\bmod G(x))$ 。 $A(x)\bmod G(x)$ 的次数不超过 $k-1$ ，而 $f_{0..k-1}$ 已经给出了，就可以算了。

问题转化成了快速地求 $x^n\bmod G(x)$ ，只要将 [普通快速幂](./quick-pow.md) 中的乘法与取模换成 [多项式乘法](./poly/ntt.md) 与 [多项式取模](./poly/div-mod.md) 就可以在 $O(k\log k\log n)$ 的时间复杂度内解决这个问题了。

# bezouts
## 什么是裴蜀定理？

裴蜀定理，又称贝祖定理（Bézout's lemma）。是代数几何中一个定理。

其内容是：

设 $a,b$ 是不全为零的整数，则存在整数 $x,y$ , 使得 $ax+by=\gcd(a,b)$ .

## 证明

1.  若任何一个等于 $0$ , 则 $\gcd(a,b)=a$ . 这时定理显然成立。

2.  若 $a,b$ 不等于 $0$ .

    由于 $\gcd(a,b)=\gcd(a,-b)$ ,

    不妨设 $a,b$ 都大于 $0$ , $a\geq b,\gcd(a,b)=d$ .

    对 $ax+by=d$ , 两边同时除以 $d$ , 可得 $a_1x+b_1y=1$ , 其中 $(a_1,b_1)=1$ .

    转证 $a_1x+b_1y=1$ . 由带余除法：

    $$
    \begin{aligned}a_1 &= q_1b+r_1 &(0\leq r_1<b_1) \\ b_1 &= q_2r_1+r_2 &(0\leq r_2<r_1) \\ r_1 &= q_3r_2+r_3 &(0\leq r_3<r_2) \\ &\cdots \\ r_{n-3} &= q_{n-1}r_{n-2}+r_{n-1} \\ r_{n-2} &= q_nr_{n-1}+r_n \\ r_{n-1} &= q_{n+1}r_n\end{aligned}
    $$

    于是，有

    $$
    \gcd(a_1,b_1)=\gcd(b_1,r_1)=\gcd(r_1,r_2)=\cdots=(r_{n-1},r_n)=1
    $$

    故

    $$
    r_{n-2}=x_nr_{n-1}+1
    $$

    即

    $$
    1=r_{n-2}-x_nr_{n-1}
    $$

    由倒数第三个式子 $r_{n-1}=r_{n-3}-x_{n-1}r_{n-2}$ 代入上式，得

    $$
    1=(1+x_nx_{n-1})r_{n-2}-x_nr_{n-3}
    $$

    然后用同样的办法用它上面的等式逐个地消去 $r_{n-2},\cdots,r_1$ ,

    可证得 $1=a_1x+b_1y$ .

## 应用

???+ note "Codeforces Round #290 (Div. 2) D. Fox And Jumping"
    给出 $n$ 张卡片，分别有 $l_i$ 和 $c_i$ 。在一条无限长的纸带上，你可以选择花 $c_i$ 的钱来购买卡片 $i$ ，从此以后可以向左或向右跳 $l_i$ 个单位。问你至少花多少元钱才能够跳到纸带上全部位置。若不行，输出 $-1$ 。

分析该问题，先考虑两个数的情况，发现想要跳到每一个格子上，必须使得这些数通过数次相加或相加得出的绝对值为 $1$ ，进而想到了裴蜀定理。

可以推出：如果 $a$ 与 $b$ 互质，那么一定存在两个整数 $x$ 与 $y$ ，使得 $ax+by=1$ .

由此得出了若选择的卡牌的数通过数次相加或相减得出的绝对值为 $1$ ，那么这些数一定互质，此时可以考虑动态规划求解。

不过可以转移思想，因为这些数互质，即为 $0$ 号节点开始，每走一步求 $\gcd$ （节点号，下一个节点），同时记录代价，就成为了从 $0$ 通过不断 $\gcd$ 最后变为 $1$ 的最小代价。

由于：互质即为最大公因数为 $1$ ， $\gcd(0,x)=x$ 这两个定理，可以证明该算法的正确。选择优先队列优化 Dijkstra 求解。

不过还有个问题，即为需要记录是否已经买过一个卡片，开数组标记由于数据范围达到 $10^9$ 会超出内存限制，可以想到使用 `unordered_map` （比普通的 `map` 更快地访问各个元素，迭代效率较低，详见 [STL-map](../lang/csl/associative-container.md) ）

# newton
author: Marcythm, sshwy, nutshellfool

本文介绍如何用牛顿迭代法（Newton's method for finding roots）求方程的近似解，该方法于 17 世纪由牛顿提出。

具体的任务是，对于在 $[a,b]$ 上连续且单调的函数 $f(x)$ ，求方程 $f(x)=0$ 的近似解。

## 算法描述

初始时我们从给定的 $f(x)$ 和一个近似解 $x_0$ 开始。（ $x_0$ 的值可任意取）

假设我们目前的近似解是 $x_i$ ，我们画出与 $f(x)$ 切于点 $(x_i,f(x_i))$ 的直线 $l$ ，将 $l$ 与 $x$ 轴的交点横坐标记为 $x_{i+1}$ ，那么这就是一个更优的近似解。重复这个迭代的过程。
根据导数的几何意义，可以得到如下关系：

$$
 f^\prime(x_i) = \frac{f(x_i)}{x_{i} - x_{i+1}}
$$

整理后得到如下递推式：

$$
 x_{i+1} = x_i - \frac{f(x_i)}{f^\prime(x_i)}
$$

直观地说，如果 $f(x)$ 比较平滑，那么随着迭代次数的增加， $x_i$ 会越来越逼近方程的解。

牛顿迭代法的收敛率是平方级别的，这意味着每次迭代后近似解的精确数位会翻倍。
关于牛顿迭代法的收敛性证明可参考 [citizendium - Newton method Convergence analysis](http://en.citizendium.org/wiki/Newton%27s_method#Convergence_analysis) 

当然牛顿迭代法也同样存在着缺陷，详情参考 [Xiaolin Wu - Roots of Equations 第 18 - 20 页分析](https://www.ece.mcmaster.ca/~xwu/part2.pdf) 

## 求解平方根

我们尝试用牛顿迭代法求解平方根。设 $f(x)=x^2-n$ ，这个方程的近似解就是 $\sqrt{n}$ 的近似值。于是我们得到

$$
x_{i+1}=x_i-\frac{x_i^2-n}{2x_i}=\frac{x_i+\frac{n}{x_i}}{2}
$$

在实现的时候注意设置合适的精度。代码如下

```cpp
double sqrt_newton(double n) {
  const double eps = 1E-15;
  double x = 1;
  while (true) {
    double nx = (x + n / x) / 2;
    if (abs(x - nx) < eps) break;
    x = nx;
  }
  return x;
}
```

## 求解整数平方根

尽管我们可以调用 `sqrt()` 函数来获取平方根的值，但这里还是讲一下牛顿迭代法的变种算法，用于求不等式 $x^2\le n$ 的最大整数解。我们仍然考虑一个类似于牛顿迭代的过程，但需要在边界条件上稍作修改。如果 $x$ 在迭代的过程中上一次迭代值得近似解变小，而这一次迭代使得近似解变大，那么我们就不进行这次迭代，退出循环。

```cpp
int isqrt_newton(int n) {
  int x = 1;
  bool decreased = false;
  for (;;) {
    int nx = (x + n / x) >> 1;
    if (x == nx || (nx > x && decreased)) break;
    decreased = nx < x;
    x = nx;
  }
  return x;
}
```

## 高精度平方根

最后考虑高精度的牛顿迭代法。迭代的方法是不变的，但这次我们需要关注初始时近似解的设置，即 $x_0$ 的值。由于需要应用高精度的数一般都非常大，因此不同的初始值对于算法效率的影响也很大。一个自然的想法就是考虑 $x_0=2^{\left\lfloor\frac{1}{2}\log_2n\right\rfloor}$ ，这样既可以快速计算出 $x_0$ ，又可以较为接近平方根的近似解。

给出 Java 代码的实现：

```java
public static BigInteger isqrtNewton(BigInteger n) {
	BigInteger a = BigInteger.ONE.shiftLeft(n.bitLength() / 2);
	boolean p_dec = false;
	for (;;) {
		BigInteger b = n.divide(a).add(a).shiftRight(1);
		if (a.compareTo(b) == 0 || a.compareTo(b) < 0 && p_dec)
			break;
		p_dec = a.compareTo(b) > 0;
		a = b;
	}
	return a;
}
```

实践效果：在 $n=10^{1000}$ 的时候该算法的运行时间是 60 ms，如果我们不优化 $x_0$ 的值，直接从 $x_0=1$ 开始迭代，那么运行时间将增加到 120 ms。

## 习题

-    [UVa 10428 - The Roots](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1369) 

     **本页面主要译自博文 [Метод Ньютона (касательных) для поиска корней](http://e-maxx.ru/algo/roots_newton) 与其英文翻译版 [Newton's method for finding roots](https://cp-algorithms.com/num_methods/roots_newton.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# min-25
author: TrisolarisHD, Xeonacid

由于其由 [Min_25](http://min-25.hatenablog.com/) 发明并最早开始使用，故称「Min_25 筛」。

> 从此种筛法的思想方法来说，其又被称为「Extended Eratosthenes Sieve」。

其可以在 $O\left(\frac{n^{\frac{3}{4}}}{\log{n}}\right)$ 或 $\Theta\left(n^{1 - \epsilon}\right)$ 的时间复杂度下解决一类 **积性函数** 的前缀和问题。  
要求： $f(p)$ 是一个关于 $p$ 的项数较少的多项式或可以快速求值； $f(p^{c})$ 可以快速求值。

## 记号

-    **如无特别说明，本节中所有记为 $p$ 的变量的取值集合均为全体质数。** 
-    $x / y := \left\lfloor\frac{x}{y}\right\rfloor$ 
-    $\operatorname{isprime}(n) := [ |\{d : d \mid n\}| = 2 ]$ ，即 $n$ 为质数时其值为 $1$ ，否则为 $0$ 。
-    $p_{k}$ ：全体质数中第 $k$ 小的质数（如： $p_{1} = 2, p_{2} = 3$ ）。特别地，令 $p_{0} = 1$ 。
-    $\operatorname{lpf}(n) := [1 < n] \min\{p : p \mid n\} + [1 = n]$ ，即 $n$ 的最小质因数。特别地， $n=1$ 时，其值为 $1$ 。
-    $F_{\mathrm{prime}}(n) := \sum_{2 \le p \le n} f(p)$ 
-    $F_{k}(n) := \sum_{i = 2}^{n} [p_{k} \le \operatorname{lpf}(i)] f(i)$ 

## 具体方法

观察 $F_{k}(n)$ 的定义，可以发现答案即为 $F_{1}(n) + f(1) = F_{1}(n) + 1$ 。

* * *

考虑如何求出 $F_{k}(n)$ 。通过枚举每个 $i$ 的最小质因子及其次数可以得到递推式：

$$
\begin{aligned}
	F_{k}(n)
	&= \sum_{i = 2}^{n} [p_{k} \le \operatorname{lpf}(i)] f(i) \\
	&= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c} \le n}} f\left(p_{i}^{c}\right) ([c > 1] + F_{i + 1}\left(n / p_{i}^{c}\right)) + \sum_{\substack{k \le i \\ p_{i} \le n}} f(p_{i}) \\
	&= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c} \le n}} f\left(p_{i}^{c}\right) ([c > 1] + F_{i + 1}\left(n / p_{i}^{c}\right)) + F_{\mathrm{prime}}(n) - F_{\mathrm{prime}}(p_{k - 1}) \\
	&= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c + 1} \le n}} \left(f\left(p_{i}^{c}\right) F_{i + 1}\left(n / p_{i}^{c}\right) + f\left(p_{i}^{c + 1}\right)\right) + F_{\mathrm{prime}}(n) - F_{\mathrm{prime}}(p_{k - 1})
\end{aligned}
$$

最后一步推导基于这样一个事实：对于满足 $p_{i}^{c} \le n < p_{i}^{c + 1}$ 的 $c$ ，有 $p_{i}^{c + 1} > n \iff n / p_{i}^{c} < p_{i} < p_{i + 1}$ ，故 $F_{i + 1}\left(n / p_{i}^{c}\right) = 0$ 。  
其边界值即为 $F_{k}(n) = 0 (p_{k} > n)$ 。

假设现在已经求出了所有的 $F_{\mathrm{prime}}(n)$ ，那么有两种方式可以求出所有的 $F_{k}(n)$ ：

1.  直接按照递推式计算。
2.  从大到小枚举 $p$ 转移，仅当 $p^{2} < n$ 时转移增加值不为零，故按照递推式后缀和优化即可。

* * *

现在考虑如何计算 $F_{\mathrm{prime}}{(n)}$ 。  
观察求 $F_{k}(n)$ 的过程，容易发现 $F_{\mathrm{prime}}$ 有且仅有 $1, 2, \dots, \left\lfloor\sqrt{n}\right\rfloor, n / \sqrt{n}, \dots, n / 2, n$ 这 $O(\sqrt{n})$ 处的点值是有用的。  
一般情况下， $f(p)$ 是一个关于 $p$ 的低次多项式，可以表示为 $f(p) = \sum a_{i} p^{c_{i}}$ 。  
那么对于每个 $p^{c_{i}}$ ，其对 $F_{\mathrm{prime}}(n)$ 的贡献即为 $a_{i} \sum_{2 \le p \le n} p^{c_{i}}$ 。  
分开考虑每个 $p^{c_{i}}$ 的贡献，问题就转变为了：给定 $n, s, g(p) = p^{s}$ ，对所有的 $m = n / i$ ，求 $\sum_{p \le m} g(p)$ 。

> Notice： $g(p) = p^{s}$ 是完全积性函数！

于是设 $G_{k}(n) := \sum_{i = 1}^{n} \left[p_{k} < \operatorname{lpf}(i) \lor \operatorname{isprime}(i)\right] g(i)$ ，即埃筛第 $k$ 轮筛完后剩下的数的 $g$ 值之和。  
对于一个合数 $x$ ，必定有 $\operatorname{lpf}(x) \le \sqrt{x}$ ，则 $F_{\mathrm{prime}} = G_{\left\lfloor\sqrt{n}\right\rfloor}$ ，故只需筛到 $G_{\left\lfloor\sqrt{n}\right\rfloor}$ 即可。  
考虑 $G$ 的边界值，显然为 $G_{0}(n) = \sum_{i = 2}^{n} g(i)$ 。（还记得吗？特别约定了 $p_{0} = 1$ ）  
对于转移，考虑埃筛的过程，分开讨论每部分的贡献，有：

1.  对于 $n < p_{k}^{2}$ 的部分， $G$ 值不变，即 $G_{k}(n) = G_{k - 1}(n)$ 。
2.  对于 $p_{k}^{2} \le n$ 的部分，被筛掉的数必有质因子 $p_{k}$ ，即 $-g(p_{k}) G_{k - 1}(n / p_{k})$ 。
3.  对于第二部分，由于 $p_{k}^{2} \le n \iff p_{k} \le n / p_{k}$ ，故会有 $\operatorname{lpf}(i) < p_{k}$ 的 $i$ 被减去。这部分应当加回来，即 $g(p_{k}) G_{k - 1}(p_{k - 1})$ 。

则有：

$$
G_{k}(n) = G_{k - 1}(n) - \left[p_{k}^{2} \le n\right] g(p_{k}) (G_{k - 1}(n / p_{k}) - G_{k - 1}(p_{k - 1}))
$$

* * *

## 复杂度分析

对于 $F_{k}(n)$ 的计算，其第一种方法的时间复杂度被证明为 $O\left(n^{1 - \epsilon}\right)$ （见 zzt 集训队论文 2.3）；  
对于第二种方法，其本质即为洲阁筛的第二部分，在洲阁论文中也有提及（6.5.4），其时间复杂度被证明为 $O\left(\frac{n^{\frac{3}{4}}}{\log{n}}\right)$ 。

对于 $F_{\mathrm{prime}}(n)$ 的计算，事实上，其实现与洲阁筛第一部分是相同的。  
考虑对于每个 $m = n / i$ ，只有在枚举满足 $p_{k}^{2} \le m$ 的 $p_{k}$ 转移时会对时间复杂度产生贡献，则时间复杂度可估计为：

$$
\begin{aligned}
	T(n)
	&= \sum_{i^{2} \le n} O\left(\pi\left(\sqrt{i}\right)\right) + \sum_{i^{2} \le n} O\left(\pi\left(\sqrt{\frac{n}{i}}\right)\right) \\
	&= \sum_{i^{2} \le n} O\left(\frac{\sqrt{i}}{\ln{\sqrt{i}}}\right) + \sum_{i^{2} \le n} O\left(\frac{\sqrt{\frac{n}{i}}}{\ln{\sqrt{\frac{n}{i}}}}\right) \\
	&= O\left(\int_{1}^{\sqrt{n}} \frac{\sqrt{\frac{n}{x}}}{\log{\sqrt{\frac{n}{x}}}} \mathrm{d} x\right) \\
	&= O\left(\frac{n^{\frac{3}{4}}}{\log{n}}\right)
\end{aligned}
$$

对于空间复杂度，可以发现不论是 $F_{k}$ 还是 $F_{\mathrm{prime}}$ ，其均只在 $n / i$ 处取有效点值，共 $O(\sqrt{n})$ 个。  
则可以使用 [杜教筛一节中介绍的 trick](#Implementation) 来将空间复杂度优化至 $O(\sqrt{n})$ 。

## 有关代码实现

对于 $F_{k}(n)$ 的计算，我们实现时一般选择实现难度较低的第一种方法，其在数据规模较小时往往比第二种方法的表现要好；

对于 $F_{\mathrm{prime}}(n)$ 的计算，直接按递推式实现即可。

对于 $p_{k}^{2} \le n$ ，可以用线性筛预处理出 $s_{k} := F_{\mathrm{prime}}(p_{k})$ 来替代 $F_{k}$ 递推式中的 $F_{\mathrm{prime}}(p_{k - 1})$ 。  
相应地， $G$ 递推式中的 $G_{k - 1}(p_{k - 1}) = \sum_{i = 1}^{k - 1} g(p_{i})$ 也可以用此方法预处理。

用 Extended Eratosthenes Sieve 求 **积性函数**  $f$ 的前缀和时，应当明确以下几点：

-   如何快速（一般是线性时间复杂度）筛出前 $\sqrt{n}$ 个 $f$ 值；
-    $f(p)$ 的多项式表示；
-   如何快速求出 $f(p^{c})$ 。

明确上述几点之后按顺序实现以下几部分即可：

1.  筛出 $[1, \sqrt{n}]$ 内的质数与前 $\sqrt{n}$ 个 $f$ 值；
2.  对 $f(p)$ 多项式表示中的每一项筛出对应的 $G$ ，合并得到 $F_{\mathrm{prime}}$ 的所有 $O(\sqrt{n})$ 个有用点值；
3.  按照 $F_{k}$ 的递推式实现递归，求出 $F_{1}(n)$ 。

## 例题

### 求莫比乌斯函数的前缀和

求 $\displaystyle \sum_{i = 1}^{n} \mu(i)$ 。

易知 $f(p) = -1$ 。则 $g(p) = -1, G_{0}(n) = \sum_{i = 2}^{n} g(i) = -n + 1$ 。  
直接筛即可得到 $F_{\mathrm{prime}}$ 的所有 $O(\sqrt{n})$ 个所需点值。

### 求欧拉函数的前缀和

求 $\displaystyle \sum_{i = 1}^{n} \varphi(i)$ 。

首先易知 $f(p) = p - 1$ 。  
对于 $f(p)$ 的一次项 $(p)$ ，有 $g(p) = p, G_{0}(n) = \sum_{i = 2}^{n} g(i) = \frac{(n + 2) (n - 1)}{2}$ ；  
对于 $f(p)$ 的常数项 $(-1)$ ，有 $g(p) = -1, G_{0}(n) = \sum_{i = 2}^{n} g(i) = -n + 1$ 。  
筛两次加起来即可得到 $F_{\mathrm{prime}}$ 的所有 $O(\sqrt{n})$ 个所需点值。

###  [「LOJ #6053」简单的函数](https://loj.ac/problem/6053) 

给定 $f(n)$ ：

$$
f(n) = \begin{cases}
    1 & n = 1 \\
    p \operatorname{xor} c & n = p^{c} \\
    f(a)f(b) & n = ab \land a \perp b
\end{cases}
$$

易知 $f(p) = p - 1 + 2[p = 2]$ 。则按照筛 $\varphi$ 的方法筛，对 $2$ 讨论一下即可。  
此处给出一种 C++ 实现：

???+ 参考代码
    ```cpp
    /* 「LOJ #6053」简单的函数 */
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    
    using i64 = long long;
    
    constexpr int maxs = 200000;  // 2sqrt(n)
    constexpr int mod = 1000000007;
    
    template <typename x_t, typename y_t>
    inline void inc(x_t &x, const y_t &y) {
      x += y;
      (mod <= x) && (x -= mod);
    }
    template <typename x_t, typename y_t>
    inline void dec(x_t &x, const y_t &y) {
      x -= y;
      (x < 0) && (x += mod);
    }
    template <typename x_t, typename y_t>
    inline int sum(const x_t &x, const y_t &y) {
      return x + y < mod ? x + y : (x + y - mod);
    }
    template <typename x_t, typename y_t>
    inline int sub(const x_t &x, const y_t &y) {
      return x < y ? x - y + mod : (x - y);
    }
    template <typename _Tp>
    inline int div2(const _Tp &x) {
      return ((x & 1) ? x + mod : x) >> 1;
    }
    template <typename _Tp>
    inline i64 sqrll(const _Tp &x) {
      return (i64)x * x;
    }
    
    int pri[maxs / 7], lpf[maxs + 1], spri[maxs + 1], pcnt;
    
    inline void sieve(const int &n) {
      for (int i = 2; i <= n; ++i) {
        if (lpf[i] == 0)
          pri[lpf[i] = ++pcnt] = i, spri[pcnt] = sum(spri[pcnt - 1], i);
        for (int j = 1, v; j <= lpf[i] && (v = i * pri[j]) <= n; ++j) lpf[v] = j;
      }
    }
    
    i64 global_n;
    int lim;
    int le[maxs + 1],  // x \le \sqrt{n}
        ge[maxs + 1];  // x > \sqrt{n}
    #define idx(v) (v <= lim ? le[v] : ge[global_n / v])
    
    int G[maxs + 1][2], Fprime[maxs + 1];
    i64 lis[maxs + 1];
    int cnt;
    
    inline void init(const i64 &n) {
      for (i64 i = 1, j, v; i <= n; i = n / j + 1) {
        j = n / i;
        v = j % mod;
        lis[++cnt] = j;
        idx(j) = cnt;
        G[cnt][0] = sub(v, 1ll);
        G[cnt][1] = div2((i64)(v + 2ll) * (v - 1ll) % mod);
      }
    }
    
    inline void calcFprime() {
      for (int k = 1; k <= pcnt; ++k) {
        const int p = pri[k];
        const i64 sqrp = sqrll(p);
        for (int i = 1; lis[i] >= sqrp; ++i) {
          const i64 v = lis[i] / p;
          const int id = idx(v);
          dec(G[i][0], sub(G[id][0], k - 1));
          dec(G[i][1], (i64)p * sub(G[id][1], spri[k - 1]) % mod);
        }
      }
      /* F_prime = G_1 - G_0 */
      for (int i = 1; i <= cnt; ++i) Fprime[i] = sub(G[i][1], G[i][0]);
    }
    
    inline int f_p(const int &p, const int &c) {
      /* f(p^{c}) = p xor c */
      return p xor c;
    }
    
    int F(const int &k, const i64 &n) {
      if (n < pri[k] || n <= 1) return 0;
      const int id = idx(n);
      i64 ans = Fprime[id] - (spri[k - 1] - (k - 1));
      if (k == 1) ans += 2;
      for (int i = k; i <= pcnt && sqrll(pri[i]) <= n; ++i) {
        i64 pw = pri[i], pw2 = sqrll(pw);
        for (int c = 1; pw2 <= n; ++c, pw = pw2, pw2 *= pri[i])
          ans +=
              ((i64)f_p(pri[i], c) * F(i + 1, n / pw) + f_p(pri[i], c + 1)) % mod;
      }
      return ans % mod;
    }
    
    int main() {
      scanf("%lld", &global_n);
      lim = sqrt(global_n);
    
      sieve(lim + 1000);
      init(global_n);
      calcFprime();
      printf("%lld\n", (F(1, global_n) + 1ll + mod) % mod);
    
      return 0;
    }
    ```

# notation
author: sshwy, hsfzLZH1, Enter-tainer

在学习数学的过程中大家会见到许多复杂的公式符号。因此在学习具体内容之前，建议大家首先理解下列常见符号的含义。一些特殊的符号会在对应的章节中讲到，而这里则有一些极为常见的符号需要大家提前掌握。

### 渐进符号

请参见 [复杂度](../misc/complexity.md#_1) 。

### 整除/同余理论常见符号

1.  整除符号： $x\mid y$ ，表示 $x$ 整除 $y$ ，即 $x$ 是 $y$ 的因数。
2.  取模符号： $x\bmod y$ ，表示 $x$ 除以 $y$ 得到的余数。
3.  互质符号： $x\perp y$ ，表示 $x$ , $y$ 互质。
4.  最大公约数： $\gcd(x,y)$ ，在无混淆意义的时侯可以写作 $(x,y)$ 。
5.  最小公倍数： $\operatorname{lcm}(x,y)$ ，在无混淆意义的时侯可以写作 $[x,y]$ 。

### 数论函数常见符号

求和符号： $\sum$ 符号，表示满足特定条件的数的和。举几个例子：

-    $\sum_{i=1}^n i$ 表示 $1+2+\dotsb+n$ 的和。其中 $i$ 是一个变量，在求和符号的意义下 $i$ 通常是 **正整数或者非负整数** （除非特殊说明）。这个式子的含义可以理解为， $i$ 从 $1$ 循环到 $n$ ，所有 $i$ 的和。这个式子用代码的形式很容易表达。当然，学过简单的组合数学的同学都知道 $\sum_{i=1}^n i=\frac{n(n+1)}{2}$ 。
-    $\sum_{S\subseteq T}|S|$ 表示所有被 $T$ 包含的集合的大小的和。
-    $\sum_{p\le n,p\perp n}1$ 表示的是 $n$ 以内有多少个与 $n$ 互质的数，即 $\varphi(n)$ ， $\varphi$ 是欧拉函数。

求积符号： $\prod$ 符号，表示满足特定条件的数的积。举几个例子：

-    $\prod_{i=1}^ni$ 表示 $n$ 的阶乘，即 $n!$ 。在组合数学常见符号中会讲到。
-    $\prod_{i=1}^na_i$ 表示 $a_1\times a_2\times a_3\times \dotsb\times a_n$ 。
-    $\prod_{x|d}x$ 表示 $d$ 的所有因数的乘积。

在行间公式中，求和符号与求积符号的上下条件会放到符号的上面和下面，这一点要注意。

### 其他常见符号

1.  阶乘符号 $!$ ， $n!$ 表示 $1\times 2\times 3\times \dotsb \times n$ 。特别地， $0!=1$ 。
2.  向下取整符号： $\lfloor x\rfloor$ ，表示小于等于 $x$ 的最大的整数。常用于分数，比如分数的向下取整 $\left\lfloor\frac{x}{y}\right\rfloor$ 。
3.  向上取整符号： $\lceil x\rceil$ ，与向下取整符号相对，表示大于等于 $x$ 的最小的整数。

# gauss
## 高斯消元

> 高斯消元法（Gauss-Jordan elimination）是求解线性方程组的经典算法，它在当代数学中有着重要的地位和价值，是线性代数课程教学的重要组成部分。
>
> 高斯消元法除了用于线性方程组求解外，还可以用于行列式计算、求矩阵的逆，以及其他计算机和工程方面。
>
> 夏建明等人之前提出了应用图形处理器 (GPU) 加速求解线性方程组的高斯消元法，所提出的算法与基于 CPU 的算法相比较取得更快的运算速度。二是提出各种变异高斯消元法以满足特定工作的需要。

* * *

### 消元法及高斯消元法思想

#### 消元法说明

消元法是将方程组中的一方程的未知数用含有另一未知数的代数式表示，并将其带入到另一方程中，这就消去了一未知数，得到一解；或将方程组中的一方程倍乘某个常数加到另外一方程中去，也可达到消去一未知数的母的。消元法主要用于二元一次方程组的求解。

例一：利用消元法求解二元一次线性方程组：

$$
\left\{\begin{aligned}
4x+y&=100 \notag \\
x-y&=100 \notag
\end{aligned}\right.
$$

解：将方程组中两方程相加，消元 $y$ 可得：

 $5x = 200$ 

解得：

 $x = 40$ 

将 $x = 40$ 代入方程组中第二个方程可得：

 $y = -60$ 

#### 消元法理论的核心

消元法理论的核心主要如下：

-   两方程互换，解不变；

-   一方程乘以非零数 $k$ ，解不变；

-   一方程乘以数 $k$ 加上另一方程，解不变。

#### 高斯消元法思想概念

德国数学家高斯对消元法进行了思考分析，得出了如下结论：

-   在消元法中，参与计算和发生改变的是方程中各变量的系数；

-   各变量并未参与计算，且没有发生改变；

-   可以利用系数的位置表示变量，从而省略变量；

-   在计算中将变量简化省略，方程的解不变。

> 高斯在这些结论的基础上，提出了高斯消元法，首先将方程的增广矩阵利用行初等变换化为行最简形，然后以线性无关为准则对自由未知量赋值，最后列出表达方程组通解。

### 高斯消元五步骤法

高斯消元法在将增广矩阵化为最简形后对于自由未知量的赋值，需要掌握线性相关知识，且赋值存在人工经验的因素，使得在学习过程中有一定的困难，将高斯消元法划分为五步骤，从而提出五步骤法，内容如下：

1.  增广矩阵行初等行变换为行最简形；

2.  还原线性方程组；

3.  求解第一个变量；

4.  补充自由未知量；

5.  列表示方程组通解。

利用实例进一步说明该算法的运作情况。

例二：利用高斯消元法五步骤法求解线性方程组：

$$
\left\{\begin{aligned}
2x_1+5x_3+6x_4&=9 \notag \\
x_3+x_4&=-4 \notag \\
2x_3+2x_4&=-8 \notag
\end{aligned}\right.
$$

#### 增广矩阵行（初等）变换为行最简形

所谓增广矩阵，即为方程组系数矩阵 $A$ 与常数列 $b$ 的并生成的新矩阵，即 $(A | b)$ ，增广矩阵行初等变换化为行最简形，即是利用了高斯消元法的思想理念，省略了变量而用变量的系数位置表示变量，增广矩阵中用竖线隔开了系数矩阵和常数列，代表了等于符号。

$$
\left(\begin{matrix}
2 & 0 & 5 & 6 \\
0 & 0 & 1 & 1 \\
0 & 0 & 2 & 2
\end{matrix} \middle|
\begin{matrix}
9 \\
-4 \\
-8
\end{matrix} \right)
$$

$$
\xrightarrow{r_3-2r_2}
\left(\begin{matrix}
2 & 0 & 5 & 6 \\
0 & 0 & 1 & 1 \\
0 & 0 & 0 & 0
\end{matrix} \middle|
\begin{matrix}
9 \\
-4 \\
0
\end{matrix} \right)
$$

化为行阶梯形

$$
\xrightarrow{\frac{r_1}{2}}
\left(\begin{matrix}
1 & 0 & 2.5 & 3 \\
0 & 0 & 1 & 1 \\
0 & 0 & 0 & 0
\end{matrix} \middle|
\begin{matrix}
4.5 \\
-4 \\
0
\end{matrix} \right)
$$

$$
\xrightarrow{r_1-r_2 \times 2.5}
\left(\begin{matrix}
1 & 0 & 0 & 0.5 \\
0 & 0 & 1 & 1 \\
0 & 0 & 0 & 0
\end{matrix} \middle|
\begin{matrix}
14.5 \\
-4 \\
0
\end{matrix} \right)
$$

化为最简形

#### 还原线性方程组

$$
\left\{\begin{aligned}
x_1+0.5x_4 &= 14.5 \notag\\
x_3+x_4 &= -4 \notag \\
\end{aligned}\right.
$$

解释

> 所谓的还原线性方程组，即是在行最简形的基础上，将之重新书写为线性方程组的形式，即将行最简形中各位置的系数重新赋予变量，中间的竖线还原为等号。

#### 求解第一个变量

$$
\left\{\begin{aligned}
x_1 &= -0.5x_4+14.5\notag \\
x_3 &= -x_4-4\notag
\end{aligned}\right.
$$

解释

> 即是对于所还原的线性方程组而言，将方程组中每个方程的第一个变量，用其他量表达出来。如方程组两方程中的第一个变量 $x_1$ 和 $x_3$ 

#### 补充自由未知量

$$
\left\{\begin{aligned}
x_1 &= -0.5x_4+14.5 \notag \\
x_2 &= x_2 \notag \\
x_3 &= -x_4-4 \notag \\
x_4 &= x_4 \notag
\end{aligned}\right.
$$

解释

> 第 3 步中，求解出变量 $x_1$ 和 $x_3$ ，从而说明了方程剩余的变量 $x_2$ 和 $x_4$ 不受方程组的约束，是自由未知量，可以取任意值，所以需要在第 3 步骤解得基础上进行解得补充，补充的方法为 $x_2 = x_2,x_4 = x_4$ ，这种解得补充方式符合自由未知量定义，并易于理解，因为是自由未知量而不受约束，所以只能自己等于自己。

#### 列表示方程组的通解

$$
\begin{aligned}
\begin{pmatrix} x_1 \\ x_2 \\ x_3 \\ x_4 \end{pmatrix} &=
\begin{pmatrix} 0 \\ 1 \\ 0 \\ 0 \end{pmatrix} x_2+
\begin{pmatrix} -0.5 \\ 0 \\ -1 \\ 1 \end{pmatrix} x_4 +
\begin{pmatrix} 14.5 \\ 0 \\ -4 \\ 0 \end{pmatrix} \notag \\
&= \begin{pmatrix} 0 \\ 1 \\ 0 \\ 0 \end{pmatrix} C_1+
\begin{pmatrix} -0.5 \\ 0 \\ -1 \\ 1 \end{pmatrix} C_2 +
\begin{pmatrix} 14.5 \\ 0 \\ -4 \\ 0 \end{pmatrix} \notag
\end{aligned}
$$

其中 $C_1$ 和 $C_2$ 为任意常数。

解释

> 即在第 4 步的基础上，将解表达为列向量组合的表示形式，同时由于 $x_2$ 和 $x_4$ 是自由未知量，可以取任意值，所以在解得右边，令二者分别为任意常数 $C_1$ 和 $C_2$ ，即实现了对方程组的求解。

* * *

## 行列式

 $N \times N$ 方阵行列式（Determinant）可以理解为所有列向量所夹的几何体的有向体积

例如：

$$
\begin{vmatrix}
1 & 0 \\
0 & 1 \end{vmatrix} = 1
$$

$$
\begin{vmatrix}
1 & 2 \\
2 & 1 \end{vmatrix} = -3
$$

行列式有公式

$$
D = \left| A \right| = \sum(-1)^va_{1,l_1}a_{2,l_2}\dots a_{n,l_n}
$$

> 其中 $v$ 为 $l_1$ , $l_2$ , $\cdots$ , $l_n$ 中逆序对的个数。

通过体积概念理解行列式不变性是一个非常简单的办法：

-   矩阵转置，行列式不变；

-   矩阵行交换，行列式取反；

-   矩阵行叠加，行列式不变；

-   矩阵行伸长，行列式等比例变大。

> 由此，发现高斯消元不改变矩阵行列式，且最终行列式等于倒三角矩阵的对角线乘积。

* * *

## 生成树计数

一个无向图的生成树个数为邻接矩阵度数矩阵去一行一列的行列式。

详见： [矩阵树定理](../graph/matrix-tree.md) 

例如，一个正方形图的生成树个数

$$
\begin{pmatrix}
0 & 1 & 0 & 1 \\
1 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 \\
1 & 0 & 1 & 0 \end{pmatrix}-\begin{pmatrix}
2 & 0 & 0 & 0 \\
0 & 2 & 0 & 0 \\
0 & 0 & 2 & 0 \\
0 & 0 & 0 & 2 \end{pmatrix}=\begin{pmatrix}
-2 & 1 & 0 & 1 \\
1 & -2 & 1 & 0 \\
0 & 1 & -2 & 1 \\
1 & 0 & 1 & -2 \end{pmatrix}
$$

$$
\begin{vmatrix}
-2 & 1 & 0 \\
1 & -2 & 1 \\
0 & 1 & -2 \end{vmatrix} = 4
$$

可以用高斯消元解决，时间复杂度为 $O(n^3)$ 。

??? note "参考代码"
    ```cpp
    #include <algorithm>
    #include <cassert>
    #include <cmath>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    using namespace std;
    #define MOD 100000007
    #define eps 1e-7
    struct matrix {
      static const int maxn = 20;
      int n, m;
      double mat[maxn][maxn];
      matrix() { memset(mat, 0, sizeof(mat)); }
      void print() {
        cout << "MATRIX " << n << " " << m << endl;
        for (int i = 0; i < n; i++) {
          for (int j = 0; j < m; j++) {
            cout << mat[i][j] << "\t";
          }
          cout << endl;
        }
      }
      void random(int n) {
        this->n = n;
        this->m = n;
        for (int i = 0; i < n; i++)
          for (int j = 0; j < n; j++) mat[i][j] = rand() % 100;
      }
      void initSquare() {
        this->n = 4;
        this->m = 4;
        memset(mat, 0, sizeof(mat));
        mat[0][1] = mat[0][3] = 1;
        mat[1][0] = mat[1][2] = 1;
        mat[2][1] = mat[2][3] = 1;
        mat[3][0] = mat[3][2] = 1;
        mat[0][0] = mat[1][1] = mat[2][2] = mat[3][3] = -2;
        this->n--;  //去一行
        this->m--;  //去一列
      }
      double gauss() {
        double ans = 1;
        for (int i = 0; i < n; i++) {
          int sid = -1;
          for (int j = i; j < n; j++)
            if (abs(mat[j][i]) > eps) {
              sid = j;
              break;
            }
          if (sid == -1) continue;
          if (sid != i) {
            for (int j = 0; j < n; j++) {
              swap(mat[sid][j], mat[i][j]);
              ans = -ans;
            }
          }
          for (int j = i + 1; j < n; j++) {
            double ratio = mat[j][i] / mat[i][i];
            for (int k = 0; k < n; k++) {
              mat[j][k] -= mat[i][k] * ratio;
            }
          }
        }
        for (int i = 0; i < n; i++) ans *= mat[i][i];
        return abs(ans);
      }
    };
    int main() {
      srand(1);
      matrix T;
      // T.random(2);
      T.initSquare();
      T.print();
      double ans = T.gauss();
      T.print();
      cout << ans << endl;
    }
    ```

## inv
## 描述

给定多项式 $f\left(x\right)$ ，求 $f^{-1}\left(x\right)$ 。

## 解法

### 倍增法

首先，易知

$$
\left[x^{0}\right]f^{-1}\left(x\right)=\left(\left[x^{0}\right]f\left(x\right)\right)^{-1}
$$

假设现在已经求出了 $f\left(x\right)$ 在模 $x^{\left\lceil\frac{n}{2}\right\rceil}$ 意义下的逆元 $f^{-1}_{0}\left(x\right)$ 。
有：

$$
\begin{aligned}
	f\left(x\right)f^{-1}_{0}\left(x\right)&\equiv 1 &\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}\\
	f\left(x\right)f^{-1}\left(x\right)&\equiv 1 &\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}\\
	f^{-1}\left(x\right)-f^{-1}_{0}\left(x\right)&\equiv 0 &\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}
\end{aligned}
$$

两边平方可得：

$$
f^{-2}\left(x\right)-2f^{-1}\left(x\right)f^{-1}_{0}\left(x\right)+f^{-2}_{0}\left(x\right)\equiv 0 \pmod{x^{n}}
$$

两边同乘 $f\left(x\right)$ 并移项可得：

$$
f^{-1}\left(x\right)\equiv f^{-1}_{0}\left(x\right)\left(2-f\left(x\right)f^{-1}_{0}\left(x\right)\right) \pmod{x^{n}}
$$

递归计算即可。

时间复杂度

$$
T\left(n\right)=T\left(\frac{n}{2}\right)+O\left(n\log{n}\right)=O\left(n\log{n}\right)
$$

### Newton's Method

参见 [ **Newton's Method** ](./newton.md#newtons-method) .

## 代码

??? "多项式求逆"
    ```cpp
    constexpr int maxn = 262144;
    constexpr int mod = 998244353;
    
    using i64 = long long;
    using poly_t = int[maxn];
    using poly = int *const;
    
    void polyinv(const poly &h, const int n, poly &f) {
      /* f = 1 / h = f_0 (2 - f_0 h) */
      static poly_t inv_t;
      std::fill(f, f + n + n, 0);
      f[0] = fpow(h[0], mod - 2);
      for (int t = 2; t <= n; t <<= 1) {
        const int t2 = t << 1;
        std::copy(h, h + t, inv_t);
        std::fill(inv_t + t, inv_t + t2, 0);
    
        DFT(f, t2);
        DFT(inv_t, t2);
        for (int i = 0; i != t2; ++i)
          f[i] = (i64)f[i] * sub(2, (i64)f[i] * inv_t[i] % mod) % mod;
        IDFT(f, t2);
    
        std::fill(f + t, f + t2, 0);
      }
    }
    ```

## 例题

1.  有标号简单无向连通图计数： [「POJ 1737」Connected Graph](http://poj.org/problem?id=1737) 

## ntt
author: ChungZH, Yukimaikoriya

（本文转载自 [桃酱的算法笔记](https://zhuanlan.zhihu.com/c_1005817911142838272) ，原文戳 [链接](https://zhuanlan.zhihu.com/p/41867199) ，已获得作者授权）

## 简介

NTT 解决的是多项式乘法带模数的情况，可以说有些受模数的限制，数也比较大，

但是它比较方便呀毕竟没有复数部分

## 学习 NTT 之前……

### 生成子群

子群：群 $(S,⊕), (S′,⊕)$ ，满足 $S′⊂S$ ，则 $(S′,⊕)$ 是 $(S,⊕)$ 的子群

拉格朗日定理： $|S′|∣|S |$ 证明需要用到陪集，得到陪集大小等于子群大小，每个陪集要么不相交要么相等，所有陪集的并是集合 $S$ ，那么显然成立。

生成子群： $a \in S$ 的生成子群 $\left<a\right> = \{a^{(k)}, k \geq 1 \}$ ， $a$ 是 $\left< a \right>$ 的生成元

阶：群 $S$ 中 $a$ 的阶是满足 $a^r=e$ 的最小的 $r$ ，符号 $\operatorname{ord}(a)$ ，有 $\operatorname{ord}(a)=\left|\left<a\right>\right|$ ，显然成立。

考虑群 $Z_n^ \times =\{[a], n \in Z_n : \gcd(a, n) = 1\}, |Z_n^ \times | = \varphi(n)$ 

阶就是满足 $a^r \equiv 1 \pmod n$ 的最小的 $r$ ， $\operatorname{ord}(a)=r$ 

###  [原根](../primitive-root.md) 

 $g$ 满足 $\operatorname{ord}_n(g)=\left|Z_n^\times\right|=\varphi(n)$ ，对于质数 $p$ ，也就是说 $g^i \bmod p, 0 \leq i < p$ 结果互不相同。

模 $n$ 有原根的充要条件 : $n = 2, 4, p^e, 2 \times p^e$ 

离散对数： $g^t \equiv a \pmod n，ind_{n,g}{(a)}=t$ 

因为 $g$ 是原根，所以 $gt$ 每 $\varphi(n)$ 是一个周期，可以取到 $| Z \times n |$ 的所有元素
对于 $n$ 是质数时，就是得到 $[1,n−1]$ 的所有数，就是 $[0,n−2]$ 到 $[1,n−1]$ 的映射
离散对数满足对数的相关性质，如

求原根可以证明满足 $g^r \equiv 1\pmod p$ 的最小的 $r$ 一定是 $p−1$ 的约数
对于质数 $p$ ，质因子分解 $p−1$ ，若 $g^{(p-1)/pi} \neq 1 \pmod p$ 恒成立， $g$ 为 $p$ 的原根

## NTT

对于质数 $p=qn+1, (n=2^m)$ , 原根 $g$ 满足 $g^{qn} \equiv 1 \pmod p$ , 将 $g_n=g^p\pmod q$ 看做 $\omega_n$ 的等价，择其满足相似的性质，比如 $g_n^n \equiv 1 \pmod p, g_n^{n/2} \equiv -1 \pmod p$ 

然后因为这里涉及到数论变化，所以这里的 $N$ （为了区分 FFT 中的 $n$ ，我们把这里的 $n$ 称为 $N$ ）可以比 FFT 中的 $n$ 大，但是只要把 $\frac{qN}{n}$ 看做这里的 $q$ 就行了，能够避免大小问题……

常见的有

$$
p = 1004535809 = 479 \times 2^{21}+1, g=3
$$

$$
p=998244353=7 \times 17 \times 2^{23}+1, g=3
$$

就是 $g^{qn}$ 的等价 $e^{2\pi n}$ 

迭代到长度 $l$ 时 $g_l = g^{\frac{p-1}{l}}$ ，或者 $\omega_n = g_l = g_N^{\frac{N}{l}} = g_N^{\frac{p-1}{l}}$ 

接下来放一个大数相乘的模板

参考网址如下 <https://blog.csdn.net/blackjack_/article/details/79346433> 

```cpp
#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <string>
#include <vector>
using namespace std;

inline int read() {
  int x = 0, f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-') f = -1;
    ch = getchar();
  }
  while (ch <= '9' && ch >= '0') {
    x = 10 * x + ch - '0';
    ch = getchar();
  }
  return x * f;
}
void print(int x) {
  if (x < 0) putchar('-'), x = -x;
  if (x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}

const int N = 300100, P = 998244353;

inline int qpow(int x, int y) {
  int res(1);
  while (y) {
    if (y & 1) res = 1ll * res * x % P;
    x = 1ll * x * x % P;
    y >>= 1;
  }
  return res;
}

int r[N];

void ntt(int *x, int lim, int opt) {
  register int i, j, k, m, gn, g, tmp;
  for (i = 0; i < lim; ++i)
    if (r[i] < i) swap(x[i], x[r[i]]);
  for (m = 2; m <= lim; m <<= 1) {
    k = m >> 1;
    gn = qpow(3, (P - 1) / m);
    for (i = 0; i < lim; i += m) {
      g = 1;
      for (j = 0; j < k; ++j, g = 1ll * g * gn % P) {
        tmp = 1ll * x[i + j + k] * g % P;
        x[i + j + k] = (x[i + j] - tmp + P) % P;
        x[i + j] = (x[i + j] + tmp) % P;
      }
    }
  }
  if (opt == -1) {
    reverse(x + 1, x + lim);
    register int inv = qpow(lim, P - 2);
    for (i = 0; i < lim; ++i) x[i] = 1ll * x[i] * inv % P;
  }
}

int A[N], B[N], C[N];

char a[N], b[N];

int main() {
  register int i, lim(1), n;
  scanf("%s", &a);
  n = strlen(a);
  for (i = 0; i < n; ++i) A[i] = a[n - i - 1] - '0';
  while (lim < (n << 1)) lim <<= 1;
  scanf("%s", &b);
  n = strlen(b);
  for (i = 0; i < n; ++i) B[i] = b[n - i - 1] - '0';
  while (lim < (n << 1)) lim <<= 1;
  for (i = 0; i < lim; ++i) r[i] = (i & 1) * (lim >> 1) + (r[i >> 1] >> 1);
  ntt(A, lim, 1);
  ntt(B, lim, 1);
  for (i = 0; i < lim; ++i) C[i] = 1ll * A[i] * B[i] % P;
  ntt(C, lim, -1);
  int len(0);
  for (i = 0; i < lim; ++i) {
    if (C[i] >= 10) len = i + 1, C[i + 1] += C[i] / 10, C[i] %= 10;
    if (C[i]) len = max(len, i);
  }
  while (C[len] >= 10) C[len + 1] += C[len] / 10, C[len] %= 10, len++;
  for (i = len; ~i; --i) putchar(C[i] + '0');
  puts("");
  return 0;
}
```

## ln-exp
## 描述

给定多项式 $f(x)$ ，求模 $x^{n}$ 意义下的 $\ln{f(x)}$ 与 $\exp{f(x)}$ 。

## 解法

### 普通方法

* * *

首先，对于多项式 $f(x)$ ，若 $\ln{f(x)}$ 存在，则由其 [定义](../intro/#_5) ，其必须满足：

$$
[x^{0}]f(x)=1
$$

对 $\ln{f(x)}$ 求导再积分，可得：

$$
\begin{aligned}
    \frac{\mathrm{d} \ln{f(x)}}{\mathrm{d} x} & \equiv \frac{f'(x)}{f(x)} & \pmod{x^{n}} \\
    \ln{f(x)} & \equiv \int \mathrm{d} \ln{x} \equiv \int\frac{f'(x)}{f(x)} \mathrm{d} x & \pmod{x^{n}}
\end{aligned}
$$

多项式的求导，积分时间复杂度为 $O(n)$ ，求逆时间复杂度为 $O(n\log{n})$ ，故多项式求 $\ln$ 时间复杂度 $O(n\log{n})$ 。

* * *

首先，对于多项式 $f(x)$ ，若 $\exp{f(x)}$ 存在，则其必须满足：

$$
[x^{0}]f(x)=0
$$

否则 $\exp{f(x)}$ 的常数项不收敛。

对 $\exp{f(x)}$ 求导，可得：

$$
\frac{\mathrm{d} \exp{f(x)}}{\mathrm{d} x} \equiv \exp{f(x)}f'(x)\pmod{x^{n}}
$$

比较两边系数可得：

$$
[x^{n-1}]\frac{\mathrm{d} \exp{f(x)}}{\mathrm{d} x} = \sum_{i = 0}^{n - 1} \left([x^{i}]\exp{f(x)}\right) \left([x^{n-i-1}]f'(x)\right)
$$

$$
n[x^{n}]\exp{f(x)} = \sum_{i = 0}^{n} \left([x^{i}]\exp{f(x)}\right) \left((n - i + 1)[x^{n - i}]f(x)\right)
$$

又 $[x^{0}]f(x)=0$ ，则：

$$
n[x^{n}]\exp{f(x)} = \sum_{i = 0}^{n - 1} \left([x^{i}]\exp{f(x)}\right) \left((n - i + 1)[x^{n - i}]f(x)\right)
$$

使用分治 FFT 即可解决。

时间复杂度 $O(n\log^{2}{n})$ 。

### Newton's Method

使用 [ **Newton's Method** ](./newton.md#newtons-method) 即可在 $O(n\log{n})$ 的时间复杂度内解决多项式 $\exp$ 。

## 代码

??? "多项式 ln/exp"
    ```cpp
    constexpr int maxn = 262144;
    constexpr int mod = 998244353;
    
    using i64 = long long;
    using poly_t = int[maxn];
    using poly = int *const;
    
    inline void derivative(const poly &h, const int n, poly &f) {
      for (int i = 1; i != n; ++i) f[i - 1] = (i64)h[i] * i % mod;
      f[n - 1] = 0;
    }
    
    inline void integrate(const poly &h, const int n, poly &f) {
      for (int i = n - 1; i; --i) f[i] = (i64)h[i - 1] * inv[i] % mod;
      f[0] = 0; /* C */
    }
    
    void polyln(const poly &h, const int n, poly &f) {
      /* f = ln h = ∫ h' / h dx */
      assert(h[0] == 1);
      static poly_t ln_t;
      const int t = n << 1;
    
      derivative(h, n, ln_t);
      std::fill(ln_t + n, ln_t + t, 0);
      polyinv(h, n, f);
    
      DFT(ln_t, t);
      DFT(f, t);
      for (int i = 0; i != t; ++i) ln_t[i] = (i64)ln_t[i] * f[i] % mod;
      IDFT(ln_t, t);
    
      integrate(ln_t, n, f);
    }
    
    void polyexp(const poly &h, const int n, poly &f) {
      /* f = exp(h) = f_0 (1 - ln f_0 + h) */
      assert(h[0] == 0);
      static poly_t exp_t;
      std::fill(f, f + n + n, 0);
      f[0] = 1;
      for (int t = 2; t <= n; t <<= 1) {
        const int t2 = t << 1;
    
        polyln(f, t, exp_t);
        exp_t[0] = sub(pls(h[0], 1), exp_t[0]);
        for (int i = 1; i != t; ++i) exp_t[i] = sub(h[i], exp_t[i]);
        std::fill(exp_t + t, exp_t + t2, 0);
    
        DFT(f, t2);
        DFT(exp_t, t2);
        for (int i = 0; i != t2; ++i) f[i] = (i64)f[i] * exp_t[i] % mod;
        IDFT(f, t2);
    
        std::fill(f + t, f + t2, 0);
      }
    }
    ```

## 例题

1.  计算 $f^{k}(x)$ 

普通做法为多项式快速幂，时间复杂度 $O(n\log{n}\log{k})$ 。

当 $[x^{0}]f(x)=1$ 时，有：

$$
f^{k}(x)=\exp{(k\ln{f(x)})}
$$

当 $[x^{0}]f(x)\neq 1$ 时，设 $f(x)$ 的最低次项为 $f_{i}x^{i}$ ，则：

$$
f^{k}(x)=f_{i}^{k}x^{ik}\exp{(k\ln{\frac{f(x)}{f_{i}x^{i}}})}
$$

时间复杂度 $O(n\log{n})$ 。

## intro
## 前置知识

FFT，多项式乘法

## Basic Concepts

### 多项式的度

对于一个多项式 $f(x)$ ，称其最高次项的次数为该多项式的 **度（Degree）** ，记作 $\operatorname{deg}{f}$ 。

### 多项式的逆元

对于多项式 $f(x)$ ，若存在 $g(x)$ 满足：

$$
\begin{aligned}
	f(x) g(x) & \equiv 1 \pmod{x^{n}} \\
	\operatorname{deg}{g} & \le \operatorname{deg}{f}
\end{aligned}
$$

则称 $g(x)$ 为 $f(x)$ 在模 $x^{n}$ 意义下的 **逆元（Inverse Element）** ，记作 $f^{-1}(x)$ 。

### 多项式的余数和商

对于多项式 $f(x), g(x)$ ，存在 **唯一** 的 $Q(x), R(x)$ 满足：

$$
\begin{aligned}
    f(x) &= Q(x) g(x) + R(x) \\
    \operatorname{deg}{Q} &= \operatorname{deg}{f} - \operatorname{deg}{g} \\
    \operatorname{deg}{R} &< \operatorname{deg}{g}
\end{aligned}
$$

我们称 $Q(x)$ 为 $g(x)$ 除 $f(x)$ 的 **商（Quotient）** ， $R(x)$ 为 $g(x)$ 除 $f(x)$ 的 **余数（Remainder）** 。
亦可记作

$$
f(x) \equiv R(x) \pmod{g(x)}
$$

### <span id="ln-exp">多项式的对数函数与指数函数</span>

对于一个多项式 $f(x)$ ，可以将其对数函数看作其与麦克劳林级数的复合：

$$
\ln{(1 - f(x))} = -\sum_{i = 1}^{+\infty} \frac{f^{i}(x)}{i}\\
\ln{(1 + f(x))} = \sum_{i = 1}^{+\infty} \frac{(-1)^{i - 1}f^{i}(x)}{i}
$$

其指数函数同样可以这样定义：

$$
\exp{f(x)} = e^{f(x)} = \sum_{i = 0}^{+\infty} \frac{f^{i}(x)}{i!}
$$

### 多项式的多点求值和插值

 **多项式的多点求值（Multi-point evaluation）** 即给出一个多项式 $f(x)$ 和 $n$ 个点 $x_{1}, x_{2}, \dots, x_{n}$ ，求

$$
f(x_{1}), f(x_{2}), \dots, f(x_{n})
$$

 **多项式的插值（Interpolation）** 即给出 $n + 1$ 个点

$$
(x_{0}, y_{0}), (x_{1}, y_{1}), \dots, (x_{n}, y_{n})
$$

求一个 $n$ 次多项式 $f(x)$ 使得这 $n + 1$ 个点都在 $f(x)$ 上。

这两种操作的实质就是将多项式在 **系数表示** 和 **点值表示** 间转化。

## References

-    [ **Picks's Blog** ](https://picks.logdown.com) 
-    [ **Miskcoo's Space** ](https://blog.miskcoo.com) 

## tri-func
## 描述

给定多项式 $f\left(x\right)$ ，求模 $x^{n}$ 意义下的 $\sin{f\left(x\right)}, \cos{f\left(x\right)}$ 与 $\tan{f\left(x\right)}$ 。

## 解法

首先由 [Euler's formula](https://en.wikipedia.org/wiki/Euler's_formula)  $\left(e^{ix} = \cos{x} + i\sin{x}\right)$ 可以得到 [三角函数的另一个表达式](https://en.wikipedia.org/wiki/Trigonometric_functions#Relationship_to_exponential_function_and_complex_numbers) ：

$$
\begin{aligned}
	\sin{x} &= \frac{e^{ix} + e^{-ix}}{2i} \\
	\cos{x} &= \frac{e^{ix} - e^{-ix}}{2}
\end{aligned}
$$

那么代入 $f\left(x\right)$ 就有：

$$
\begin{aligned}
	\sin{f\left(x\right)} &= \frac{\exp{\left(if\left(x\right)\right)} - \exp{\left(-if\left(x\right)\right)}}{2i} \\
	\cos{f\left(x\right)} &= \frac{\exp{\left(if\left(x\right)\right)} + \exp{\left(-if\left(x\right)\right)}}{2}
\end{aligned}
$$

注意到我们是在 $\mathbb{Z}_{998244353}$ 上做 NTT，那么相应地，虚数单位 $i$ 应该换成 $\sqrt{-1} \equiv \sqrt{998244352} \equiv 86583718 \pmod{998244353}$ 。

直接按式子求就完了。

~~啥？你问 $\tan{f\left(x\right)}$ 怎么求？回去学高中数学必修四吧。webp~~

## 代码

??? "多项式三角函数"
    ```cpp
    constexpr int maxn = 262144;
    constexpr int mod = 998244353;
    constexpr int imgunit = 86583718; /* sqrt(-1) = sqrt(998233452) */
    
    using i64 = long long;
    using poly_t = int[maxn];
    using poly = int *const;
    
    void polytri(const poly &h, const int n, poly &sin_t, poly &cos_t) {
      /* sin(f) = (exp(i * f) - exp(- i * f)) / 2i */
      /* cos(f) = (exp(i * f) + exp(- i * f)) / 2 */
      /* tan(f) = sin(f) / cos(f) */
      assert(h[0] == 0);
      static poly_t tri1_t, tri2_t;
    
      for (int i = 0; i != n; ++i) tri2_t[i] = (i64)h[i] * imgunit % mod;
      polyexp(tri2_t, n, tri1_t);
      polyinv(tri1_t, n, tri2_t);
    
      if (sin_t != nullptr) {
        const int invi = fpow(pls(imgunit, imgunit), mod - 2);
        for (int i = 0; i != n; ++i)
          sin_t[i] = (i64)(tri1_t[i] - tri2_t[i] + mod) * invi % mod;
      }
      if (cos_t != nullptr) {
        for (int i = 0; i != n; ++i) cos_t[i] = div2(pls(tri1_t[i], tri2_t[i]));
      }
    }
    ```

## div-mod
## 描述

给定多项式 $f\left(x\right),g\left(x\right)$ ，求 $g\left(x\right)$ 除 $f\left(x\right)$ 的商 $Q\left(x\right)$ 和余数 $R\left(x\right)$ 。

## 解法

发现若能消除 $R\left(x\right)$ 的影响则可直接 [ **多项式求逆** ](../inv) 解决。

考虑构造变换

$$
f^{R}\left(x\right)=x^{\operatorname{deg}{f}}f\left(\frac{1}{x}\right)
$$

观察可知其实质为反转 $f\left(x\right)$ 的系数。

设 $n=\operatorname{deg}{f},m=\operatorname{deg}{g}$ 。

将 $f\left(x\right)=Q\left(x\right)g\left(x\right)+R\left(x\right)$ 中的 $x$ 替换成 $\frac{1}{x}$ 并将其两边都乘上 $x^{n}$ ，得到：

$$
\begin{aligned}
    x^{n}f\left(\frac{1}{x}\right)&=x^{n-m}Q\left(x\right)x^{m}g\left(x\right)+x^{n-m+1}x^{m-1}R\left(x\right)\\
    f^{R}\left(x\right)&=Q^{R}\left(x\right)g^{R}\left(x\right)+x^{n-m+1}R^{R}\left(x\right)
\end{aligned}
$$

注意到上式中 $R^{R}\left(x\right)$ 的系数为 $x^{n-m+1}$ ，则将其放到模 $x^{n-m+1}$ 意义下即可消除 $R^{R}\left(x\right)$ 带来的影响。

又因 $Q^{R}\left(x\right)$ 的次数为 $\left(n-m\right)<\left(n-m+1\right)$ ，故 $Q^{R}\left(x\right)$ 不会受到影响。

则：

$$
f^{R}\left(x\right)\equiv Q^{R}\left(x\right)g^{R}\left(x\right)\pmod{x^{n-m+1}}
$$

使用多项式求逆即可求出 $Q\left(x\right)$ ，将其反代即可得到 $R\left(x\right)$ 。

时间复杂度 $O\left(n\log{n}\right)$ 。

## fwt
author: Xeonacid

（本文转载自 [桃酱的算法笔记](https://zhuanlan.zhihu.com/c_1005817911142838272) ，原文戳 [链接](https://zhuanlan.zhihu.com/p/41867199) ，已获得作者授权）

## 简介

> 沃尔什转换（Walsh Transform）是在频谱分析上作为离散傅立叶变换的替代方案的一种方法。—— [维基百科](https://zh.wikipedia.org/zh-cn/%E6%B2%83%E7%88%BE%E4%BB%80%E8%BD%89%E6%8F%9B) 

其实这个变换在信号处理中应用很广泛，fft 是 double 类型的，但是 walsh 把信号在不同震荡频率方波下拆解，因此所有的系数都是绝对值大小相同的整数，这使得不需要作浮点数的乘法运算，提高了运算速度。

所以，FWT 和 FFT 的核心思想应该是相同的，都是对数组的变换。我们记对数组 $A$ 进行快速沃尔什变换后得到的结果为 $FWT[A]$ 。

那么 FWT 核心思想就是：

我们需要一个新序列 $C$ ，由序列 $A$ 和序列 $B$ 经过某运算规则得到，即 $C = A \cdot B$ ；

我们先正向得到 $FWT[A], FWT[B]$ ，再根据 $FWT[C]=FWT[A] \cdot FWT[B]$ 在 $O(n)$ 的时间复杂度内求出 $FWT[C]$ ；

然后逆向运算得到原序列 $C$ 。时间复杂度为 $O(n \log{n})$ 。

在算法竞赛中，FWT 是用于解决对下标进行位运算卷积问题的方法。

公式： $C_{i} = \sum_{i=j \bigoplus k}A_{j} B_{k}$ 

（其中 $\bigoplus$ 是二元位运算中的某一种， $*$ 是普通乘法）

## FWT 的运算

### FWT 之与（ $\And$ ）运算和或（ $|$ ）运算

与运算和或运算的本质是差不多的，所以这里讲一下或运算，与运算也是可以自己根据公式 yy 出来的。

### 或运算 $A_i$ 

如果有 $k=i|j$ ，那么 $i$ 的二进制位为 $1$ 的位置和 $j$ 的二进制位为 $1$ 的位置肯定是 $k$ 的二进制位为 $1$ 的位置的子集。

现在要得到 $FWT[C] = FWT[A] * FWT[B]$ ，我们就要构造这个 fwt 的规则。

我们按照定义，显然可以构造 $FWT[A] = A' = \sum_{i=i|j}A_{j}$ ，来表示 $j$ 满足二进制中 $1$ 为 $i$ 的子集。

那么显然会有 $C_{i} = \sum_{i=j|k}A_{j}*B_{k} \Rightarrow FWT[C] = FWT[A] * FWT[B]$ 

那么我们接下来看 $FWT[A]$ 怎么求。

首先肯定不能枚举了，复杂度为 $O(n^2)$ 。既然不能整体枚举，我们就考虑分治。

我们把整个区间二分，其实二分区间之后，下标写成二进制形式是有规律可循的。

我们令 $A_0$ 表示 $A$ 的前一半， $A_1$ 表示区间的后一半，那么 $A_0$ 就是 A 下标最大值的最高位为 $0$ ，他的子集就是他本身的子集（因为最高位为 $0$ 了），但是 $A_1$ 的最高位是 $1$ ，他满足条件的子集不仅仅是他本身，还包最高位为 $0$ 的子集，即

$$
FWT[A] = merge(FWT[A_0], FWT[A_0] + FWT[A_1])
$$

其中 merge 表示像字符串拼接一样把它们拼起来， $+$ 就是普通加法，表示对应二进制位相加。

这样我们就通过二分能在 $O(\log{n})$ 的时间复杂度内完成拼接，每次拼接的时候要完成一次运算，也就是说在 $O(n\log{n})$ 的时间复杂度得到了 $FWT[A]$ 。

接下来就是反演了，其实反演是很简单的，既然知道了 $A_0$ 的本身的子集是他自己 ( $A_0 = FAT[A_0]$ )， $A_1$ 的子集是 $FAT[A_0] + FAT[A_1]（A_1'= A_0' + A_1'$ ），那就很简单的得出反演的递推式了：

$$
UFWT[A'] = merge(UFWT[A_0'], UFWT[A_1'] - UFWT[A_0'])
$$

### 与运算

与运算类比或运算可以得到类似结论

$$
FWT[A] = merge(FWT[A_0] + FWT[A_1], FWT[A_1])
$$

$$
UFWT[A'] = merge(UFWT[A_0'] - UFWT[A_1'], UFWT[A_1'])
$$

### 异或运算

最常考的异或运算。

异或的卷积是基于如下原理：

若我们令 $i\And j$ 中 $1$ 数量的奇偶性为 $i$ 与 $j$ 的奇偶性，那么 $i$ 与 $k$ 的奇偶性异或 $j$ 和 $k$ 的奇偶性等于 $i \operatorname{xor} j$ 和 $k$ 的奇偶性。

对于 $FWT[A]$ 的运算其实也很好得到。

公式如下：

 $A_{i} = \sum_{C_1}A_{j} - \sum_{C_2}A_{j}$ ( $C_1$ 表示 $i \And j$ 奇偶性为 $0$ ， $C_2$ 表示 $i \And j$ 的奇偶性为 $1$ )

结论：

$$
FWT[A] = merge(FWT[A_0] + FWT[A_1], FWT[A_0] - FWT[A_1])
$$

$$
UFWT[A'] - merge(\frac{FWT[A_0'] + FWT[A_1']}{2}, \frac{FWT[A_0'] - FWT[A_1']}{2})
$$

### 同或运算

类比异或运算给出公式：

 $A_{i} = \sum_{C_1}A_{j} - \sum_{C_2}A_{j}$ ( $C_1$ 表示 $i|j$ 奇偶性为 $0$ ， $C_2$ 表示 $i|j$ 的奇偶性为 $1$ )

$$
FWT[A] = merge(FWT[A_1] - FWT[A_0], FWT[A_1] + FWT[A_0])
$$

$$
UFWT[A'] = merge(\frac{FWT[A_1'] - FWT[A_0']}{2}, \frac{FWT[A_1'] + FWT[A_0']}{2})
$$

## inv-tri-func
## 描述

给定多项式 $f\left(x\right)$ ，求模 $x^{n}$ 意义下的 $\arcsin{f\left(x\right)}, \arccos{f\left(x\right)}$ 与 $\arctan{f\left(x\right)}$ 。

## 解法

仿照求多项式 $\ln$ 的方法，对反三角函数求导再积分可得：

$$
\begin{aligned}
	\frac{\mathrm{d}}{\mathrm{d} x} \arcsin{x} &= \frac{1}{\sqrt{1 - x^{2}}} \\
	\arcsin{x} &= \int \frac{1}{\sqrt{1 - x^{2}}} \mathrm{d} x \\
	\frac{\mathrm{d}}{\mathrm{d} x} \arccos{x} &= - \frac{1}{\sqrt{1 - x^{2}}} \\
	\arccos{x} &= - \int \frac{1}{\sqrt{1 - x^{2}}} \mathrm{d} x \\
	\frac{\mathrm{d}}{\mathrm{d} x} \arctan{x} &= \frac{1}{1 + x^{2}} \\
	\arctan{x} &= \int \frac{1}{1 + x^{2}} \mathrm{d} x
\end{aligned}
$$

那么代入 $f\left(x\right)$ 就有：

$$
\begin{aligned}
	\frac{\mathrm{d}}{\mathrm{d} x} \arcsin{f\left(x\right)} &= \frac{f'\left(x\right)}{\sqrt{1 - f^{2}\left(x\right)}} \\
	\arcsin{f\left(x\right)} &= \int \frac{f'\left(x\right)}{\sqrt{1 - f^{2}\left(x\right)}} \mathrm{d} x \\
	\frac{\mathrm{d}}{\mathrm{d} x} \arccos{f\left(x\right)} &= - \frac{f'\left(x\right)}{\sqrt{1 - f^{2}\left(x\right)}} \\
	\arccos{f\left(x\right)} &= - \int \frac{f'\left(x\right)}{\sqrt{1 - f^{2}\left(x\right)}} \mathrm{d} x \\
	\frac{\mathrm{d}}{\mathrm{d} x} \arctan{f\left(x\right)} &= \frac{f'\left(x\right)}{1 + f^{2}\left(x\right)} \\
	\arctan{f\left(x\right)} &= \int \frac{f'\left(x\right)}{1 + f^{2}\left(x\right)} \mathrm{d} x
\end{aligned}
$$

直接按式子求就可以了。

## 代码

??? "多项式反三角函数"
    ```cpp
    constexpr int maxn = 262144;
    constexpr int mod = 998244353;
    
    using i64 = long long;
    using poly_t = int[maxn];
    using poly = int *const;
    
    inline void derivative(const poly &h, const int n, poly &f) {
      for (int i = 1; i != n; ++i) f[i - 1] = (i64)h[i] * i % mod;
      f[n - 1] = 0;
    }
    
    inline void integrate(const poly &h, const int n, poly &f) {
      for (int i = n - 1; i; --i) f[i] = (i64)h[i - 1] * inv[i] % mod;
      f[0] = 0; /* C */
    }
    
    void polyarcsin(const poly &h, const int n, poly &f) {
      /* arcsin(f) = ∫ f' / sqrt(1 - f^2) dx  */
      static poly_t arcsin_t;
      const int t = n << 1;
      std::copy(h, h + n, arcsin_t);
      std::fill(arcsin_t + n, arcsin_t + t, 0);
    
      DFT(arcsin_t, t);
      for (int i = 0; i != t; ++i) arcsin_t[i] = sqr(arcsin_t[i]);
      IDFT(arcsin_t, t);
    
      arcsin_t[0] = sub(1, arcsin_t[0]);
      for (int i = 1; i != n; ++i)
        arcsin_t[i] = arcsin_t[i] ? mod - arcsin_t[i] : 0;
    
      polysqrt(arcsin_t, n, f);
      polyinv(f, n, arcsin_t);
      derivative(h, n, f);
    
      DFT(f, t);
      DFT(arcsin_t, t);
      for (int i = 0; i != t; ++i) arcsin_t[i] = (i64)f[i] * arcsin_t[i] % mod;
      IDFT(arcsin_t, t);
    
      integrate(arcsin_t, n, f);
    }
    
    void polyarccos(const poly &h, const int n, poly &f) {
      /* arccos(f) = - ∫ f' / sqrt(1 - f^2) dx  */
      polyarcsin(h, n, f);
      for (int i = 0; i != n; ++i) f[i] = f[i] ? mod - f[i] : 0;
    }
    
    void polyarctan(const poly &h, const int n, poly &f) {
      /* arctan(f) = ∫ f' / (1 + f^2) dx  */
      static poly_t arctan_t;
      const int t = n << 1;
      std::copy(h, h + n, arctan_t);
      std::fill(arctan_t + n, arctan_t + t, 0);
    
      DFT(arctan_t, t);
      for (int i = 0; i != t; ++i) arctan_t[i] = sqr(arctan_t[i]);
      IDFT(arctan_t, t);
    
      inc(arctan_t[0], 1);
      std::fill(arctan_t + n, arctan_t + t, 0);
    
      polyinv(arctan_t, n, f);
      derivative(h, n, arctan_t);
    
      DFT(f, t);
      DFT(arctan_t, t);
      for (int i = 0; i != t; ++i) arctan_t[i] = (i64)f[i] * arctan_t[i] % mod;
      IDFT(arctan_t, t);
    
      integrate(arctan_t, n, f);
    }
    ```

## sqrt
## 描述

给定多项式 $g\left(x\right)$ ，求 $f\left(x\right)$ ，满足：

$$
f^{2}\left(x\right)\equiv g\left(x\right) \pmod{x^{n}}
$$

## 解法

### 倍增法

假设现在已经求出了 $g\left(x\right)$ 在模 $x^{\left\lceil\frac{n}{2}\right\rceil}$ 意义下的平方根 $f_{0}\left(x\right)$ ，则有：

$$
\begin{aligned}
	f_{0}^{2}\left(x\right)&\equiv g\left(x\right) &\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}\\
	f_{0}^{2}\left(x\right)-g\left(x\right)&\equiv 0 &\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}\\
	\left(f_{0}^{2}\left(x\right)-g\left(x\right)\right)^{2}&\equiv 0 &\pmod{x^{n}}\\
	\left(f_{0}^{2}\left(x\right)+g\left(x\right)\right)^{2}&\equiv 4f_{0}^{2}\left(x\right)g\left(x\right) &\pmod{x^{n}}\\
	\left(\frac{f_{0}^{2}\left(x\right)+g\left(x\right)}{2f_{0}\left(x\right)}\right)^{2}&\equiv g\left(x\right) &\pmod{x^{n}}\\
	\frac{f_{0}^{2}\left(x\right)+g\left(x\right)}{2f_{0}\left(x\right)}&\equiv f\left(x\right) &\pmod{x^{n}}\\
	2^{-1}f_{0}\left(x\right)+2^{-1}f_{0}^{-1}\left(x\right)g\left(x\right)&\equiv f\left(x\right) &\pmod{x^{n}}
\end{aligned}
$$

倍增计算即可。

时间复杂度

$$
T\left(n\right)=T\left(\frac{n}{2}\right)+O\left(n\log{n}\right)=O\left(n\log{n}\right)
$$

还有一种常数较小的写法就是在倍增维护 $f\left(x\right)$ 的时候同时维护 $f^{-1}\left(x\right)$ 而不是每次都求逆。

> 当 $\left[x^{0}\right]g\left(x\right)\neq 1$ 时，可能需要使用二次剩余来计算 $\left[x^{0}\right]f\left(x\right)$ 。

??? "洛谷模板题 [P5205 【模板】多项式开根](https://www.luogu.com.cn/problem/P5205) 参考代码"
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    const int maxn = 1 << 20, mod = 998244353;
    
    int a[maxn], b[maxn], g[maxn], gg[maxn];
    
    int qpow(int x, int y) {
      int ans = 1;
    
      while (y) {
        if (y & 1) {
          ans = 1LL * ans * x % mod;
        }
        x = 1LL * x * x % mod;
        y >>= 1;
      }
      return ans;
    }
    
    int inv2 = qpow(2, mod - 2);
    
    inline void change(int *f, int len) {
      for (int i = 1, j = len >> 1; i < len - 1; i++) {
        if (i < j) {
          swap(f[i], f[j]);
        }
    
        int k = len >> 1;
        while (j >= k) {
          j -= k;
          k >>= 1;
        }
        if (j < k) {
          j += k;
        }
      }
    }
    
    inline void NTT(int *f, int len, int type) {
      change(f, len);
    
      for (int q = 2; q <= len; q <<= 1) {
        int nxt = qpow(3, (mod - 1) / q);
        for (int i = 0; i < len; i += q) {
          int w = 1;
    
          for (int k = i; k < i + (q >> 1); k++) {
            int x = f[k];
            int y = 1LL * w * f[k + (q >> 1)] % mod;
    
            f[k] = (x + y) % mod;
            f[k + (q >> 1)] = (x - y + mod) % mod;
            w = 1LL * w * nxt % mod;
          }
        }
      }
    
      if (type == -1) {
        reverse(f + 1, f + len);
        int iv = qpow(len, mod - 2);
    
        for (int i = 0; i < len; i++) {
          f[i] = 1LL * f[i] * iv % mod;
        }
      }
    }
    
    inline void inv(int deg, int *f, int *h) {
      if (deg == 1) {
        h[0] = qpow(f[0], mod - 2);
        return;
      }
    
      inv(deg + 1 >> 1, f, h);
    
      int len = 1;
      while (len < deg << 1) {
        len <<= 1;
      }
    
      copy(f, f + deg, gg);
      fill(gg + deg, gg + len, 0);
    
      NTT(gg, len, 1);
      NTT(h, len, 1);
      for (int i = 0; i < len; i++) {
        h[i] = 1LL * (2 - 1LL * gg[i] * h[i] % mod + mod) % mod * h[i] % mod;
      }
    
      NTT(h, len, -1);
      fill(h + deg, h + len, 0);
    }
    
    int n, t[maxn];
    
    inline void sqrt(int deg, int *f, int *h) {
      if (deg == 1) {
        h[0] = 1;
        return;
      }
    
      sqrt(deg + 1 >> 1, f, h);
    
      int len = 1;
      while (len < deg << 1) {
        len <<= 1;
      }
      fill(g, g + len, 0);
      inv(deg, h, g);
      copy(f, f + deg, t);
      fill(t + deg, t + len, 0);
      NTT(t, len, 1);
      NTT(g, len, 1);
      NTT(h, len, 1);
    
      for (int i = 0; i < len; i++) {
        h[i] = 1LL * inv2 * (1LL * h[i] % mod + 1LL * g[i] * t[i] % mod) % mod;
      }
      NTT(h, len, -1);
      fill(h + deg, h + len, 0);
    }
    
    int main() {
      cin >> n;
    
      for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
      }
      sqrt(n, a, b);
    
      for (int i = 0; i < n; i++) {
        printf("%d ", b[i]);
      }
    
      return 0;
    }
    ```

### Newton's Method

参见 [ **Newton's Method** ](./newton.md#newtons-method) .

## 例题

1.   [ **「Codeforces Round #250」E. The Child and Binary Tree** ](https://codeforces.com/contest/438/problem/E) 

## lagrange
author: Ir1d, TrisolarisHD, YanWQ-monad, x4Cx58x54

!!! note "例题 [Luogu P4781【模板】拉格朗日插值](https://www.luogu.org/problemnew/show/P4781)"

### 题目大意

给出 $n$ 个点 $P_i(x_i,y_i)$ ，将过这 $n$ 个点的最多 $n-1$ 次的多项式记为 $f(x)$ ，求 $f(k)$ 的值。

### 方法 1：差分法

差分法适用于 $x_i=i$ 的情况。

如，用差分法求某三次多项式 $f(x)=\sum_{i=0}^{3} a_ix^i$ 的多项式形式，已知 $f(1)$ 至 $f(6)$ 的值分别为 $1, 5, 14, 30, 55, 91$ 。

$$
\begin{array}{cccccccccccc}
&  1 &    &  5 &    & 14 &    & 30 &    & 55 &    & 91 & \\
&    &  4 &    &  9 &    & 16 &    & 25  &    & 36 & \\
&    &    &  5 &    &  7 &    &  9 &    &  11 & \\
&    &    &    &  2 &    &  2 &    &  2 & \\
\end{array}
$$

第一行为 $f(x)$ 的连续的前 $n$ 项；之后的每一行为之前一行中对应的相邻两项之差。观察到，如果这样操作的次数足够多（前提是 $f(x)$ 为多项式），最终总会返回一个定值，可以利用这个定值求出 $f(x)$ 的每一项的系数，然后即可将 $k$ 代入多项式中求解。上例中可求出 $f(x)=\frac 1 3 x^3+\frac 1 2 x^2+\frac 1 6 x$ 。时间复杂度为 $O(n^2)$ 。这种方法对给出的点的限制性较强。

### 方法 2：待定系数法

设 $f(x)=\sum_{i=0}^{n-1} a_ix^i$ 将每个 $x_i$ 代入 $f(x)$ ，有 $f(x_i)=y_i$ ，这样就可以得到一个由 $n$ 条 $n$ 元一次方程所组成的方程组，然后使用 **高斯消元** 解该方程组求出每一项 $a_i$ ，即确定了 $f(x)$ 的表达式。

如果您不知道什么是高斯消元，请看 [高斯消元](../gauss.md) 。

时间复杂度 $O(n^3)$ ，对给出点的坐标无要求。

### 方法 3：拉格朗日插值法

如图所示，将每一个点 $(x_i, y_i)$ 在 $x$ 轴上的投影 $(x_i, 0)$ 记为 $H_i$ 。对每一个 $i$ ，我们选择一个点集 $\lbrace P_i\rbrace \cup \lbrace H_j \vert 1 \le i\le n, j \neq i\rbrace$ ，作过这 $n$ 个点的至多 $n-1$ 次的线 $g_i(x)$ 。图中 $f(x)$ 用黑线表示， $g_i(x)$ 用彩色线表示。

![example](./images/lagrange-interpolation.png)

这样，我们得到了 $n$ 个 $g_i(x)\;(1 \le i \le n)$ ，它们都在各自对应的 $x_i$ 处的值为 $y_i$ ，并且在其它 $x_j\ (j \neq i)$ 处值为 $0$ 。所以很容易构造出 $g_i(x)$ 的表达式：

$$
g_i(x) = y_i\prod_{j\neq i }\frac{x-x_j}{x_i-x_j}.
$$

很容易通过将每一个 $x_i$ 代入上式以验证此其正确性。最后，我们所求的 $f(x)=\sum_{i=1}^{n}g_i(x)$ ，即各 $g_i(x)$ 之和。因为对于每一个 $i$ ，都只有一条 $g_i$ 经过 $P_i$ ，其余 $g_j$ 都经过 $H_i$ ，故它们相加后在 $x_i$ 的取值仍为 $y_i$ ，即最后的和函数总是过所有 $P_i$ 的。

公式整理得：

$$
f(x)=\sum_{i=1}^{n} y_i\prod_{j\neq i }\frac{x-x_j}{x_i-x_j}
$$

如果要将每一项的系数都算出来，时间复杂度仍为 $O(n^2)$ ，但是本题中只用求出 $f(k)$ 的值，所以在计算上式的过程中直接将 $k$ 代入即可。

$$
f(k)=\sum_{i=1}^{n} y_i\prod_{j\neq i }\frac{k-x_j}{x_i-x_j}
$$

本题中，还需要求解逆元。如果先分别计算出分子和分母，再将分子乘进分母的逆元，累加进最后的答案，时间复杂度的瓶颈就不会在求逆元上，时间复杂度为 $O(n^2)$ 。

### 代码实现

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
const int maxn = 2010;
using ll = long long;
ll mod = 998244353;
ll n, k, x[maxn], y[maxn], ans, s1, s2;
ll powmod(ll a, ll x) {
  ll ret = 1ll, nww = a;
  while (x) {
    if (x & 1) ret = ret * nww % mod;
    nww = nww * nww % mod;
    x >>= 1;
  }
  return ret;
}
ll inv(ll x) { return powmod(x, mod - 2); }
int main() {
  scanf("%lld%lld", &n, &k);
  for (int i = 1; i <= n; i++) scanf("%lld%lld", x + i, y + i);
  for (int i = 1; i <= n; i++) {
    s1 = y[i] % mod;
    s2 = 1ll;
    for (int j = 1; j <= n; j++)
      if (i != j)
        s1 = s1 * (k - x[j]) % mod, s2 = s2 * ((x[i] - x[j] % mod) % mod) % mod;
    ans += s1 * inv(s2) % mod;
    ans = (ans + mod) % mod;
  }
  printf("%lld\n", ans);
  return 0;
}
```

## multipoint-eval-interpolation
## 多项式的多点求值

### 描述

给出一个多项式 $f\left(x\right)$ 和 $n$ 个点 $x_{1},x_{2},...,x_{n}$ ，求

$$
f\left(x_{1}\right),f\left(x_{2}\right),...,f\left(x_{n}\right)
$$

### 解法

考虑使用分治来将问题规模减半。

将给定的点分为两部分：

$$
\begin{aligned}
	X_{0}&=\left\{x_{1},x_{2},...,x_{\left\lfloor\frac{n}{2}\right\rfloor}\right\}\\
	X_{1}&=\left\{x_{\left\lfloor\frac{n}{2}\right\rfloor+1},x_{\left\lfloor\frac{n}{2}\right\rfloor+2},...,x_{n}\right\}
\end{aligned}
$$

构造多项式

$$
g_{0}\left(x\right)=\prod_{x_{i}\in X_{0}}\left(x-x_{i}\right)
$$

则有 $\forall x\in X_{0}:g_{0}\left(x\right)=0$ 。

考虑将 $f\left(x\right)$ 表示为 $g_{0}\left(x\right)Q\left(x\right)+f_{0}\left(x\right)$ 的形式，即：

$$
f_{0}\left(x\right)\equiv f\left(x\right)\pmod{g_{0}\left(x\right)}
$$

则有 $\forall x\in X_{0}:f\left(x\right)=g_{0}\left(x\right)Q\left(x\right)+f_{0}\left(x\right)=f_{0}\left(x\right)$ ， $X_{1}$ 同理。

至此，问题的规模被减半，可以使用分治 + 多项式取模解决。

时间复杂度

$$
T\left(n\right)=2T\left(\frac{n}{2}\right)+O\left(n\log{n}\right)=O\left(n\log^{2}{n}\right)
$$

## 多项式的快速插值

### 描述

给出一个 $n+1$ 个点的集合

$$
X=\left\{\left(x_{0},y_{0}\right),\left(x_{1},y_{1}\right),...,\left(x_{n},y_{n}\right)\right\}
$$

求一个 $n$ 次多项式 $f\left(x\right)$ 使得其满足 $\forall\left(x,y\right)\in X:f\left(x\right)=y$ 。

### 解法

考虑拉格朗日插值公式

$$
f(x) = \sum_{i=1}^{n} \prod_{j\neq i }\frac{x-x_j}{x_i-x_j} y_i
$$

记多项式 $M(x) = \prod_{i=1}^n (x - x_i)$ ，由洛必达法则可知

$$
\prod_{j\neq i} (x_i - x_j) = \lim_{x\rightarrow x_i} \frac{\prod_{j=1}^n (x - x_j)}{x - x_i} = M'(x_i)
$$

因此多项式被表示为

$$
f(x) = \sum_{i = 1}^n \frac{y_i}{M'(x_i)}\prod_{j \neq i}(x - x_j)
$$

我们首先通过分治计算出 $M(x)$ 的系数表示，接着可以通过多点求值在 $O(n\log^2 n)$ 时间内计算出所有的 $M'(x_i)$ 。

我们令 $v_i = \frac{y_i}{M'(x_i)}$ ，接下来考虑计算出 $f(x)$ 。对于 $n = 1$ 的情况，有 $f(x) = v_1, M(x) = x - x_1$ 。否则令

$$
\begin{aligned}
f_0(x) & = \sum_{i = 1}^{\left\lfloor \frac n2 \right \rfloor} v_i\prod_{j \neq i \wedge j \le \left\lfloor \frac n2 \right \rfloor}(x - x_j)\\
M_0(x) & = \prod_{i = 1}^{\left\lfloor \frac n2 \right \rfloor} (x - x_i)\\
f_1(x) & = \sum_{i = \left\lfloor \frac n2 \right \rfloor+1}^n v_i\prod_{j \neq i \wedge \left\lfloor \frac n2 \right \rfloor < j \le n}(x - x_j) \\
M_1(x) & = \prod_{i = \left\lfloor \frac n2 \right \rfloor+1}^n (x - x_i)
\end{aligned}
$$

可得 $f(x) = f_0(x)M_1(x) + f_1(x)M_0(x), M(x) = M_0(x)M_1(x)$ ，因此可以分治计算，这一部分的复杂度同样是 $O(n\log^2 n)$ 。

## newton
## 描述

给定多项式 $g\left(x\right)$ ，已知有 $f\left(x\right)$ 满足：

$$
g\left(f\left(x\right)\right)\equiv 0\pmod{x^{n}}
$$

求出模 $x^{n}$ 意义下的 $f\left(x\right)$ 。

## Newton's Method

考虑倍增。

首先当 $n=1$ 时， $\left[x^{0}\right]g\left(f\left(x\right)\right)=0$ 的解需要单独求出。

假设现在已经得到了模 $x^{\left\lceil\frac{n}{2}\right\rceil}$ 意义下的解 $f_{0}\left(x\right)$ ，要求模 $x^{n}$ 意义下的解 $f\left(x\right)$ 。

将 $g\left(f\left(x\right)\right)$ 在 $f_{0}\left(x\right)$ 处进行泰勒展开，有：

$$
\sum_{i=0}^{+\infty}\frac{g^{\left(i\right)}\left(f_{0}\left(x\right)\right)}{i!}\left(f\left(x\right)-f_{0}\left(x\right)\right)^{i}\equiv 0\pmod{x^{n}}
$$

因为 $f\left(x\right)-f_{0}\left(x\right)$ 的最低非零项次数最低为 $\left\lceil\frac{n}{2}\right\rceil$ ，故有：

$$
\forall 2\leqslant i:\left(f\left(x\right)-f_{0}\left(x\right)\right)^{i}\equiv 0\pmod{x^{n}}
$$

则：

$$
\sum_{i=0}^{+\infty}\frac{g^{\left(i\right)}\left(f_{0}\left(x\right)\right)}{i!}\left(f\left(x\right)-f_{0}\left(x\right)\right)^{i}\equiv g\left(f_{0}\left(x\right)\right)+g'\left(f_{0}\left(x\right)\right)\left(f\left(x\right)-f_{0}\left(x\right)\right)\equiv 0\pmod{x^{n}}
$$

$$
f\left(x\right)\equiv f_{0}\left(x\right)-\frac{g\left(f_{0}\left(x\right)\right)}{g'\left(f_{0}\left(x\right)\right)}\pmod{x^{n}}
$$

## 例题

### <span id="inv"> [多项式求逆](../inv) </span>

设给定函数为 $h\left(x\right)$ ，有方程：

$$
g\left(f\left(x\right)\right)=\frac{1}{f\left(x\right)}-h\left(x\right)\equiv 0\pmod{x^{n}}
$$

应用 Newton's Method 可得：

$$
\begin{aligned}
    f\left(x\right)&\equiv f_{0}\left(x\right)-\frac{\frac{1}{f_{0}\left(x\right)}-h\left(x\right)}{-\frac{1}{f_{0}^{2}\left(x\right)}}&\pmod{x^{n}}\\
    &\equiv 2f_{0}\left(x\right)-f_{0}^{2}\left(x\right)h\left(x\right)&\pmod{x^{n}}
\end{aligned}
$$

时间复杂度

$$
T\left(n\right)=T\left(\frac{n}{2}\right)+O\left(n\log{n}\right)=O\left(n\log{n}\right)
$$

### <span id="sqrt"> [多项式开方](../sqrt) </span>

设给定函数为 $h\left(x\right)$ ，有方程：

$$
g\left(f\left(x\right)\right)=f^{2}\left(x\right)-h\left(x\right)\equiv 0\pmod{x^{n}}
$$

应用 Newton's Method 可得：

$$
\begin{aligned}
    f\left(x\right)&\equiv f_{0}\left(x\right)-\frac{f_{0}^{2}\left(x\right)-h\left(x\right)}{2f_{0}\left(x\right)}&\pmod{x^{n}}\\
    &\equiv\frac{f_{0}^{2}\left(x\right)+h\left(x\right)}{2f_{0}\left(x\right)}&\pmod{x^{n}}
\end{aligned}
$$

时间复杂度

$$
T\left(n\right)=T\left(\frac{n}{2}\right)+O\left(n\log{n}\right)=O\left(n\log{n}\right)
$$

### <span id="exp"> [多项式 exp](../ln-exp) </span>

设给定函数为 $h\left(x\right)$ ，有方程：

$$
g\left(f\left(x\right)\right)=\ln{f\left(x\right)}-h\left(x\right)\pmod{x^{n}}
$$

应用 Newton's Method 可得：

$$
\begin{aligned}
    f\left(x\right)&\equiv f_{0}\left(x\right)-\frac{\ln{f_{0}\left(x\right)}-h\left(x\right)}{\frac{1}{f_{0}\left(x\right)}}&\pmod{x^{n}}\\
    &\equiv f_{0}\left(x\right)\left(1-\ln{f_{0}\left(x\right)+h\left(x\right)}\right)&\pmod{x^{n}}
\end{aligned}
$$

时间复杂度

$$
T\left(n\right)=T\left(\frac{n}{2}\right)+O\left(n\log{n}\right)=O\left(n\log{n}\right)
$$

## fft
author: AndrewWayne, GavinZhengOI. ChungZH, henryrabbit, Xeonacid, sshwy, Yukimaikoriya

前置知识： [复数](../complex.md) 。

本文将介绍一种算法，它支持在 $O(n\log n)$ 的时间内计算两个 $n$ 度的多项式的乘法，比朴素的 $O(n^2)$ 算法更高效。由于两个整数的乘法也可以被当作多项式乘法，因此这个算法也可以用来加速大整数的乘法计算。

## 概述

离散傅里叶变换（Discrete Fourier Transform，缩写为 DFT），是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其 DTFT 的频域采样。

FFT 是一种高效实现 DFT 的算法，称为快速傅立叶变换（Fast Fourier Transform，FFT）。它对傅里叶变换的理论并没有新的发现，但是对于在计算机系统或者说数字系统中应用离散傅立叶变换，可以说是进了一大步。快速数论变换 (NTT) 是快速傅里叶变换（FFT）在数论基础上的实现。

在 1965 年，Cooley 和 Tukey 发表了快速傅里叶变换算法。事实上 FFT 早在这之前就被发现过了，但是在当时现代计算机并未问世，人们没有意识到 FFT 的重要性。一些调查者认为 FFT 是由 Runge 和 König 在 1924 年发现的。但事实上高斯早在 1805 年就发明了这个算法，但一直没有发表。

## 多项式的表示

### 系数表示法

系数表示法就是用一个多项式的各个项系数来表达这个多项式，即使用一个系数序列来表示多项式：

$$
f(x) = a_0+a_1x+a_2x^2+\cdots +a_{n}x^{n} \Leftrightarrow f(x) = \{a_0, a_1, \cdots,a_{n}\}
$$

### 点值表示法

点值表示法是把这个多项式看成一个函数，从上面选取 $n+1$ 个点，从而利用这 $n+1$ 个点来唯一的表示这个函数。

为什么用 $n+1$ 个点就能唯一的表示这个函数了呢？想一下高斯消元法，两点确定一条直线。再来一个点，能确定这个直线中的另一个参数，那么也就是说 $n+1$ 个点能确定 $n$ 个参数（不考虑倍数点之类的没用点）。

设

$$
\begin{array}{c}
f(x_0) = y_0 = a_0 + a_1x_0+a_2x_0^2+a_3x_0^3+ \cdots + a_nx_0^n\\
f(x_1) = y_1 = a_0 + a_1x_1+a_2x_1^2+a_3x_1^3+ \cdots + a_nx_1^n\\
f(x_2) = y_2 = a_0 + a_1x_2+a_2x_2^2+a_3x_2^3+ \cdots + a_nx_2^n\\
\vdots\\
f(x_{n}) = y_{n} = a_0 + a_1x_{n}+a_2x_{n}^2+a_3x_{n}^3+ \cdots + a_nx_{n}^n
\end{array}
$$

那么用点值表示法表示 $f(x)$ 如下

$$
f(x) = a_0+a_1x+a_2x^2+\cdots +a_{n}x^{n} \Leftrightarrow f(x) = \{(x_0,y_0),(x_1,y_1), \cdots,(x_n,y_{n})\}
$$

通俗地说，多项式由系数表示法转为点值表示法的过程，就是 DFT 的过程。相对地，把一个多项式的点值表示法转化为系数表示法的过程，就是 IDFT。而 FFT 就是通过取某些特殊的 $x$ 的点值来加速 DFT 和 IDFT 的过程。

## 单位复根

考虑这样一个问题：

DFT 是把多项式从系数表示转到了点值表示，那么我们把点值相乘之后，如果能够快速还原成系数表示，是不是就完美解决我们的问题了呢？上述过程如下：

假设我们 DFT 过程对于两个多项式选取的 $x$ 序列相同，那么可以得到

$$
f(x)={(x_0, f(x_0)), (x_1, f(x_1)), (x_2, f(x_2)), \cdots, (x_n, f(x_n))}\\
g(x)={(x_0, g(x_0)), (x_1, g(x_1)), (x_2, g(x_2)), \cdots, (x_n, g(x_n))}
$$

如果我们设 $F(x) = f(x) \cdot g(x)$ ，那么很容易得到 $F(x)$ 的点值表达式：

$$
F(x) = \{(x_0, f(x_0)g(x_0)), (x_1, f(x_1)g(x_1)), (x_2, f(x_2)g(x_2)), \cdots, (x_n, f(x_n)g(x_n))\}
$$

但是我们要的是系数表达式，接下来问题变成了从点值回到系数。如果我们带入到高斯消元法的方程组中去，会把复杂度变得非常高。光是计算 $x^i(0 \leq i \leq n)$ 就是 $n$ 项，这就已经 $O(n^2)$ 了，更别说还要把 $n+1$ 个方程进行消元……

这里会不会觉得我们不去计算 $x^i$ 比较好呢？ $1$ 和 $-1$ 的幂都很好算，但是也仅仅有两个不够啊，我们至少需要 $n+1$ 个。想到我们刚刚学的长度为 $1$ 的虚数了吗？不管怎么乘长度都是 $1$ 。我们需要的是 $\omega^k=1$ 中的 $\omega$ ，很容易想到 $-i$ 和 $1$ 是符合的。那其他的呢？

![img](./images/fft2.jpg)

现在我们看上图的圆圈。容易发现这是一个单位圆（圆心为原点，半径为 $1$ ），单位圆上的向量模长均为 $1$ ，根据复数的运算法则，两个复数相乘，在复平面上表示为两个向量模长相乘，辐角相加。因此两个模长为 $1$ 的向量相乘，得到的仍是模长为 $1$ 的向量，辐角为两个向量辐角的和。因此我们可以将 $\omega^k=1$ 中的 $\omega$ 理解为复平面上的一个单位向量，满足它的辐角的 $k$ 倍恰好是 $360^\circ$ ——即把圆周 $k$ 等分的角。我们把符合以上条件的复数（复平面上的向量）称为复根，用 $\omega$ 表示。

### 定义

严谨地，我们称 $x^n=1$ 在复数意义下的解是 $n$ 次复根。显然，这样的解有 $n$ 个，设 $\omega_n=e^{\frac{2\pi i}{n}}$ ，则 $x^n=1$ 的解集表示为 $\{w_n^k\mid k=0,1\cdots,n-1\}$ 。我们称 $w_n$ 是 $n$ 次单位复根（The $n$ -th roots of unity）。根据复平面的知识， $n$ 次单位复根是复平面把单位圆 $n$ 等分的第一个角所对应的向量。其他复根均可以用单位复根的幂表示。

另一方面，根据欧拉公式，还可以得到 $\omega_n=e^{\frac{2\pi i}{n}}=\cos\left(\dfrac{2\pi i}{n}\right)+i\cdot \sin\left(\dfrac{2\pi i}{n}\right)$ 。

举个例子，当 $n=4$ 时， $w_n=i$ ，即 $i$ 就是 $4$ 次单位复根：

![img](./images/fft3.png)

那么很容易发现当 $n = 4$ 的时候，相当于把单位圆等分 $n= 4$ 份。然后每一份按照极角编号。那么是不是（在 $n = 4$ 的时候）我们只要知道 $\omega_4^1$ （因为他的角度是相当于单位角度），就能知道 $\omega_4^0, \omega_4^1, \omega_4^2, \omega_4^3$ 。

 $\omega_4^0$ 恒等于 $1$ ， $\omega_4^2$ 的角度是 $\omega_4^0$ 的两倍，所以 $\omega_4^2 = (\omega_4^1)^2 = i^2=-1$ ，依次以此类推。

### 性质

单位复根有三个重要的性质。对于任意正整数 $n$ 和整数 $k$ ：

$$
\omega_n^n=1\\
\omega_n^k=\omega_{2n}^{2k}\\
\omega_{2n}^{k+n}=-\omega_{2n}^k\\
$$

## 快速傅里叶变换

FFT 算法的基本思想是分治。就 DFT 来说，它分治地来求当 $x=\omega_n^k$ 的时候 $f(x)$ 的值。他的分治思想体现在将多项式分为奇次项和偶次项处理。

举个例子，对于一共 $8$ 项的多项式

$$
f(x) = a_0 + a_1x + a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6+a_7x^7
$$

按照次数的奇偶来分成两组，然后右边提出来一个 $x$ 

$$
\begin{split}
f(x) &= (a_0+a_2x^2+a_4x^4+a_6x^6) + (a_1x+a_3x^3+a_5x^5+a_7x^7)\\
     &= (a_0+a_2x^2+a_4x^4+a_6x^6) + x(a_1+a_3x^2+a_5x^4+a_7x^6)
\end{split}
$$

分别用奇偶次次项数建立新的函数

$$
G(x) = a_0+a_2x+a_4x^2+a_6x^3\\
H(x)=a_1+a_3x+a_5x^2+a_7x^3
$$

那么原来的 $f(x)$ 用新函数表示为

$$
F(x)=G\left(x^2\right) + x  \times  H\left(x^2\right)
$$

利用单位复根的性质得到

$$
\begin{split}
\operatorname{DFT}(f(\omega_n^k))
&=\operatorname{DFT}(G((\omega_n^k)^2)) + \omega_n^k  \times \operatorname{DFT}(H((\omega_n^k)^2))\\
&=\operatorname{DFT}(G(\omega_n^{2k})) + \omega_n^k  \times \operatorname{DFT}(H(\omega_n^{2k}))\\
&=\operatorname{DFT}(G(\omega_{n/2}^k)) + \omega_n^k  \times \operatorname{DFT}(H(\omega_{n/2}^k))
\end{split}
$$

同理可得

$$
\begin{split}
\operatorname{DFT}(f(\omega_n^{k+n/2}))
&=\operatorname{DFT}(G(\omega_n^{2k+n})) + \omega_n^{k+n/2}  \times \operatorname{DFT}(H(\omega_n^{2k+n}))\\
&=\operatorname{DFT}(G(\omega_n^{2k})) - \omega_n^k  \times \operatorname{DFT}(H(\omega_n^{2k}))\\
&=\operatorname{DFT}(G(\omega_{n/2}^k)) - \omega_n^k  \times \operatorname{DFT}(H(\omega_{n/2}^k))
\end{split}
$$

因此我们求出了 $\operatorname{DFT}(G(\omega_{n/2}^k))$ 和 $\operatorname{DFT}(H(\omega_{n/2}^k))$ 后，就可以同时求出 $\operatorname{DFT}(f(\omega_n^k))$ 和 $\operatorname{DFT}(f(\omega_n^{k+n/2}))$ 。于是对 $G$ 和 $H$ 分别递归 DFT 即可。

考虑到分治 DFT 能处理的多项式长度只能是 $2^m(m \in N^ \ast )$ ，否则在分治的时候左右不一样长，右边就取不到系数了。所以要在第一次 DFT 之前就把序列向上补成长度为 $2^m(m \in N^\ast )$ （高次系数补 $0$ ）、最高项次数为 $2^m-1$ 的多项式。

在代入值的时候，因为要代入 $n$ 个不同值，所以我们代入 $\omega_n^0,\omega_n^1,\omega_n^2,\cdots, \omega_n^{n-1} (n=2^m(m \in N^ \ast ))$ 一共 $2^m$ 个不同值。

代码实现方面，STL 提供了复数的模板，当然也可以手动实现。两者区别在于，使用 STL 的 `complex` 可以调用 `exp` 函数求出 $\omega_n$ 。但事实上使用欧拉公式得到的虚数来求 $\omega_n$ 也是等价的。

???+ note "递归版 FFT"
    ```cpp
    #include <cmath>
    #include <complex>
    
    typedef std::complex<double> Comp;  // STL complex
    
    const Comp I(0, 1);  // i
    const int MAX_N = 1 << 20;
    
    Comp tmp[MAX_N];
    
    void DFT(Comp *f, int n, int rev) {  // rev=1,DFT; rev=-1,IDFT
      if (n == 1) return;
      for (int i = 0; i < n; ++i) tmp[i] = f[i];
      for (int i = 0; i < n; ++i) {  //偶数放左边，奇数放右边
        if (i & 1)
          f[n / 2 + i / 2] = tmp[i];
        else
          f[i / 2] = tmp[i];
      }
      Comp *g = f, *h = f + n / 2;
      DFT(g, n / 2, rev), DFT(h, n / 2, rev);  //递归DFT
      Comp cur(1, 0), step(cos(2 * M_PI / n), sin(2 * M_PI * rev / n));
      // Comp step=exp(I*(2*M_PI/n*rev));//两个step定义是等价的
      for (int k = 0; k < n / 2; ++k) {
        tmp[k] = g[k] + cur * h[k];
        tmp[k + n / 2] = g[k] - cur * h[k];
        cur *= step;
      }
      for (int i = 0; i < n; ++i) f[i] = tmp[i];
    }
    ```

时间复杂度 $O(n\log n)$ 。

### 蝴蝶变换

这个算法还可以从“分治”的角度继续优化。我们每一次都会把整个多项式的奇数次项和偶数次项系数分开，一只分到只剩下一个系数。但是，这个递归的过程需要更多的内存。因此，我们可以先“模仿递归”把这些系数在原数组中“拆分”，然后再“倍增”地去合并这些算出来的值。然而我们又要如何去拆分这些数呢？

设初始序列为 $\{x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7\}$ 

一次二分之后 $\{x_0, x_2, x_4, x_6\},\{x_1, x_3,x_5, x_7 \}$ 

两次二分之后 $\{x_0,x_4\} \{x_2, x_6\},\{x_1, x_3\},\{x_5, x_7 \}$ 

三次二分之后 $\{x_0\}\{x_4\}\{x_2\}\{x_6\}\{x_1\}\{x_5\}\{x_3\}\{x_7 \}$ 

有啥规律呢？其实就是原来的那个序列，每个数用二进制表示，然后把二进制翻转对称一下，就是最终那个位置的下标。比如 $x_1$ 是 001，翻转是 100，也就是 4，而且最后那个位置确实是 4。我们称这个变换为蝴蝶变换。根据它的定义，我们可以在 $O(n\log n)$ 的时间内求出每个数蝴蝶变换的结果：

???+ note "蝴蝶变换实现（$O(n\log n)$）"
    ```cpp
    /*
     * 进行 FFT 和 IFFT 前的反置变换
     * 位置 i 和 i 的二进制反转后的位置互换
     *len 必须为 2 的幂
     */
    void change(Complex y[], int len) {
      int i, j, k;
      for (int i = 1, j = len / 2; i < len - 1; i++) {
        if (i < j) swap(y[i], y[j]);
        // 交换互为小标反转的元素，i<j 保证交换一次
        // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的
        k = len / 2;
        while (j >= k) {
          j = j - k;
          k = k / 2;
        }
        if (j < k) j += k;
      }
    }
    ```

实际上，蝴蝶变换还可以 $O(n)$ 从小到大递推实现：（以下都为二进制数）

想一想我们要翻转 `11001` ，len 为 `100000` 时，我们是怎么实现的。

1.  考虑前面的 `1100` ，显然我们已经处理过它的翻转，它的翻转是 `0011` ，但前面求出 `(0)1100` 的翻转是 `0011(0)` ，因此去掉末尾的 `0` ，就可以得到 `0011` ；
2.  考虑最后一位，如果是 `1` ，它就要翻转到数的最高位，即翻转数加上 `10000` ，即 `len/2` ，如果是 `0` 则不用考虑。

???+ note "蝴蝶变换实现（$O(n)$ 递推版）"
    ```cpp
    //同样需要保证 len 是 2 的幂
    //记 rev[i] 为 i 翻转后的值
    void change(Complex y[], int len) {
      for (int i = 0; i < len; ++i) {
        rev[i] = rev[i >> 1] >> 1;
        if (i & 1) {  //如果最后一位是 1，则翻转成 len/2
          rev[i] |= len >> 1;
        }
      }
      for (int i = 0; i < len; ++i) {
        if (i < rev[i]) {  //保证每对数只翻转一次
          swap(y[i], y[rev[i]]);
        }
      }
      return;
    }
    ```

## 快速傅里叶逆变换

这一步 IDFT（傅里叶反变换）的作用我说的已经很清楚啦，就是把上一步获得的目标多项式的点值形式转换成系数形式。但是似乎并不简单呢……但是，我们把单位复根代入多项式之后，就是下面这个样子（矩阵表示方程组）

$$
\begin{bmatrix}y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_{n-1} \end{bmatrix}
=
\begin{bmatrix}1 & 1 & 1 & 1 & \cdots & 1 \\
1 & \omega_n^1 & \omega_n^2 & \omega_n^3 & \cdots & \omega_n^{n-1} \\
1 & \omega_n^2 & \omega_n^4 & \omega_n^6 & \cdots & \omega_n^{2(n-1)} \\
1 & \omega_n^3 & \omega_n^6 & \omega_n^9 & \cdots & \omega_n^{3(n-1)} \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
1 & \omega_n^{n-1} & \omega_n^{2(n-1)} & \omega_n^{3(n-1)} & \cdots & \omega_n^{(n-1)^2} \end{bmatrix}
\begin{bmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_{n-1} \end{bmatrix}
$$

而且现在我们已经得到最左边的结果了，中间的 $x$ 值在目标多项式的点值表示中也是一一对应的，所以，根据矩阵的基础知识，我们只要在式子两边左乘中间那个大矩阵的逆矩阵就行了。由于这个矩阵的元素非常特殊，他的逆矩阵也有特殊的性质，就是每一项取倒数，再除以 $n$ ，就能得到他的逆矩阵。

如何改变我们的操作才能使计算的结果为原来的倒数呢？根据单位复根的性质并结合欧拉公式，可以得到

$$
\frac{1}{\omega_k}=\omega_k^{-1}=e^{-\frac{2\pi i}{k}}=\cos\left(\frac{2\pi i}{k}\right)+i\cdot \sin\left(-\frac{2\pi i}{k}\right)
$$

因此我们可以尝试着把 $π$ 取成 - 3.14159…，这样我们的计算结果就会变成原来的倒数，而其它的操作过程与 DFT 是完全相同的。我们可以定义一个函数，在里面加一个参数 $1$ 或者是 $-1$ ，然后把它乘到 $π$ 的身上。传入 $1$ 就是 DFT，传入 $-1$ 就是 IDFT。

### 对 IDFT 操作的证明

由于上述矩阵的逆矩阵并未给出严格的推理过程，因此这里提供另一种对 IDFT 操作的证明。考虑原本的多项式是 $f(x)=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}=\sum_{i=0}^{n-1}a_ix^i$ 。而 IDFT 就是把你的点值表示还原为系数表示。

考虑 **构造法** 。我们已知 $y_i=f\left( \omega_n^i \right),i\in\{0,1,\cdots,n-1\}$ ，求 $\{a_0,a_1,\cdots,a_{n-1}\}$ 。构造多项式如下

$$
A(x)=\sum_{i=0}^{n-1}y_ix^i
$$

相当于把 $\{y_0,y_1,y_2,\cdots,y_{n-1}\}$ 当做多项式 $A$ 的系数表示法。设 $b_i=\omega_n^{-i}$ ，则多项式 $A$ 在 $x=b_0,b_1,\cdots,b_{n-1}$ 处的点值表示法为 $\left\{ A(b_0),A(b_1),\cdots,A(b_{n-1}) \right\}$ 。

对 $A(x)$ 的定义式做一下变换，可以将 $A(b_k)$ 表示为

$$
\begin{split}
A(b_k)&=\sum_{i=0}^{n-1}f(\omega_n^i)\omega_n^{-ik}=\sum_{i=0}^{n-1}\omega_n^{-ik}\sum_{j=0}^{n-1}a_j(\omega_n^i)^{j}\\
&=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j\omega_n^{i(j-k)}=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}\left(\omega_n^{j-k}\right)^i\\
\end{split}
$$

记 $S\left(\omega_n^a\right)=\sum_{i=0}^{n-1}\left(\omega_n^a\right)^i$ 。

当 $a=0$ 时， $S\left(\omega_n^a\right)=n$ 。

当 $a\neq 0$ 时，我们错位相减一下

$$
\begin{split}
S\left(\omega_n^a\right)&=\sum_{i=0}^{n-1}\left(\omega_n^a\right)^i\\
\omega_n^a S\left(\omega_n^a\right)&=\sum_{i=1}^{n}\left(\omega_n^a\right)^i\\
S\left(\omega_n^a\right)&=\frac{\left(\omega_n^a\right)^n-\left(\omega_n^a\right)^0}{\omega_n^a-1}=0\\
\end{split}
$$

也就是说

$$
S\left(\omega_n^a\right)=
\left\{\begin{split}
n,a=0\\
0,a\neq 0
\end{split}\right.
$$

那么代回原式

$$
A(b_k)=\sum_{j=0}^{n-1}a_jS\left(\omega_n^{j-k}\right)=a_k\cdot n
$$

也就是说给定点 $b_i=\omega_n^{-i}$ ，则 $A$ 的点值表示法为

$$
\begin{split}
&\left\{ (b_0,A(b_0)),(b_1,A(b_1)),\cdots,(b_{n-1},A(b_{n-1})) \right\}\\
=&\left\{ (b_0,a_0\cdot n),(b_1,a_1\cdot n),\cdots,(b_{n-1},a_{n-1}\cdot n) \right\}
\end{split}
$$

综上所述，我们取单位根为其倒数，对 $\{y_0,y_1,y_2,\cdots,y_{n-1}\}$ 跑一遍 FFT，然后除以 $n$ 即可得到 $f(x)$ 的系数序列，这就是 IDFT 操作的过程。

所以我们 FFT 函数可以集 DFT 和 IDFT 于一身。代码实现如下：

???+ note "非递归版 FFT"
    ```cpp
    /*
     * 做 FFT
     *len 必须是 2^k 形式
     *on == 1 时是 DFT，on == -1 时是 IDFT
     */
    void fft(Complex y[], int len, int on) {
      change(y, len);
      for (int h = 2; h <= len; h <<= 1) {                  // 模拟合并过程
        Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));  // 计算当前单位复根
        for (int j = 0; j < len; j += h) {
          Complex w(1, 0);  // 计算当前单位复根
          for (int k = j; k < j + h / 2; k++) {
            Complex u = y[k];
            Complex t = w * y[k + h / 2];
            y[k] = u + t;  // 这就是吧两部分分治的结果加起来
            y[k + h / 2] = u - t;
            // 后半个 “step” 中的ω一定和 “前半个” 中的成相反数
            //“红圈”上的点转一整圈“转回来”，转半圈正好转成相反数
            // 一个数相反数的平方与这个数自身的平方相等
            w = w * wn;
          }
        }
      }
      if (on == -1) {
        for (int i = 0; i < len; i++) {
          y[i].x /= len;
        }
      }
    }
    ```

??? "FFT 模板（ [HDU 1402](http://acm.hdu.edu.cn/showproblem.php?pid=1402) ）"
    ```cpp
    #include <cmath>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    
    const double PI = acos(-1.0);
    struct Complex {
      double x, y;
      Complex(double _x = 0.0, double _y = 0.0) {
        x = _x;
        y = _y;
      }
      Complex operator-(const Complex &b) const {
        return Complex(x - b.x, y - b.y);
      }
      Complex operator+(const Complex &b) const {
        return Complex(x + b.x, y + b.y);
      }
      Complex operator*(const Complex &b) const {
        return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
      }
    };
    /*
     * 进行 FFT 和 IFFT 前的反置变换
     * 位置 i 和 i 的二进制反转后的位置互换
     *len 必须为 2 的幂
     */
    void change(Complex y[], int len) {
      int i, j, k;
      for (int i = 1, j = len / 2; i < len - 1; i++) {
        if (i < j) swap(y[i], y[j]);
        // 交换互为小标反转的元素，i<j 保证交换一次
        // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的
        k = len / 2;
        while (j >= k) {
          j = j - k;
          k = k / 2;
        }
        if (j < k) j += k;
      }
    }
    /*
     * 做 FFT
     *len 必须是 2^k 形式
     *on == 1 时是 DFT，on == -1 时是 IDFT
     */
    void fft(Complex y[], int len, int on) {
      change(y, len);
      for (int h = 2; h <= len; h <<= 1) {
        Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));
        for (int j = 0; j < len; j += h) {
          Complex w(1, 0);
          for (int k = j; k < j + h / 2; k++) {
            Complex u = y[k];
            Complex t = w * y[k + h / 2];
            y[k] = u + t;
            y[k + h / 2] = u - t;
            w = w * wn;
          }
        }
      }
      if (on == -1) {
        for (int i = 0; i < len; i++) {
          y[i].x /= len;
        }
      }
    }
    
    const int MAXN = 200020;
    Complex x1[MAXN], x2[MAXN];
    char str1[MAXN / 2], str2[MAXN / 2];
    int sum[MAXN];
    
    int main() {
      while (scanf("%s%s", str1, str2) == 2) {
        int len1 = strlen(str1);
        int len2 = strlen(str2);
        int len = 1;
        while (len < len1 * 2 || len < len2 * 2) len <<= 1;
        for (int i = 0; i < len1; i++) x1[i] = Complex(str1[len1 - 1 - i] - '0', 0);
        for (int i = len1; i < len; i++) x1[i] = Complex(0, 0);
        for (int i = 0; i < len2; i++) x2[i] = Complex(str2[len2 - 1 - i] - '0', 0);
        for (int i = len2; i < len; i++) x2[i] = Complex(0, 0);
        fft(x1, len, 1);
        fft(x2, len, 1);
        for (int i = 0; i < len; i++) x1[i] = x1[i] * x2[i];
        fft(x1, len, -1);
        for (int i = 0; i < len; i++) sum[i] = int(x1[i].x + 0.5);
        for (int i = 0; i < len; i++) {
          sum[i + 1] += sum[i] / 10;
          sum[i] %= 10;
        }
        len = len1 + len2 - 1;
        while (sum[len] == 0 && len > 0) len--;
        for (int i = len; i >= 0; i--) printf("%c", sum[i] + '0');
        printf("\n");
      }
      return 0;
    }
    ```

## 快速数论变换

若要计算的多项式系数是别的具有特殊意义的整数，那么 FFT 全部用浮点数运算，从时间上比整数运算慢，且只能用 long double 类型。

可否应用数论变化从而避开浮点运算，快速求解？参见 [快速数论变换](/math/poly/ntt) 。

## 参考文献

1.   [桃酱的算法笔记](https://zhuanlan.zhihu.com/p/41867199) .

# topic
# problemsetting
## 出题前的准备

### 具备一定的水平

一方面，一个人自己出题，很难出出难度大于自身水平的题目，一定的 OI 水平有助于想到更加优质的 idea 并想出优秀的做法；另一方面，OI 水平在一定程度上代表着 OI 资历，见识过更多的题目的选手也会对“好题”拥有自己的见解。

### 抱有认真负责的态度

出题是给别人做的，比起展示自己，更多是为了是服务他人。算法竞赛是选手之间的竞赛，而不是出题人与做题人之间的较量。因此，出题不应以考倒选手为目标（当然，适当的防 AK 与良好的区分度也是非常重要的），而应当让选手能在比赛中有所收获。花费足够的时间精力去学习如何出题并认真负责地出题非常重要。

### 做好耗费大量时间的准备

如果想要认真地出题，就必然要花费大量的时间。如果不做好心理准备，可能导致比赛准备匆忙，质量不过关，也可能在事后由于没有将时间花费在学习上而懊悔。但出题也可以带来很多美好的回忆，如果真的对出题抱有兴趣，并做好了充分的心理准备，出题带来的收获也能够弥补那些花费的时间。

### 认真阅读本文的内容

本文从如何出题、如何把题出好两个方面对整个出题流程进行了介绍。对于想要出题的人来说，认真阅读本文一定能够受益匪浅。

## 题目内容

出一道题，idea，即题目本质的内容，是题目的灵魂，也是出题的第一步。

### idea 的来源

1.  受到已有题目的启发（但不能照搬或无意义地加强，如：序列题目搬到仙人掌上）。
2.  受到学过的知识点的启发（但不能毫无联系地拼凑知识点）。
3.  从生活/游戏中受到启发（但注意不要把游戏出成大模拟）。
4.  不知道为什么，就是想到了一道题。

### 什么样的 idea 是不好的

#### 关于原题

原题大致可分为完全一致、几乎一致和做法一致三种。

-   完全一致：使用一题的 AC 代码可以 AC 另一题。
-   几乎一致：由一题的 AC 代码改动至另一题的 AC 代码可以由一个不会该题的人完成。
-   做法一致：核心思路、做法一致，但代码实现上、不那么关键的细节上有差异。

这三种原题自下而上为包含关系。

以下情况不应出现：

1.  在明知有“几乎一致”的原题的情况下出原题。
2.  由于未使用搜索引擎查找导致自己不清楚有原题，从而出了“几乎一致”的原题。
3.  在“做法一致”的原题广为人知（如：NOIP、NOI 原题）时出原题。
4.  在带有选拔性的考试的非送分题中出现“做法一致”的原题。

以下情况最好不要出现：

1.  在明知有至少为“做法一致”的原题的情况下出原题。
2.  由于未使用搜索引擎查找导致自己不清楚有原题，从而出了“做法一致”的原题。
3.  在任何情况下出“几乎一致”的原题。

可以放宽要求的例外情况：

1.  校内模拟赛。
2.  以专题训练为目的的模拟赛。
3.  难度较低的比赛，或是定位为送分题的题目。

#### 关于毒瘤题

“毒瘤题”是一个非常模糊而主观的观念，在这只是引用一些前人关于此的探讨，加以自己的一些理解。这个话题是非常开放的，欢迎大家来发表自己的观点。

> 一道好题不应该是两道题拼在一起，一道好题会有自己的 idea——而它应该不加过多包装地突出这个 idea。
>
> 一道好题应该新颖。真正的好题，应该是能让人脑洞出新的好题的好题。
>
> ——[vfk《UOJ 精神之源流》][1]

例子： [「XR-1」柯南家族](https://www.luogu.org/problemnew/show/P5346) ，做法的前后两部分完全割裂，前半部分为 [「模板」树上后缀排序](https://www.luogu.org/problemnew/show/P5353) ，后半部分是经典树上问题。就算是随意输入树的点权，依然可以做第二部分，前后部分没有联系。

> 一类 OI 题以数学为主，无论是题目描述还是做法都是数学题的特征，并且解法中不含算法相关的知识点，这类 OI 题目统称为纯数学题。
>
> ——[王天懿《论偏题的危害》][2]

经典例子： [NOIP2017 小凯的疑惑](https://uoj.ac/problem/329) 

OI 中的数学题与其它数学题的区别，也是体现 OI 本质的一个特点，是 OI 中的数学题往往重点不在答案 **是什么** ，而在如何 **加快** 答案的计算。如果一道题考察的重点是“怎么算”而非“怎么快速计算”，这样的数学题一般都是不适合出在 OI 中的。

> 一部分偏题中牵涉到了大学物理的内容，导致选手在面对这些从未接触过物理知识点时变得不知所措，造成了知识上的隔膜。
>
> ——[王天懿《论偏题的危害》][2]

经典例子： [「清华集训 2015」多边形下海](https://uoj.ac/problem/159) 

不止是物理，OI 题目中不应过多涉及到其它学科的知识，如果涉及应当给予详细的解释，不应使其它学科的知识作为解题的重大障碍。

> 一道好题无论难度如何，都应该具有自己的思维难度，需要选手去思考并发现一些性质。
>
> 一道好题的代码可以长，但一定不是通过强行嵌套或者增加条件而让代码变长，而是长得自然，让人感觉这个题的代码就应该是这么长。
>
> ——[王天懿《论偏题的危害》][2]

经典例子： [「SDOI2010」猪国杀](https://loj.ac/problem/2885) ， [「集训队互测 2015」未来程序·改](https://uoj.ac/problem/98) 

在一般的 OI 比赛中，思维难度应占主要部分。当然，如 THUWC/THUSC 的 Day 2+ 那样的工程题也有其存在的道理——毕竟体验营的目的除了考察选手的算法设计能力，还有和大学学习对接的工程代码以及文档学习能力。但在一般的 OI 比赛中，考察更多的应当还是算法设计与思维能力。

## 题面

### 使用 LaTeX 书写公式

网上有很多 LaTeX 的教程，如：

-    [LaTeX 入门](../intro/latex.md#_22) 
-    [LaTeX 数学公式大全](https://www.luogu.org/blog/IowaBattleship/latex-gong-shi-tai-quan) 
-    [LaTeX 各种命令，符号](https://blog.csdn.net/garfielder007/article/details/51646604) 

使用时请注意 [LaTeX 公式的格式要求](../intro/htc.md#latex) 。

### 题目背景

题目背景最好尽量简短。在题目背景较长时，应当与题目描述分开。

需要绝对避免题目背景严重影响题意的理解。

必要时，可以提供与背景结合的题目描述与简洁的题目描述两个版本。

### 题目描述

简而言之，题目描述需要 **清晰易懂** 。

题面中的每个可能不被理解的定义都应得到解释，不应凭空冒出未加定义的概念。例如：在 [CF1172D Nauuo and Portals](https://codeforces.com/problemset/problem/1172/D) 中，你必须在题面中解释什么是“传送门”。

题面中涉及到的每个概念应当使用单一的词汇来描述。例如：不应一会儿说“费用”，一会儿说“代价“。

不应不加说明地使用与原义、常见义不同的词汇。例如：不应不加说明地用“路径”代指一条边。

你需要保证你的题面不会自相矛盾。例如：在 [CF1173A Nauuo and Votes](https://codeforces.com/problemset/problem/1173/A) 中，没有把 "?" 作为一种 "result"，是因为 "?" 的含义是 "there are more than one possible results"。

你需要保证你的题面不能被错误理解而自圆其说，即使这种理解是反常识、没有人会这么去想的。例如：在 [CF1172D Nauuo and Portals](https://codeforces.com/problemset/problem/1172/D) 中，之所以要繁琐地定义 "walk into" 并与 "teleport" 区分，是为了防止这种理解：通过传送门可以到另一个传送门，而到了传送门会传送，因此会反复横跳。

顺着读题目描述应当能看懂每一句话，并理解题目的任务与要求。至少在紧接着的下一段话中疑惑能够得到解释，而不是需要在若干段后才能得到解释，或者要看了输入输出格式才能明白题意，甚至需要根据样例来猜题意。例如：在 [「GuOJ Round #1」琪露诺的冰雪宴会](https://github.com/OI-wiki/problemset/blob/master/contest/online/GuOJ/OI%20Archive%20-%20GuOJ1171.pdf) 中，在输出格式才第一次出现了题目的目标“雾之湖最终能接收到的最大水量”，再加上“灵梦当然能很快算出来清理完全部小溪的总费用是多少”这句带有误解性质的话，更容易使人读错题意，这是不可取的，应当在题目描述中就对题目的目标进行说明。（在这个例子中还存在题目背景严重影响题意理解的问题。）

### 输入输出格式

输入输出格式清晰 **完整** 即可，没有死板的要求，个人建议参照 CF 的题目来写输入输出格式，具体可以参考[CF 出题人须知][3]。

为了方便选手做题，输入输出格式中最好说明每个变量的具体含义，除非变量的意义非常长，没法一句话说清楚（这时可以说“意义见题目描述”）。

需要特别注意的是，如果输出中含有小数，请尽量使用 SPJ。如果无法使用 SPJ，请保证对精度的要求是有限的。

如果没有保证，对精度的要求可能是无限的。例如：要求保留三位小数，实际答案为 $0.0015$ ，此时只要有任意大小的误差导致计算出的答案小于 $0.0015$ ，即使计算出的答案是 $0.00149999\cdots$ 也会输出错误的答案。

保证对精度要求有限的例子：请输出答案四舍五入后保留小数点后三位的结果。令标准答案为 $ans$ ，数据保证对于任意满足 $\frac{|x-ans|}{\max(1,ans)}<10^{-9}$ 的 $x$ ，四舍五入后结果与 $ans$ 四舍五入后相同。

可以参考的一些句子：

```latex
输入的第一行包含三个正整数 $n$, $m$, $k$ ($1\le n,m\le 2\cdot 10^5$, $1\le k\le 100$) — $n$ 表示数列的长度，$m$ 表示操作个数，$k$ 的意义见题目描述。
```

```latex
输入的第二行包含 $n$ 个非负整数 $a_1,a_2,\ldots,a_n$ ($1\le a_i\le 10^9$) — 题目给出的数列。
```

```latex
接下来的 $m$ 行中的第 $i$ 行包含两个正整数 $l_i$ 和 $r_i$ ($1\le l_i\le r_i\le n$)，表示第 $i$ 次操作在区间 $[l_i,r_i]$ 上进行。
```

```latex
接下来的 $n-1$ 行，每行包含两个正整数 $u$ 和 $v$ ($1\le u,v\le n$)，表示 $u$ 和 $v$ 之间由一条边相连。

数据保证给出的边能构成一棵树。
```

```latex
输入的唯一一行包含一个由小写英文字母构成的非空字符串，其长度不超过 $10^6$。
```

```latex
输入的第二行包含一个小数点后不超过三位的实数 $x$ ($-10^6\le x\le 10^6$)，意义见题目描述。
```

```latex
输出包含一个实数，当你的输出与标准答案之间的绝对误差或相对误差小于 $10^{-6}$ 时视作正确。
```

```latex
输出的第二行包含 $n$ 个正整数，表示你构造的一组方案 — 其中第 $i$ 个数表示你打出的第 $i$ 张牌的编号。

如果有多组合法的答案，可以任意输出其中一组。
```

### 数据范围

按照 CF 的要求，数据范围要写在输入格式里，但在国内，数据范围往往是写在题目的最后的。

数据范围中最容易犯的错误就是不完整。输入中的每一个数、每一个字符串都应该有清晰的界定。在上文所给出的输入输出格式示例中就有一些数据范围的正确写法。

数据范围的常见遗漏：

1.  “整数”中的“整”。
2.  题面中只说了是“整数”没说是“正整数”，并且数据范围中只有上限没有下限。
3.  字符串没说字符集。
4.  实数没说小数点后位数。
5.  某些变量没有给范围。

你需要保证标程可以通过满足题面所述数据范围的 **任何一组数据** 。

### 样例

样例应当有一定的强度，能够查出一些简单的错误。读错题意的人应当能够通过样例发现自己读错了题意。

有多种操作的题，每种操作都应在样例中出现。

有多种输出的题（如 [CF1173A Nauuo and Votes](https://codeforces.com/problemset/problem/1173/A) ），每种输出都应在样例中出现。例外：实际上不可能无解，但要求判断是否有解的题目。

### 样例解释

题目描述越复杂、越不易理解就越应当有详细的样例解释。

题目难度越简单就越应当有详细的样例解释。

详细的样例解释可以选择配上图片。

较大的样例可以没有样例解释。

为了照顾色觉障碍者，最好不要使颜色成为理解样例解释所必备的。可以用彩色图片来美化样例解释，但如果一定要用颜色传递一些必要的信息，最好不要同时出现红黄或者红绿。

## 时限、空间限制与部分分

时限与空间限制的目的是卡掉复杂度错误的做法。（当然，也是为了防止评测用时过长，如：只对交互次数有限制而对时间复杂度没有限制的交互题也有时间限制。）

因此，原则上时间限制应当选取不使错误做法通过的尽量大的值。

一般地，时限应满足以下要求：

1.  至少为 std 在最坏情况下用时的两倍。
2.  如果比赛允许使用 Java，应使 Java 能够通过。
3.  不应使错误做法通过（实在卡不掉、想放某种错解过除外）。

为了更好地在放大常数做法过的同时卡掉错解，一般可以采用同时增大数据范围和时限的方法。但要注意，有时正解（由于缓存等玄学问题）会在数据范围增大时有极大的常数增加，此时增大数据范围不一定能够增大正解与错解之间用时的差距。

在有部分分的赛制中，还可以通过设置有梯度的数据、数据范围稍小的数据来使较为优秀的错解和大常数正解不能通过，同时使其获得较高的部分分。

需要注意的是，在数据范围小于 $5\cdot 10^5$ 时，应当考虑是否能使用 [指令集](https://ouuan.github.io/n方过百万-暴力碾标算——指令集优化的基础使用) 通过。

一般情况下空间限制应当设置的足够大，除非空间复杂度更优的做法的确十分巧妙，值得卡掉空间复杂度大的做法。这种情况下可以考虑设置空间限制较松的部分分。值得注意的是，如果不想卡掉空间消耗较大的做法，数据结构题一般需要设置较大的空间限制。

> 一道好题应该具有它的选拔性质，具有足够的区分度。应该至少 4 档部分分，让新手可以拿到分，让高手能够展示自己的实力。
>
> ——vfk《UOJ 精神之源流》

部分分一般分为较小数据范围与特殊性质两种。

较小数据范围一般要设置多档，即使你想不到某种复杂度的做法，也可以考虑给这种复杂度一档分。一般来说，为了避免卡常，可以设置一档极限数据除以二的部分分。

“数据有梯度”最好用多档部分分替代。

特殊性质部分分的设置要依具体题目而定。理想的特殊性质部分分应当是能够引导选手思考正解的。与较小数据范围部分分不同，在你不会针对某种特殊性质的做法时，最好不要给这种特殊性质一档分。例如： [「CTS2019」随机立方体](https://loj.ac/problem/3119) 的 $k=1$ 这档部分分在讲题时就被很多人吐槽，称这档部分分妨碍了思考正解。

如果题目给分方式与默认方式不同（如：在一般的 OI 赛制比赛中绑 Subtask 测试），一定要在题面中说明。

不推荐使用“百分之 XX 的数据满足 XX”的说法，尤其是数据范围有多个变量时。除非真的能够没有歧义地推断出每个测试点的数据范围。

## 造数据

数据生成是出题过程中必要的一步，也是对拍时所必需的，掌握一些生成数据的技巧，就能使造数据的过程更加轻松，造出来的数据强度更高。

### 生成随机数据

#### 生成随机数

请参考 [随机函数](../misc/random.md) 页面。

需要特别提醒的是，在生成值域比随机函数返回值更大的数时，请 **不要** 使用 `rand() * rand()` 之类的写法，这样的写法生成的随机数非常不均匀。

另外，出题时推荐使用 [testlib](../intro/testlib/generator.md) 来造数据，可以保证在不同平台上同一个种子生成的随机数相同，并且种子会依据命令行参数自动生成。

#### 生成随机排列

可以使用 STL 中的 `random_shuffle` 函数，也可以手写：

```cpp
for (int i = 1; i <= n; ++i) {
  p[i] = i;
  std::swap(p[i], p[rand() % i + 1]);
}
```

如果使用 `testlib.h` ，可以使用 `shuffle` 函数，和 `random_shuffle` 类似，但使用 `rnd.next` 作为随机数生成器。

#### 生成随机区间

常见错误方法：在 $[1,n]$ 中随机生成左端点 $l$ ，再在 $[l, n]$ 中随机生成右端点 $r$ 。这样的话生成的区间会比较靠右。

较为正确的方法（推荐做法）：在 $[1, n]$ 中随机生成两个数，取较小的作为左端点，较大的作为右端点。

真正均匀随机的方法：在 $[1, n(n+1)]$ 中生成一个随机数 $x$ ，若 $x\le n-1$ ，再在 $[1, n]$ 中生成一个随机数 $y$ ，区间为 $[y,y]$ ；否则按“较为正确的方法”生成。

#### 生成随机树

常用方法是为 $2\sim n$ 的每个节点 $i$ 从 $[1,i-1]$ 中随机选择一个父亲。这样做的话生成的树不是均匀随机的，期望高度为 $O(\log n)$ 。

还有一种随机方法：从 $[i\cdot low, i\cdot high]$ 中随机选择 $i$ 的父亲。若 $low$ 和 $high$ 设置得当，可以造出强度较高的树。

真正均匀随机的方法是利用 [Prufer 序列](../graph/prufer.md) ，先生成一个随机 Prufer 序列，再通过序列生成树。这样做的话，树的期望高度为 $O(\sqrt n)$ 。

除此之外，可以随机一个排列来给节点重编号/打乱边的顺序。

### 构造数据

#### 区间相关的题目

常用构造：长度特别小（特殊地，全部为单点）、长度特别大（特殊地，全部为整个序列）。

#### 需要分解因数的题目

可重质因数个数尽量多： $2$ 的幂。

去重后质因数个数尽量多：最小的若干个质数相乘。

约数尽量多：可以参考 OEIS 上的 [A002182](http://oeis.org/A002182) 数列。

#### 树上问题

常用构造：

-   链
-   菊花
-   完全二叉树
-   将完全二叉树的每个节点替换为一条长为 $\sqrt n$ 的链
-   菊花上挂一条链
-   链上挂一些单点
-   一棵高度为 $d$ 且 $d>1$ 的树的根节点有两个儿子，左子树是一条长为 $d-1$ 的链，右子树是一棵高度为 $d-1$ 的这样的树。

如果不是在考场上，还可以使用 [Tree-Generator](https://github.com/ouuan/Tree-Generator) 来生成各种各样的树。

### 批量生成数据

笔者推荐使用命令行参数 + bat/sh 的方法。

例如：

 `gen.cpp` :

```cpp
#include "testlib.h"

using namespace std;

int n, m, k;
vector<int> p;

int main(int argc, char* argv[]) {
  registerGen(argc, argv, 1);

  int i;

  n = atoi(argv[1]);
  m = atoi(argv[2]);
  k = rnd.next(1, n);

  for (i = 1; i <= n; ++i) p.push_back(i);

  shuffle(p.begin(), p.end());
  // 使用 rnd.next() 进行 shuffle

  printf("%d %d %d\n", n, m, k);
  for (i = 0; i < n; ++i) {
    printf("%d%c", p[i], " \n"[i == n - 1]);
    // 把字符串当作数组用，中间空格，末尾换行，是一个造数据时常用的技巧
  }

  return 0;
}
```

 `gen_scripts.bat` :

```bat
gen 10 10 > 1.in
gen 1 1 > 2.in
gen 100 200 > 3.in
gen 2000 1000 > 4.in
gen 100000 100000 > 5.in
```

这样做的好处是，对于不同的数据只需要写一个 generator，并且可以方便地修改某个测试点的参数。

### 造数据的要求

数据应当包含各个参数的最小值和最大值。

数据应当包含各种边角情况。

数据（包括输入、输出）最好覆盖到值域中的各个范围。

为了防止特判过掉，可以将不同的构造结合在一个测试点中，或者数据的大部分是构造，掺杂小部分的随机。

数据中应当包含各种各样的构造，即使你不知道什么错解会挂在这组构造上。（在按测试点给分的赛制中需要酌情处理。）

当然，如果你已知一个（正常人能想的到、写的出的）正确性有问题的错解，要尽量卡掉它。

需要特别提醒的是，如果有整型溢出的可能，一定要卡掉会溢出的做法。在有部分分的赛制中，不应使不开 long long 的人得到和暴力一样甚至更低的分数。

如果有 pretests，pretests 应尽量强，（同时尽量少）。换言之，你需要在 pretests 中（用尽量少的数据组数）包含该题的所有已知叉点。

如果你希望出现少量而非没有 FST，你可以问问 Sooke 对这件事的看法（Sooke 曾经坚称“FST 是 CF 的灵魂”，在我的强烈要求下，在 [CF1172A Nauuo and Cards](https://codeforces.com/problemset/problem/1172/A) 中，他构造了许多数据，在 pretests 中卡掉了所有已知错解，最后，这题在比赛中 Div.2 的 FST 率为 18.5%）。

## Special Judge

 [SPJ 编写教程](../intro/spj.md) 

输出方案题和输出浮点数题是两种较为常见的需要使用 SPJ 的题型，其它题目视情况也需要使用 SPJ。在 CF 上，所有题目都必须使用基于 testlib.h 的 checker，例如：题目要求输出若干个整数时，你可以任意输出空白字符（既可以空格也可以换行）。

checker 一般使用 testlib.h 编写。由于你要应对各种各样的不合法输出，需要极强的鲁棒性，因此不使用 testlib.h 是很难写好 checker 的。

编写 checker 需要注意以下两点：

1.  你需要应对各种不合法的输出，因此，请检查读入的每个变量是否在合法范围中（ `readInt(minvalue, maxvalue)` ）。例如：读入一个在 check 过程中会作为数组下标的变量时必须检查其范围，否则可能引发数组越界，有时这会导致 RE，有时则可能判为 AC。
2.  原则上 checker 中不应检查空白字符（即，不应使用 readSpace()、readEoln()、readEof()，值得一提的是，testlib.h 会自动检查是否有多余的输出）。

## 题解

题解的目标是让预计会来参加比赛的人都能看懂。所以官方题解详细程度的要求会比一般的题解高。

### 关于部分分

在有部分分的题目中，题解里可以考虑写一写部分分的做法。

### 关于知识点

解题中用到的知识点应当写出来。对于一些难度和题目难度相当的知识点，最好给出学习该知识点的资料（比如一篇博客的地址）。“这样，再这样，然后 **用一些技巧** 就可以了”，而其中的“一些技巧”并不是谁都会的，这种情况要绝对避免。

### 关于定义

题解中不要凭空冒出来一些概念。

例如：dp 的题解要解释清楚状态的定义。

再例如： [CF1172F Nauuo and Bug](https://codeforces.com/problemset/problem/1172/F) 的旧版题解，其中对“分段函数”没有定义，这是绝对不可取的。

### 关于细节

具体的实现细节如果比较巧妙最好写出来，否则的话“详见代码”也是可以的。如果“详见代码”的话，最好在代码中加上一定的注释。

### 标程

标程中最好去掉冗余部分。比如，有人在题解中保留了完整的 define 模板（为了提高做题速度，包含大量 define 与常用函数，常用于 CF 等在线比赛），并且其中很大一部分都没有用到，这是不好的。

上文已经说过了，如果涉及到一些题解中没有详细说明的实现细节，最好加上适量的注释。

## 比赛

### 比赛通知中的题目难度需真实

感觉这个是比赛通知中比较需要注意的一点。

如果不会评难度可以不评……

> Remember that authors tend to underestimate the difficulty of their problems.
>
> ——Codeforces PROPOSE A PROBLEM 页面的提醒

需要特别强调的是，如果以 CF 的难度来进行类比（如：该比赛为 Div.2 A ~ Div.2 E 难度），不仅是难度需要与 CF Div.2 类似，题型也应当是 CF 风格。

### 题目难度的分配

在类国内 OI 的模拟赛中，往往是三道题的整体难度与比赛难度相当即可。

在类 CF/ATC 这种线上赛的比赛中，需要尽量保证难度的递增（虽然由于对难度的误估很多时候都并不能真正做到），并且尽量避免出现大的 difficulty gap。可以通过把一题分为难易两题（两个 Subtask）来减少 difficulty gap。

### 题目知识点的分配

一场比赛应尽量涵盖较广的知识点（专题训练赛当然除外）。

经典反例：涵盖了动态规划、期望、组合计数、容斥原理、多项式等多种知识点的 CTS2019。（~~组题人：我要从五道题里选六道，我也很无奈啊。~~）

## 出题平台

### Polygon

Polygon 是一个功能非常强大的多人合作出题平台，可以作为在任何网站（使用 package 功能导出到不支持 Polygon 的网站）多人合作出题的首选方案，单人出题（尤其是在不同设备上出题）时也是很不错的选择，使用方法参见 [Polygon 简介](../intro/polygon.md) 。

### Codeforces

Codeforces 是全球最著名的算法竞赛网站之一，题目质量较高，非常适合有一定出题经验并且想进一步提升出题水平、想要出一套高质量题目的出题人。不足之处是审核速度较慢（一般要几个月），但你也可以在审核期间就开始题目的准备（虽然有题目被否掉导致准备白费了的风险）。

#### 出题资格

-   蓝名且参加过至少 25 场 rated 比赛；
-   紫名且参加过至少 15 场 rated 比赛；
-   橙名且参加过至少 5 场 rated 比赛；
-   红名或黑红名。

#### 提交比赛申请

有了出题资格后，在侧边栏可以看到 [Propose a contest/problems](http://codeforces.com/proposals/new-contest) 按钮。

点进去之后，先写一份 contest proposal（在 PROPOSE A CONTEST 里写），然后再写 problem proposal 并添加进比赛里。

题目决定好之后，就可以将 contest proposal open to review（提交审核）了。

#### 在 Polygon 上准备题目

参考 [Polygon 简介](../intro/polygon.md) 。

#### 与管理之间的联系

与管理联系有两个作用：

1.  加快审核速度。
2.  进入准备阶段后管理会提供建议和帮助。

正规的联系方式是在 proposal system 中以 proposal 的形式提交申请，管理开始审核之后以 comment 的形式在 proposal 的下方进行讨论。

实际上，如果 proposal 长时间没有过审，可以私信联系管理（其实 CF 上写了 "Don't send private messages or emails to coordinators"，但 300iq 在 [评论](http://codeforces.com/blog/entry/64077#comment-478933) 中表示可以私信他）。

在进入准备阶段后，一般会使用 Telegram 进行讨论，如果由于一些原因无法使用 Telegram，可以尝试邀请管理使用 QQ（300iq 是会使用 QQ 的）。

### Comet OJ

创办时间不是很久的国内算法竞赛平台，应该算是国内平台出题的最佳选择。

出题申请： <https://info.cometoj.com/contests/Questionnaire_IssuerInfo/> 

### CodeChef

印度的算法竞赛平台，支持 10 天且带 challenge 的 Long Challenge，2.5h 类 ICPC 的 Cook-Off，3h 类 IOI 的 LunchTime 三种赛制。

出题 FAQ： <https://www.codechef.com/wiki/faq-problem-setters> 

出题指南： <https://www.codechef.com/problemsetting> 

### AtCoder

日本的算法竞赛平台，出题联系方式： [contest@atcoder.jp](mailto:contest@atcoder.jp) 。

### UOJ & LOJ

比赛不多的国内 OJ。

出题貌似是联系管理？

### 洛谷

#### 个人公开赛

在 [我的题库](https://www.luogu.org/app/userproblem) 中出题并提交比赛申请。

#### 团队公开赛

在团队页面中出题并提交比赛申请。

## 参考资料

1.  [vfk《UOJ 精神之源流》][1]

2.  [王天懿《论偏题的危害》][2]

3.  [CF 出题人须知][3]（ [国内可访问的图片版](https://github.com/OI-wiki/libs/blob/master/topic/rules.jpg) ）

4.  [CF 出题人的自我修养][4]

本文由作者本人自 [ouuan 的出题规范](https://ouuan.github.io/ouuan-的出题规范/) 搬运而来并有所修改、补充。

[1]: https://vfleaking.blog.uoj.ac/blog/909 "vfk《UOJ 精神之源流》"

[2]: https://github.com/OI-wiki/libs/blob/master/topic/7-%E7%8E%8B%E5%A4%A9%E6%87%BF-%E8%AE%BA%E5%81%8F%E9%A2%98%E7%9A%84%E5%8D%B1%E5%AE%B3.ppt "王天懿《论偏题的危害》"

[3]: https://docs.google.com/document/d/e/2PACX-1vRhazTXxSdj7JEIC7dp-nOWcUFiY8bXi9lLju-k6vVMKf4IiBmweJoOAMI-ZEZxatXF08I9wMOQpMqC/pub "CF 出题人须知"

[4]: https://github.com/OI-wiki/libs/blob/master/topic/CF%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.md "CF 出题人的自我修养"

# rmq
## 简介

RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。

在笔者接下来的描述中，默认初始数组大小为 $n$ 。

在笔者接下来的描述中，默认时间复杂度标记方式为 $O($ 数据预处理 $)-O($ 单次询问 $)$ 。

## 单调栈

由于 Oi wiki 中已有此部分的描述，本文仅给出 [链接](../ds/monotonous-stack.md) 。这部分不再展开。

时间复杂度 $O(m\log m)-O(\log n)$ 

空间复杂度 $O(n)$ 

## ST 表

由于 Oi wiki 中已有此部分的描述，本文仅给出 [链接](../ds/sparse-table.md) 。这部分不再展开。

时间复杂度 $O(n\log n)-O(1)$ 

空间复杂度 $O(n\log n)$ 

## 线段树

由于 Oi wiki 中已有此部分的描述，本文仅给出 [链接](../ds/seg.md) 。这部分不再展开。

时间复杂度 $O(n)-O(\log n)$ 

空间复杂度 $O(n\log n)$ 

## Four Russian

Four russian 是一个由四位俄罗斯籍的计算机科学家提出来的基于 ST 表的算法。

在 ST 表的基础上 Four russian 算法对其做出的改进是序列分块。

具体来说，我们将原数组——我们将其称之为数组 A——每 $S$ 个分成一块，总共 $n/S$ 块。

对于每一块我们预处理出来块内元素的最小值，建立一个长度为 $n/S$ 的数组 B，并对数组 B 采用 ST 表的方式预处理。

同时，我们对于数组 A 的每一个零散块也建立一个 ST 表。

询问的时候，我们可以将询问区间划分为不超过 1 个数组 B 上的连续块区间和不超过 2 个数组 A 上的整块内的连续区间。显然这些问题我们通过 ST 表上的区间查询解决。

在 $S=\log n$ 时候，预处理复杂度达到最优，为 $O((n / \log n)\log n+(n / \log n)\times\log n\times\log \log n)=O(n\log \log n)$ 。

时间复杂度 $O(n\log \log n)-O(1)$ 

空间复杂度 $O(n\log \log n)$ 

当然询问由于要跑三个 ST 表，该实现方法的常数较大。

!!! note "一些小小的算法改进"
    我们发现，在询问的两个端点在数组 A 中属于不同的块的时候，数组 A 中块内的询问是关于每一块前缀或者后缀的询问。

    显然这些询问可以通过预处理答案在 $O(n)$ 的时间复杂度内被解决。

    这样子我们只需要在询问的时候进行至多一次 ST 表上的查询操作了。

!!! note "一些玄学的算法改进"
    由于 Four russian 算法以 ST 表为基础，而算法竞赛一般没有非常高的时间复杂度要求，所以 Four russian 算法一般都可以被 ST 表代替，在算法竞赛中并不实用。这里提供一种在算法竞赛中更加实用的 Four russian 改进算法。

    我们将块大小设为 $\sqrt n$，然后预处理出每一块内前缀和后缀的 RMQ，再暴力预处理出任意连续的整块之间的 RMQ，时间复杂度为 $O(n)$。

    查询时，对于左右端点不在同一块内的询问，我们可以直接 $O(1)$ 得到左端点所在块的后缀 RMQ，左端点和右端点之间的连续整块 RMQ，和右端点所在块的前缀 RMQ，答案即为三者之间的最值。

    而对于左右端点在同一块内的询问，我们可以暴力求出两点之间的 RMQ，时间复杂度为 $O(\sqrt n)$，但是单个询问的左右端点在同一块内的期望为 $O(\frac{\sqrt n}{n})$，所以这种方法的时间复杂度为期望 $O(n)$。

    而在算法竞赛中，我们并不用非常担心出题人卡掉这种算法，因为我们可以通过在 $\sqrt n$ 的基础上随机微调块大小，很大程度上避免算法在根据特定块大小构造的数据中出现最坏情况。并且如果出题人想要卡掉这种方法，则暴力有可能可以通过。

    这是一种期望时间复杂度达到下界，并且代码实现难度和算法常数均较小的算法，因此在算法竞赛中比较实用。

    以上做法参考了[P3793 由乃救爷爷](https://www.luogu.com.cn/problemnew/show/P3793)中的题解。

## 笛卡尔树在 RMQ 上的应用

不了解笛卡尔树的朋友请移步 [笛卡尔树](../ds/cartesian-tree.md) 。

我们发现，原序列上两个点之间的 min/max，等于笛卡尔树上两个点的 LCA 的权值。

这也说明，我们现在需要去解决的是如何 $O(n)-O(1)$ 树上两个点之间的 LCA 的。

树上 LCA 在 [LCA](../graph/lca.md) 部分已经有描述，这里不再展开。

这里我们需要采用的是基于 RMQ 的树上 LCA 算法。

可能会有同学会问：为什么我们在绕了一圈之后，又回到了 RMQ 问题呢？

别着急，我们来找一找这个 RMQ 问题的特殊性质：

因为树的 dfs 序列的相邻两个节点互为父子关系，也就是说相邻两个节点深度差为 $\pm 1$ 。我们一般称这种相邻两个元素差为 1 的 RMQ 问题为 $\pm 1$ RMQ 问题。

根据这个特性我们就可以改进 Four Russian 算法了。

由于 Four russian 算法的瓶颈在于块内 RMQ 问题，我们重点去讨论块内 RMQ 问题的优化。

由于相邻两个数字的差值为 $\pm 1$ ，所以在固定左端点数字时 长度不超过 $\log n$ 的右侧序列种类数为 $\sum_{i=1}^{i \leq \log n} 2^{i-1}$ ，而这个式子显然不超过 $n$ 。

这启示我们可以预处理所有不超过 $n$ 种情况的 最小值 - 第一个元素 的值。

在预处理的时候我们需要去预处理同一块内相邻两个数字之间的差，并且使用二进制将其表示出来。

在询问的时候我们找到询问区间对应的二进制表示，查表得出答案。

这样子 Four russian 预处理的时间复杂度就被优化到了 $O(n)$ 。

结合笛卡尔树部分我们就可以实现 $O(n)-O(1)$ 的 RMQ 问题了。

代码和例题由于在 LCA 部分已经给出 [链接](../graph/lca.md) ，这里不再赘述。

当然由于转化步数较多， $O(n)-O(1)$ RMQ 跑的比较慢。

如果数据随机，则我们还可以暴力在笛卡尔树上查找。此时的时间复杂度为期望 $O(n)-O(\log n)$ ，并且实际使用时这种算法的常数往往很小。

## general-weight-match
author: accelsao

# 一般图最大权匹配

## 带权带花树

待补。

## 习题

-    [UOJ #81. 一般图最大权匹配](http://uoj.ac/problem/81) 

## bigraph-weight-match
author: accelsao

# 二分图最大权匹配

最大权匹配是指边权和最大的匹配。
首先，将两个集合中点数比较少的补点，使得两边点数相同，再将不存在的边权重设为 $0$ ，问题就转换成求 **最大权完美匹配问题** 。
即找一个匹配使得边权和最大且所有点都在匹配内。

## Hungarian Algorithm（Kuhn-Munkres Algorithm）

匈牙利算法又称为 **KM** 算法，可以在 $O(n^3)$ 时间内求出最大权完美匹配。

??? note "可行顶标"

    给每个节点 $i$ 分配一个权值 $l(i)$，对于所有边 $(u,v)$ 满足 $w(u,v) \leq l(u) + l(v)$。

??? note "相等子图"

    在一组可行顶标下原图的生成子图，包含所有点但只包含满足 $w(u,v) = l(u) + l(v)$ 的边 $(u,v)$。

??? note "定理 1 : 对于某组可行顶标，如果其相等子图存在完美匹配，那么，该匹配就是原二分图的最大权完美匹配。"

    ### 证明 1.
    考虑原二分图任意一组完美匹配 $M$，其边权和为

    $val(M) = \sum_{(u,v)\in M} {w(u,v)} \leq \sum_{(u,v)\in M} {l(u) + l(v)} \leq \sum_{i=1}^{n} l(i)$

    任意一组可行顶标的相等子图的完美匹配 $M'$ 的边权和

    $val(M') = \sum_{(u,v)\in M} {l(u) + l(v)} = \sum_{i=1}^{n} l(i)$

    即任意一组完美匹配的边权和都不会大于 $val(M')$，那个 $M'$ 就是最大权匹配。

有了定理 1，我们的目标就是透过不断的调整可行顶标，使得相等子图是完美匹配。

因为两边点数相等，假设点数为 $n$ ， $lx(i)$ 表示左边第 $i$ 个点的顶标， $ly(i)$ 表示右边第 $i$ 个点的顶标， $w(u,v)$ 表示左边第 $u$ 个点和右边第 $v$ 个点之间的权重。

首先初始化一组可行顶标，例如

 $lx(i)$ = max { $w(i, j)$ for j = 1 to n}, $ly(i) = 0$ 

然后选一个未匹配点，如同最大匹配一样求增广路。
找到增广路就增广，否则，会得到一个交错树。
令 $S$ , $T$ 表示二分图左边右边在交错树中的点， $S'$ , $T'$ 表示不在交错树中的点。

![bigraph-weight-match-1](./images/bigraph-weight-match-1.png)

在相等子图中：

-    $S-T'$ 的边不存在，否则交错树会增长。
-    $S'-T$ 一定是非匹配边，否则他就属于 $S$ 。

假设给 $S$ 中的顶标 $-a$ ，给 $T$ 中的顶标 $+a$ ，
可以发现

-    $S-T$ 边依然存在相等子图中。
-    $S'-T'$ 没变化。
-    $S-T'$ lx + ly 有所减少可能加入相等子图。
-    $S'-T$ lx + ly 会增加所以不可能加入相等子图。

所以这个 $a$ 值的选择，显然得是 $S-T'$ 当中最小的边权，

 $a$ = min { $lx(u) + ly(v) - w(u,v)$ \| $u\in{S}$ , $v\in{T'}$ }。

当一条新的边 $(u,v)$ 加入相等子图后有两种情况

-   v 是未匹配点，则找到增广路
-   v 和 S' 中的点已经匹配

这样至多修改 $n$ 次顶标后，就可以找到增广路。

每次修改顶标的时候，交错树中的边不会离开相等子图，那么我们直接维护这棵树。

我们对 $T$ 中的每个点 $v$ 维护

 $slack(v)$ = min { $lx(u) + ly(v) - w(u,v)$ \| $u\in{S}$ }。

所以可以在 $O(n)$ 算出顶标修改值 $a$ 

 $a$ = min { $slack(v)$ \| $v\in{T'}$ }

交错树新增一个点进入 $S$ 的时候需要 $O(n)$ 更新 $slack(v)$ 。
修改顶标需要 $O(n)$ 给每个 $slack(v)$ 减去 $a$ 。
只要交错树找到一个未匹配点，就找到增广路。
一开始枚举 $n$ 个点找增广路，为了找增广路需要延伸 $n$ 次交错树，每次延伸需要 $n$ 次维护，共 $O(n^3)$ 。

### 代码

这里是 $O(n^3)$ 的代码

```cpp
template <typename T>
struct hungarian {  // km
  int n;
  vector<int> matchx;  // 左集合对应的匹配点
  vector<int> matchy;  // 右集合对应的匹配点
  vector<int> pre;     // 连接右集合的左点
  vector<bool> visx;   // 拜访数组 左
  vector<bool> visy;   // 拜访数组 右
  vector<T> lx;
  vector<T> ly;
  vector<vector<T> > g;
  vector<T> slack;
  T inf;
  T res;
  queue<int> q;
  int org_n;
  int org_m;

  hungarian(int _n, int _m) {
    org_n = _n;
    org_m = _m;
    n = max(_n, _m);
    inf = numeric_limits<T>::max();
    res = 0;
    g = vector<vector<T> >(n, vector<T>(n));
    matchx = vector<int>(n, -1);
    matchy = vector<int>(n, -1);
    pre = vector<int>(n);
    visx = vector<bool>(n);
    visy = vector<bool>(n);
    lx = vector<T>(n, -inf);
    ly = vector<T>(n);
    slack = vector<T>(n);
  }

  void addEdge(int u, int v, int w) {
    g[u][v] = max(w, 0);  // 负值还不如不匹配 因此设为0不影响
  }

  bool check(int v) {
    visy[v] = true;
    if (matchy[v] != -1) {
      q.push(matchy[v]);
      visx[matchy[v]] = true;  // in S
      return false;
    }
    // 找到新的未匹配点 更新匹配点 pre 数组记录着"非匹配边"上与之相连的点
    while (v != -1) {
      matchy[v] = pre[v];
      swap(v, matchx[pre[v]]);
    }
    return true;
  }

  void bfs(int i) {
    while (!q.empty()) {
      q.pop();
    }
    q.push(i);
    visx[i] = true;
    while (true) {
      while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v = 0; v < n; v++) {
          if (!visy[v]) {
            T delta = lx[u] + ly[v] - g[u][v];
            if (slack[v] >= delta) {
              pre[v] = u;
              if (delta) {
                slack[v] = delta;
              } else if (check(v)) {  // delta=0 代表有机会加入相等子图 找增广路
                                      // 找到就return 重建交错树
                return;
              }
            }
          }
        }
      }
      // 没有增广路 修改顶标
      T a = inf;
      for (int j = 0; j < n; j++) {
        if (!visy[j]) {
          a = min(a, slack[j]);
        }
      }
      for (int j = 0; j < n; j++) {
        if (visx[j]) {  // S
          lx[j] -= a;
        }
        if (visy[j]) {  // T
          ly[j] += a;
        } else {  // T'
          slack[j] -= a;
        }
      }
      for (int j = 0; j < n; j++) {
        if (!visy[j] && slack[j] == 0 && check(j)) {
          return;
        }
      }
    }
  }

  void solve() {
    // 初始顶标
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        lx[i] = max(lx[i], g[i][j]);
      }
    }

    for (int i = 0; i < n; i++) {
      fill(slack.begin(), slack.end(), inf);
      fill(visx.begin(), visx.end(), false);
      fill(visy.begin(), visy.end(), false);
      bfs(i);
    }

    // custom
    for (int i = 0; i < n; i++) {
      if (g[i][matchx[i]] > 0) {
        res += g[i][matchx[i]];
      } else {
        matchx[i] = -1;
      }
    }
    cout << res << "\n";
    for (int i = 0; i < org_n; i++) {
      cout << matchx[i] + 1 << " ";
    }
    cout << "\n";
  }
};
```

## 习题

??? note "[UOJ #78. 二分图最大匹配](http://uoj.ac/problem/78) "

    模板题
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    template <typename T>
    struct hungarian { // km
      int n;
      vector<int> matchx;
      vector<int> matchy;
      vector<int> pre;
      vector<bool> visx;
      vector<bool> visy;
      vector<T> lx;
      vector<T> ly;
      vector< vector<T> > g;
      vector<T> slack;
      T inf;
      T res;
      queue<int> q;
      int org_n;
      int org_m;

      hungarian(int _n, int _m) {
    	org_n = _n;
    	org_m = _m;
    	n = max(_n, _m);
    	inf = numeric_limits<T>::max();
    	res = 0;
    	g = vector< vector<T> >(n, vector<T>(n));
    	matchx = vector<int>(n, -1);
    	matchy = vector<int>(n, -1);
    	pre = vector<int>(n);
    	visx = vector<bool>(n);
    	visy = vector<bool>(n);
    	lx = vector<T>(n, -inf);
    	ly = vector<T>(n);
    	slack = vector<T>(n);
      }

      void addEdge(int u, int v, int w) {
    	g[u][v] = max(w, 0); // 负值还不如不匹配 因此设为0不影响
      }


      bool check(int v) {
    	visy[v] = true;
    	if(matchy[v] != -1) {
    	  q.push(matchy[v]);
    	  visx[matchy[v]] = true;
    	  return false;
    	}
    	while(v != -1) {
    	  matchy[v] = pre[v];
    	  swap(v, matchx[pre[v]]);
    	}
    	return true;
      }

      void bfs(int i) {
    	while(!q.empty()) {
    	  q.pop();
    	}
    	q.push(i);
    	visx[i] = true;
    	while(true) {
    	  while(!q.empty()) {
    		int u = q.front();
    		q.pop();
    		for(int v = 0; v < n; v++) {
    		  if(!visy[v]) {
    			T delta = lx[u] + ly[v] - g[u][v];
    			if(slack[v] >= delta) {
    			  pre[v] = u;
    			  if(delta) {
    				slack[v] = delta;
    			  } else if(check(v)) {
    				return ;
    			  }
    			}
    		  }
    		}
    	  }
    	  // 没有增广路 修改顶标
    	  T a = inf;
    	  for(int j = 0; j < n; j++) {
    		if(!visy[j]){
    		  a = min(a, slack[j]);
    		}
    	  }
    	  for(int j = 0; j < n; j++) {
    		if(visx[j]) { // S
    		  lx[j] -= a;
    		}
    		if(visy[j]) { // T
    		  ly[j] += a;
    		} else { // T'
    		  slack[j] -= a;
    		}
    	  }
    	  for(int j = 0; j < n; j++) {
    		if(!visy[j] && slack[j] == 0 && check(j)) {
    		  return ;
    		}
    	  }
    	}

      }

      void solve() {
    	// 初始顶标
    	for(int i = 0; i < n; i++) {
    	  for(int j = 0; j < n; j++) {
    		lx[i] = max(lx[i], g[i][j]);
    	  }
    	}

    	for(int i = 0; i < n; i++) {
    	  fill(slack.begin(), slack.end(), inf);
    	  fill(visx.begin(), visx.end(), false);
    	  fill(visy.begin(), visy.end(), false);
    	  bfs(i);
    	}

    	// custom
    	for(int i = 0; i < n; i++) {
    	  if(g[i][matchx[i]] > 0) {
    		res += g[i][matchx[i]];
    	  } else {
    		matchx[i] = -1;
    	  }

    	}
    	cout << res << "\n";
    	for(int i = 0; i < org_n; i++) {
    	  cout << matchx[i] + 1 << " ";
    	}
    	cout << "\n";
      }
    };

    int main(){
      ios::sync_with_stdio(0), cin.tie(0);
      int n, m, e;
      cin >> n >> m >> e;

      hungarian<long long> solver(n, m);

      int u, v, w;
      for(int i = 0; i < e; i++) {
    	cin >> u >> v >> w;
    	u--, v--;
    	solver.addEdge(u, v, w);
      }
      solver.solve();
    }

    ```

## augment
author: accelsao

# 增广路定理 Berge's lemma

这是最大匹配的一个重要理论。

-   交错路（alternating path) 始于非匹配点且由匹配边与非匹配边交错而成。
-   增广路（augmenting path）是始于非匹配点且终于非匹配点的交错路。

增广路上非匹配边比匹配边数量多一，如果将匹配边改为未匹配边，反之亦然，则匹配大小会增加一且依然是交错路。

![augment-1](./images/augment-1.png)

如图 匹配数从 2 增加为 3，我们称此过程为 **增广** 。

根据 Berge's lemma 当找不到增广路的时候，得到最大匹配。

由此定理可知我们求最大匹配的核心思路。

!!! 核心思路

    枚举所有未匹配点，找增广路径，直到找不到增广路径。

事实上，对于每个点只要枚举一次就好。

![augment-2](./images/augment-2.png)

假设某一轮沿着增广路 $a - b$ 增广后，出现了以 $x$ 为起点的增广路 $P_x$ ，则 $P_x$ 必相交 $a - b$ 。
假设 $P_x$ 第一次碰上 $a - b$ ，由于 $a - b$ 是交错路，意味着相交点是不同类型的（图中以红和蓝表示），那增广前 $x$ 就能走到 $a - b$ 中的某个未匹配点，说明早已存在从 $x$ 出发的增广路。

## graph-match
author: accelsao

 **匹配** 或是 **独立边集** 是一张图中没有公共边的集合。
在二分图中求匹配等价于网路流问题。

图匹配算法是信息学竞赛中常用的算法，总体分为最大匹配以及最大权匹配，先从二分图开始介绍，在进一步提出一般图的作法。

# 匹配

在图论中，假设图 $G=(V,E)$ ，其中 $V$ 是点集， $E$ 是边集。
一组两两没有公共点的边集 $(M(M\in E))$ 称为这张图的 **匹配** 。
定义匹配的大小为其中边的数量 $|M|$ ，边数最大的 $M$ 为 **最大匹配** 。
当图中带权的时候，边权和最大的为 **最大权匹配** 。
匹配中的边称为 **匹配边** ，反之称为 **未匹配边** 。
一个点如果属于 $M$ 且为至多一条边的端点，称为 **匹配点** ，反之称为 **未匹配点** 。

> maximal matching: 无法再增加匹配边的匹配。不见得是最大匹配。
> 最大匹配（maximum matching): 匹配数最多的匹配。
> 完美匹配（perfect matching): 所有点都属于匹配，同时也符合最大匹配。
> 近完美匹配（near-perfect matching): 发生在图的点数为奇数，刚好只有一个点不在匹配中，扣掉此点以后的图称为 factor-critical graph。

 **maximal matching** ![graph-match-1](./images/graph-match-1.png) **最大匹配** ![graph-match-2](./images/graph-match-2.png)

# 二分图匹配

一张二分图上的匹配称作二分匹配。![graph-match-3](./images/graph-match-3.png)

设 $G$ 为二分图，若在 $G$ 的子图 $M$ 中，任意两条边都没有公共节点，那么称 $M$ 为二分图 $G$ 的一个匹配，且 $M$ 的边数为匹配数。

## 完备匹配

设 $G=<V_1, V_2, E>$ 为二分图， $|V_1| \leq |V_2|$ ， $M$ 为 $G$ 中一个最大匹配，且 $|M|=2|V_1|$ ，则称 $M$ 为 $V_1$ 到 $V_2$ 的完备匹配。

## 霍尔定理

设二分图 $G=<V_1, V_2, E>, |V_1| \leq |V_2|$ ，则 $G$ 中存在 $V_1$ 到 $V_2$ 的完备匹配当且仅当对于任意的 $S \subset V_1$ ，均有 $|S|\leq|N(S)|$ ，其中 $N(S)=\Cup_{v_i \in S}{N(V_i)}$ ，是 $S$ 的邻域。

## 最大匹配

寻找二分图边数最大的匹配称为最大匹配问题。

# 算法

组合优化中的一个基本问题是求 **最大匹配（maximum matching)** 。

## 二分图最大匹配

在无权二分图中，Hopcroft-Karp 算法可在 $O(\sqrt{V}E)$ 解决。

## 二分图最大权匹配

在带权二分图中，可用 Hungarian 算法解决。
如果在最短路搜寻中用 Bellman–Ford 算法，时间复杂度为 $O(V^2E)$ ，
如果用  Dijkstra 算法或 Fibonacci heap，可用 $O(V^{2}\log {V}+VE)$ 解决。

## 一般图最大匹配

无权一般图中，Edmonds' blossom 算法可在 $O(V^2E)$ 解决。

## 一般图最大权匹配

带权一般图中，Edmonds' blossom 算法可在 $O(V^2E)$ 解决。

# 参考资料

-   [1][Wikiwand - Matching (graph theory)]( <https://www.wikiwand.com/en/Matching_(graph_theory)> )
-   [2][Wikiwand - Blossom algorithm]( <https://www.wikiwand.com/en/Blossom_algorithm> )
-   [3]2015 年《浅谈图的匹配算法及其应用》- 陈胤伯
-   [4][演算法笔记 - Matching]( <http://www.csie.ntnu.edu.tw/~u91029/Matching.html> )
-   [5][the-tourist/algo]( <https://github.com/the-tourist/algo> )
-   [6][Bill Yang's Blog - 带花树学习笔记]( <https://blog.bill.moe/blossom-algorithm-notes/> )
-   [7][二分图的最大匹配、完美匹配和匈牙利算法]( <https://www.renfei.org/blog/bipartite-matching.html> )
-   [8][Wikiwand - Hopcroft–Karp algorithm]( <https://www.wikiwand.com/en/Hopcroft%E2%80%93Karp_algorithm> )

## general-match
author: accelsao

# 一般图最大匹配

## 带花树算法（Blossom Algorithm)

开花算法（Blossom Algorithm，也被称做带花树）可以解决一般图最大匹配问题（maximum cardinality matchings)。此算法由 Jack Edmonds 在 1961 年提出。
经过一些修改后也可以解决一般图最大权匹配问题。
此算法是第一个给出证明说最大匹配有多项式复杂度。

一般图匹配和二分图匹配（bipartite matching）不同的是，图可能存在奇环。

以此图为例，若直接取反（匹配边和未匹配边对调），会使得取反后的 $M$ 不合法，某些点会出现在两条匹配上，而问题就出在奇环。

下面考虑一般图的增广算法。
从二分图的角度出发，每次枚举一个未匹配点，设出发点为根，标记为 **"o"** ，接下来交错标记 **"o"** 和 **"i"** ，不难发现 **"i"** 到 **"o"** 这段边是匹配边。

假设当前点是 $v$ ，相邻点为 $u$ 。

case 1: $u$ 未拜访过，当 $u$ 是未匹配点，则找到增广路径，否则从 $u$ 的配偶找增广路。

case 2: $u$ 已拜访过，遇到标记 "o" 代表需要 **缩花** ，否则代表遇到偶环，跳过。

遇到偶环的情况，将他视为二分图解决，故可忽略。 **缩花** 后，再新图中继续找增广路。

![general-matching-2](./images/general-matching-2.png)

设原图为 $G$ ， **缩花** 后的图为 $G'$ ，我们只需要证明：

1.  若 $G$ 存在增广路， $G'$ 也存在。
2.  若 $G'$ 存在增广路， $G$ 也存在。

![general-matching-3](./images/general-matching-3.png)

设非树边（形成环的那条边）为（u, v)，定义花根 $h=LCA(u,v)$ 。
奇环是交替的，有且仅有 $h$ 的两条邻边类型相同，都是非匹配边。
那么进入 $h$ 的树边肯定是匹配边，环上除了 $h$ 以外其他点往环外的边都是非匹配边。

观察可知，从环外的边出去有两种情况，顺时针或逆时针。

![general-matching-4](./images/general-matching-4.png)

于是 **缩花** 与 **不缩花** 都不影响正确性。

实作上找到 **花** 以后我们不需要真的 **缩花** ，可以用数组纪录每个点在以哪个点为根的那朵花中。

### 复杂度分析 Complexity Analysis

每次找增广路，遍历所有边，遇到 **花** 会维护 **花** 上的点， $O(|E|^2)$ 。
枚举所有未匹配点做增广路，总共 $O(|V||E|^2)$ 。

### 代码

```cpp
// graph
template <typename T>
class graph {
 public:
  struct edge {
    int from;
    int to;
    T cost;
  };
  vector<edge> edges;
  vector<vector<int> > g;
  int n;
  graph(int _n) : n(_n) { g.resize(n); }
  virtual int add(int from, int to, T cost) = 0;
};

// undirectedgraph
template <typename T>
class undirectedgraph : public graph<T> {
 public:
  using graph<T>::edges;
  using graph<T>::g;
  using graph<T>::n;

  undirectedgraph(int _n) : graph<T>(_n) {}
  int add(int from, int to, T cost = 1) {
    assert(0 <= from && from < n && 0 <= to && to < n);
    int id = (int)edges.size();
    g[from].push_back(id);
    g[to].push_back(id);
    edges.push_back({from, to, cost});
    return id;
  }
};

// blossom / find_max_unweighted_matching
template <typename T>
vector<int> find_max_unweighted_matching(const undirectedgraph<T> &g) {
  std::mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
  vector<int> match(g.n, -1);   // 匹配
  vector<int> aux(g.n, -1);     // 时间戳记
  vector<int> label(g.n);       // "o" or "i"
  vector<int> orig(g.n);        // 花根
  vector<int> parent(g.n, -1);  // 父节点
  queue<int> q;
  int aux_time = -1;

  auto lca = [&](int v, int u) {
    aux_time++;
    while (true) {
      if (v != -1) {
        if (aux[v] == aux_time) {  //找到拜访过的点 也就是LCA
          return v;
        }
        aux[v] = aux_time;
        if (match[v] == -1) {
          v = -1;
        } else {
          v = orig[parent[match[v]]];  //以匹配点的父节点继续寻找
        }
      }
      swap(v, u);
    }
  };  // lca

  auto blossom = [&](int v, int u, int a) {
    while (orig[v] != a) {
      parent[v] = u;
      u = match[v];
      if (label[u] == 1) {  // 初始点设为"o" 找增广路
        label[u] = 0;
        q.push(u);
      }
      orig[v] = orig[u] = a;  // 缩花
      v = parent[u];
    }
  };  // blossom

  auto augment = [&](int v) {
    while (v != -1) {
      int pv = parent[v];
      int next_v = match[pv];
      match[v] = pv;
      match[pv] = v;
      v = next_v;
    }
  };  // augment

  auto bfs = [&](int root) {
    fill(label.begin(), label.end(), -1);
    iota(orig.begin(), orig.end(), 0);
    while (!q.empty()) {
      q.pop();
    }
    q.push(root);
    // 初始点设为 "o", 这里以"0"代替"o", "1"代替"i"
    label[root] = 0;
    while (!q.empty()) {
      int v = q.front();
      q.pop();
      for (int id : g.g[v]) {
        auto &e = g.edges[id];
        int u = e.from ^ e.to ^ v;
        if (label[u] == -1) {  //找到未拜访点
          label[u] = 1;        // 标记 "i"
          parent[u] = v;
          if (match[u] == -1) {  //找到未匹配点
            augment(u);          // 寻找增广路径
            return true;
          }
          // 找到已匹配点 将与她匹配的点丢入queue 延伸交错树
          label[match[u]] = 0;
          q.push(match[u]);
          continue;
        } else if (label[u] == 0 &&
                   orig[v] !=
                       orig[u]) {  //找到已拜访点 且标记同为"o" 代表找到"花"
          int a = lca(orig[v], orig[u]);
          // 找LCA 然后缩花
          blossom(u, v, a);
          blossom(v, u, a);
        }
      }
    }
    return false;
  };  // bfs

  auto greedy = [&]() {
    vector<int> order(g.n);
    // 随机打乱 order
    iota(order.begin(), order.end(), 0);
    shuffle(order.begin(), order.end(), rng);

    // 将可以匹配的点匹配
    for (int i : order) {
      if (match[i] == -1) {
        for (auto id : g.g[i]) {
          auto &e = g.edges[id];
          int to = e.from ^ e.to ^ i;
          if (match[to] == -1) {
            match[i] = to;
            match[to] = i;
            break;
          }
        }
      }
    }
  };  // greedy

  // 一开始先随机匹配
  greedy();
  // 对未匹配点找增广路
  for (int i = 0; i < g.n; i++) {
    if (match[i] == -1) {
      bfs(i);
    }
  }
  return match;
}
```

## 习题

??? note "[UOJ #79. 一般图最大匹配](http://uoj.ac/problem/79) "

    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    // graph
    template <typename T>
    class graph {
     public:
      struct edge {
    	int from;
    	int to;
    	T cost;
      };
      vector<edge> edges;
      vector<vector<int> > g;
      int n;
      graph(int _n) : n(_n) { g.resize(n); }
      virtual int add(int from, int to, T cost) = 0;
    };

    // undirectedgraph
    template <typename T>
    class undirectedgraph : public graph<T> {
     public:
      using graph<T>::edges;
      using graph<T>::g;
      using graph<T>::n;

      undirectedgraph(int _n) : graph<T>(_n) {}
      int add(int from, int to, T cost = 1) {
    	assert(0 <= from && from < n && 0 <= to && to < n);
    	int id = (int)edges.size();
    	g[from].push_back(id);
    	g[to].push_back(id);
    	edges.push_back({from, to, cost});
    	return id;
      }
    };

    // blossom / find_max_unweighted_matching
    template <typename T>
    vector<int> find_max_unweighted_matching(const undirectedgraph<T> &g) {
      std::mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
      vector<int> match(g.n, -1);   // 匹配
      vector<int> aux(g.n, -1);     // 时间戳记
      vector<int> label(g.n);       // "o" or "i"
      vector<int> orig(g.n);        // 花根
      vector<int> parent(g.n, -1);  // 父节点
      queue<int> q;
      int aux_time = -1;

      auto lca = [&](int v, int u) {
    	aux_time++;
    	while (true) {
    	  if (v != -1) {
    		if (aux[v] == aux_time) {  //找到拜访过的点 也就是LCA
    		  return v;
    		}
    		aux[v] = aux_time;
    		if (match[v] == -1) {
    		  v = -1;
    		} else {
    		  v = orig[parent[match[v]]];  //以匹配点的父节点继续寻找
    		}
    	  }
    	  swap(v, u);
    	}
      };  // lca

      auto blossom = [&](int v, int u, int a) {
    	while (orig[v] != a) {
    	  parent[v] = u;
    	  u = match[v];
    	  if (label[u] == 1) {  // 初始点设为"o" 找增广路
    		label[u] = 0;
    		q.push(u);
    	  }
    	  orig[v] = orig[u] = a;  // 缩花
    	  v = parent[u];
    	}
      };  // blossom

      auto augment = [&](int v) {
    	while (v != -1) {
    	  int pv = parent[v];
    	  int next_v = match[pv];
    	  match[v] = pv;
    	  match[pv] = v;
    	  v = next_v;
    	}
      };  // augment

      auto bfs = [&](int root) {
    	fill(label.begin(), label.end(), -1);
    	iota(orig.begin(), orig.end(), 0);
    	while (!q.empty()) {
    	  q.pop();
    	}
    	q.push(root);
    	// 初始点设为 "o", 这里以"0"代替"o", "1"代替"i"
    	label[root] = 0;
    	while (!q.empty()) {
    	  int v = q.front();
    	  q.pop();
    	  for (int id : g.g[v]) {
    		auto &e = g.edges[id];
    		int u = e.from ^ e.to ^ v;
    		if (label[u] == -1) {  //找到未拜访点
    		  label[u] = 1;        // 标记 "i"
    		  parent[u] = v;
    		  if (match[u] == -1) {  //找到未匹配点
    			augment(u);          // 寻找增广路径
    			return true;
    		  }
    		  // 找到已匹配点 将与她匹配的点丢入queue 延伸交错树
    		  label[match[u]] = 0;
    		  q.push(match[u]);
    		  continue;
    		} else if (label[u] == 0 &&
    				   orig[v] !=
    					   orig[u]) {  //找到已拜访点 且标记同为"o" 代表找到"花"
    		  int a = lca(orig[v], orig[u]);
    		  // 找LCA 然后缩花
    		  blossom(u, v, a);
    		  blossom(v, u, a);
    		}
    	  }
    	}
    	return false;
      };  // bfs

      auto greedy = [&]() {
    	vector<int> order(g.n);
    	// 随机打乱 order
    	iota(order.begin(), order.end(), 0);
    	shuffle(order.begin(), order.end(), rng);

    	// 将可以匹配的点匹配
    	for (int i : order) {
    	  if (match[i] == -1) {
    		for (auto id : g.g[i]) {
    		  auto &e = g.edges[id];
    		  int to = e.from ^ e.to ^ i;
    		  if (match[to] == -1) {
    			match[i] = to;
    			match[to] = i;
    			break;
    		  }
    		}
    	  }
    	}
      };  // greedy

      // 一开始先随机匹配
      greedy();
      // 对未匹配点找增广路
      for (int i = 0; i < g.n; i++) {
    	if (match[i] == -1) {
    	  bfs(i);
    	}
      }
      return match;
    }
    int main(){
      ios::sync_with_stdio(0), cin.tie(0);
      int n, m;
      cin >> n >> m;
      undirectedgraph<int> g(n);
      int u, v;
      for(int i = 0; i < m; i++) {
    	cin >> u >> v;
    	u--;
    	v--;
    	g.add(u, v, 1);
      }
      auto blossom_match = find_max_unweighted_matching(g);
      vector<int> ans;
      int tot = 0;
      for(int i = 0; i < blossom_match.size(); i++) {
    	ans.push_back(blossom_match[i]);
    	if(blossom_match[i] != -1) {
    	  tot++;
    	}
      }
      cout << (tot >> 1) << "\n";
      for(auto x : ans) {
    	cout << x + 1 << " ";
      }
    }

    ```

## bigraph-match
author: accelsao

# 二分图最大匹配

为了描述方便将两个集合分成左和右两个部分，所有匹配边都是横跨左右两个集合，可以假想成男女配对。

假设图有 $n$ 个顶点， $m$ 条边。

## 增广路算法 Augmenting Path Algorithm

因为增广路长度为奇数，路径起始点非左即右，所以我们先考虑从左边的未匹配点找增广路。
注意到因为交错路的关系，增广路上的第奇数条边都是非匹配边，第偶数条边都是匹配边，于是左到右都是非匹配边，右到左都是匹配边。
于是我们给二分图 **定向** ，问题转换成，有向图中从给定起点找一条简单路径走到某个未匹配点，此问题等价给定起始点 $s$ 能否走到终点 $t$ 。
那么只要从起始点开始 DFS 遍历直到找到某个未匹配点， $O(m)$ 。
未找到增广路时，我们拓展的路也称为 **交错树** 。

因为要枚举 $n$ 个点，总复杂度为 $O(nm)$ 。

### 代码

```cpp
struct augment_path {
  vector<vector<int> > g;
  vector<int> pa;  // 匹配
  vector<int> pb;
  vector<int> vis;  // 访问
  int n, m;         // 顶点数量
  int dfn;          // 时间戳记
  int res;          // 匹配数

  augment_path(int _n, int _m) : n(_n), m(_m) {
    assert(0 <= n && 0 <= m);
    pa = vector<int>(n, -1);
    pb = vector<int>(m, -1);
    vis = vector<int>(n);
    g.resize(n);
    res = 0;
    dfn = 0;
  }

  void add(int from, int to) {
    assert(0 <= from && from < n && 0 <= to && to < m);
    g[from].push_back(to);
  }

  bool dfs(int v) {
    vis[v] = dfn;
    for (int u : g[v]) {
      if (pb[u] == -1) {
        pb[u] = v;
        pa[v] = u;
        return true;
      }
    }
    for (int u : g[v]) {
      if (vis[pb[u]] != dfn && dfs(pb[u])) {
        pa[v] = u;
        pb[u] = v;
        return true;
      }
    }
    return false;
  }

  int solve() {
    while (true) {
      dfn++;
      int cnt = 0;
      for (int i = 0; i < n; i++) {
        if (pa[i] == -1 && dfs(i)) {
          cnt++;
        }
      }
      if (cnt == 0) {
        break;
      }
      res += cnt;
    }
    return res;
  }
};
```

## Dinic 算法

二分图最大匹配可以转换成网络流模型。
将左边所有点接上源点，右边所有点接上汇点，容量皆为 $1$ 。
原来的每条边从左往右连边，容量也皆为 $1$ ，最大流即最大匹配，可在 $O(\sqrt{n}m)$ 求出。

Dinic 算法分成两部分，第一部分用 $O(m)$ 时间 BFS 建立网络流，第二步是 $O(nm)$ 时间 DFS 进行增广。
但因为容量为 $1$ ，所以实际时间复杂度为 $O(m)$ 。
接下来前 $O(\sqrt{n})$ 轮，复杂度为 $O(\sqrt{n}m)$ 。 $O(\sqrt{n})$ 轮以后，每条增广路径长度至少 $\sqrt{n}$ ，而这样的路径不超过 $\sqrt{n}$ ，
所以此时最多只需要跑 $\sqrt{n}$ 轮，整体复杂度为 $O(\sqrt{n}m)$ 。

### 代码

待补。

## 补充

### 二分图最大独立集

选最多的点，满足两两之间没有边相连。

二分图中，最大独立集 = $n$ - 最大匹配。

### 二分图最小点覆盖

选最少的点，满足每条边至少有一个端点被选，不难发现补集是独立集。

二分图中，最小点覆盖 = $n$ - 最大独立集。

## 习题

??? note "[UOJ #78. 二分图最大匹配](http://uoj.ac/problem/78) "

    模板题
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    struct augment_path {
      vector< vector<int> > g;
      vector<int> pa; // 匹配
      vector<int> pb;
      vector<int> vis; // 访问
      int n, m; // 顶点数量
      int dfn; // 时间戳记
      int res; // 匹配数

      augment_path(int _n, int _m) : n(_n), m(_m) {
    	assert(0 <= n && 0 <= m);
    	pa = vector<int> (n, -1);
    	pb = vector<int> (m, -1);
    	vis = vector<int> (n);
    	g.resize(n);
    	res = 0;
    	dfn = 0;
      }

      void add(int from, int to) {
    	assert(0 <= from && from < n && 0 <= to && to < m);
    	g[from].push_back(to);
      }

      bool dfs(int v) {
    	vis[v] = dfn;
    	for(int u: g[v]) {
    	  if(pb[u] == -1) {
    		pb[u] = v;
    		pa[v]= u;
    		return true;
    	  }
    	}
    	for(int u: g[v]) {
    	  if(vis[pb[u]] != dfn && dfs(pb[u])) {
    		pa[v] = u;
    		pb[u] = v;
    		return true;
    	  }
    	}
    	return false;
      }

      int solve() {
    	while(true) {
    	  dfn++;
    	  int cnt = 0;
    	  for(int i = 0; i < n; i++) {
    		if(pa[i] == -1 && dfs(i)) {
    		  cnt++;
    		}
    	  }
    	  if(cnt == 0) {
    		break;
    	  }
    	  res += cnt;
    	}
    	return res;
      }
    };

    int main(){
    	int n, m, e;
    	cin >> n >> m >> e;
    	augment_path solver(n, m);
    	int u, v;
    	for(int i = 0; i < e; i++){
    	cin >> u >> v;
    	u--, v--;
    	solver.add(u, v);
    	}
    	cout << solver.solve() << "\n";
    	for(int i = 0; i < n; i++) {
    	cout << solver.pa[i] + 1 << " ";
    	}
    	cout << "\n";
    }

    ```

??? note "[P1640 [SCOI2010]连续攻击游戏](https://www.luogu.com.cn/problem/P1640) "

    None

??? note "[Codeforces 1139E - Maximize Mex](https://codeforces.com/problemset/problem/1139/E) "

    None

# misc
# stern-brocot
## Stern-Brocot 树

Stern-Brocot 树是一种维护分数的优雅的数据结构。它分别由 Moritz Stern 在 1858 年和 Achille Brocot 在 1861 年发现这个结构。

### 概述

Stern-Borcot 树从两个简单的分数开始：

$$
\frac{0}{1}, \frac{1}{0}
$$

这个 $\frac{1}{0}$ 可能看得你有点懵逼。不过我们不讨论这方面的严谨性，你只需要把它当作 $\infty$ 就行了。

每次我们在相邻的两个分数 $\frac{a}{b},\frac{c}{d}$ 中间插入一个分数 $\frac{a+c}{b+d}$ ，这样就完成了一次迭代，得到下一个序列。于是它就会变成这样

$$
\begin{array}{c}
\dfrac{0}{1}, \dfrac{1}{1}, \dfrac{1}{0} \\\\
\dfrac{0}{1}, \dfrac{1}{2}, \dfrac{1}{1}, \dfrac{2}{1}, \dfrac{1}{0} \\\\
\dfrac{0}{1}, \dfrac{1}{3}, \dfrac{1}{2}, \dfrac{2}{3}, \dfrac{1}{1}, \dfrac{3}{2}, \dfrac{2}{1}, \dfrac{3}{1}, \dfrac{1}{0}
\end{array}
$$

既然我们叫这个数据结构 Stern-Brocot 树，那么它总得有一个树的样子对吧。来一张图：

![pic](./images/stern-brocot1.png)

你可以把第 $i$ 层的序列当作是深度为 $i-1$ 的 Stern-Brocot 树的中序遍历。

### 性质

接下来讨论一下 Stern-Brocot 树的性质。

#### 单调性

在每一层的序列中，真分数是单调递增的。

略证：只需要在 $\frac{a}{b}\le \frac{c}{d}$ 的情况下证明

$$
\frac{a}{b}\le \frac{a+c}{b+d}\le \frac{c}{d}
$$

就行了。这个很容易，直接做一下代数变换即可

$$
\begin{array}{l}
&\frac{a}{b}\le \frac{c}{d}\\
\Rightarrow &ad\le bc\\
\Rightarrow &ad+ab\le bc+ab\\
\Rightarrow &\frac{a}{b}\le\frac{a+c}{b+d}
\end{array}
$$

另一边同理可证。

#### 最简性

序列中的分数（除了 $\frac{0}{1},\frac{1}{0}$ ）都是最简分数。

略证：为证明最简性，我们首先证明对于序列中连续的两个分数 $\frac{a}{b},\frac{c}{d}$ ：

$$
bc-ad=1
$$

显然，我们只需要在 $bc-ad=1$ 的条件下证明 $\frac{a}{b}, \frac{a+c}{b+d}, \frac{c}{d}$ 的情况成立即可。

$$
a(b+d)-b(a+c)=ad-bc=1
$$

后半部分同理。证明了这个，利用扩展欧几里德定理，如果上述方程有解，显然 $\gcd(a,b)=\gcd(c,d)=1$ 。这样就证完了。

有了上面的证明，我们可以证明 $\frac{a}{b}<\frac{c}{d}$ 。

有了这两个性质，你就可以把它当成一棵平衡树来做了。建立和查询就向平衡树一样做就行了。

### 实现

构建实现

```cpp
void build(int a = 0, int b = 1, int c = 1, int d = 0, int level = 1) {
  int x = a + c, y = b + d;
  //... output the current fraction x/y
  // at the current level in the tree
  build(a, b, x, y, level + 1);
  build(x, y, c, d, level + 1);
}
```

查询实现

```cpp
string find(int x, int y, int a = 0, int b = 1, int c = 1, int d = 0) {
  int m = a + c, n = b + d;
  if (x == m && y == n) return "";
  if (x * n < y * m)
    return 'L' + find(x, y, a, b, m, n);
  else
    return 'R' + find(x, y, m, n, c, d);
}
```

## Farey 序列

Stern-Brocot 树与 Farey 序列有着极其相似的特征。第 $i$ 个 Farey 序列记作 $F_i$ ，表示把分母小于等于 $i$ 的所有最简真分数按大小顺序排列形成的序列。

$$
\begin{array}{l}
F_1=\{&\frac{0}{1},&&&&&&&&&&\frac{1}{1}&\}\\
F_2=\{&\frac{0}{1},&&&&&\frac{1}{2},&&&&&\frac{1}{1}&\}\\
F_3=\{&\frac{0}{1},&&&\frac{1}{3},&&\frac{1}{2},&&\frac{2}{3},&&&\frac{1}{1}&\}\\
F_4=\{&\frac{0}{1},&&\frac{1}{4},&\frac{1}{3},&&\frac{1}{2},&&\frac{2}{3},&\frac{3}{4},&&\frac{1}{1}&\}\\
F_5=\{&\frac{0}{1},&\frac{1}{5},&\frac{1}{4},&\frac{1}{3},&\frac{2}{5},&\frac{1}{2},&\frac{3}{5},&\frac{2}{3},&\frac{3}{4},&\frac{4}{5},&\frac{1}{1}&\}\\
\end{array}
$$

显然，上述构建 Stern-Brocot 树的算法同样适用于构建 Farey 序列。因为 Stern-Brocot 树中的数是最简分数，因此在边界条件（分母）稍微修改一下就可以形成构造 Farey 序列的代码。你可以认为 Farey 序列 $F_i$ 是 Stern-Brocot 第 $i-1$ 次迭代后得到的序列的子序列。

Farey 序列同样满足最简性和单调性，并且满足一个与 Stern-Brocot 树相似的性质：对于序列中连续的三个数 $\frac ab,\frac xy,\frac cd$ ，有 $x=a+c,y=b+d$ 。这个可以轻松证明，不再赘述。

由 Farey 序列的定义，我们可以得到 $F_i$ 的长度 $L_i$ 公式为：

$$
L_i=L_{i-1}+\varphi(i)\\
L_i=1+\sum_{k=1}^i\varphi(k)
$$

 **本页面主要译自博文 [Дерево Штерна-Броко. Ряд Фарея](http://e-maxx.ru/algo/stern_brocot_farey) 与其英文翻译版 [The Stern-Brocot Tree and Farey Sequences](https://cp-algorithms.com/others/stern_brocot_tree_farey_sequences.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# endianness
字节顺序是跨越多字节的程序对象的存储规则，表示一个对象的字节的排列方法。

字节顺序有两种，分为小端序（little endian）和大端序（big endian）。

事实上，这两种字节顺序没有孰优孰劣之分。这两种顺序的名字（ `小端` 和 `大端` ），正是出自《格列佛游记》一书，书中的两个派别交战的原因是无法就从哪一端打开鸡蛋达成一致。就和鸡蛋的问题一样，选择何种字节顺序成了没有技术上理由的争论。

当然，字节顺序的不一致会导致二进制数据在不同类型的机器之间进行传输时被反序。为了避免这件事情，网络应用程序建立了一套标准，保证发送过程中是使用约定好的网络标准，而不是不同机器的内部表示。

下面，我们以一个位于 `0x100` 处，类型为 `int` ，十六进制值为 `0x01234567` 的变量为例介绍两种字节顺序：

（这里 `0x01` 是最高位有效字节， `0x67` 是最低位有效字节）

## 小端序

小端序是指机器选择在内存中按照从 **最低** 有效字节到 **最高** 有效字节的顺序存储对象。

上文提到的变量就表示如下：

| .... | 0x100 | 0x101 | 0x102 | 0x103 | .... |
| ---- | ----- | ----- | ----- | ----- | ---- |
| .... | 67    | 45    | 23    | 01    | .... |

## 大端序

大端序是指机器选择在内存中按照从 **最高** 有效字节到 **最低** 有效字节的顺序存储对象。

上文提到的变量就表示如下：

| .... | 0x100 | 0x101 | 0x102 | 0x103 | .... |
| ---- | ----- | ----- | ----- | ----- | ---- |
| .... | 01    | 23    | 45    | 67    | .... |

## 惯例

小端序：x86, ARM processors running Android, iOS, and Windows

大端序：Sun, PPC Mac, Internet

# josephus
约瑟夫问题由来已久，而这个问题的解法也在不断改进，只是目前仍没有一个极其高效的算法（log 以内）解决这个问题。

## 问题描述

> n 个人标号 $0,1,\cdots, n-1$ 。逆时针站一圈，从 $0$ 号开始，每一次从当前的人逆时针数 $k$ 个，然后让这个人出局。问最后剩下的人是谁。

这个经典的问题由约瑟夫于公元 1 世纪提出，尽管他当时只考虑了 $k=2$ 的情况。现在我们可以用许多高效的算法解决这个问题。

## 朴素算法

最朴素的算法莫过于直接枚举。用一个环形链表枚举删除的过程，重复 $n-1$ 次得到答案。复杂度 $\Theta (n^2)$ 。

## 简单优化

寻找下一个人的过程可以用线段树优化。具体地，开一个 $0,1,\cdots, n-1$ 的线段树，然后记录区间内剩下的人的个数。寻找当前的人的位置以及之后的第 $k$ 个人可以在线段树上二分做。

## 线性算法

设 $J_{n,k}$ 表示规模分别为 $n,k$ 的约瑟夫问题的答案。我们有如下递归式

$$
J_{n,k}=(J_{n-1,k}+k)\bmod n
$$

这个也很好推。你从 $0$ 开始数 $k$ 个，让第 $k-1$ 个人出局后剩下 $n-1$ 个人，你计算出在 $n-1$ 个人中选的答案后，再加一个相对位移 $k$ 得到真正的答案。这个算法的复杂度显然是 $\Theta (n)$ 的。

```cpp
int josephus(int n, int k) {
  int res = 0;
  for (int i = 1; i <= n; ++i) res = (res + k) % i;
  return res;
}
```

## 对数算法

对于 $k$ 较小 $n$ 较大的情况，本题还有一种复杂度为 $\Theta (k\log n)$ 的算法。

考虑到我们每次走 $k$ 个删一个，那么在一圈以内我们可以删掉 $\left\lfloor\frac{n}{k}\right\rfloor$ 个，然后剩下了 $n-\left\lfloor\frac{n}{k}\right\rfloor$ 个人。这时我们在第 $\left\lfloor\frac{n}{k}\right\rfloor\cdot k$ 个人的位置上。而你发现这个东西它等于 $n-n\bmod k$ 。于是我们继续递归处理，算完后还原它的相对位置。得到如下的算法：

```cpp
int josephus(int n, int k) {
  if (n == 1) return 0;
  if (k == 1) return n - 1;
  if (k > n) return (josephus(n - 1, k) + k) % n;  // 线性算法
  int res = josephus(n - n / k, k);
  res -= n % k;
  if (res < 0)
    res += n;  // mod n
  else
    res += res / (k - 1);  // 还原位置
  return res;
}
```

可以证明这个算法的复杂度是 $\Theta (k\log n)$ 的。我们设这个过程的递归次数是 $x$ ，那么每一次问题规模会大致变成 $\displaystyle n\left(1-\frac{1}{k}\right)$ ，于是得到

$$
n\left(1-\frac{1}{k}\right)^x=1
$$

解这个方程得到

$$
x=-\frac{\ln n}{\ln\left(1-\frac{1}{k}\right)}
$$

下面我们证明该算法的复杂度是 $\Theta (k\log n)$ 的。

考虑 $\displaystyle \lim _{k \rightarrow \infty} k \log \left(1-\frac{1}{k}\right)$ ，我们有

$$
\begin{aligned}
\lim _{k \rightarrow \infty} k \log \left(1-\frac{1}{k}\right)&=\lim _{k \rightarrow \infty} \frac{\log \left(1-\frac{1}{k}\right)}{1 / k}\\
&=\lim _{k \rightarrow \infty} \frac{\frac{\mathrm d}{\mathrm d k} \log \left(1-\frac{1}{k}\right)}{\frac{\mathrm d}{\mathrm d k}\left(\frac{1}{k}\right)}\\
&=\lim _{k \rightarrow \infty} \frac{\frac{1}{k^{2}\left(1-\frac{1}{k}\right)}}{-\frac{1}{k^{2}}}\\
&=\lim _{k \rightarrow \infty}-\frac{k}{k-1}\\
&=-\lim _{k \rightarrow \infty} \frac{1}{1-\frac{1}{k}}\\
&=-1
\end{aligned}
$$

所以 $x \sim k \ln n, k\to \infty$ ，即 $-\dfrac{\ln n}{\ln\left(1-\frac{1}{k}\right)}= \Theta (k\log n)$ 

 **本页面主要译自博文 [Задача Иосифа](https://e-maxx.ru/algo/joseph_problem) 与其英文翻译版 [Josephus Problem](https://cp-algorithms.com/others/josephus_problem.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# io
在默认情况下， `std::cin/std::cout` 是极为迟缓的读入/输出方式，而 `scanf/printf` 比 `std::cin/std::cout` 快得多。

可是为什么会这样呢？有没有什么办法解决读入输出缓慢的问题呢？

## 关闭同步/解除绑定

###  `std::ios::sync_with_stdio(false)` 

这个函数是一个“是否兼容 stdio”的开关，C++ 为了兼容 C，保证程序在使用了 `printf` 和 `std::cout` 的时候不发生混乱，将输出流绑到了一起。

这其实是 C++ 为了兼容而采取的保守措施。我们可以在进行 IO 操作之前将 stdio 解除绑定，但是在这样做之后要注意不能同时使用 `std::cin/std::cout` 和 `scanf/printf` 。

###  `tie` 

tie 是将两个 stream 绑定的函数，空参数的话返回当前的输出流指针。

在默认的情况下 `std::cin` 绑定的是 `std::cout` ，每次执行 `<<` 操作符的时候都要调用 `flush()` ，这样会增加 IO 负担。可以通过 `std::cin.tie(0)` （0 表示 NULL）来解除 `std::cin` 与 `std::cout` 的绑定，进一步加快执行效率。

### 代码实现

```cpp
std::ios::sync_with_stdio(false);
std::cin.tie(0);
// 如果编译开启了 C++11 或更高版本，建议使用 std::cin.tie(nullptr);
```

## 读入优化

 `scanf` 和 `printf` 依然有优化的空间，这就是本章所介绍的内容——读入和输出优化。

-   注意，本页面中介绍的读入和输出优化均针对整型数据，若要支持其他类型的数据（如浮点数），可自行按照本页面介绍的优化原理来编写代码。

### 原理

众所周知， `getchar` 是用来读入 1 byte 的数据并将其转换为 `char` 类型的函数，且速度很快，故可以用“读入字符——转换为整型”来代替缓慢的读入

每个整数由两部分组成——符号和数字

整数的 '+' 通常是省略的，且不会对后面数字所代表的值产生影响，而 '-' 不可省略，因此要进行判定

10 进制整数中是不含空格或除 0~9 和正负号外的其他字符的，因此在读入不应存在于整数中的字符（通常为空格）时，就可以判定已经读入结束

C 和 C++ 语言分别在 ctype.h 和 cctype 头文件中，提供了函数 `isdigit` , 这个函数会检查传入的参数是否为十进制数字字符，是则返回 **true** ，否则返回 **false** 。对应的，在下面的代码中，可以使用 `isdigit(ch)` 代替 `ch >= '0' && ch <= '9'` ，而可以使用 `!isdigit(ch)` 代替 `ch <'0' || ch> '9'` 

### 代码实现

```cpp
int read() {
  int x = 0, w = 1;
  char ch = 0;
  while (ch < '0' || ch > '9') {  // ch 不是数字时
    if (ch == '-') w = -1;        // 判断是否为负
    ch = getchar();               // 继续读入
  }
  while (ch >= '0' && ch <= '9') {  // ch 是数字时
    x = x * 10 + (ch - '0');  // 将新读入的数字’加’在 x 的后面
    // x 是 int 类型，char 类型的 ch 和 ’0’ 会被自动转为其对应的
    // ASCII 码，相当于将 ch 转化为对应数字
    // 此处也可以使用 (x<<3)+(x<<1) 的写法来代替 x*10
    ch = getchar();  // 继续读入
  }
  return x * w;  // 数字 * 正负号 = 实际数值
}
```

-   举例

读入 num 可写为 `num=read();` 

## 输出优化

### 原理

同样是众所周知， `putchar` 是用来输出单个字符的函数

因此将数字的每一位转化为字符输出以加速

要注意的是，负号要单独判断输出，并且每次 %（mod）取出的是数字末位，因此要倒序输出

### 代码实现

```cpp
int write(int x) {
  if (x < 0) {  // 判负 + 输出负号 + 变原数为正数
    x = -x;
    putchar('-');
  }
  if (x > 9) write(x / 10);  // 递归，将除最后一位外的其他部分放到递归中输出
  putchar(x % 10 + '0');  // 已经输出（递归）完 x 末位前的所有数字，输出末位
}
```

但是递归实现常数是较大的，我们可以写一个栈来实现这个过程

```cpp
inline void write(int x) {
  static int sta[35];
  int top = 0;
  do {
    sta[top++] = x % 10, x /= 10;
  } while (x);
  while (top) putchar(sta[--top] + 48);  // 48 是 '0'
}
```

-   举例

输出 num 可写为 `write(num);` 

## 更快的读入/输出优化

通过 `fread` 或者 `mmap` 可以实现更快的读入。其本质为一次性将输入文件读入一个巨大的缓存区，如此比逐个字符读入要快的多 ( `getchar` , `putchar` ）。因为硬盘的多次读写速度是要慢于内存的，所以先一次性读到缓存区里再从缓存区读入要快的多。

更通用的是 `fread` ，因为 `mmap` 不能在 Windows 环境下使用。

 `fread` 类似于参数为 `"%s"` 的 `scanf` ，不过它更为快速，而且可以一次性读入若干个字符（包括空格换行等制表符），如果缓存区足够大，甚至可以一次性读入整个文件。

对于输出，我们还有对应的 `fwrite` 函数

```cpp
std::size_t fread(void* buffer, std::size_t size, std::size_t count,
                  std::FILE* stream);
std::size_t fwrite(const void* buffer, std::size_t size, std::size_t count,
                   std::FILE* stream);
```

使用示例： `fread(Buf, 1, SIZE, stdin)` ，表示从 stdin 文件流中读入 SIZE 个大小为 1 byte 的数据块到 Buf 中。

读入之后的使用就跟普通的读入优化相似了，只需要重定义一下 getchar。它原来是从文件中读入一个 char，现在变成从 Buf 中读入一个 char，也就是头指针向后移动一位。

```cpp
char buf[1 << 20], *p1, *p2;
#define gc()                                                               \
  (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) \
       ? EOF                                                               \
       : *p1++)
```

 `fwrite` 也是类似的，先放入一个 `OutBuf[MAXSIZE]` 中，最后通过 `fwrite` 一次性将 `OutBuf` 输出。

参考代码：

```cpp
namespace IO {
const int MAXSIZE = 1 << 20;
char buf[MAXSIZE], *p1, *p2;
#define gc()                                                               \
  (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \
       ? EOF                                                               \
       : *p1++)
inline int rd() {
  int x = 0, f = 1;
  char c = gc();
  while (!isdigit(c)) {
    if (c == '-') f = -1;
    c = gc();
  }
  while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();
  return x * f;
}
char pbuf[1 << 20], *pp = pbuf;
inline void push(const char &c) {
  if (pp - pbuf == 1 << 20) fwrite(pbuf, 1, 1 << 20, stdout), pp = pbuf;
  *pp++ = c;
}
inline void write(int x) {
  static int sta[35];
  int top = 0;
  do {
    sta[top++] = x % 10, x /= 10;
  } while (x);
  while (top) push(sta[--top] + '0');
}
}  // namespace IO
```

## 输入输出的缓冲

 `printf` 和 `scanf` 是有缓冲区的。这也就是为什么，如果输入函数紧跟在输出函数之后/输出函数紧跟在输入函数之后可能导致错误。

### 刷新缓冲区

1.  程序结束
2.  关闭文件
3.   `printf` 输出 `\r` 或者 `\n` 到终端的时候（注：如果是输出到文件，则不会刷新缓冲区）
4.  手动 `fflush()` 
5.  缓冲区满自动刷新
6.   `cout` 输出 `endl` 

## 使输入输出优化更为通用

如果你的程序使用多个类型的变量，那么可能需要写多个输入输出优化的函数。下面给出的代码使用 [C++ 中的 `template` ](http://www.cplusplus.com/doc/oldtutorial/templates) 实现了对于所有整数类型的输入输出优化。

```cpp
template <typename T>
inline T
read() {  //声明 template 类,要求提供输入的类型T,并以此类型定义内联函数 read()
  T sum = 0, fl = 1;  //将 sum,fl 和 ch 以输入的类型定义
  int ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') fl = -1;
  for (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';
  return sum * fl;
}
```

如果要分别输入 `int` 类型的变量 a， `long long` 类型的变量 b 和 `__int128` 类型的变量 c，那么可以写成

```cpp
a = read<int>();
b = read<long long>();
c = read<__int128>();
```

## 完整带调试版

关闭调试开关时使用 `fread()` , `fwrite()` ，退出时自动析构执行 `fwrite()` 。

开启调试开关时使用 `getchar()` , `putchar()` ，便于调试。

若要开启文件读写时，请在所有读写之前加入 `freopen()` 。

```cpp
// #define DEBUG 1  //调试开关
struct IO {
#define MAXSIZE (1 << 20)
#define isdigit(x) (x >= '0' && x <= '9')
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}
  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  inline char gc() {
#if DEBUG  //调试，可显示字符
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? ' ' : *p1++;
  }
  inline bool blank(char ch) {
    return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
  }
  template <class T>
  inline void read(T &x) {
    register double tmp = 1;
    register bool sign = 0;
    x = 0;
    register char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == '-') sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0');
    if (ch == '.')
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - '0');
    if (sign) x = -x;
  }
  inline void read(char *s) {
    register char ch = gc();
    for (; blank(ch); ch = gc())
      ;
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  inline void read(char &c) {
    for (c = gc(); blank(c); c = gc())
      ;
  }
  inline void push(const char &c) {
#if DEBUG  //调试，可显示字符
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }
  template <class T>
  inline void write(T x) {
    if (x < 0) x = -x, push('-');  // 负数输出
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + '0');
  }
  template <class T>
  inline void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;
```

## 参考

 <http://www.hankcs.com/program/cpp/cin-tie-with-sync_with_stdio-acceleration-input-and-output.html> 

 <http://meme.biology.tohoku.ac.jp/students/iwasaki/cxx/speed.html> 

# rollback-mo-algo
author: StudyingFather, Backl1ght, countercurrent-time, Ir1d, greyqz, MicDZ, ouuan

有些题目在区间转移时，可能会出现增加或者删除无法实现的问题。在只有增加不可实现或者只有删除不可实现的时候，就可以使用回滚莫队在 $O(n \sqrt n)$ 的时间内解决问题。回滚莫队的核心思想就是既然我只能实现一个操作，那么我就只使用一个操作，剩下的交给回滚解决。

回滚莫队分为只使用增加操作的回滚莫队和只使用删除操作的回滚莫队。以下仅介绍只使用增加操作的回滚莫队，只使用删除操作的回滚莫队和只使用增加操作的回滚莫队只在算法实现上有一点区别，故不再赘述。

## 例题 [JOISC 2014 Day1 历史研究](https://loj.ac/problem/2874) 

给你一个长度为 $n$ 的数组 $A$ 和 $m$ 个询问 $(1 \leq n, m \leq 10^5)$ ，每次询问一个区间 $[L, R]$ 内重要度最大的数字，要求 **输出其重要度** 。一个数字 $i$ 重要度的定义为 $i$ 乘上 $i$ 在区间内出现的次数。

在这个问题中，在增加的过程中更新答案是很好实现的，但是在删除的过程中更新答案是不好实现的。因为如果增加会影响答案，那么新答案必定是刚刚增加的数字的重要度，而如果删除过后区间重要度最大的数字改变，我们很难确定新的重要度最大的数字是哪一个。所以，普通的莫队很难解决这个问题。

## 具体算法

-   对原序列进行分块，对询问按以左端点所属块编号升序为第一关键字，右端点升序为第二关键字的方式排序
-   按顺序处理询问
    -   如果询问左端点所属块 $B$ 和上一个询问左端点所属块的不同，那么将莫队区间的左端点初始化为 $B$ 的右端点加 1, 将莫队区间的右端点初始化为 $B$ 的右端点
    -   如果询问的左右端点所属的块相同，那么直接扫描区间回答询问
    -   如果询问的左右端点所属的块不同
        -   如果询问的右端点大于莫队区间的右端点，那么不断扩展右端点直至莫队区间的右端点等于询问的右端点
        -   不断扩展莫队区间的左端点直至莫队区间的左端点等于询问的左端点
        -   回答询问
        -   撤销莫队区间左端点的改动，使莫队区间的左端点回滚到 $B$ 的右端点加 1

## 复杂度证明

假设左右端点同属于一个块的询问个个数为 $C_1$ ，左右端点不属于同一个块的询问的个数为 $C_2$ 。

回答一个左右端点同属于一个块的询问的时间复杂度为 $O(\sqrt n)$ ，回答所有左右端点同属于一个块的询问的时间复杂度为 $O(C_1\sqrt n)$ 。

对于左右端点不属于同一个块的询问，将其按左端点所属块分类。对于一类询问，假设属于这一类询问的个数为 $c_i$ 。在回答这一类询问的时候莫队区间右端点至多扩展 $n$ 次；回答这一类问题中的一个的时候，左端点扩展和回滚的复杂度为 $O(\sqrt n)$ 。由此，回答一类问题的复杂度为 $O(n + c_i\sqrt n)$ 。总共有 $\sqrt n$ 类询问，所以回答左右端点不属于同一个块的询问的时间复杂度为 $O(C_2\sqrt n + n\sqrt n)$ 。

综上，这个算法的复杂度 $T(n) = O(C_2\sqrt n + n\sqrt n) + O(C_1\sqrt n) = O(n\sqrt n + m\sqrt n)$ 。

??? 参考代码
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int N = 1e5 + 5;
    int n, q;
    int x[N], t[N], m;
    
    struct Query {
      int l, r, id;
    } Q[N];
    int pos[N], L[N], R[N], sz, tot;
    int cnt[N], __cnt[N];
    ll ans[N];
    
    inline bool cmp(const Query& A, const Query& B) {
      if (pos[A.l] == pos[B.l]) return A.r < B.r;
      return pos[A.l] < pos[B.l];
    }
    
    void build() {
      sz = sqrt(n);
      tot = n / sz;
      for (int i = 1; i <= tot; i++) {
        L[i] = (i - 1) * sz + 1;
        R[i] = i * sz;
      }
      if (R[tot] < n) {
        ++tot;
        L[tot] = R[tot - 1] + 1;
        R[tot] = n;
      }
    }
    
    inline void Add(int v, ll& Ans) {
      ++cnt[v];
      Ans = max(Ans, 1LL * cnt[v] * t[v]);
    }
    
    inline void Del(int v) { --cnt[v]; }
    
    int main() {
      scanf("%d %d", &n, &q);
      for (int i = 1; i <= n; i++) scanf("%d", &x[i]), t[++m] = x[i];
      for (int i = 1; i <= q; i++) scanf("%d %d", &Q[i].l, &Q[i].r), Q[i].id = i;
    
      build();
    
      // 对询问进行排序
      for (int i = 1; i <= tot; i++)
        for (int j = L[i]; j <= R[i]; j++) pos[j] = i;
      sort(Q + 1, Q + 1 + q, cmp);
    
      // 离散化
      sort(t + 1, t + 1 + m);
      m = unique(t + 1, t + 1 + m) - (t + 1);
      for (int i = 1; i <= n; i++) x[i] = lower_bound(t + 1, t + 1 + m, x[i]) - t;
    
      int l = 1, r = 0, last_block = 0, __l;
      ll Ans = 0, tmp;
      for (int i = 1; i <= q; i++) {
        // 询问的左右端点同属于一个块则暴力扫描回答
        if (pos[Q[i].l] == pos[Q[i].r]) {
          for (int j = Q[i].l; j <= Q[i].r; j++) ++__cnt[x[j]];
          for (int j = Q[i].l; j <= Q[i].r; j++)
            ans[Q[i].id] = max(ans[Q[i].id], 1LL * t[x[j]] * __cnt[x[j]]);
          for (int j = Q[i].l; j <= Q[i].r; j++) --__cnt[x[j]];
          continue;
        }
    
        // 访问到了新的块则重新初始化莫队区间
        if (pos[Q[i].l] != last_block) {
          while (r > R[pos[Q[i].l]]) Del(x[r]), --r;
          while (l < R[pos[Q[i].l]] + 1) Del(x[l]), ++l;
          Ans = 0;
          last_block = pos[Q[i].l];
        }
    
        // 扩展右端点
        while (r < Q[i].r) ++r, Add(x[r], Ans);
        __l = l;
        tmp = Ans;
    
        // 扩展左端点
        while (__l > Q[i].l) --__l, Add(x[__l], tmp);
        ans[Q[i].id] = tmp;
    
        // 回滚
        while (__l < l) Del(x[__l]), ++__l;
      }
      for (int i = 1; i <= q; i++) printf("%lld\n", ans[i]);
      return 0;
    }
    ```

## 参考资料

-    [回滚莫队及其简单运用 | Parsnip's Blog](https://www.cnblogs.com/Parsnip/p/10969989.html) 

# mo-algo-with-bitset
author: StudyingFather, Backl1ght, countercurrent-time, Ir1d, greyqz, MicDZ, ouuan

bitset 常用于常规数据结构难以维护的的判定、统计问题，而莫队可以维护常规数据结构难以维护的区间信息。把两者结合起来使用可以同时利用两者的优势。

## 例题 [「Ynoi2016」掉进兔子洞](https://www.luogu.com.cn/problem/P4688) 

本题刚好符合上面提到的莫队配合 bitset 的特征。不难想到我们可以分别用 bitset 存储每一个区间内的出现过的所有权值，一组询问的答案即所有区间的长度和减去三者的并集元素个数 $\times 3$ 。

但是在莫队中使用 bitset 也需要针对 bitset 的特性调整算法：

1.  bitset 不能很好地处理同时出现多个权值的情况。我们可以把当前元素离散化后的权值与当前区间的的出现次数之和作为往 bitset 中插入的对象。
2.  我们平常使用莫队时，可能会不注意 4 种移动指针的方法顺序，所以指针移动的过程中可能会出现区间的左端点在右端点右边，区间长度为负值的情况，导致元素的个数为负数。这在其他情况下并没有什么影响，但是本题中在 bitset 中插入的元素与元素个数有关，所以我们需要注意 4 种移动指针的方法顺序，将左右指针分别往左边和右边移动的语句写在前面，避免往 bitset 中插入负数。
3.  虽然 bitset 用空间小，但是仍然难以承受 $10 ^ 5 \times 10 ^ 5$ 的数据规模。所以我们需要将询问划分成常数块分别处理，保证空间刚好足够的情况下时间复杂度不变。

??? 参考代码
    ```cpp
    #include <algorithm>
    #include <bitset>
    #include <cmath>
    #include <cstdio>
    #include <cstring>
    using namespace std;
    const int N = 100005, M = N / 3 + 10;
    int n, m, maxn;
    int a[N], ans[M], cnt[N];
    bitset<N> sum[M], now;
    struct query {
      int l, r, id;
      bool operator<(const query& x) const {
        if (l / maxn != x.l / maxn) return l < x.l;
        return (l / maxn) & 1 ? r < x.r : r > x.r;
      }
    } q[M * 3];
    void static_set() {
      static int tmp[N];
      memcpy(tmp, a, sizeof(a));
      sort(tmp + 1, tmp + n + 1);
      for (int i = 1; i <= n; i++)
        a[i] = lower_bound(tmp + 1, tmp + n + 1, a[i]) - tmp;
    }
    void add(int x) {
      now.set(x + cnt[x]);
      cnt[x]++;
    }
    void del(int x) {
      cnt[x]--;
      now.reset(x + cnt[x]);
    }
    void solve() {
      int cnt = 0, tot = 0;
      now.reset();
      for (tot = 0; tot < M - 5 && m; tot++) {
        m--;
        ans[tot] = 0;
        sum[tot].set();
        for (int j = 0; j < 3; j++) {
          scanf("%d%d", &q[cnt].l, &q[cnt].r);
          q[cnt].id = tot;
          ans[tot] += q[cnt].r - q[cnt].l + 1;
          cnt++;
        }
      }
      sort(q, q + cnt);
      for (int i = 0, l = 1, r = 0; i < cnt; i++) {
        while (l > q[i].l) add(a[--l]);
        while (r < q[i].r) add(a[++r]);
        while (l < q[i].l) del(a[l++]);
        while (r > q[i].r) del(a[r--]);
        sum[q[i].id] &= now;
      }
      for (int i = 0; i < tot; i++)
        printf("%d\n", ans[i] - (int)sum[i].count() * 3);
    }
    int main() {
      scanf("%d%d", &n, &m);
      for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
      static_set();
      maxn = sqrt(n);
      solve();
      memset(cnt, 0, sizeof(cnt));
      solve();
      memset(cnt, 0, sizeof(cnt));
      solve();
      return 0;
    }
    ```

## 习题

-    [小清新人渣的本愿](https://www.luogu.com.cn/problem/P3674) 
-    [「Ynoi2017」由乃的玉米田](https://www.luogu.com.cn/problem/P5355) 
-    [「Ynoi2011」WBLT](https://www.luogu.com.cn/problem/P5313) 

# parallel-binsearch
## 引子

在信息学竞赛中，有一部分题可以使用二分的办法来解决。但是当这种题目有多次询问且每次询问我们对每个查询都直接二分，可能会收获一个 TLE。这时候我们就会用到整体二分。整体二分的主体思路就是把多个查询一起解决。（所以这是一个离线算法）

> 可以使用整体二分解决的题目需要满足以下性质：
>
> 1.  询问的答案具有可二分性
>
> 2.   **修改对判定答案的贡献互相独立** ，修改之间互不影响效果
>
> 3.  修改如果对判定答案有贡献，则贡献为一确定的与判定标准无关的值
>
> 4.  贡献满足交换律，结合律，具有可加性
>
> 5.  题目允许使用离线算法
>
>     ——许昊然《浅谈数据结构题几个非经典解法》

## 思路

记 $[l,r]$ 为答案的值域， $[L,R]$ 为答案的定义域。（也就是说求答案时仅考虑下标在区间 $[L,R]$ 内的操作和询问，这其中询问的答案在 $[l,r]$ 内）

-   我们首先把所有操作 **按时间顺序** 存入数组中，然后开始分治。
-   在每一层分治中，利用数据结构（常见的是树状数组）统计当前查询的答案和 $mid$ 之间的关系。
-   根据查询出来的答案和 $mid$ 间的关系（小于等于 $mid$ 和大于 $mid$ ）将当前处理的操作序列分为 $q1$ 和 $q2$ 两份，并分别递归处理。
-   当 $l=r$ 时，找到答案，记录答案并返回即可。

需要注意的是，在整体二分过程中，若当前处理的值域为 $[l,r]$ ，则此时最终答案范围不在 $[l,r]$ 的询问会在其他时候处理。

## 详解

注：

1.  为可读性，文中代码或未采用实际竞赛中的常见写法。
2.  若觉得某段代码有难以理解之处，请先参考之前题目的解释，
    因为节省篇幅解释过的内容不再赘述。

从普通二分说起：

### 查询第 k 小：一次二分多个询问

>  **题 1** 在一个数列中查询第 $k$ 小的数。

当然可以直接排序。如果用二分法呢？可以用数据结构记录每个大小范围内有多少个数，然后用二分法猜测，利用数据结构检验。

>  **题 2** 在一个数列中多次查询第 $k$ 小的数。

可以对于每个询问进行一次二分；但是，也可以把所有的询问放在一起二分。

先考虑二分的本质：假设要猜一个 $[l,r]$ 之间的数，猜测之后会知道是猜大了，猜小了还是刚好。当然可以从 $l$ 枚举到 $r$ ，但更优秀的方法是二分：猜测答案是 $m = \lfloor\frac{l + r}{2}\rfloor$ ，然后去验证 $m$ 的正确性，再调整边界。这样做每次询问的复杂度为 $O(n\log n)$ ，若询问次数为 $q$ ，则时间复杂度为 $O(qn\log n)$ 。

回过头来，对于当前的所有询问，可以去猜测所有询问的答案都是 $mid$ ，然后去依次验证每个询问的答案应该是小于等于 $mid$ 的还是大于 $mid$ 的，并将询问分为两个部分（不大于/大于），对于每个部分继续二分。注意：如果一个询问的答案是大于 $mid$ 的，则在将其划至右侧前需更新它的 $k$ ，即，如果当前数列中小于等于 $mid$ 的数有 $t$ 个，则将询问划分后实际是在右区间询问第 $k - t$ 小数。如果一个部分的 $l = r$ 了，则结束这个部分的二分。利用线段树的相关知识，我们每次将整个答案可能在的区间 $[1,maxans]$ 划分成了若干个部分，这样的划分共进行了 $O(\log maxans)$ 次，一次划分会将整个操作序列操作一次。若对整个序列进行操作，并支持对应的查询的时间复杂度为 $O(T)$ ，则整体二分的时间复杂度为 $O(T\log n)$ 。

试试完成以下代码：

```cpp
struct Query {
  int id, k;  // 这个询问的编号, 这个询问的k
};
int ans[N];        // ans[i] 表示编号为i的询问的答案
int check(int x);  // 返回原数列中小于等于x的数的个数
void solve(int l, int r, vector<Query> q)
// 请补全这个函数
{
  int m = (l + r) / 2;
  vector<Query> q1, q2;  // 将被划到左侧的询问和右侧的询问
  if (l == r) {
    // ...
    return;
  }
  // ...
  solve(l, m, q1), solve(m + 1, r, q2);
  return;
}
```

参考代码如下

```cpp
void solve(int l, int r, vector<Query> q) {
  int m = (l + r) / 2;
  if (l == r) {
    for (unsigned i = 0; i < q.size(); i++) ans[q[i].id] = l;
    return;
  }
  vector<int> q1, q2;
  for (unsigned i = 0; i < q.size(); i++)
    if (check(m) <= q[i].k)
      q1.push_back(q[i]);
    else
      q[i].k -= check(m), q2.push_back(q[i]);
  solve(l, m, q1), solve(m + 1, r, q2);
  return;
}
```

### 区间查询第 k 小：对只询问指定区间的处理

>  **题 3** 在一个数列中多次查询区间第 $k$ 小的数。

涉及到给定区间的查询，再按之前的方法进行二分就会导致 `check` 函数的时间复杂度爆炸。仍然考虑询问与值域中点 $m$ 的关系：若询问区间内小于等于 $m$ 的数有 $t$ 个，询问的是区间内的 $k$ 小数，则当 $k \leq t$ 时，答案应小于等于 $m$ ；否则，答案应大于 $m$ 。（注意边界问题）此处需记录一个区间小于等于指定数的数的数量，即单点加，求区间和，可用树状数组快速处理。为提高效率，只对数列中值在值域区间 $[l,r]$ 的数进行统计，即，在进一步递归之前，不仅将询问划分，将当前处理的数按值域范围划为两半。

参考代码（关键部分）

```cpp
struct Num {
  int p, x;
};  // 位于数列中第 p 项的数的值为 x
struct Query {
  int l, r, k, id;
};  // 一个编号为 id, 询问 [l,r] 中第 k 大数的询问
int ans[N];
void add(int p, int x);  // 树状数组, 在 p 位置加上 x
int query(int p);        // 树状数组, 求 [1,p] 的和
void clear();            // 树状数组, 清空
void solve(int l, int r, vector<Num> a, vector<Query> q)
// a中为给定数列中值在值域区间 [l,r] 中的数
{
  int m = (l + r) / 2;
  if (l == r) {
    for (unsigned i = 0; i < q.size(); i++) ans[q[i].id] = l;
    return;
  }
  vector<Num> a1, a2;
  vector<Query> q1, q2;
  for (unsigned i = 0; i < a.size(); i++)
    if (a[i].x <= m)
      a1.push_back(a[i]), add(a[i].p, 1);
    else
      a2.push_back(a[i]);
  for (unsigned i = 0; i < q.size(); i++) {
    int t = query(q[i].r) - query(q[i].l - 1);
    if (q[i].k <= t)
      q1.push_back(q[i]);
    else
      q[i].k -= t, q2.push_back(q[i]);
  }
  clear();
  solve(l, m, a1, q1), solve(m + 1, r, a2, q2);
  return;
}
```

### 带修区间第 k 小：整体二分的完整运用

>  **题 4**  [Dynamic Rankings](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2112) 给定一个数列，要支持单点修改，区间查第 $k$ 小。

修改操作可以直接理解为从原数列中删去一个数再添加一个数，为方便起见，将询问和修改统称为“操作”。因后面的操作会依附于之前的操作，不能如题 3 一样将统计和处理询问分开，故可将所有操作存于一个数组，用标识区分类型，依次处理每个操作。为便于处理树状数组，修改操作可分拆为擦除操作和插入操作。

 **优化** 

1.  注意到每次对于操作进行分类时，只会更改操作顺序，故可直接在原数组上操作。具体实现，在二分时将记录操作的 $q, a$ 数组换为一个大的全局数组，二分时记录信息变为 $L, R$ ，即当前处理的操作是全局数组上的哪个区间。利用临时数组记录当前的分类情况，进一步递归前将临时数组信息写回原数组。
2.  树状数组每次清空会导致时间复杂度爆炸，可采用每次使用树状数组时记录当前修改位置（这已由 1 中提到的临时数组实现），本次操作结束后在原位置加 $-1$ 的方法快速清零。
3.  一开始对于数列的初始化操作可简化为插入操作。

关键部分参考代码

```cpp
struct Opt {
  int x, y, k, type, id;
  // 对于询问, type = 1, x, y 表示区间左右边界, k 表示询问第 k 小
  // 对于修改, type = 0, x 表示修改位置, y 表示修改后的值,
  // k 表示当前操作是插入(1)还是擦除(-1), 更新树状数组时使用.
  // id 记录每个操作原先的编号, 因二分过程中操作顺序会被打散
};
Opt q[N], q1[N], q2[N];
// q 为所有操作,
// 二分过程中, 分到左边的操作存到 q1 中, 分到右边的操作存到 q2 中.
int ans[N];
void add(int p, int x);
int query(int p);  // 树状数组函数, 含义见题3
void solve(int l, int r, int L, int R)
// 当前的值域范围为 [l,r], 处理的操作的区间为 [L,R]
{
  if (l > r || L > R) return;
  int cnt1 = 0, cnt2 = 0, m = (l + r) / 2;
  // cnt1, cnt2 分别为分到左边, 分到右边的操作数
  if (l == r) {
    for (int i = L; i <= R; i++)
      if (q[i].type == 1) ans[q[i].id] = l;
    return;
  }
  for (int i = L; i <= R; i++)
    if (q[i].type == 1) {  // 是询问: 进行分类
      int t = query(q[i].y) - query(q[i].x - 1);
      if (q[i].k <= t)
        q1[++cnt1] = q[i];
      else
        q[i].k -= t, q2[++cnt2] = q[i];
    } else
        // 是修改: 更新树状数组 & 分类
        if (q[i].y <= m)
      add(q[i].x, q[i].k), q1[++cnt1] = q[i];
    else
      q2[++cnt2] = q[i];
  for (int i = 1; i <= cnt1; i++)
    if (q1[i].type == 0) add(q1[i].pos, -q1[i].k);  // 清空树状数组
  for (int i = 1; i <= cnt1; i++) q[L + i - 1] = q1[i];
  for (int i = 1; i <= cnt2; i++)
    q[L + cnt1 + i - 1] = q2[i];  // 将临时数组中的元素合并回原数组
  solve(l, m, L, L + cnt1 - 1), solve(m + 1, r, L + cnt1, R);
  return;
}
```

### 参考习题

 [「国家集训队」矩阵乘法](https://www.luogu.org/problemnew/show/P1527) 

 [「POI2011 R3 Day2」流星 Meteors](https://loj.ac/problem/2169) 

## 参考资料

-   许昊然《浅谈数据结构题几个非经典解法》

# discrete
author: GavinZhengOI

## 简介

离散化本质上可以看成是一种 [哈希](../string/hash.md) ，其保证数据在哈希以后仍然保持原来的全/偏序关系。

通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。

用来离散化的可以是大整数、浮点数、字符串……等等。

## 实现

C++ 离散化有现成的 STL 算法：

### 离散化数组

将一个数组离散化，并进行查询是比较常用的应用场景：

```cpp
// a[i] 为初始数组,下标范围为 [1, n]
// len 为离散化后数组的有效长度
std::sort(a + 1, a + 1 + n);
len = std::unique(a + 1, a + n + 1) - a -
      1;  // 离散化整个数组的同时求出离散化后本质不同数的个数。
```

在完成上述离散化之后可以使用 `std::lower_bound` 函数查找离散化之后的排名（即新编号）：

```cpp
std::lower_bound(a + 1, a + len + 1, x) - a;  // 查询 x 离散化后对应的编号
```

同样地，我们也可以对 `vector` 进行离散化：

```cpp
// std::vector<int> a, b; // b 是 a 的一个副本
std::sort(a.begin(), a.end());
a.erase(std::unique(a.begin(), a.end()), a.end());
for (int i = 0; i < n; ++i)
  b[i] = std::lower_bound(a.begin(), a.end(), b[i]) - a.begin();
```

# hill-climbing
## 简介

爬山算法是一种局部择优的方法，采用启发式方法，是对深度优先搜索的一种改进，它利用反馈信息帮助生成解的决策。

直白地讲，就是当目前无法直接到达最优解，但是可以判断两个解哪个更优的时候，根据一些反馈信息生成一个新的可能解。

因此，爬山算法每次在当前找到的最优方案 $x$ 附近寻找一个新方案。如果这个新的解 $x'$ 更优，那么转移到 $x'$ ，否则不变。

这种算法对于单峰函数显然可行。

> Q：你都知道是单峰函数了为什么不三分呢
> A：在多年的 OI 生活中，我意识到了，人类是有极限的，无论多么工于心计，绞尽脑汁，状态总是表示不出来的，出题人的想法总是猜不透的，边界总是写不对的——所以——我不三分了 JOJO！

认真地说，爬山算法的优势在于当正解的写法你并不了解（常见于毒瘤计算几何和毒瘤数学题），或者本身状态维度很多，无法容易地写分治（例 2 就可以用二分完成合法正解）时，可以通过非常暴力的计算得到最优解。

但是对于多数需要求解的函数，爬山算法很容易进入一个局部最优解，如下图（最优解为 $\color{green}{\Uparrow}$ ，而爬山算法可能找到的最优解为 $\color{red}{\Downarrow}$ ）。

/home/llj/Desktop/OI-wiki-master/docs/misc/![](./images/hill-climbing.png)

* * *

## 具体实现

爬山算法一般会引入温度参数（类似模拟退火）。类比地说，爬山算法就像是一只兔子喝醉了在山上跳，它每次都会朝着它所认为的更高的地方（这往往只是个不准确的趋势）跳，显然它有可能一次跳到山顶，也可能跳过头翻到对面去。不过没关系，兔子翻过去之后还会跳回来。显然这个过程很没有用，兔子永远都找不到出路，所以在这个过程中兔子冷静下来并在每次跳的时候更加谨慎，少跳一点，以到达合适的最优点。

兔子逐渐变得清醒的过程就是降温过程，即温度参数在爬山的时候会不断减小。

关于降温：降温参数是略小于 $1$ 的常数，一般在 $[0.985, 0.999]$ 中选取。

### 例 1 [「JSOI2008」球形空间产生器](https://www.luogu.org/problem/P4035) 

题意：给出 $n$ 维空间中的 $n$ 个点，已知它们在同一个 $n$ 维球面上，求出球心。 $n \leq 10$ ，坐标绝对值不超过 $10000$ 。

很明显的单峰函数，可以使用爬山解决。本题算法流程：

1.  初始化球心为各个给定点的重心（即其各维坐标均为所有给定点对应维度坐标的平均值），以减少枚举量。
2.  对于当前的球心，求出每个已知点到这个球心欧氏距离的平均值。
3.  遍历所有已知点。记录一个改变值 cans（分开每一维度记录）对于每一个点的欧氏距离，如果大于平均值，就把改变值加上差值，否则减去。实际上并不用判断这个大小问题，只要不考虑绝对值，直接用坐标计算即可。这个过程可以形象地转化成一个新的球心，在空间里推来推去，碰到太远的点就往点的方向拉一点，碰到太近的点就往点的反方向推一点。
4.  将我们记录的 cans 乘上温度，更新球心，回到步骤 2
5.  在温度小于某个给定阈值的时候结束。

因此，我们在更新球心的时候，不能直接加上改变值，而是要加上改变值与温度的乘积。

并不是每一道爬山题都可以具体地用温度解决，这只是一个例子。

???+ 例题参考代码
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    double ans[10001], cans[100001], dis[10001], tot, f[1001][1001], seed = 718;
    int n;
    double check() {
      tot = 0;
      for (int i = 1; i <= n + 1; i++) {
        dis[i] = 0;
        cans[i] = 0;
        for (int j = 1; j <= n; j++)
          dis[i] += (f[i][j] - ans[j]) * (f[i][j] - ans[j]);
        dis[i] = sqrt(dis[i]);  //欧氏距离
        tot += dis[i];
      }
      tot /= (n + 1);  //平均
      for (int i = 1; i <= n + 1; i++)
        for (int j = 1; j <= n; j++)
          cans[j] += (dis[i] - tot) * (f[i][j] - ans[j]) /
                     tot;  //对于每个维度把修改值更新掉，欧氏距离差*差值贡献
    }
    int main() {
      srand(seed);
      cin >> n;
      for (int i = 1; i <= n + 1; i++)
        for (int j = 1; j <= n; j++) {
          cin >> f[i][j];
          ans[j] += f[i][j];
        }
      for (int i = 1; i <= n; i++) ans[i] /= (n + 1);   //初始化
      for (double t = 10001; t >= 0.0001; t *= 0.9999)  //不断降温
      {
        check();
        for (int i = 1; i <= n; i++) ans[i] += cans[i] * t;  //修改
      }
      for (int i = 1; i <= n; i++) printf("%.3f ", ans[i]);
    }
    ```

* * *

### 例 2 [「BZOJ 3680」吊打 XXX](https://www.luogu.org/problem/P1337) 

题意：求 $n$ 个点的带权类费马点。

框架类似，用了点物理知识。

???+ 参考代码
    ```cpp
    #include <cmath>
    #include <cstdio>
    const int N = 10005;
    int n, x[N], y[N], w[N];
    double ansx, ansy;
    void hillclimb() {
      double t = 1000;
      while (t > 1e-8) {
        double nowx = 0, nowy = 0;
        for (int i = 1; i <= n; ++i) {
          double dx = x[i] - ansx, dy = y[i] - ansy;
          double dis = sqrt(dx * dx + dy * dy);
          nowx += (x[i] - ansx) * w[i] / dis;
          nowy += (y[i] - ansy) * w[i] / dis;
        }
        ansx += nowx * t, ansy += nowy * t;
        if (t > 0.5)
          t *= 0.5;
        else
          t *= 0.97;
      }
    }
    int main() {
      scanf("%d", &n);
      for (int i = 1; i <= n; ++i) {
        scanf("%d%d%d", &x[i], &y[i], &w[i]);
        ansx += x[i], ansy += y[i];
      }
      ansx /= n, ansy /= n;
      hillclimb();
      printf("%.3lf %.3lf\n", ansx, ansy);
      return 0;
    }
    ```

* * *

## 优化

很容易想到的是，为了尽可能获取优秀的答案，我们可以多次爬山。方法有修改初始状态/修改降温参数/修改初始温度等，然后开一个全局最优解记录答案。每次爬山结束之后，更新全局最优解。

这样处理可能会存在的问题是超时，在正式考试时请手造大数据测试调参。

## 劣势

其实爬山算法的劣势上文已经提及：它容易陷入一个局部最优解。当目标函数不是单峰函数时，这个劣势是致命的。因此我们要引进 [ **模拟退火** ](./simulated-annealing.md) 。

# largest-matrix
## 适用问题

给定一个 $n\times m$ 的 01 矩阵 $a$ ，求其面积最大的子矩阵，使得这个子矩阵中的每一位的值都为 $0$ 。

## 悬线法

悬线法可以在 $O(nm)$ 的时间复杂度内解决以上问题。

### 悬线的定义

在讲解中，我们将值为 $1$ 的点称为“障碍点”。

悬线，就是一条竖线，这条竖线要满足其上端点在矩形的上边界或其上端点的上面是障碍点。

我们枚举每个点的悬线，求出其最多能向左和向右扩展到何处，取最大值，就能求出最大子矩阵了。

### 一些定义

定义 $up[i][j]$ 为矩阵上的点 $(i,j)$ 向上的悬线长度；

定义 $lft[i][j]$ 为点 $(i,j)$ 向左最多扩展而不会碰到障碍点的长度；

对应的，定义 $rgt[i][j]$ 为点 $(i,j)$ 向右最多扩展而不会碰到障碍点的长度。

### 用悬线法解决最大子矩阵问题

我们可以在 $O(nm)$ 的时间复杂度内预处理出 $up,lft,rgt$ 数组的值。

但是，仅仅做出预处理是不够的。我们发现，一条悬线向左扩展的最长距离还取决于 $lft[i-up[i][j]+1][j],lft[i-up[i][j]+2][j],...,lft[i-1][j]$ ，向右同理。所以，我们在枚举时对 $lft[i][j]$ 和 $rgt[i][j]$ 进行更新，使 $lft[i][j]=\max\{lft[i][j],lft[i-1][j]\},rgt[i][j]=\min\{rgt[i][j],rgt[i-1][j]\}$ 。

注意，我们在遇到障碍点的时候，不对 $lft$ 和 $rgt$ 值进行更新，因为障碍点使悬线的起点有所不同。

### 代码展示

```cpp
for (int i = 1; i <= n; i++)
  for (int j = 1; j <= m; j++)
    scanf(" %c", s[i] + j), lft[i][j] = rgt[i][j] = j, up[i][j] = 1;
for (int i = 1; i <= n; i++) {
  for (int j = 1; j <= m; j++)
    if (s[i][j] == '0' && s[i][j - 1] == '0') lft[i][j] = lft[i][j - 1];
  for (int j = m; j >= 1; j--)
    if (s[i][j] == '0' && s[i][j + 1] == '0') rgt[i][j] = rgt[i][j + 1];
}
for (int i = 1; i <= n; i++)
  for (int j = 1; j <= m; j++) {
    if (i > 1 && s[i][j] == '0' && s[i - 1][j] == '0') {
      lft[i][j] = max(lft[i][j], lft[i - 1][j]);
      rgt[i][j] = min(rgt[i][j], rgt[i - 1][j]);
      up[i][j] = up[i - 1][j] + 1;
    }
    ans = max(ans, (rgt[i][j] - lft[i][j] + 1) * up[i][j]);
  }
```

最后， $ans$ 即为最大子矩阵的面积。

## 习题

 [luogu P4147 玉蟾宫](https://www.luogu.org/problemnew/show/P4147) 

 [luogu P1578 奶牛浴场](https://www.luogu.org/problemnew/show/P1578) 

 [「ZJOI2007」棋盘制作](https://www.luogu.org/problem/P1169) 

# mo-algo
author: StudyingFather, Backl1ght, countercurrent-time, Ir1d, greyqz, MicDZ, ouuan

## 形式

假设 $n=m$ ，那么对于序列上的区间询问问题，如果从 $[l,r]$ 的答案能够 $O(1)$ 扩展到 $[l-1,r],[l+1,r],[l,r+1],[l,r-1]$ （即与 $[l,r]$ 相邻的区间）的答案，那么可以在 $O(n\sqrt{n})$ 的复杂度内求出所有询问的答案。

## 实现

离线后排序，顺序处理每个询问，暴力从上一个区间的答案转移到下一个区间答案（一步一步移动即可）。

## 排序方法

对于区间 $[l,r]$ , 以 $l$ 所在块的编号为第一关键字， $r$ 为第二关键字从小到大排序。

## 模板

```cpp
inline void move(int pos, int sign) {
  // update nowAns
}

void solve() {
  BLOCK_SIZE = int(ceil(pow(n, 0.5)));
  sort(querys, querys + m);
  for (int i = 0; i < m; ++i) {
    const query &q = querys[i];
    while (l > q.l) move(--l, 1);
    while (r < q.r) move(r++, 1);
    while (l < q.l) move(l++, -1);
    while (r > q.r) move(--r, -1);
    ans[q.id] = nowAns;
  }
}
```

## 复杂度分析

以下的情况在 $n$ 和 $m$ 同阶的前提下讨论。

首先是分块这一步，这一步的时间复杂度是 $O(\sqrt{n}\cdot\sqrt{n}\log\sqrt{n}+n\log n)=O(n\log n)$ ;

接着就到了莫队算法的精髓了，下面我们用通俗易懂的初中方法来证明它的时间复杂度是 $O(n\sqrt{n})$ ；

证：令每一块中 $L$ 的最大值为 $\max_1,\max_2,\max_3, \cdots , \max_{\lceil\sqrt{n}\rceil}$ 。

由第一次排序可知， $\max_1 \le \max_2 \le \cdots \le \max_{\lceil\sqrt{n}\rceil}$ 。

显然，对于每一块暴力求出第一个询问的时间复杂度为 $O(n)$ 。

考虑最坏的情况，在每一块中， $R$ 的最大值均为 $n$ ，每次修改操作均要将 $L$ 由 $\max_{i - 1}$ 修改至 $\max_i$ 或由 $\max_i$ 修改至 $\max_{i - 1}$ 。

考虑 $R$ ：因为 $R$ 在块中已经排好序，所以在同一块修改完它的时间复杂度为 $O(n)$ 。对于所有块就是 $O(n\sqrt{n})$ 。

重点分析 $L$ ：因为每一次改变的时间复杂度都是 $O(\max_i-\max_{i-1})$ 的，所以在同一块中时间复杂度为 $O(\sqrt{n}\cdot(\max_i-\max_{i-1}))$ 。

将每一块 $L$ 的时间复杂度合在一起，可以得到：

对于 $L$ 的总时间复杂度为

$$
\begin{aligned}
& O(\sqrt{n}(\max{}_1-1)+\sqrt{n}(\max{}_2-\max{}_1)+\sqrt{n}(\max{}_3-\max{}_2)+\cdots+\sqrt{n}(\max{}_{\lceil\sqrt{n}\rceil}-\max{}_{\lceil\sqrt{n}\rceil-1))} \\
= & O(\sqrt{n}\cdot(\max{}_1-1+\max{}_2-\max{}_1+\max{}_3-\max{}_2+\cdots+\max{}_{\lceil\sqrt{n}\rceil-1}-\max{}_{\lceil\sqrt{n}\rceil-2}+\max{}_{\lceil\sqrt{n}\rceil}-\max{}_{\lceil\sqrt{n}\rceil-1)}) \\
= & O(\sqrt{n}\cdot(\max{}_{\lceil\sqrt{n}\rceil-1}))\\
\end{aligned}
$$

（裂项求和）

由题可知 $\max_{\lceil\sqrt{n}\rceil}$ 最大为 $n$ ，所以 $L$ 的总时间复杂度最坏情况下为 $O(n\sqrt{n})$ 。

综上所述，莫队算法的时间复杂度为 $O(n\sqrt{n})$ ；

但是对于 $m$ 的其他取值，如 $m<n$ ，分块方式需要改变才能变的更优。

怎么分块呢？

我们设块长度为 $S$ ，那么对于任意多个在同一块内的询问，挪动的距离就是 $n$ ，一共 $\displaystyle \frac{n}{S}$ 个块，移动的总次数就是 $\displaystyle \frac{n^2}{S}$ ，移动可能跨越块，所以还要加上一个 $mS$ 的复杂度，总复杂度为 $\displaystyle O\left(\frac{n^2}{S}+mS\right)$ ，我们要让这个值尽量小，那么就要将这两个项尽量相等，发现 $S$ 取 $\displaystyle \frac{n}{\sqrt{m}}$ 是最优的，此时复杂度为 $\displaystyle O\left(\frac{n^2}{\displaystyle \frac{n}{\sqrt{m}}}+m\left(\frac{n}{\sqrt{m}}\right)\right)=O(n\sqrt{m})$ 。

## 例题 & 代码

???+note "例题[「国家集训队」小 Z 的袜子](https://www.luogu.com.cn/problem/P1494)"
    题目大意：

    有一个长度为 $n$ 的序列 $\{c_i\}$ 。现在给出 $m$ 个询问，每次给出两个数 $l,r$ ，从编号在 $l$ 到 $r$ 之间的数中随机选出两个不同的数，求两个数相等的概率。

思路：莫队算法模板题。

对于区间 $[l,r]$ ，以 $l$ 所在块的编号为第一关键字， $r$ 为第二关键字从小到大排序。

然后从序列的第一个询问开始计算答案，第一个询问通过直接暴力算出，复杂度为 $O(n)$ ，后面的询问在前一个询问的基础上得到答案。

具体做法：

对于区间 $[i,i]$ ，由于区间只有一个元素，我们很容易就能知道答案。然后一步一步从当前区间（已知答案）向下一个区间靠近。

我们设 $col[i]$ 表示当前颜色 $i$ 出现了多少次， $ans$ 当前共有多少种可行的配对方案（有多少种可以选到一双颜色相同的袜子），表示然后每次移动的时候更新答案——设当前颜色为 $k$ ，如果是增长区间就是 $ans$ 加上 $C_{col[k]+1}^2-C_{col[k]}^2$ ，如果是缩短就是 $ans$ 减去 $C_{col[k]}^2-C_{col[k]-1}^2$ 。

而这个询问的答案就是 $\displaystyle \frac{ans}{C_{r-l+1}^2}$ 。

这里有个优化： $\displaystyle C_a^2=\frac{a (a-1)}{2}$ 。

所以 $\displaystyle C_{a+1}^2-C_a^2=\frac{(a+1) a}{2}-\frac{a (a-1)}{2}=\frac{a}{2}\cdot (a+1-a+1)=\frac{a}{2}\cdot 2=a$ 。

所以 $C_{col[k]+1}^2-C_{col[k]}^2=col[k]$ 。

算法总复杂度： $O(n\sqrt{n} )$ 

下面的代码中 `deno` 表示答案的分母 (denominator)， `nume` 表示分子（numerator)， `sqn` 表示块的大小： $\sqrt{n}$ ， `arr` 是输入的数组， `node` 是存储询问的结构体， `tab` 是询问序列（排序后的）， `col` 同上所述。

 **注意：由于 `++l` 和 `--r` 的存在，下面代码中的移动区间的 4 个 for 循环的位置很关键，不能改变它们之间的位置关系。** 

??? 参考代码
    ```cpp
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    using namespace std;
    const int N = 50005;
    int n, m, maxn;
    int c[N];
    long long sum;
    int cnt[N];
    long long ans1[N], ans2[N];
    struct query {
      int l, r, id;
      bool operator<(const query &x) const {
        if (l / maxn != x.l / maxn) return l < x.l;
        return (l / maxn) & 1 ? r < x.r : r > x.r;
      }
    } a[N];
    void add(int i) {
      sum += cnt[i];
      cnt[i]++;
    }
    void del(int i) {
      cnt[i]--;
      sum -= cnt[i];
    }
    long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }
    int main() {
      scanf("%d%d", &n, &m);
      maxn = sqrt(n);
      for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
      for (int i = 0; i < m; i++) scanf("%d%d", &a[i].l, &a[i].r), a[i].id = i;
      sort(a, a + m);
      for (int i = 0, l = 1, r = 0; i < m; i++) {
        if (a[i].l == a[i].r) {
          ans1[a[i].id] = 0, ans2[a[i].id] = 1;
          continue;
        }
        while (l < a[i].l) del(c[l++]);
        while (l > a[i].l) add(c[--l]);
        while (r < a[i].r) add(c[++r]);
        while (r > a[i].r) del(c[r--]);
        ans1[a[i].id] = sum;
        ans2[a[i].id] = (long long)(r - l + 1) * (r - l) / 2;
      }
      for (int i = 0; i < m; i++) {
        if (ans1[i] != 0) {
          long long g = gcd(ans1[i], ans2[i]);
          ans1[i] /= g, ans2[i] /= g;
        } else
          ans2[i] = 1;
        printf("%lld/%lld\n", ans1[i], ans2[i]);
      }
      return 0;
    }
    ```

## 普通莫队的优化

我们看一下下面这组数据

```text
// 设块的大小为 2 (假设)
1 1
2 100
3 1
4 100
```

手动模拟一下可以发现，r 指针的移动次数大概为 300 次，我们处理完第一个块之后， $l = 2, r = 100$ ，此时只需要移动两次 l 指针就可以得到第四个询问的答案，但是我们却将 r 指针移动到 1 来获取第三个询问的答案，再移动到 100 获取第四个询问的答案，这样多了九十几次的指针移动。我们怎么优化这个地方呢？这里我们就要用到奇偶化排序。

什么是奇偶化排序？奇偶化排序即对于属于奇数块的询问，r 按从小到大排序，对于属于偶数块的排序，r 从大到小排序，这样我们的 r 指针在处理完这个奇数块的问题后，将在返回的途中处理偶数块的问题，再向 n 移动处理下一个奇数块的问题，优化了 r 指针的移动次数，一般情况下，这种优化能让程序快 30% 左右。

排序代码：

压行

```cpp
// 这里有个小细节等下会讲
int unit;  // 块的大小
struct node {
  int l, r, id;
  bool operator<(const node &x) const {
    return l / unit == x.l / unit
               ? (r == x.r ? 0 : ((l / unit) & 1) ^ (r < x.r))
               : l < x.l;
  }
};
```

不压行

```cpp
struct node {
  int l, r, id;
  bool operator<(const node &x) const {
    if (l / unit != x.l / unit) return l < x.l;
    if ((l / unit) & 1)
      return r <
             x.r;  // 注意这里和下面一行不能写小于（大于）等于，否则会出错（详见下面的小细节）
    return r > x.r;
  }
};
```

!!! warning
    小细节：如果使用 sort 比较两个函数，不能出现 $a < b$ 和 $b < a$ 同时为真的情况，否则会运行错误。

对于压行版，如果没有 `r == x.r` 的特判，当 l 属于同一奇数块且 r 相等时，会出现上面小细节中的问题（自己手动模拟一下），对于压行版，如果写成小于（大于）等于，则也会出现同样的问题。

## 参考资料

-    [莫队算法学习笔记 | Sengxian's Blog](https://blog.sengxian.com/algorithms/mo-s-algorithm) 

# mo-algo-on-tree
author: StudyingFather, Backl1ght, countercurrent-time, Ir1d, greyqz, MicDZ, ouuan

## 括号序树上莫队

一般的莫队只能处理线性问题，我们要把树强行压成序列。

我们可以将树的括号序跑下来，把括号序分块，在括号序上跑莫队。

具体怎么做呢？

dfs 一棵树，然后如果 dfs 到 x 点，就 `push_back(x)` ，dfs 完 x 点，就直接 `push_back(-x)` ，然后我们在挪动指针的时候，

-   新加入的值是 x  ---> `add(x)` 
-   新加入的值是 - x ---> `del(x)` 
-   新删除的值是 x  ---> `del(x)` 
-   新删除的值是 - x ---> `add(x)` 

这样的话，我们就把一棵树处理成了序列。

???+note "例题[「WC2013」糖果公园](http://uoj.ac/problem/58)"
    题意：给你一棵树，每个点有颜色，每次询问

    $$\sum_{c}val_c\sum_{i=1}^{cnt_c}w_i$$

    其中：$val$ 表示该颜色的价值，$cnt$ 表示颜色出现的次数，$w$ 表示该颜色出现 $i$ 次后的价值

先把树变成序列，然后每次添加/删除一个点，这个点的对答案的的贡献是可以在 $O(1)$ 时间内获得的，即 $val_c\times w_{cnt_{c+1}}$ 

发现因为他会把起点的子树也扫了一遍，产生多余的贡献，怎么办呢？

因为扫的过程中起点的子树里的点肯定会被扫两次，但贡献为 0。

所以可以开一个 $vis$ 数组，每次扫到点 x，就把 $vis_x$ 异或上 1。

如果 $vis_x=0$ ，那这个点的贡献就可以不计。

所以可以用树上莫队来求。

修改的话，加上一维时间维即可，变成带修改树上莫队。

然后因为所包含的区间内可能没有 LCA，对于没有的情况要将多余的贡献删除，然后就完事了。

??? 参考代码
    ```cpp
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    using namespace std;
    
    const int maxn = 200010;
    
    int f[maxn], g[maxn], id[maxn], head[maxn], cnt, last[maxn], dep[maxn],
        fa[maxn][22], v[maxn], w[maxn];
    int block, index, n, m, q;
    int pos[maxn], col[maxn], app[maxn];
    bool vis[maxn];
    long long ans[maxn], cur;
    
    struct edge {
      int to, nxt;
    } e[maxn];
    int cnt1 = 0, cnt2 = 0;  // 时间戳
    
    struct query {
      int l, r, t, id;
      bool operator<(const query &b) const {
        return (pos[l] < pos[b.l]) || (pos[l] == pos[b.l] && pos[r] < pos[b.r]) ||
               (pos[l] == pos[b.l] && pos[r] == pos[b.r] && t < b.t);
      }
    } a[maxn], b[maxn];
    
    inline void addedge(int x, int y) {
      e[++cnt] = (edge){y, head[x]};
      head[x] = cnt;
    }
    
    void dfs(int x) {
      id[f[x] = ++index] = x;
      for (int i = head[x]; i; i = e[i].nxt) {
        if (e[i].to != fa[x][0]) {
          fa[e[i].to][0] = x;
          dep[e[i].to] = dep[x] + 1;
          dfs(e[i].to);
        }
      }
      id[g[x] = ++index] = x;  // 括号序
    }
    
    inline int lca(int x, int y) {
      if (dep[x] < dep[y]) swap(x, y);
      if (dep[x] != dep[y]) {
        int dis = dep[x] - dep[y];
        for (int i = 20; i >= 0; i--)
          if (dis >= (1 << i)) dis -= 1 << i, x = fa[x][i];
      }  // 爬到同一高度
      if (x == y) return x;
      for (int i = 20; i >= 0; i--) {
        if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
      }
      return fa[x][0];
    }
    
    inline void add(int x) {
      if (vis[x])
        cur -= (long long)v[col[x]] * w[app[col[x]]--];
      else
        cur += (long long)v[col[x]] * w[++app[col[x]]];
      vis[x] ^= 1;
    }
    
    inline void modify(int x, int t) {
      if (vis[x]) {
        add(x);
        col[x] = t;
        add(x);
      } else
        col[x] = t;
    }  // 在时间维上移动
    
    int main() {
      scanf("%d%d%d", &n, &m, &q);
      for (int i = 1; i <= m; i++) scanf("%d", &v[i]);
      for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
      for (int i = 1; i < n; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        addedge(x, y);
        addedge(y, x);
      }
      for (int i = 1; i <= n; i++) {
        scanf("%d", &last[i]);
        col[i] = last[i];
      }
      dfs(1);
      for (int j = 1; j <= 20; j++)
        for (int i = 1; i <= n; i++)
          fa[i][j] = fa[fa[i][j - 1]][j - 1];  // 预处理祖先
      int block = pow(index, 2.0 / 3);
      for (int i = 1; i <= index; i++) {
        pos[i] = (i - 1) / block;
      }
      while (q--) {
        int opt, x, y;
        scanf("%d%d%d", &opt, &x, &y);
        if (opt == 0) {
          b[++cnt2].l = x;
          b[cnt2].r = last[x];
          last[x] = b[cnt2].t = y;
        } else {
          if (f[x] > f[y]) swap(x, y);
          a[++cnt1] = (query){lca(x, y) == x ? f[x] : g[x], f[y], cnt2, cnt1};
        }
      }
      sort(a + 1, a + cnt1 + 1);
      int L, R, T;  // 指针坐标
      L = R = 0;
      T = 1;
      for (int i = 1; i <= cnt1; i++) {
        while (T <= a[i].t) {
          modify(b[T].l, b[T].t);
          T++;
        }
        while (T > a[i].t) {
          modify(b[T].l, b[T].r);
          T--;
        }
        while (L > a[i].l) {
          L--;
          add(id[L]);
        }
        while (L < a[i].l) {
          add(id[L]);
          L++;
        }
        while (R > a[i].r) {
          add(id[R]);
          R--;
        }
        while (R < a[i].r) {
          R++;
          add(id[R]);
        }
        int x = id[L], y = id[R];
        int llca = lca(x, y);
        if (x != llca && y != llca) {
          add(llca);
          ans[a[i].id] = cur;
          add(llca);
        } else
          ans[a[i].id] = cur;
      }
      for (int i = 1; i <= cnt1; i++) {
        printf("%lld\n", ans[i]);
      }
      return 0;
    }
    ```

## 真·树上莫队

上面的树上莫队只是将树转化成了链，下面的才是真正的树上莫队。

由于莫队相关的问题都是模板题，因此实现部分不做太多解释

### 询问的排序

首先我们知道莫队的是基于分块的算法，所以我们需要找到一种树上的分块方法来保证时间复杂度。

条件：

-   属于同一块的节点之间的距离不超过给定块的大小
-   每个块中的节点不能太多也不能太少
-   每个节点都要属于一个块
-   编号相邻的块之间的距离不能太大

了解了这些条件后，我们看到这样一道题 [「SCOI2005」王室联邦](https://loj.ac/problem/2152) 。

在这道题的基础上我们只要保证最后一个条件就可以解决分块的问题了。

!!! 思路
    令 lim 为希望块的大小，首先，对于整个树 dfs，当子树的大小大于 lim 时，就将它们分在一块，容易想到：对于根，可能会剩下一些点，于是将这些点分在最后一个块里。

做法：用栈维护当前节点作为父节点访问它的子节点，当从栈顶到父节点的距离大于希望块的大小时，弹出这部分元素分为一块，最后剩余的一块单独作为一块。

最后的排序方法：若第一维时间戳大于第二维，交换它们，按第一维所属块为第一关键字，第二维时间戳为第二关键字排序。

### 指针的移动

容易想到，我们可以标记被计入答案的点，让指针直接向目标移动，同时取反路径上的点。

但是，这样有一个问题，若指针一开始都在 x 上，显然 x 被标记，当两个指针向同一子节点移动（还有许多情况）时，x 应该不被标记，但实际情况是 x 被标记，因为两个指针分别标记了一次，抵消了。

如何解决呢？

有一个很显然的性质：这些点肯定是某些 LCA，因为 LCA 处才有可能被重复撤销导致撤销失败。

所以我们每次不标记 LCA，到需要询问答案时再将 LCA 标记，然后再撤销。

```cpp
//取反路径上除LCA以外的所有节点
void move(int x, int y) {
  if (dp[x] < dp[y]) swap(x, y);
  while (dp[x] > dp[y]) update(x), x = fa[x];
  while (x != y) update(x), update(y), x = fa[x], y = fa[y];
  // x!=y保证LCA没被取反
}
```

对于求 LCA，我们可以用树剖，然后我们就可以把分块的步骤放到树剖的第一次 dfs 里面，时间戳也可以直接用第二次 dfs 的 dfs 序。

```cpp
int bl[100002], bls = 0;  //属于的块，块的数量
unsigned step;            //块大小
int fa[100002], dp[100002], hs[100002] = {0}, sz[100002] = {0};
//父节点，深度，重儿子，大小
stack<int> sta;
void dfs1(int x) {
  sz[x] = 1;
  unsigned ss = sta.size();
  for (int i = head[x]; i; i = nxt[i])
    if (ver[i] != fa[x]) {
      fa[ver[i]] = x;
      dp[ver[i]] = dp[x] + 1;
      dfs1(ver[i]);
      sz[x] += sz[ver[i]];
      if (sz[ver[i]] > sz[hs[x]]) hs[x] = ver[i];
      if (sta.size() - ss >= step) {
        bls++;
        while (sta.size() != ss) bl[sta.top()] = bls, sta.pop();
      }
    }
  sta.push(x);
}
// main
if (!sta.empty()) {
  bls++;  //这一行可写可不写
  while (!sta.empty()) bl[sta.top()] = bls, sta.pop();
}
```

### 时间复杂度

重点到了，这里关系到块的大小取值。

设块的大小为 $unit$ ：

-   对于 x 指针，由于每个块中节点的距离在 $unit$ 左右，每个块中 x 指针移动 $unit^2$ 次（ $unit\times dis_max$ ），共计 $n\times unit$ （ $unit^2 \times (n\div unit)$ ）次；
-   对于 y 指针，每个块中最多移动 $O(n)$ 次，共计 $n^2\div unit$ （ $n \times (n \div unit)$ ）次。

加起来大概在根号处取得最小值（由于树上莫队块的大小不固定，所以不一定要严格按照）。

### 例题「WC2013」糖果公园

由于多了时间维，块的大小取到 $0.6n$ 的样子就差不多了。

??? 参考代码
    ```cpp
    #include <bits/stdc++.h>
    //#pragma GCC optimize(2)
    using namespace std;
    inline int gi() {
      register int x, c, op = 1;
      while (c = getchar(), c < '0' || c > '9')
        if (c == '-') op = -op;
      x = c ^ 48;
      while (c = getchar(), c >= '0' && c <= '9')
        x = (x << 3) + (x << 1) + (c ^ 48);
      return x * op;
    }
    int head[100002], nxt[200004], ver[200004], tot = 0;
    void add(int x, int y) {
      ver[++tot] = y, nxt[tot] = head[x], head[x] = tot;
      ver[++tot] = x, nxt[tot] = head[y], head[y] = tot;
    }
    int bl[100002], bls = 0;
    unsigned step;
    int fa[100002], dp[100002], hs[100002] = {0}, sz[100002] = {0}, top[100002],
                                id[100002];
    stack<int> sta;
    void dfs1(int x) {
      sz[x] = 1;
      unsigned ss = sta.size();
      for (int i = head[x]; i; i = nxt[i])
        if (ver[i] != fa[x]) {
          fa[ver[i]] = x, dp[ver[i]] = dp[x] + 1;
          dfs1(ver[i]);
          sz[x] += sz[ver[i]];
          if (sz[ver[i]] > sz[hs[x]]) hs[x] = ver[i];
          if (sta.size() - ss >= step) {
            bls++;
            while (sta.size() != ss) bl[sta.top()] = bls, sta.pop();
          }
        }
      sta.push(x);
    }
    int cnt = 0;
    void dfs2(int x, int hf) {
      top[x] = hf, id[x] = ++cnt;
      if (!hs[x]) return;
      dfs2(hs[x], hf);
      for (int i = head[x]; i; i = nxt[i])
        if (ver[i] != fa[x] && ver[i] != hs[x]) dfs2(ver[i], ver[i]);
    }
    int lca(int x, int y) {
      while (top[x] != top[y]) {
        if (dp[top[x]] < dp[top[y]]) swap(x, y);
        x = fa[top[x]];
      }
      return dp[x] < dp[y] ? x : y;
    }
    struct qu {
      int x, y, t, id;
      bool operator<(const qu a) const {
        return bl[x] == bl[a.x] ? (bl[y] == bl[a.y] ? t < a.t : bl[y] < bl[a.y])
                                : bl[x] < bl[a.x];
      }
    } q[100001];
    int qs = 0;
    struct ch {
      int x, y, b;
    } upd[100001];
    int ups = 0;
    long long ans[100001];
    int b[100001] = {0};
    int a[100001];
    long long w[100001];
    long long v[100001];
    long long now = 0;
    bool vis[100001] = {0};
    void back(int t) {
      if (vis[upd[t].x]) {
        now -= w[b[upd[t].y]--] * v[upd[t].y];
        now += w[++b[upd[t].b]] * v[upd[t].b];
      }
      a[upd[t].x] = upd[t].b;
    }
    void change(int t) {
      if (vis[upd[t].x]) {
        now -= w[b[upd[t].b]--] * v[upd[t].b];
        now += w[++b[upd[t].y]] * v[upd[t].y];
      }
      a[upd[t].x] = upd[t].y;
    }
    void update(int x) {
      if (vis[x])
        now -= w[b[a[x]]--] * v[a[x]];
      else
        now += w[++b[a[x]]] * v[a[x]];
      vis[x] ^= 1;
    }
    void move(int x, int y) {
      if (dp[x] < dp[y]) swap(x, y);
      while (dp[x] > dp[y]) update(x), x = fa[x];
      while (x != y) update(x), update(y), x = fa[x], y = fa[y];
    }
    int main() {
      int n = gi(), m = gi(), k = gi();
      step = (int)pow(n, 0.6);
      for (int i = 1; i <= m; i++) v[i] = gi();
      for (int i = 1; i <= n; i++) w[i] = gi();
      for (int i = 1; i < n; i++) add(gi(), gi());
      for (int i = 1; i <= n; i++) a[i] = gi();
      for (int i = 1; i <= k; i++)
        if (gi())
          q[++qs].x = gi(), q[qs].y = gi(), q[qs].t = ups, q[qs].id = qs;
        else
          upd[++ups].x = gi(), upd[ups].y = gi();
      for (int i = 1; i <= ups; i++) upd[i].b = a[upd[i].x], a[upd[i].x] = upd[i].y;
      for (int i = ups; i; i--) back(i);
      fa[1] = 1;
      dfs1(1), dfs2(1, 1);
      if (!sta.empty()) {
        bls++;
        while (!sta.empty()) bl[sta.top()] = bls, sta.pop();
      }
      for (int i = 1; i <= n; i++)
        if (id[q[i].x] > id[q[i].y]) swap(q[i].x, q[i].y);
      sort(q + 1, q + qs + 1);
      int x = 1, y = 1, t = 0;
      for (int i = 1; i <= qs; i++) {
        if (x != q[i].x) move(x, q[i].x), x = q[i].x;
        if (y != q[i].y) move(y, q[i].y), y = q[i].y;
        int f = lca(x, y);
        update(f);
        while (t < q[i].t) change(++t);
        while (t > q[i].t) back(t--);
        ans[q[i].id] = now;
        update(f);
      }
      for (int i = 1; i <= qs; i++) printf("%lld\n", ans[i]);
      return 0;
    }
    ```

# job-order
你有 $n$ 个任务，要求你找到一个代价最小的的顺序执行他们。第 $i$ 个任务花费的时间是 $t_i$ ，而第 $i$ 个任务等待 $t$ 的时间会花费 $f_i(t)$ 的代价。

形式化地说，给出 $n$ 个函数 $f_i$ 和 $n$ 个数 $t_i$ ，求一个排列 $p$ ，最小化

$$
F(p)=\sum_{i=1}^nf_{p_i}\left(\sum_{j=1}^{i-1}t_{p_j}\right)
$$

## 特殊的代价函数

### 线性代价函数

首先我们考虑所有的函数是线性的函数，即 $f_i(x)=c_ix+d_i$ ，其中 $c_i$ 是非负整数。显然我们可以事先把常数项加起来，因此函数就转化为了 $f_i(x)=c_ix$ 的形式。

考虑两个排列 $p$ 和 $p'$ ，其中 $p'$ 是把 $p$ 的第 $i$ 个位置上的数和 $i+1$ 个位置上的数交换得到的排列。则

$$
\begin{split}
F(p')-F(p)&=c_{p'_i}\sum_{j=1}^{i-1}t_{p'_j}+c_{p'_{i+1}}\sum_{j=1}^{i}t_{p'_j}
-\left(c_{p_i}\sum_{j=1}^{i-1}t_{p_j}+c_{p_{i+1}}\sum_{j=1}^{i}t_{p_j}\right)\\
&=c_{p_i}t_{p_{i+1}}-c_{p_{i+1}}t_{p_i}
\end{split}
$$

于是我们使用如果 $c_{p_i}t_{p_{i+1}}-c_{p_{i+1}}t_{p_i}>0$ 就交换的策略做一下排序就可以了。写成 $\dfrac{c_{p_i}}{t_{p_i}}>\dfrac{c_{p_{i+1}}}{t_{p_{i+1}}}$ 的形式，就可以理解为将排列按 $\dfrac{c_i}{t_i}$ 升序排序。

处理这个问题，我们的思路是考虑微扰后的变换情况，贪心地选取最优解。

### 指数代价函数

考虑代价函数的形式为 $f_i(x)=c_ie^{ax}$ ，其中 $c_i\ge 0,a>0$ 。

我们沿用之前的思路，考虑将 $i$ 和 $i+1$ 的位置上的数交换引起的代价变化。最终得到的算法是将排列按照 $\dfrac{1-e^{at_i}}{c_i}$ 升序排序。

### 相同的单增函数

我们考虑所有的 $f_i(x)$ 是同一个单增函数。那么显然我们将排列按照 $t_i$ 升序排序即可。

## Livshits-Kladov 定理

Livshits-Kladov 定理成立，当且仅当代价函数是以下三种情况：

-   线性函数： $f_i(t) = c_it + d_i$ ，其中 $c_i\ge 0$ ；
-   指数函数： $f_i(t) = c_i e^{a t} + d_i$ ，其中 $c_i,a>0$ ；
-   相同的单增函数： $f_i(t) = \phi(t)$ ，其中 $\phi(t)$ 是一个单增函数。

定理是在假设代价函数足够平滑（存在三阶导数）的条件下证明的。在这三种情况下，问题的最优解可以通过简单的排序在 $O(n\log n)$ 的时间内解决。

* * *

 **本页面主要译自博文 [Задача Джонсона с одним станком](http://e-maxx.ru/algo/johnson_problem_1) 与其英文翻译版 [Scheduling jobs on one machine](https://cp-algorithms.com/schedules/schedule_one_machine.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。** 

# expression
author: Ir1d, Anguei, hsfzLZH1, siger-young, HeRaNO

表达式求值要解决的问题一般是输入一个字符串表示的表达式，要求输出它的值。当然也有变种比如表达式中是否包含括号，指数运算，含多少变量，判断多个表达式是否等价，等等。

其中判断表达式等价的部分使用了拉格朗日插值法等数学工具，在此暂不进行展开。

一般的思路分为两种，一种递归一种非递归。

## 递归

递归的方法是把表达式拆分成如图所示的表达式树，然后在树结构上自底向上进行运算。/home/llj/Desktop/OI-wiki-master/docs/misc/![](./images/bet.png)

表达式树上进行 [树的遍历](../graph/tree-basic.md#_10) 可以得到不同类型的表达式

-   前序遍历对应前缀表达式（波兰式）
-   中序遍历对应中缀表达式
-   后序遍历对应后缀表达式（逆波兰式）

## 非递归

非递归的方法是定义两个 [栈](../ds/stack.md) 来分别存储运算符和运算数。每当遇到一个数直接放进数的栈；每当遇到一个操作符时，要查找之前运算符栈中的元素，按照预先定义好的优先级来进行适当的弹出操作（弹出的同时求出对应的子表达式的值）。

我们要知道：算术表达式分为三种，分别是前缀表达式、中缀表达式、后缀表达式。其中，中缀表达式是我们日常生活中最常用的表达式；后缀表达式是计算机最容易理解的表达式。为什么说后缀表达式最容易被计算机理解呢？因为后缀表达式不需要括号表示，它的运算顺序是唯一确定的。举个例子：在后缀表达式 $3 2 * 1 -$ 中，首先计算 $3 \times 2 = 6$ （使用最后一个运算符，即栈顶运算符），然后计算 $6 - 1 = 5$ 。可以看到：对于一个后缀表达式，只需要 **维护一个数字栈，每次遇到一个运算符，就取出两个栈顶元素，将运算结果重新压入栈中** 。最后，栈中唯一一个元素就是改后缀表达式的运算结果时间复杂度 $O(n)$ 。

所以说，对于普通中缀表达式的计算，我们可以将其转化为后缀表达式再进行计算。转换方法也十分简单。只要建立一个用于存放运算符的栈，扫描该中缀表达式：

1.  如果遇到数字，直接将该数字输出到后缀表达式（以下部分用「输出」表示输出到后缀表达式）
2.  如果遇到左括号，入栈
3.  如果遇到右括号，不断输出栈顶元素，直至遇到左括号。（左括号出栈，但不输出）
4.  如果遇到其他运算符，不断去除所有运算优先级大于等于当前运算符的运算符，输出。最后，新的符号入栈。
5.  把栈中剩下的符号依次输出，表达式转换结束。

时间复杂度 $O(n)$ .

示例代码：

```cpp
// 下面代码摘自笔者 NOIP2005 等价表达式
std::string convert(const std::string &s) {  // 把中缀表达式转换为后缀表达式
  std::stack<char> oper;
  std::stringstream ss;
  ss << s;
  std::string t, tmp;
  while (ss >> tmp) {
    if (isdigit(tmp[0]))
      t += tmp + " ";  // 1. 如果遇到一个数，输出该数
    else if (tmp[0] == '(')
      oper.push(tmp[0]);       // 2. 如果遇到左括号，把左括号入栈
    else if (tmp[0] == ')') {  // 3. 如果遇到右括号，
      while (/home/llj/Desktop/OI-wiki-master/docs/misc/!oper.empty() && oper.top() /home/llj/Desktop/OI-wiki-master/docs/misc/!= '(')
        t += std::string(1, oper.top()) + " ",
            oper.pop();  // 不断取出栈顶并输出，直到栈顶为左括号，
      oper.pop();        // 然后把左括号出栈
    } else {             // 4. 如果遇到运算符
      while (/home/llj/Desktop/OI-wiki-master/docs/misc/!oper.empty() && level[oper.top()] >= level[tmp[0]])
        t += std::string(1, oper.top()) + " ",
            oper.pop();  // 只要栈顶符号的优先级不低于新符号，就不断取出栈顶并输出
      oper.push(tmp[0]);  // 最后把新符号进栈
    }
  }
  while (/home/llj/Desktop/OI-wiki-master/docs/misc/!oper.empty()) t += std::string(1, oper.top()) + " ", oper.pop();
  return t;
}

int calc(const std::string &s) {  // 计算转换好的后缀表达式
  std::stack<int> num;
  std::stringstream ss;
  ss << s;
  std::string t, tmp;
  while (ss >> tmp) {
    if (isdigit(tmp[0]))
      num.push(stoi(tmp));
    else {
      int b, a;  // 取出栈顶元素，注意顺序
      if (/home/llj/Desktop/OI-wiki-master/docs/misc/!num.empty()) b = num.top();
      num.pop();
      if (/home/llj/Desktop/OI-wiki-master/docs/misc/!num.empty()) a = num.top();
      num.pop();
      if (tmp[0] == '+') num.push(a + b);
      if (tmp[0] == '-') num.push(a - b);
      if (tmp[0] == '*') num.push(a * b);
      if (tmp[0] == '^') num.push(qpow(a, b));
    }
  }
  return num.top();
}
```

## 习题

1.   [表达式求值（NOIP2013）](https://vijos.org/p/1849) 
2.   [后缀表达式](https://www.luogu.org/problemnew/show/P1449) 
3.   [Transform the Expression](https://www.spoj.com/problems/ONP/) 

# index
这个板块主要介绍的是一些难以分类的算法及 OI 相关知识。

# mo-algo-intro
author: StudyingFather, Backl1ght, countercurrent-time, Ir1d, greyqz, MicDZ, ouuan

莫队算法是由莫涛提出的算法。在莫涛提出莫队算法之前，莫队算法已经在 Codeforces 的高手圈里小范围流传，但是莫涛是第一个对莫队算法进行详细归纳总结的人。莫涛提出莫队算法时，只分析了普通莫队算法，但是经过 OIer 和 ACMer 的集体智慧改造，莫队有了多种扩展版本。

莫队算法可以解决一类离线区间询问问题，适用性极为广泛。同时将其加以扩展，便能轻松处理树上路径询问以及支持修改操作。

# random
## 概述

随机化被广泛应用于 OI 中各种 **骗分** ， **偷懒** 的场景下。

当然，也有正经用途，例如：考场上造出随机数据然后对拍。

尤其是当算法期望复杂度正确且 **与输入数据无关** 时可用随机化使复杂度达到期望平衡，比如 Treap 和可并堆等。

## 实现

### rand

用于生成一个伪随机数，缺点是比较慢，使用时需要 `#include<cstdlib>` 。

使用 `rand()` 需要一个随机数种子，可以使用 `srand(seed)` 函数来将随机种子更改为 `seed` ，当然不初始化也是可以的。

相同的 `seed` 两次运行同一程序随机出的结果将会是相同的

有一个选择是使用当前系统时间来作为随机种子： `srand(time(0))` 。

调用 `rand()` 函数会返回一个随机非负整数。在 `Linux` 系统下随机范围为 $\left[0,2^{31}\right)$ 。可以用取模来限制它的大小。

!!! warning
    在 `Windows` 系统下 `rand()` 返回值的取值范围为 $\left[0,2^{15}\right)$ ，当需要生成的数不小于 $2^{15}$ 时建议使用 `(rand() << 15 | rand())` 来生成更大的随机数。

### mt19937

是一个随机数生成器类，效用同 `rand` ，优点是更加随机（出现循环的周期更长）且速度比 `rand()` 快很多。使用时需要 `#include<random>` 。

 `mt19937` 基于 [Mersenne Twister algorithm](https://en.wikipedia.org/wiki/Mersenne_Twister) ，使用时用其定义一个随机数生成器即可： `std::mt19937 myrand(seed)` ， `seed` 可不填，不填 `seed` 则会使用默认随机种子。

 `mt19937` 重载了 `operator ()` ，需要生成随机数时调用 `myrand()` 即可返回一个随机数。

#### 示例

```cpp
#include <ctime>
#include <iostream>
#include <random>

using namespace std;

int main() {
  mt19937 myrand(time(0));
  cout << myrand() << endl;
  return 0;
}
```

### random_shuffle

用于随机打乱指定序列。使用时需要 `#include<algorithm>` 。

使用时传入指定区间的首尾指针或迭代器（左闭右开）即可： `std::random_shuffle(first, last)` 或 `std::random_shuffle(first, last, myrand)` 

内部使用的随机数生成器默认为 `rand()` 。当然也可以传入自定义的随机数生成器。

!!! warning
     `random_shuffle` 已于 C++14 标准中被弃用，于 C++17 标准中被移除。

### shuffle

效用同 `random_shuffle` 。使用时需要 `#include<algorithm>` 。

区别在于必须使用自定义的随机数生成器： `std::shuffle(first, last, myrand())` 。

下面是用 `rand()` 及 `random_shuffle()` 编写的一个数据生成器。生成数据为 [「ZJOI2012」灾难](https://www.luogu.org/problemnew/show/P2597) 的随机小数据。

```cpp
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <iostream>

int a[100];

int main() {
  srand(time(0));
  int n = rand() % 99 + 1;
  for (int i = 1; i <= n; i++) a[i] = i;
  std::cout << n << '\n';
  for (int i = 1; i <= n; i++) {
    std::random_shuffle(a + 1, a + i);
    int cnt = rand() % i;
    for (int j = 1; j <= cnt; j++) std::cout << a[j] << ' ';
    std::cout << 0 << '\n';
  }
}
```

## Example I

先来看一道网络流题： [「TJOI2015」线性代数](https://loj.ac/problem/2100) 。

我们并不想写网络流，于是开始偷税。建模？不存在的。

### 做法

随机一个位置，把这个位置取反，判断大小并更新答案。

### 代码

```cpp
#include <algorithm>
#include <cstdlib>
#include <iostream>

int n;

int a[510], b[510], c[510][510], d[510];
int p[510], q[510];

int maxans = 0;

void check() {
  memset(d, 0, sizeof d);
  int nowans = 0;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++) d[i] += a[j] * c[i][j];
  for (int i = 1; i <= n; i++) nowans += (d[i] - b[i]) * a[i];
  maxans = std::max(maxans, nowans);
}

int main() {
  srand(19260817);
  std::cin >> n;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++) std::cin >> c[i][j];
  for (int i = 1; i <= n; i++) std::cin >> b[i];
  for (int i = 1; i <= n; i++) a[i] = 1;
  check();
  for (int T = 1000; T; T--) {
    int tmp = rand() % n + 1;
    a[tmp] ^= 1;
    check();
  }
  std::cout << maxans << '\n';
}
```

## Example II

当一个算法的期望复杂度正确且与输入数据无关时，我们可以通过随机化达到期望上的平衡（就是随机卡不掉的意思

Treap 的随机很经典了，来一发可并堆

### 做法

可并堆最常用的写法应该是左偏树了，通过维护树高让树左偏来保证合并的复杂度。然而…… **维护树高什么的好烦啊** 。

那么我们可以考虑使用极其难卡的随机堆，即不按照树高来交换儿子，而是随机交换。

### 代码

```cpp
struct Node {
  int child[2];
  long long val;
} nd[100010];
int root[100010];

int merge(int u, int v) {
  if (!(u && v)) return u | v;
  int x = rand() & 1, p = nd[u].val > nd[v].val ? u : v;
  nd[p].child[x] = merge(nd[p].child[x], u + v - p);
  return p;
}

void pop(int &now) { now = merge(nd[now].child[0], nd[now].child[1]); }
```

# complexity
author: linehk

复杂度是我们衡量一个算法好坏的重要的标准。在算法竞赛中，我们通常关注于算法的时间复杂度和空间复杂度。

一般来说，复杂度是一个关于数据规模的函数。对于某些算法来说，相同数据规模的不同数据依然会造成算法的运行时间/空间的不同，因此我们通常使用算法的最坏时间复杂度，记为 $T(n)$ 。对于一些特殊的情况，我们可能会关心它的平均情况复杂度（特别是对于随机算法 (randomized algorithm)），这个时候我们通过使用随机分析 (probabilistic analysis) 来得到期望的复杂度。

## 渐进符号

我们通常使用渐进符号来描述一个算法的复杂度。

### 大 Θ 符号

对于给定的一个函数 $g(n)$ , $f(n)=\Theta(g(n))$ ，当且仅当 $\exists c_1,c_2,n_0>0$ ，使得 $\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)$ 。

也就是说，如果函数 $f(n)=\Theta(g(n))$ ，那么我们能找到两个正数 $c_1, c_2$ 使得 $f(n)$ 被 $c_1\cdot g(n)$ 和 $c_2\cdot g(n)$ 夹在中间。

### 大 O 符号

 $\Theta$ 符号同时给了我们一个函数的上下界，如果我们只有一个函数的渐进上界的时候，我们使用 $O$ 符号。对于一个给定的函数 $g(n)$ , 我们把它记作 $O(g(n))$ 。 $f(n)=O(g(n))$ ，当且仅当 $\exists c,n_0$ ，使得 $\forall n \ge n_0,0\le f(n)\le c\cdot g(n)$ 。

研究时间复杂度时通常会使用 $O$ 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界。

### 大 Ω 符号

同样的，我们使用 $\Omega$ 符号来描述一个函数的渐进下界。 $f(n)=\Omega(g(n))$ ，当且仅当 $\exists c,n_0$ ，使得 $\forall n \ge n_0,0\le c\cdot g(n)\le f(n)$ 。

### 小 o 符号

如果说 $O$ 符号相当于小于等于号，那么 $o$ 符号就相当于小于号。

 $f(n)=o(g(n))$ ，当且仅当对于任意给定的正数 $c$ ， $\exists n_0$ ，使得 $\forall n \ge n_0,0\le f(n)< c\cdot g(n)$ 。

### 小 ω 符号

如果说 $\Omega$ 符号相当于大于等于号，那么 $\omega$ 符号就相当于大于号。

 $f(n)=\omega(g(n))$ ，当且仅当对于任意给定的正数 $c$ ， $\exists n_0$ ，使得 $\forall n \ge n_0,0\le c\cdot g(n)< f(n)$ 。

/home/llj/Desktop/OI-wiki-master/docs/misc/![](images/order.png)

### 常见性质

-    $f(n) = \Theta(g(n))\Leftrightarrow f(n)=O(g(n))\land f(n)=\Omega(g(n))$ 
-    $f_1(n) + f_2(n) = O(\max(f_1(n), f_2(n)))$ 
-    $f_1(n) \times f_2(n) = O(f_1(n) \times f_2(n))$ 
-    $\forall a \neq 1, \log_a{n} = O(\log_2 n)$ 。由换底公式可以得知，任何对数函数无论底数为何，都具有相同的增长率，因此渐进时间复杂度中对数的底数一般省略不写。

## 主定理 (Master Theorem)

我们可以使用 Master Theorem 来快速的求得关于递归算法的复杂度。
假设我们有递推关系式

$$
T(n) = a T\left(\frac{n}{b}\right)＋f(n)\qquad \forall n > b
$$

那么

$$
T(n) = \begin{cases}\Theta(n^{\log_b a}) & f(n) = O(n^{\log_b a-\epsilon}) \\ \Theta(f(n)) & f(n) = \Omega(n^{\log_b a+\epsilon}) \\ \Theta(n^{\log_b a}\log^{k+1} n) & f(n)=\Theta(n^{\log_b a}\log^k n),k\ge 0 \end{cases}
$$

## 均摊复杂度

算法往往是会对内存中的数据进行修改的，而同一个算法的多次执行，就会通过对数据的修改而互相影响。

例如快速排序中的“按大小分类”操作，单次执行的最坏时间复杂度，看似是 $O(n)$ 的。
但是由于快排的分治过程，先前的“分类”操作每次都减小了数组长度，所以实际的总复杂度 $O(n \log n)$ ，分摊在每一次“分类”操作上，是 $O(\log n)$ 。

多次操作的总复杂度除以操作次数，就是这种操作的 **均摊复杂度** 。

## 势能分析

势能分析，是一种求均摊复杂度下界的方法。
求均摊复杂度，关键是表达出先前操作对当前操作的影响。势能分析用一个函数来表达此种影响。

定义“状态” $S$ ：即某一时刻的所有数据。_在快排的例子中，一个“状态”就是当前过程需要排序的下标区间_

定义“初始状态” $S_0$ ：即未进行任何操作时的状态。_在快排的例子中，“初始状态”就是整个数组_

假设存在从状态到数的函数 $F$ ，且对于任何状态 $S$ ， $F(S) \geq F(S_0)$ ，则有以下推论：

设 $S_1,S_2, \cdots ,S_m$ 为从 $S_0$ 开始连续做 $m$ 次操作所得的状态序列， $c_i$ 为第 $i$ 次操作的时间开销。

记 $p_i = c_i + F(S_i) - F(S_{i-1})$ ，则 $m$ 次操作的总时间花销为

$$
\sum_{i=1}^m p_i + F(S_0) - F(S_m)
$$

（正负相消，证明显然）

又因为 $F(S) \geq F(S_0)$ ，所以有

$$
\sum_{i=1}^m p_i \geq \sum_{i=1}^m c_i
$$

因此，若 $p_i = O(T(n))$ ，则 $O(T(n))$ 是均摊复杂度的一个下界。

势能分析使用中有很多技巧，案例在此不题。

# cc-basic
本部分将介绍基础的计算理论的知识。这部分内容在 OI 中作用不大（但还是略有作用：如果你遇到了一个 NP-hard 问题，你可以认为它是不存在多项式复杂度的解法的），可以作为兴趣了解，或者为以后的学习做准备。

本文中许多结论都是不加证明的，如果有兴趣的话可以自行查阅相关证明。

前置知识： [时间复杂度](./complexity.md) 。

## 问题

### 语言

一个 **字母表（alphabet)** 是一个非空有限集合，该集合中的元素称为 **符号/字符（symbol)** 。

令 $\Sigma^\ast$ 表示非负整数个 $\Sigma$ 中的字符连接而成的串，字母表 $\Sigma$ 上的一个 **语言（language)** 是 $\Sigma^\ast$ 的一个子集。

需要注意的是，这里的“语言”是一个抽象的概念，通常意义上的字符串是语言，所有的有向无环图也可以是一个语言（01 串与有向图之间可以建立双射，具体方式无需了解）。

由于任何语言都可以转化成 01 串的形式，所以在下文中不加说明时 $\Sigma=\{0, 1\}$ 。

### 判定问题

判定问题就是只能用 YES/NO 回答的问题，本质上是判定一个串是否属于一个语言，即： $f:\Sigma^\ast\rightarrow\{0, 1\}, f(x)=1\iff x\in L$ 是一个关于字母表 $\Sigma$ 和语言 $L$ 的判定问题。如，“判定一张图是不是一个有向无环图”就是一个判定问题。

判定问题由于其简洁性而常常被作为计算理论研究的对象。本文中不加说明时，“问题”都指“判定问题”，当然，有时一些命题也能简单地推广到其它问题上。

一个语言也可以代指“判定一个串是否属于这个语言”这个判定问题，因此，“语言”和“问题”可以视作同义词。

### 功能性问题

功能性问题的回答不止 YES/NO，可以是一个数或是其它。如，“求两个数的和”就是一个功能性问题。

任何功能性问题都可以转化为一个判定问题，如，“求两个数的和”可以转化为“判定两个数的和是否等于第三个数”。

判定问题也可以转化为一个功能性问题：求这个判定问题的指示函数，即上文中判定问题定义里的 $f$ 。

## 图灵机

### 确定性图灵机

不加说明时，“图灵机”往往指“确定性图灵机”，本文中也是如此。

图灵机有很多不同的定义，这里选取其中一种，其它定义下的图灵机往往与下面这种定义的图灵机计算能力等价。

图灵机是一个在一条可双向无限延伸且被划分为若干格子的纸带上进行操作的机器，其有内部状态，还有一个可以在纸带上进行修改与移动的磁针。

正式地说，图灵机是一个七元组 $M=<Q,\Gamma,b,\Sigma,\delta,q_0,F>$ ，其中：

-    $Q$ 是一个有限非空的 **状态集合** ；
-    $\Gamma$ 是一个有限非空的 **磁带字母表** ；
-    $b\in\Gamma$ 是 **空字符** ，它是唯一一个在计算过程中可以在磁带上无限频繁地出现的字符；
-    $\Sigma\subseteq(\Gamma\setminus\{b\})$ 是 **输入符号集** ，是可以出现在初始磁带（即输入）上的字符；
-    $q_0\in Q$ 是 **初始状态** ；
-    $F\subseteq Q$ 是 **接受状态** ，如果一个图灵机在某个接受状态停机，则称初始磁带上的内容被这个图灵机 **接受** 。
-    $\delta :(Q\setminus F)\times \Gamma \not \to Q\times \Gamma \times \{L,R\}$ 是一个被称作 **转移函数** 的 partial function（即只对定义域的一个子集有定义的函数）。如果 $\delta$ 在当前状态下没有定义，则图灵机停机。

图灵机从初始状态与纸带起点起，每次根据当前的内部状态 $x$ 和当前磁针指向的纸带上的单元格中的字符 $y$ 进行操作：若 $\delta(x, y)$ 没有定义则停机，否则若 $\delta(x, y)=(a, b, c)$ ，则将内部状态修改为 $a$ ，将磁针指向的格子中的字符修改为 $b$ ，若 $c$ 为 $L$ 则向左移动一格，为 $R$ 则向右移动一格。

其实，知道图灵机的工作细节是不必要的，只需建立直观理解即可。

图灵机 $M$ 在输入 $x$ 下的输出记作 $M(x)$ （ $M(x)=1$ 当且仅当 $M$ 接受 $x$ ， $M(x)=0$ 当且仅当 $M$ 在输入 $x$ 下在有限步骤内停机且 $M$ 不接受 $x$ ），也可以在括号内包含多个参数，用逗号隔开，具体实现时可以向字母表中添加一个元素表示逗号来隔开各个参数。

图灵机与冯·诺依曼计算机解决问题的时间复杂度差别在多项式级别内，所以研究复杂度类时可以使用图灵机作为计算模型。

### 非确定性图灵机

非确定型图灵机是图灵机的一种，它与确定型图灵机的不同在于：确定型图灵机的每一步只能转移到一个状态，而非确定型图灵机可以“同时”转移到多个状态，从而在多个“分支”并行计算，一旦这些“分支”中有一个在接受状态停机，则此非确定性图灵机接受这个输入。

事实上，任何确定型图灵机都可以用类似于迭代加深搜索的方式在指数级时间内模拟一台非确定型图灵机多项式时间内的行为。

在现实生活中，确定型图灵机相当于单核处理器，只支持串行处理；而非确定型图灵机相当于理想的多核处理器，支持无限大小的并行处理。

### 多带图灵机

标准的图灵机只能在一条纸带上进行操作，但为了方便，本文中研究多带图灵机。对于一个 $k$ 带图灵机，其中一条纸带是只读的输入带，而剩下的 $k-1$ 条纸带可以进行读写，并且这 $k-1$ 条纸带中还有一条纸带用作输出。

多带图灵机的纸带数必须是有限的。

对于一个多带图灵机，它使用的空间是磁头在除输入带外的其它纸带上所访问过的单元格数目。

### 图灵机的编码

图灵机可以被自然数编码，即存在满射函数 $f:\mathbb{N}\to\mathbb{M}$ ，使得每个自然数都对应一个图灵机，而每个图灵机都有无数个编码。因此，由若干图灵机构成的集合可以是一个语言。

记由自然数 $\alpha$ 编码的图灵机为 $M_{\alpha}$ 。

### 通用图灵机

存在一台图灵机 $\mathcal U$ 满足：

1.  若 $M_{\alpha}$ 在输入 $x$ 下在有限时间内停机，则 $\mathcal{U}(x, \alpha)=M_{\alpha}(x)$ ，否则 $\mathcal{U}(x, \alpha)$ 不会在有限时间内停机；
2.  如果对于任意 $x\in\{0, 1\}^\ast$ ， $M_\alpha$ 在输入 $x$ 下在 $T(|x|)$ 时间内停机，则对于任意 $x\in\{0, 1\}^\ast$ ， $\mathcal{U}(x, \alpha)$ 在 $O(T(|x|)\log T(|x|))$ 时间内停机。

即：存在一台通用图灵机，它能模拟任何一台图灵机，且花费的时间只会比这台被模拟的图灵机慢其运行时间的对数。

## 可计算性

### 不可计算问题

对于一个判定问题，若存在一个总是在有限步内停机且能够正确进行判定的图灵机，则这个问题是一个 **图灵可计算** 的问题，否则这个问题是一个 **图灵不可计算** 的问题。

由于图灵机可以被自然数编码，所以图灵机的个数是可数无穷，而语言（即二进制串的集合）的个数是不可数无穷，而每个图灵机最多判定一个语言，所以一定存在图灵不可计算的问题。

### 停机问题

停机问题是一个经典的图灵不可计算问题：给定 $\alpha$ 和 $x$ ，判定 $M_{\alpha}$ 在输入为 $x$ 时是否会在有限步内停机。

??? note "停机问题是图灵不可计算的证明"
    定义函数 $\mathsf{UC}:\{0,1\}^\ast\to\{0,1\}$ 为：

    $$
    \mathsf{UC}(\alpha)=\begin{cases}0&M_\alpha(\alpha)=1\\1&\text{otherwise}\end{cases}
    $$

    我们先证明 $\mathsf{UC}$ 函数是图灵不可计算的：

    假设存在一台图灵机 $M_{\beta}$ 能够计算 $\mathsf{UC}$ ，那么根据 $\mathsf{UC}$ 的定义可以得到 $\mathsf{UC}(\beta)=1\iff M_\beta(\beta)\neq 1$ ，而根据 $M_{\beta}$ 能够计算 $\mathsf{UC}$ 可以得到 $M_{\beta}(\beta)=\mathsf{UC}(\beta)$ ，产生了矛盾，所以假设不成立，不存在可以计算 $\mathsf{UC}$ 的图灵机。

    令 $M_{\mathsf{HALT}}$ 是一个可以解决停机问题的图灵机， $M_{\mathsf{HALT}}(x,\alpha)$ 的值是判定问题 $M_\alpha$ 在输入为 $x$ 时是否会在有限步内停机的解，那么我们可以构造出一台能够计算 $\mathsf{UC}$ 函数的图灵机 $M_{\mathsf{UC}}$ ：

     $M_\mathsf{UC}$ 首先调用 $M_\mathsf{HALT}(α,α)$ , 如果它输出 $0$ , 则 $M_\mathsf{UC}(α)=1$ ；否则， $M_\mathsf{UC}$ 使用通用图灵机模拟计算得到答案。

    由于 $\mathsf{UC}$ 函数是图灵不可计算的，所以 $M_\mathsf{HALT}$ 不存在，也就是说停机问题是图灵不可计算的。

## 丘奇 - 图灵论题

丘奇 - 图灵论题称，若一类问题有一个有效的方法解决，则这类问题可以被某个图灵机解决。

其中，“有效的方法”需要满足：

1.  包含有限条清晰的指令；
2.  当用其解决这类问题的其中一个时，这个方法需要在有限步骤内结束，且得到正确的答案。

这个论题没有被证明，但其是计算理论的一条基本公理。

## 复杂度类

复杂度类有很多，本文只会介绍其中较为常见的一小部分。

### R 和 RE

对于语言 $L$ 和图灵机 $M$ ，若 $M$ 在任何输入下都能在有限步骤内停机，且 $M(x)=1\iff x\in L$ ，则称 $M$ 能够 **判定**  $L$ 。

对于语言 $L$ 和图灵机 $M$ ，若对于任何属于 $L$ 的输入， $M$ 都在有限步骤内停机，且 $M(x)=1\iff x\in L$ ，则称 $M$ 能够 **识别**  $L$ 。

复杂度类 $\mathsf R$ 表示那些可以被某台图灵机判定的语言的集合，即所有图灵可计算的语言。

复杂度类 $\mathsf{RE}$ 表示那些可以被某台图灵机识别的语言的集合。 $\mathsf{RE}$ 也被称作递归可枚举语言。

由定义可以得到 $\mathsf{R}\subseteq\mathsf{RE}$ 。

### DTIME

如果存在一台确定性图灵机能够判定一个语言，且对于任何输入 $x$ ，这台图灵机可以在 $O(f(|x|))$ 的时间内停机，那么这个语言属于 $\mathsf{DTIME}(f(n))$ 类。

### P

复杂度类 $\mathsf P$ 表示可以由确定性图灵机在多项式时间内解决的判定问题，即：

$$
\mathsf{P}=\bigcup\limits_{k\in\mathbb{N}}\mathsf{DTIME}(n^k)
$$

线性规划、计算最大公约数、求图的最大匹配的判定版本都是 $\mathsf P$ 类问题。

### EXPTIME

复杂度类 $\mathsf{EXPTIME}$ 表示可以由确定性图灵机在指数级时间内解决的判定问题，即：

$$
\mathsf{EXPTIME}=\bigcup\limits_{k\in\mathbb{N}}\mathsf{DTIME}(2^{n^k})
$$

停机问题的弱化版——给定一个图灵机的编码以及一个正整数 $k$ ，判定这个图灵机是否在 $k$ 步内停机，是一个 $\mathsf{EXPTIME}$ 类的问题。因为这个问题的解法需要 $O(k)$ 的时间，而数字 $k$ 可以被编码为长度为 $O(\log k)$ 的二进制串。

### NTIME

如果存在一台非确定性图灵机能够判定一个语言，且对于任何输入 $x$ ，这台图灵机可以在 $O(f(|x|))$ 的时间内停机，那么这个语言属于 $\mathsf{NTIME}(f(n))$ 类。

### NP

复杂度类 $\mathsf{NP}$ 表示可以由非确定性图灵机在多项式时间内解决的判定问题，即：

$$
\mathsf{NP}=\bigcup\limits_{k\in\mathbb{N}}\mathsf{NTIME}(n^k)
$$

所有 $\mathsf P$ 类问题都是 $\mathsf{NP}$ 类问题。更多 $\mathsf{NP}$ 类问题请参见下文中的 NPC 问题以及 NP-intermediate 问题。

#### NP-hard

如果所有 $\mathsf{NP}$ 类问题都可以在多项式时间内规约到问题 $H$ ，那么问题 $H$ 是 NP-hard 的。

换句话说，如果可以在一单位的时间内解决 NP-hard 的问题 $H$ ，那么所有 $\mathsf{NP}$ 类问题都可以在多项式单位的时间内解决。

#### NP-complete

如果一个问题既是 $\mathsf{NP}$ 类问题又是 NP-hard 的，那么这个问题是 NP 完全 (NP-complete) 的，或者说这是一个 NPC 问题。

一些经典的 NPC 问题：旅行商问题的判定版本、最大独立集问题的判定版本、最小点覆盖问题的判定版本、最长路问题的判定版本、0-1 整数规划问题的判定版本、集合覆盖问题、图着色问题、背包问题、三维匹配问题、最大割问题的判定版本。

NPC 问题的功能性版本往往是 NP-hard 的，例如：“判定一张图中是否存在大小为 $k$ 的团”既是一个 $\mathsf{NP}$ 类问题又是 NP-hard 的，从而它是一个 NPC 问题，而它的功能性版本“求一张图的最大团”不是 NPC 问题，但这个功能性版本依然是 NP-hard 的。

类似地，其它复杂度类也会有“XX-complete”，如所有 $\mathsf{EXPTIME}$ 类的问题都能在多项式时间内规约到 EXPTIME-complete 的问题。

#### co-NP

一个问题是 $\mathsf{co-NP}$ 类问题，当且仅当它的补集是 $\mathsf{NP}$ 类问题。如果将“问题”理解为“语言”，而“语言”是 $\Sigma^\ast$ 的子集，就能理解“补集”了。

例如：“给定 $n$ 个子集，判断是否能够从中选取 $k$ 个，覆盖整个集合”是一个 NPC 问题，而其补集“给定 $n$ 个子集，判断是否从中任取 $k$ 个都不能覆盖整个集合”是一个 $\mathsf{co-NP}$ 类问题。如果第一个问题的答案是“是”，那么相当于找到了第二个问题的一组反例，从而第二个问题的答案是“否”。

#### NP-intermediate

如果一个问题是 $\mathsf{NP}$ 类问题，但它既不是 $\mathsf{P}$ 类问题也不是 NPC 问题，则称其为 NP-intermediate 问题。

就人们目前的了解，图同构问题、离散对数问题和因数分解问题可能是 NP-intermediate 的。

Ladner 定理指出，如果 $\mathsf{P}\ne\mathsf{NP}$ ，则一定存在问题是 NP-intermediate 的。

### NEXPTIME

复杂度类 $\mathsf{NEXPTIME}$ 表示可以由非确定性图灵机在指数级时间内解决的判定问题，即：

$$
\mathsf{NEXPTIME}=\bigcup\limits_{k\in\mathbb{N}}\mathsf{NTIME}(2^{n^k})
$$

### #P

 $\mathsf{\#P}$ 类问题不是判定问题，而是关于 $\mathsf{NP}$ 类问题的计数问题：数一个 $\mathsf{NP}$ 类问题的解的个数是一个 $\mathsf{\#P}$ 类的问题。换句话说，数一个串在一个总是在多项式时间内停机的非确定性图灵机的多少个分支处被接受是一个 $\mathsf{\#P}$ 类的问题。

求一张普通图或二分图的匹配或完美匹配个数都是 #P 完全的，对应的判定问题为“判定一张图是否存在（完美）匹配”。

### DSPACE

如果存在一台确定性图灵机能够在输入为 $x$ 时在 $O(f(|x|))$ 的空间内判定一个语言，那么这个语言属于 $\mathsf{DSPACE}(f(n))$ 类。

-    $\mathsf{REG}=\mathsf{DSPACE}(O(1))$ ，即正则语言，也就是自动机能够判定的语言。

-    $\mathsf{L}=\mathsf{DSPACE}(O(\log n))$ ，需要注意的是图灵机使用的空间不包括输入占用的空间。

-    $\mathsf{PSPACE}=\bigcup\limits_{k\in\mathbb N}\mathsf{DSPACE}(n^k)$ 

-    $\mathsf{EXPSPACE}=\bigcup\limits_{k\in\mathbb N}\mathsf{DSPACE}(2^{n^k})$ 

### NSPACE

如果存在一台非确定性图灵机能够在输入为 $x$ 时在 $O(f(|x|))$ 的空间内判定一个语言，那么这个语言属于 $\mathsf{NSPACE}(f(n))$ 类。

-    $\mathsf{REG}=\mathsf{DSPACE}(O(1))=\mathsf{NSPACE}(O(1))$ 

-    $\mathsf{NL}=\mathsf{NSPACE}(O(\log n))$ 

-    $\mathsf{CSL}=\mathsf{NSPACE}(O(n))$ ，即上下文相关语言。

-    $\mathsf{PSPACE}=\mathsf{NPSPACE}=\bigcup\limits_{k\in\mathbb N}\mathsf{NSPACE}(n^k)$ 

-    $\mathsf{EXPSPACE}=\mathsf{NEXPSPACE}=\bigcup\limits_{k\in\mathbb N}\mathsf{NSPACE}(2^{n^k})$ 

## 可构造函数

### 时间可构造函数

有时，我们想让图灵机知道自己用了多长的时间，例如，强制图灵机在进行 $T(n)$ 步计算后停机。但如果计算 $T(n)$ 的用时就超过了 $T(n)$ ，这便是不可做到的。为此，定义了时间可构造函数，来避免这样的麻烦。

如果存在图灵机 $M$ ，使得输入为 $1^n$ ( $n$ 个 1) 时 $M$ 能在 $O(f(n))$ 的时间内停机并且输出 $f(n)$ 的二进制表示（注意，这里的图灵机的输出不是接受/不接受，而是一个串，输出可以在纸带上进行），则 $f(n)$ 是一个 **时间可构造函数** 。

由于读入需要 $O(n)$ 的时间， $o(n)$ 的非常值函数都不是时间可构造函数。

### 空间可构造函数

类似地可以定义空间可构造函数。

如果存在图灵机 $M$ ，使得输入为 $1^n$ ( $n$ 个 1) 时 $M$ 能在 $O(f(n))$ 的空间内停机并且输出 $f(n)$ 的二进制表示，则 $f(n)$ 是一个 **空间可构造函数** 。

## 复杂度类之间的关系

### 时间谱系定理

#### 确定性时间谱系定理

若 $f(n)$ 是一个时间可构造函数，则：

$$
\mathsf {DTIME}\left(o\left({\frac {f(n)}{\log f(n)}}\right)\right)\subsetneq \mathsf {DTIME}(f(n))
$$

由确定性时间谱系定理可以得到 $\mathsf{P}\subsetneq\mathsf{EXPTIME}$ 。

??? note "确定性时间谱系定理的证明"
    定义语言 $L=\{(x, y)|\mathcal{U}((x, y), x)\text{ 在 }f(|x|+|y|)\text{ 时间内停机并拒绝}\}$ ，由于 $f(n)$ 是一个时间可构造函数，可以根据定义进行计算来判定 $L$ ，用时为 $O(f(|x|+|y|))$ ，所以 $L\in\mathsf{DTIME}(f(n))$ 。

    现在假设 $L\in\mathsf{DTIME}(o\left({\dfrac {f(n)}{\log f(n)}}\right))$ ，设 $M_z$ 就是那台在 $o\left({\dfrac {f(n)}{\log f(n)}}\right)$ 的时间内判定 $L$ 的图灵机。

    令通用图灵机 $\mathcal{U}(x, z)$ 关于 $x$ 的用时为 $g(|x|)$ ，由上文关于通用图灵机的介绍可以得到 $g(n)=o(f(n))$ ，所以，当 $y$ 足够大时，$g(|z|+|y|)<f(|z|+|y|)$ 。

    令 $y'$ 是一个足够大的 $y$ ，那么 $\mathcal{U}((z, y'), z)$ 一定能在 $f(|z|+|y'|)$ 时间内停机，从而 $M_z(z, y')\ne M_z(z, y')$，产生矛盾，所以假设不成立，确定性时间谱系定理证毕。

#### 非确定性时间谱系定理

若 $g(n)$ 是一个时间可构造函数，并且 $f(n+1)=o(g(n))$ ，则 $\mathsf{NTIME}(f(n))\subsetneq\mathsf{NTIME}(g(n))$ 。

由非确定性时间谱系定理可以得到 $\mathsf{NP}\subsetneq\mathsf{NEXPTIME}$ 。

### 空间谱系定理

若 $f(n)$ 是一个空间可构造函数且 $f(n)=\Omega(\log n)$ ，则 $\mathsf{SPACE}(o(f(n)))\subsetneq\mathsf{SPACE}(f(n))$ 。

其中 $\mathsf{SPACE}$ 可以代指 $\mathsf{DSPACE}$ 或 $\mathsf{NSPACE}$ 。

由空间谱系定理可以得到 $\mathsf{PSPACE}\subsetneq\mathsf{EXPSPACE}$ 。

### 萨维奇定理

一台确定性图灵机可以在一台非确定性图灵机所消耗空间的平方内模拟它（尽管消耗的时间可能多很多），即：

若 $f(n)=\Omega(\log n)$ ，则：

$$
\mathsf{NSPACE}\left(f\left(n\right)\right)\subseteq \mathsf {DSPACE}\left(\left(f\left(n\right)\right)^2\right)
$$

推论： $\mathsf{PSPACE}=\mathsf{NPSPACE}$ , $\mathsf{EXPSPACE}=\mathsf{NEXPSPACE}$ 。

### P?=NP

复杂度类 $\mathsf{P}$ 与 $\mathsf{NP}$ 是否相等是计算复杂度理论中一个著名的尚未解决的问题。

若 $\mathsf{P}=\mathsf{NP}$ ，可以得到 $\mathsf{NP}=\mathsf{co-NP}$ ，但反之不行（目前没有基于 $\mathsf{NP}=\mathsf{co-NP}$ 证明 $\mathsf{P}=\mathsf{NP}$ 的方法）。

若 $\mathsf{P}=\mathsf{NP}$ ，还可以得到 $\mathsf{EXPTIME}=\mathsf{NEXPTIME}$ 。

若 $\mathsf{P}\ne\mathsf{NP}$ ，可以得到 NP-intermediate 不为空。

## 参考资料

1.   [计算复杂性（1）Warming Up: 自动机模型](https://lingeros-tot.github.io/2019/03/05/Warming-Up-自动机模型/) ；

2.   [计算复杂性（2）图灵机计算模型](https://lingeros-tot.github.io/2019/03/05/图灵机模型与可计算性/) ；

3.   [Wikipedia](https://en.wikipedia.org/) 的相关词条以及这些词条的参考资料。

# gray-code
author: sshwy

格雷码是一个二进制数系，其中两个相邻数的二进制位只有一位不同。举个例子， $3$ 位二进制数的格雷码序列为

$$
000,001,011,010,110,111,101,100
$$

注意序列的下标我们以 $0$ 为起点，也就是说 $G(0)=000,G(4)=100$ 。

格雷码由贝尔实验室的 Frank Gray 于 1940 年发现。

## 构造格雷码（变换）

格雷码的构造方法很多。我们首先介绍手动构造方法，然后会给出构造的代码以及正确性证明。

### 手动构造

 $k$ 位的格雷码可以通过以下方法构造。我们从全 $0$ 格雷码开始，按照下面策略：

1.  翻转最右边的位（个位）得到下一个格雷码，（例如 $000\to 001$ ）；
2.  把最右边的 $1$ 的左边的位翻转得到下一个格雷码，（例如 $001\to 011$ ）；

交替按照上述策略生成 $2^k-1$ 次，可得到 $k$ 位的格雷码序列。

### 镜像构造

 $k$ 位的格雷码可以从 $k-1$ 位的格雷码以上下镜射后加上新位的方式快速的得到，如下图：

$$
\begin{matrix}
k=1\\
0\\ 1\\\\\\\\\\\\\\
\end{matrix}
\to \begin{matrix}\\
\color{Red}0\\\color{Red}1\\\color{Blue}1\\\color{Blue}0\\\\\\\\\\
\end{matrix}
\to \begin{matrix}
k=2\\
{\color{Red}0}0\\{\color{Red}0}1\\{\color{Blue}1}1\\{\color{Blue}1}0\\\\\\\\\\
\end{matrix}
\to \begin{matrix}\\
\color{Red}00\\\color{Red}01\\\color{Red}11\\\color{Red}10\\\color{Blue}10\\\color{Blue}11\\\color{Blue}01\\\color{Blue}00
\end{matrix}
\to \begin{matrix}
k=3\\
{\color{Red}0}00\\{\color{Red}0}01\\{\color{Red}0}11\\{\color{Red}0}10\\{\color{Blue}1}10\\{\color{Blue}1}11\\{\color{Blue}1}01\\{\color{Blue}1}00
\end{matrix}
$$

### 计算方法

我们观察一下 $n$ 的二进制和 $G(n)$ 。可以发现，如果 $G(n)$ 的二进制第 $i$ 位为 $1$ ，仅当 $n$ 的二进制第 $i$ 位为 $1$ ，第 $i+1$ 位为 $0$ 或者第 $i$ 位为 $0$ ，第 $i+1$ 位为 $1$ 。于是我们可以当成一个异或的运算，即

$$
G(n)=n\oplus \left\lfloor\frac{n}{2}\right\rfloor
$$

```cpp
int g(int n) { return n ^ (n >> 1); }
```

### 正确性证明

接下来我们证明一下，按照上述公式生成的格雷码序列，相邻两个格雷码的二进制位有且近有一位不同。

我们考虑 $n$ 和 $n+1$ 的区别。把 $n$ 加 $1$ ，相当于把 $n$ 的二进制下末位的连续的 $1$ 全部变成取反，然后把最低位的 $0$ 变成 $1$ 。我们这样表示 $n$ 和 $n+1$ 的二进制位：

$$
\begin{array}{rll}
(n)_2&=&\cdots0\underbrace{11\cdots11}_{k\text{个}}\\
(n+1)_2&=&\cdots1\underbrace{00\cdots00}_{k\text{个}}
\end{array}
$$

于是我们在计算 $g(n)$ 和 $g(n+1)$ 的时侯，后 $k$ 位都会变成 $\displaystyle\underbrace{100\cdots00}_{k\text{个}}$ 的形式，而第 $k+1$ 位是不同的，因为 $n$ 和 $n+1$ 除了后 $k+1$ 位，其他位都是相同的。因此第 $k+1$ 位要么同时异或 $1$ ，要么同时异或 $0$ 。两种情况，第 $k+1$ 位都是不同的。而除了后 $k+1$ 位以外的二进制位也是做相同的异或运算，结果是相同的。

证毕。

## 通过格雷码构造原数（逆变换）

接下来我们考虑格雷码的逆变换，即给你一个格雷码 $g$ ，要求你找到原数 $n$ 。我们考虑从二进制最高位遍历到最低位（最低位下标为 $1$ ，即个位；最高位下标为 $k$ ）。则 $n$ 的二进制第 $i$ 位与 $g$ 的二进制第 $i$ 位 $g_i$ 的关系如下：

$$
\begin{array}{rll}
n_k &= g_k \\
n_{k-1} &= g_{k-1} \oplus n_k &= g_k \oplus g_{k-1} \\
n_{k-2} &= g_{k-2} \oplus n_{k-1} &= g_k \oplus g_{k-1} \oplus g_{k-2} \\
n_{k-3} &= g_{k-3} \oplus n_{k-2} &= g_k \oplus g_{k-1} \oplus g_{k-2} \oplus g_{k-3} \\
&\vdots\\
n_{k-i} &=\displaystyle\bigoplus_{j=0}^ig_{k-j}
\end{array}
$$

```cpp
int rev_g(int g) {
  int n = 0;
  for (; g; g >>= 1) n ^= g;
  return n;
}
```

## 实际应用

格雷码有一些十分有用的应用，有些应用让人意想不到：

-    $k$ 位二进制数的格雷码序列可以当作 $k$ 维空间中的一个超立方体（二维里的正方形，一维里的单位向量）顶点的哈密尔顿回路，其中格雷码的每一位代表一个维度的坐标。

-   格雷码被用于最小化数字模拟转换器（比如传感器）的信号传输中出现的错误，因为它每次只改变一个位。

-   格雷码可以用来解决汉诺塔的问题。

    设盘的数量为 $n$ 。我们从 $n$ 位全 $0$ 的格雷码 $G(0)$ 开始，依次移向下一个格雷码（ $G(i)$ 移向 $G(i+1)$ ）。当前格雷码的二进制第 $i$ 位表示从小到大第 $i$ 个盘子。

    由于每一次只有一个二进制位会改变，因此当第 $i$ 位改变时，我们移动第 $i$ 个盘子。在移动盘子的过程中，除了最小的盘子，其他任意一个盘子在移动的时侯，只能有一个放置选择。在移动第一个盘子的时侯，我们总是有两个放置选择。于是我们的策略如下：

    如果 $n$ 是一个奇数，那么盘子的移动路径为 $f\to t\to r\to f\to t\to r\to\cdots$ ，其中 $f$ 是最开始的柱子， $t$ 是最终我们把所有盘子放到的柱子， $r$ 是中间的柱子。

    如果 $n$ 是偶数： $f \to r \to t \to f \to r \to t \to \cdots$ 

-   格雷码也在遗传算法理论中得到应用。

## 习题

-    [CSP S2 2019 D1T1](https://www.luogu.org/problem/P5657) Difficulty: easy

-    [SGU #249 Matrix](http://codeforces.com/problemsets/acmsguru/problem/99999/249) Difficulty: medium

> 本页面部分内容译自博文 [Код Грея](http://e-maxx.ru/algo/gray_code) 与其英文翻译版 [Gray code](https://cp-algorithms.com/algebra/gray-code.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。

# offline


# modifiable-mo-algo
author: StudyingFather, Backl1ght, countercurrent-time, Ir1d, greyqz, MicDZ, ouuan

请确保您已经会普通莫队算法了。如果您还不会，请先阅读前面的“普通莫队算法”。

## 特点

普通莫队是不能带修改的。

我们可以强行让它可以修改，就像 DP 一样，可以强行加上一维 **时间维** , 表示这次操作的时间。

时间维表示经历的修改次数。

即把询问 $[l,r]$ 变成 $[l,r,time]$ 。

那么我们的坐标也可以在时间维上移动，即 $[l,r,time]$ 多了一维可以移动的方向，可以变成：

-    $[l-1,r,time]$ 
-    $[l+1,r,time]$ 
-    $[l,r-1,time]$ 
-    $[l,r+1,time]$ 
-    $[l,r,time-1]$ 
-    $[l,r,time+1]$ 

这样的转移也是 $O(1)$ 的，但是我们排序又多了一个关键字，再搞搞就行了。

可以用和普通莫队类似的方法排序转移，做到 $O(n^{\frac{5}{3}})$ 。

这一次我们排序的方式是以 $n^{\frac{2}{3}}$ 为一块，分成了 $n^{\frac{1}{3}}$ 块，第一关键字是左端点所在块，第二关键字是右端点所在块，第三关键字是时间。

还是来证明一下时间复杂度（默认块大小为 $\sqrt{n}$ ）：

-   左右端点所在块不变，时间在排序后单调向右移，这样的复杂度是 $O(n)$ ；
-   若左右端点所在块改变，时间一次最多会移动 n 个格子，时间复杂度 $O(n)$ ；
-   左端点所在块一共有 $n^{\frac{1}{3}}$ 中，右端点也是 $n^{\frac{1}{3}}$ 种，一共 ${n^{\frac{1}{3}}}\times{n^{\frac{1}{3}}}=n^{\frac{2}{3}}$ 种，每种乘上移动的复杂度 $O(n)$ ，总复杂度 $O(n^{\frac{5}{3}})$ 。

## 例题

???+note "例题[「国家集训队」数颜色 / 维护队列](https://www.luogu.org/problem/P1903)"

    题目大意：给你一个序列，M 个操作，有两种操作：

    1.  修改序列上某一位的数字
    2.  询问区间 $[l,r]$ 中数字的种类数（多个相同的数字只算一个）

我们不难发现，如果不带操作 1（修改）的话，我们就能轻松用普通莫队解决。

但是题目还带单点修改，所以用 **带修改的莫队** 。

先考虑普通莫队的做法：

-   每次扩大区间时，每加入一个数字，则统计它已经出现的次数，如果加入前这种数字出现次数为 $0$ ，则说明这是一种新的数字，答案 $+1$ 。然后这种数字的出现次数 $+1$ 。
-   每次减小区间时，每删除一个数字，则统计它删除后的出现次数，如果删除后这种数字出现次数为 $0$ ，则说明这种数字已经从当前的区间内删光了，也就是当前区间减少了一种颜色，答案 $-1$ 。然后这种数字的出现次数 $-1$ 。

现在再来考虑修改：

-   单点修改，把某一位的数字修改掉。假如我们是从一个经历修改次数为 $i$ 的询问转移到一个经历修改次数为 $j$ 的询问上，且 $i<j$ 的话，我们就需要把第 $i+1$ 个到第 $j$ 个修改强行加上。
-   假如 $j<i$ 的话，则需要把第 $i$ 个到第 $j+1$ 个修改强行还原。

怎么强行加上一个修改呢？假设一个修改是修改第 $pos$ 个位置上的颜色，原本 $pos$ 上的颜色为 $a$ ，修改后颜色为 $b$ ，还假设当前莫队的区间扩展到了 $[l,r]$ 。

-   加上这个修改：我们首先判断 $pos$ 是否在区间 $[l,r]$ 内。如果是的话，我们等于是从区间中删掉颜色 $a$ ，加上颜色 $b$ ，并且当前颜色序列的第 $pos$ 项的颜色改成 $b$ 。如果不在区间 $[l,r]$ 内的话，我们就直接修改当前颜色序列的第 $pos$ 项为 $b$ 。
-   还原这个修改：等于加上一个修改第 $pos$ 项、把颜色 $b$ 改成颜色 $a$ 的修改。

因此这道题就这样用带修改莫队轻松解决啦！

??? 参考代码
    ```cpp
    #include <bits/stdc++.h>
    #define SZ (10005)
    using namespace std;
    template <typename _Tp>
    inline void IN(_Tp& dig) {
      char c;
      dig = 0;
      while (c = getchar(), !isdigit(c))
        ;
      while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
    }
    int n, m, sqn, c[SZ], ct[SZ], c1, c2, mem[SZ][3], ans, tot[1000005], nal[SZ];
    struct query {
      int l, r, i, c;
      bool operator<(const query another) const {
        if (l / sqn == another.l / sqn) {
          if (r / sqn == another.r / sqn) return i < another.i;
          return r < another.r;
        }
        return l < another.l;
      }
    } Q[SZ];
    void add(int a) {
      if (!tot[a]) ans++;
      tot[a]++;
    }
    void del(int a) {
      tot[a]--;
      if (!tot[a]) ans--;
    }
    char opt[10];
    int main() {
      IN(n), IN(m), sqn = pow(n, (double)2 / (double)3);
      for (int i = 1; i <= n; i++) IN(c[i]), ct[i] = c[i];
      for (int i = 1, a, b; i <= m; i++)
        if (scanf("%s", opt), IN(a), IN(b), opt[0] == 'Q')
          Q[c1].l = a, Q[c1].r = b, Q[c1].i = c1, Q[c1].c = c2, c1++;
        else
          mem[c2][0] = a, mem[c2][1] = ct[a], mem[c2][2] = ct[a] = b, c2++;
      sort(Q, Q + c1), add(c[1]);
      int l = 1, r = 1, lst = 0;
      for (int i = 0; i < c1; i++) {
        for (; lst < Q[i].c; lst++) {
          if (l <= mem[lst][0] && mem[lst][0] <= r)
            del(mem[lst][1]), add(mem[lst][2]);
          c[mem[lst][0]] = mem[lst][2];
        }
        for (; lst > Q[i].c; lst--) {
          if (l <= mem[lst - 1][0] && mem[lst - 1][0] <= r)
            del(mem[lst - 1][2]), add(mem[lst - 1][1]);
          c[mem[lst - 1][0]] = mem[lst - 1][1];
        }
        for (++r; r <= Q[i].r; r++) add(c[r]);
        for (--r; r > Q[i].r; r--) del(c[r]);
        for (--l; l >= Q[i].l; l--) add(c[l]);
        for (++l; l < Q[i].l; l++) del(c[l]);
        nal[Q[i].i] = ans;
      }
      for (int i = 0; i < c1; i++) printf("%d\n", nal[i]);
      return 0;
    }
    ```

# cdq-divide
## 引子

什么是 cdq 分治呢？，其实他是一种思想而不是具体的算法（就和 dp 是一样的），因此 cdq 分治涵盖的范围相当的广泛，由于这样的思路最早是被陈丹琦引入国内的，所以就叫 cdq 分治了

现在 oi 界对于 cdq 分治这个思想的拓展十分广泛，但是这些都叫 cdq 的东西其实原理和写法上并不相同不过我们可以大概的将它们分为三类

 **1.cdq 分治解决和点对有关的问题** 

 **2.cdq 分治优化 1D/1D 动态规划的转移** 

 **3. 通过 cdq 分治，将一些动态问题转化为静态问题** 

* * *

## CDQ 分治解决和点对有关的问题

这类问题一般是给你一个长度为 n 的序列，然后让你统计有一些特性的点对 $(i,j)$ 有多少个，又或者说是找到一对点 $(i,j)$ 使得一些函数的值最大之类的问题

那么 cdq 分治基于这样一个算法流程解决这类问题

 **1. 找到这个序列的中点 $mid$ ** 

 **2. 将所有点对 $(i,j)$ 划分为 3 类** 

 **第一种是 $1 \leq i \leq mid,1 \leq j \leq mid$ 的点对** 

 **第二种是 $1  \leq i \leq mid ,mid+1 \leq j \leq n$ 的点对** 

 **第三种是 $mid+1 \leq  i \leq n,mid+1 \leq j \leq n$ 的点对** 

 **3. 将 $(1,n)$ 这个序列拆成两个序列 $(1,mid)$ 和 $(mid+1,n)$ ** 

 **会发现第一类点对和第三类点对都在这两个序列之中，递归的去解决这两类点对** 

 **4. 想方设法处理一下第二类点对的信息** 

_实际应用的时候我们通常都是写一个函数 $solve(l,r)$ 表示我们正在处理 $l \leq i \leq r,l \leq j \leq r$ 的点对_

_所以刚才的算法流程中的递归部分我们就是通过 $solve(l,mid),solve(mid,r)$ 来实现的_

所以说 cdq 分治只是一种十分模糊的思想，可以看到这种思想就是不断的把点对通过递归~~（甩锅）~~的方式分给左右两个区间

至于我们设计出来的算法真正干活的部分就是第 4 部分需要我们想方设法解决的部分了

所以说让我们上几道例题看一下第四部分一般该怎么写

比如说我们来一个 cdq 分治的经典问题——三维偏序

### 三维偏序

给定一个序列，每个点有两个属性 $(a,b)$ ，试求：这个序列里有多少对点对 $(i,j)$ 满足 $i<j,a_{i}<a_{j},b_{i}<b_{j}$ 

统计序列里点对的个数？我们给他套个 cdq 试试。

好了假设我们现在正在 $solve(l,r)$ 并且通过某些奥妙重重的手段搞定了 $solve(l,mid)$ 和 $solve(mid+1,r)$ （其实就是递归）

那么我们现在就是统计满足 $l \leq i \leq mid,mid+1 \leq j \leq r$ 的点对 $(i,j)$ 中，有多个点对还满足 $i<j,a_{i}<a_{j},b_{i}<b_{j}$ 的限制条件咯

然后你会发现那个 $i<j$ 的限制条件没啥用了，既然 $i$ 比 $mid$ 小 $j$ 比 $mid$ 大，那 $i$ 肯定比 $j$ 要小

你又发现现在还剩下两个限制条件 $a_{i}<a_{j},b_{i}<b_{j}$ , 根据这个限制条件我们就可以枚举 $j$ , 求出有多少个满足条件的 $i$ 

为了方便枚举，我们把 $(l,mid)$ 和 $(mid+1,r)$ 中的点全部按照 $a$ 值从小到大排个序

之后我们依次枚举每一个 $j$ , 把所有 $a_{i}<a_{j}$ 的点 $i$ 全部插入到某一个神奇数据结构里，

此时只要对这个神奇数据结构询问一发：这个数据结构里有多少个点的 $b$ 值是小于 $b_{j}$ 的，我们就对于这个点 $j$ 求出了有多少个 $i$ 可以和他合法的匹配了

问题来了那个神奇数据结构叫什么呢？

树状数组啊

当我们插入一个 $b$ 值等于 $x$ 的点时，我们就令树状数组的 $x$ 这个位置单点 + 1，而查询数据结构里有多少个点小于 $x$ 的操作实际上就是在求前缀和，只要我们事先对于所有的 b 值做了离散化我们的复杂度就是对的

问题又来了，对于每一个 $j$ 我们都需要将所有 $a_{i}<a_{j}$ 的点 $i$ 插入树状数组中，这样的话我们总共要对树状数组做 $O(n^2)$ 次操作啊，怎么办呢？

还记得你把所有的 $i$ 和 $j$ 都事先按照 $a$ 值排好序了吗？我们以双指针的方式在树状数组里插入点，这样的话我们就只需要做 $O(n)$ 次插入操作啦~

所以通过这样一个算法流程我们就用 $O(n\log n)$ 的时间处理完了关于第 $2$ 类点对的信息了

这样的话我们的算法复杂度就是 $T(n)=T(\lfloor \frac{n}{2} \rfloor)+T(\lceil \frac{n}{2} \rceil)+O(n\log n)=O(n\log^2n)$ 了

### 例题[CQOI2011]动态逆序对

仔细推一下就是和三维偏序差不多的式子了，基本就是一个三维偏序的板子

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
typedef long long ll;
int n;
int m;
struct treearray {
  int ta[200010];
  inline void ub(int& x) { x += x & (-x); }
  inline void db(int& x) { x -= x & (-x); }
  inline void c(int x, int t) {
    for (; x <= n + 1; ub(x)) ta[x] += t;
  }
  inline int sum(int x) {
    int r = 0;
    for (; x > 0; db(x)) r += ta[x];
    return r;
  }
} ta;
struct data {
  int val;
  int del;
  int ans;
} a[100010];
int rv[100010];
ll res;
bool cmp1(const data& a, const data& b) { return a.val < b.val; }
bool cmp2(const data& a, const data& b) { return a.del < b.del; }
void solve(int l, int r) {
  if (r - l == 1) {
    return;
  }
  int mid = (l + r) / 2;
  solve(l, mid);
  solve(mid, r);
  int i = l + 1;
  int j = mid + 1;
  while (i <= mid) {
    while (a[i].val > a[j].val && j <= r) {
      ta.c(a[j].del, 1);
      j++;
    }
    a[i].ans += ta.sum(m + 1) - ta.sum(a[i].del);
    i++;
  }
  i = l + 1;
  j = mid + 1;
  while (i <= mid) {
    while (a[i].val > a[j].val && j <= r) {
      ta.c(a[j].del, -1);
      j++;
    }
    i++;
  }
  i = mid;
  j = r;
  while (j > mid) {
    while (a[j].val < a[i].val && i > l) {
      ta.c(a[i].del, 1);
      i--;
    }
    a[j].ans += ta.sum(m + 1) - ta.sum(a[j].del);
    j--;
  }
  i = mid;
  j = r;
  while (j > mid) {
    while (a[j].val < a[i].val && i > l) {
      ta.c(a[i].del, -1);
      i--;
    }
    j--;
  }
  sort(a + l + 1, a + r + 1, cmp1);
  return;
}
int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; i++) {
    scanf("%d", &a[i].val);
    rv[a[i].val] = i;
  }
  for (int i = 1; i <= m; i++) {
    int p;
    scanf("%d", &p);
    a[rv[p]].del = i;
  }
  for (int i = 1; i <= n; i++) {
    if (a[i].del == 0) a[i].del = m + 1;
  }
  for (int i = 1; i <= n; i++) {
    res += ta.sum(n + 1) - ta.sum(a[i].val);
    ta.c(a[i].val, 1);
  }
  for (int i = 1; i <= n; i++) {
    ta.c(a[i].val, -1);
  }
  solve(0, n);
  sort(a + 1, a + n + 1, cmp2);
  for (int i = 1; i <= m; i++) {
    printf("%lld\n", res);
    res -= a[i].ans;
  }
  return 0;
}
```

* * *

## CDQ 分治优化 1D/1D 动态规划的转移

所谓 1D/1D 动态规划就是说我们的 dp 数组是 1 维的，转移是 $O(n)$ 的一类 dp 问题，如果条件良好的话我们有些时候可以通过 cdq 分治来把这类问题的时间复杂度由 $O(n^2)$ 降至 $O(n\log^2n)$ 

那么比如说我们要优化这样的一个 $dp$ 式子给你一个序列每个元素有两个属性 $a,b$ 我们希望计算一个 dp 式子的值，它的转移方程如下：

 $dp_{i}=1+ \max_{j=1}^{i-1}dp_{j}[a_{j}<a_{i}][b_{j}<b_{i}]$ 

_如果你足够熟练的话可以看出这就是一个二维最长上升子序列的 $dp$ 方程_

解释一下上面的式子就是说只有 $i<j,a_{i}<a_{j},b_{i}<b_{j}$ 的点 $j$ 可以去更新点 $i$ 的 dp 值

直接转移显然是 $O(n^2)$ 的，我们如何使用 $cdq$ 分治去优化它的转移过程呢？

这个转移过程相对来讲比较套路，我们先介绍算法流程然后再慢慢证明为什么这样是对的

我们发现 $dp_{j}$ 转移到 $dp_{i}$ 这种转移关系也是一种点对间的关系，所以我们像 $cdq$ 分治处理点对关系一样的来处理它

具体来讲我们这样写 cdq, 假设我们现在正在处理的区间是 $(l,r)$ ,

 **0. 如果 $l=r$ 说明我们的 $dp_{r}$ 值已经被计算好了，我们直接令 $dp_{r}++$ 然后返回即可** 

 **1. 先递归的 $solve(l,mid)$ ** 

 **2. 处理所有 $l \leq j \leq mid,mid+1 \leq i \leq r$ 的转移关系** 

 **3. 然后递归的 $solve(mid+1,r)$ ** 

那么第二步怎么做呢？

其实和 cdq 分治求三维偏序差不多，我们会发现处理 $l \leq j \leq mid,mid+1 \leq i \leq r$ 的转移关系的时候我们已经不用管 $j<i$ 这个限制条件了，因此我们依然是将所有的点 $i$ 和点 $j$ 按 $a$ 值进行排序处理之后用双指针的方式将 $j$ 点插入到树状数组里，然后最后查一发前缀最大值更新一下 $dp_{i}$ 就可以了

你会发现此时的 cdq 写法和上一种处理点对间关系的 cdq 写法最大的不同就是处理 $l \leq j \leq mid,mid+1 \leq i \leq r$ 的点对这一部分，上面的写法中这一部分我们放到哪里都是可以的，但是，在用 cdq 分治优化 dp 的时候这个流程却必须夹在 $solve(l,mid),solve(mid+1,r)$ 的中间，为什么呢？

因为 dp 的转移是 **有序的** ，我们的 dp 的转移必须满足两个条件否则就是不对的

 **1. 用来计算 $dp_{i}$ 的所有 $dp_{j}$ 值都必须是已经计算完毕的，不能存在 "半成品"** 

 **2. 用来计算 $dp_{i}$ 的所有 $dp_{j}$ 值都必须能更新到 $dp_{i}$ 不能存在有的 $dp_{j}$ 值没有更新到** 

上述两个条件可能在 $O(n^2)$ 暴力的时候是相当容易满足的，但是由于我们现在使用了 cdq 分治，很显然转移顺序被我们搞的乱七八糟了，所以我们有必要好好考虑一下我们这样做到底是不是对的

那就让我们看一看 cdq 分治的递归树好了

/home/llj/Desktop/OI-wiki-master/docs/misc/![](./images/cdq1.png)

然后你会发现我们执行刚才的算法流程的话

你会发现比如说 $8$ 这个点的 $dp$ 值是在 $solve(1,8),solve(5,8),solve(7,8)$ 这 3 个函数中被更新完成的，而三次用来更新它的点分别是 $(1,4)(5,6)(7,7)$ 这三个不相交的区间

又比如说 $5$ 这个点它的 dp 值就是在 $solve(1,4)$ 函数中解决的，更新它的区间是 $(1,4)$ 

仔细观察就会发现一个 i 点的 dp 值被更新了 log 次，而且，更新它的区间刚好是 $(1,i)$ 在线段树上被拆分出来的 log 个区间

因此我们的第 2 个条件就满足了，我们的确保证了所有合法的 $j$ 都去更新过点 $i$ 

我们接着分析我们算法的执行流程

第一个结束的函数是 $solve(1,1)$ 此时我们发现 $dp_{1}$ 的值已经计算完毕了

第一个执行转移过程的函数是 $solve(1,2)$ 此时我们发现 $dp_{2}$ 的值已经被转移好了

第二个结束的函数 $solve(2,2)$ 此时我们发现 $dp_{2}$ 的值已经计算完毕了

接下来 $solve(1,2)$ 结束， $(1,2)$ 这段区间的 $dp$ 值均被计算好

下一个执行转移流程的函数是 $solve(1,4)$ 这次转移结束之后我们发现 $dp_{3}$ 的值已经被转移好了

接下来结束的函数是 $solve(3,3)$ 我们会发现 $dp_{3}$ 的 dp 值被计算好了

接下来执行的转移是 $solve(2,4)$ 此时 $dp_{4}$ 在 $solve(1,4)$ 中被 $(1,2)转移了一次,这次又被$ (3,3)$ 转移了

因此 $dp_{4}$ 的值也被转移好了

接下来 $solve(4,4)$ 结束 $dp_{4}$ 的值被计算完毕

接下来 $solve(3,4)$ 结束 $(3,4)$ 的值被计算完毕了

接下来 $solve(1,4)$ 结束 $(1,4)$ 的值被计算完毕了

通过我们刚才手玩了半个函数流程我们会发现一个令人惊讶的事实就是每次 $solve(l,r)$ 结束的时候 $(l,r)$ 区间的 dp 值全部会被计算好，由于我们每一次执行转移函数的时候由于 $solve(l,mid)$ 已经结束，因此我们每一次执行的转移过程都是合法的

在刚才的过程我们发现，如果将 cdq 分治的递归树看成一颗线段树，那么 cdq 分治就是这个线段树的 **中序遍历函数** ，因此我们相当于按顺序处理了所有的 dp 值，只是转移顺序被拆开了而已，所以我们的算法是正确的

* * *

### 例题[SDOI2011]拦截导弹

一道二维最长上升子序列的题，为了确定某一个元素是否在最长上升子序列中可以正反跑两遍 CDQ

```C
#include<cstdio>
#include<algorithm>
using namespace std;
typedef double db;const int N=1e6+10;
struct data{int h;int v;int p;int ma;db ca;}a[2][N];int n;bool tr;
inline bool cmp1(const data& a,const data& b){if(tr)return a.h>b.h;else return a.h<b.h;}
inline bool cmp2(const data& a,const data& b){if(tr)return a.v>b.v;else return a.v<b.v;}
inline bool cmp3(const data& a,const data& b){if(tr)return a.p<b.p;else return a.p>b.p;}
inline bool cmp4(const data& a,const data& b){return a.v==b.v;}
struct treearray
{
    int ma[2*N];db ca[2*N];
    inline void c(int x,int t,db c)
    {for(;x<=n;x+=x&(-x)){if(ma[x]==t){ca[x]+=c;}else if(ma[x]<t){ca[x]=c;ma[x]=t;}}}
    inline void d(int x){for(;x<=n;x+=x&(-x)){ma[x]=0;ca[x]=0;}}
    inline void q(int x,int& m,db& c)
    {for(;x>0;x-=x&(-x)){if(ma[x]==m){c+=ca[x];}else if(m<ma[x]){c=ca[x];m=ma[x];}}}
}ta;int rk[2][N];
inline void solve(int l,int r,int t)
{
    if(r-l==1){return;}int mid=(l+r)/2;
    solve(l,mid,t);sort(a[t]+mid+1,a[t]+r+1,cmp1);int p=l+1;
    for(int i=mid+1;i<=r;i++)
    {
        for(;(cmp1(a[t][p],a[t][i])||a[t][p].h==a[t][i].h)&&p<=mid;p++)
        {ta.c(a[t][p].v,a[t][p].ma,a[t][p].ca);}db c=0;int m=0;ta.q(a[t][i].v,m,c);
        if(a[t][i].ma<m+1){a[t][i].ma=m+1;a[t][i].ca=c;}else if(a[t][i].ma==m+1){a[t][i].ca+=c;}
    }for(int i=l+1;i<=mid;i++){ta.d(a[t][i].v);}
    sort(a[t]+mid,a[t]+r+1,cmp3);solve(mid,r,t);
    sort(a[t]+l+1,a[t]+r+1,cmp1);
}
inline void ih(int t)
{
    sort(a[t]+1,a[t]+n+1,cmp2);rk[t][1]=1;
    for(int i=2;i<=n;i++){rk[t][i]=(cmp4(a[t][i],a[t][i-1]))?rk[t][i-1]:i;}
    for(int i=1;i<=n;i++){a[t][i].v=rk[t][i];}sort(a[t]+1,a[t]+n+1,cmp3);
    for(int i=1;i<=n;i++){a[t][i].ma=1;a[t][i].ca=1;}
}int len;db ans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&a[0][i].h,&a[0][i].v);a[0][i].p=i;
        a[1][i].h=a[0][i].h;a[1][i].v=a[0][i].v;a[1][i].p=i;
    }ih(0);solve(0,n,0);tr=1;ih(1);solve(0,n,1);tr=1;
    sort(a[0]+1,a[0]+n+1,cmp3);sort(a[1]+1,a[1]+n+1,cmp3);
    for(int i=1;i<=n;i++){len=max(len,a[0][i].ma);}printf("%d\n",len);
    for(int i=1;i<=n;i++){if(a[0][i].ma==len){ans+=a[0][i].ca;}}
    for(int i=1;i<=n;i++)
    {
        if(a[0][i].ma+a[1][i].ma-1==len){printf("%.5lf ",(a[0][i].ca*a[1][i].ca)/ans);}
        else {printf("0.00000 ");}
    }return 0;
}
```

* * *

## 需要 CDQ 将动态问题转化为静态问题的题

我们会发现 CDQ 分治一般是一种处理序列问题的套路，通过将序列折半之后递归处理点对间的关系来获得良好的复杂度

不过在这一部分当中我们分治的却不是一般的序列而是时间序列

什么意思呢？

众所周知的是有些数据结构题需要我们兹次做 xxx 修改然后做 xxx 询问的情况

然后你会发现一个有趣的事实是如果我们把询问进行离线之后，所有操作按照时间自然的排成了一个序列，另一个比较显然的事实是每一个修改会对它之后的询问发生关系，而这样的修改 - 询问关系一共会有 $O(n^2)$ 对

因此我们可以使用 cdq 分治对于这个操作序列进行分治，按照 cdq 分治处理修改和询问之间的关系

还是和处理点对关系的 cdq 分治类似，我们假设我们正在分治的序列是 $(l,r)$ , 我们先递归的处理 $(l,mid)$ 和 $(mid,r)$ 之间的修改 - 询问关系

接下来我们处理所有 $l \leq i \leq mid,mid+1 \leq j \leq r$ 并且 $i$ 是一个修改并且 $j$ 是一个询问的修改 - 询问关系

注意如果我们的各个修改之间是 **独立** 的话我们不需要管处理 $l \leq i \leq mid,mid+1 \leq j \leq r$ 和 $solve(l,mid)$ 以及 $solve(mid+1,r)$ 之间时序关系（比如你的修改就是普通的加法和减法问题之类的）

但是如果你的各个修改之间并不独立，比如说我们的修改是一个赋值操作，这样的话我们做完这个赋值操作之后序列长什么样可能需要依赖于之前的序列长什么样

那这样的话我们处理所有跨越 mid 的修改 - 询问关系的时候就必须把它放在 $solve(l,mid)$ 和 $solve(mid+1,r)$ 之间了，理由和 cdq 分治优化 1D/1D 动态规划的原因是一样的，按照中序遍历序进行分治，然后我们就可以保证每一个修改都是严格按照时间顺序被执行的

这样光说是没办法解决我们的问题的，因此我们还是上道例题吧

### 矩形加矩形求和

这里的矩形加矩形求和就是字面意思上的矩形加矩形求和，让你维护一个二维平面，然后支持在一个矩形区域内加一个数字，每次询问一个矩形区域的和

那么对于这个问题的静态版本，也就是二维平面里有一堆矩形，我们希望询问一个矩形区域的和这个问题，我们是有一个经典做法叫线段树 + 扫描线的

具体来讲就是我们将每个矩形拆成插入和删除两个操作，将每个询问拆成两个前缀和相减的形式然后离线跑一波就可以了

问题来了啊，我们现在的问题是动态的啊，怎么办呢？

不如强行套一个 cdq 分治试试？

我们将所有的询问和修改操作全部离线，这些操作形成了一个序列，并且有 $O(N^2)$ 对修改 - 询问的关系

那么我们依然使用 cdq 分治的一般套路，将所有的关系分成三类，在这一层分治过程当中仅仅处理跨越 $mid$ ，的修改 - 询问关系，而剩下的修改 - 询问关系通过递归的的方式来解决

那么这样的话我们会发现这样的一个事实就是所有的修改都在询问之前被做出了

这个问题就等价于平面上有静态的一堆矩形接下来不停的询问一个矩形区域的和了

那么我们可以套一个扫描线在 $O(n\log n)$ 的时间内处理好所有跨越 $mid$ 的修改 - 询问关系

剩下的事情就是递归的分治左右两侧修改 - 询问关系来解决这个问题了

这样实现的 cdq 分治的话你会发现同一个询问被处理了 $O(\log n)$ 次来回答，不过没有关系因为每次贡献这个询问的修改是互不相交的

时间复杂度为 $T(n)=T(\lfloor \frac{n}{2} \rfloor)+T(\lceil \frac{n}{2} \rceil)+ O(n\log n)=O(n\log^2n)$ 

观察上述的算法流程，我们发现一开始我们只能解决静态的矩形加矩形求和问题，但是只是简单的套了一个 cdq 分治上去我们就可以离线的解决一个动态的矩形加矩形求和问题了。

那么我们可以将动态问题转化为静态问题的精髓就在于 cdq 分治每次仅仅处理跨越某一个点的修改和询问关系了，这样的话我们就只需要考虑所有询问都在修改之后这个简单的问题了。

也正是因为这一点 cdq 分治被称为 **动态问题转化为静态问题的工具** 

### [Ynoi2016]镜中的昆虫

一句话题意区间赋值区间数颜色

我们维护一下每个位置左侧第一个同色点的位置，记为 $pre_{i}$ ，此时区间数颜色就被转化为了一个经典的二维数点问题

通过将连续的一段颜色看成一个点的方式我们可以证明 $pre$ 的变化量是 $O(n+m)$ 的，换句话说单次操作仅仅引起 $O(1)$ 的 $pre$ 值变化，那么我们可以用 cdq 分治来解决动态的单点加矩形求和问题

 $pre$ 数组的具体变化可以使用 $std::set$ 来进行处理（这个用 set 维护连续的区间的技巧也被称之为_old driver tree_)

```C
#include<cstdio>
#include<algorithm>
#include<set>
#include<map> 
#define SNI set <nod> :: iterator 
#define SDI set <data> :: iterator 
using namespace std;const int N=1e5+10;int n;int m;int pre[N];int npre[N];int a[N];int tp[N];int lf[N];int rt[N];int co[N];
struct modi{int t;int pos;int pre;int va;friend bool operator <(modi a,modi b){return a.pre<b.pre;}}md[10*N];int tp1;
struct qry{int t;int l;int r;int ans;friend bool operator <(qry a,qry b){return a.l<b.l;}}qr[N];int tp2;int cnt;
inline bool cmp(const qry& a,const qry& b){return a.t<b.t;}
inline void modify(int pos,int co)//修改函数
{
    if(npre[pos]==co)return;md[++tp1]=(modi){++cnt,pos,npre[pos],-1};
    md[++tp1]=(modi){++cnt,pos,npre[pos]=co,1};
}
namespace prew
{
    int lst[2*N];map <int,int> mp;//提前离散化
    inline void prew()
    {
        scanf("%d%d",&n,&m);for(int i=1;i<=n;i++)scanf("%d",&a[i]),mp[a[i]]=1;
        for(int i=1;i<=m;i++){scanf("%d%d%d",&tp[i],&lf[i],&rt[i]);if(tp[i]==1)scanf("%d",&co[i]),mp[co[i]]=1;}
        map <int,int> :: iterator it,it1;
        for(it=mp.begin(),it1=it,++it1;it1/home/llj/Desktop/OI-wiki-master/docs/misc/!=mp.end();++it,++it1)it1->second+=it->second;
        for(int i=1;i<=n;i++)a[i]=mp[a[i]];for(int i=1;i<=n;i++)if(tp[i]==1)co[i]=mp[co[i]];
        for(int i=1;i<=n;i++)pre[i]=lst[a[i]],lst[a[i]]=i;for(int i=1;i<=n;i++)npre[i]=pre[i];
    }
}
namespace colist
{
    struct data {int l;int r;int x;friend bool operator <(data a,data b){return a.r<b.r;}};set <data> s;
    struct nod {int l;int r;friend bool operator <(nod a,nod b){return a.r<b.r;}};set <nod> c[2*N];set <int> bd;
    inline void split(int mid)//将一个节点拆成两个节点
    {
        SDI it=s.lower_bound((data){0,mid,0});data p=*it;if(mid==p.r)return;
        s.erase(p);s.insert((data){p.l,mid,p.x});s.insert((data){mid+1,p.r,p.x});
        c[p.x].erase((nod){p.l,p.r});c[p.x].insert((nod){p.l,mid});c[p.x].insert((nod){mid+1,p.r});
    }
    inline void del(set <data> :: iterator it)//删除一个迭代器
    {
        bd.insert(it->l);SNI it1,it2;it1=it2=c[it->x].find((nod){it->l,it->r});
        ++it2;if(it2/home/llj/Desktop/OI-wiki-master/docs/misc/!=c[it->x].end())bd.insert(it2->l);c[it->x].erase(it1);s.erase(it);
    }
    inline void ins(data p)//插入一个节点
    {
        s.insert(p);SNI it=c[p.x].insert((nod){p.l,p.r}).first;++it;
        if(it/home/llj/Desktop/OI-wiki-master/docs/misc/!=c[p.x].end()){bd.insert(it->l);}
    }
    inline void stv(int l,int r,int x)//区间赋值
    {
        if(l/home/llj/Desktop/OI-wiki-master/docs/misc/!=1)split(l-1);split(r);int p=l;//split两下之后删掉所有区间
        while(p/home/llj/Desktop/OI-wiki-master/docs/misc/!=r+1){SDI it=s.lower_bound((data){0,p,0});p=it->r+1;del(it);}
        ins((data){l,r,x});//扫一遍set处理所有变化的pre值
        for(set <int> :: iterator it=bd.begin();it/home/llj/Desktop/OI-wiki-master/docs/misc/!=bd.end();++it)
        {
            SDI it1=s.lower_bound((data){0,*it,0});
            if(*it/home/llj/Desktop/OI-wiki-master/docs/misc/!=it1->l)modify(*it,*it-1);
            else
            {
                SNI it2=c[it1->x].lower_bound((nod){0,*it});
                if(it2/home/llj/Desktop/OI-wiki-master/docs/misc/!=c[it1->x].begin())--it2,modify(*it,it2->r);else modify(*it,0);
            }
        }bd.clear();
    }
    inline void ih()
    {
        int nc=a[1];int ccnt=1;//将连续的一段插入到set中
        for(int i=2;i<=n;i++)
            if(nc/home/llj/Desktop/OI-wiki-master/docs/misc/!=a[i]){s.insert((data){i-ccnt,i-1,nc}),c[nc].insert((nod){i-ccnt,i-1});nc=a[i];ccnt=1;}
            else {ccnt++;} s.insert((data){n-ccnt+1,n,a[n]}),c[a[n]].insert((nod){n-ccnt+1,n});
    }
}
namespace cdq
{   
    struct treearray//树状数组
    {
        int ta[N];
        inline void c(int x,int t){for(;x<=n;x+=x&(-x))ta[x]+=t;}
        inline void d(int x){for(;x<=n;x+=x&(-x))ta[x]=0;}
        inline int  q(int x){int r=0;for(;x;x-=x&(-x))r+=ta[x];return r;}
        inline void clear(){for(int i=1;i<=n;i++)ta[i]=0;}
    }ta;int srt[N];
    inline bool cmp1(const int& a,const int& b){return pre[a]<pre[b];}
    inline void solve(int l1,int r1,int l2,int r2,int L,int R)//cdq
    {
        if(l1==r1||l2==r2)return;int mid=(L+R)/2;
        int mid1=l1;while(mid1/home/llj/Desktop/OI-wiki-master/docs/misc/!=r1&&md[mid1+1].t<=mid)mid1++;
        int mid2=l2;while(mid2/home/llj/Desktop/OI-wiki-master/docs/misc/!=r2&&qr[mid2+1].t<=mid)mid2++;
        solve(l1,mid1,l2,mid2,L,mid);solve(mid1,r1,mid2,r2,mid,R);
        if(l1/home/llj/Desktop/OI-wiki-master/docs/misc/!=mid1&&mid2/home/llj/Desktop/OI-wiki-master/docs/misc/!=r2)
        {
            sort(md+l1+1,md+mid1+1);sort(qr+mid2+1,qr+r2+1);
            for(int i=mid2+1,j=l1+1;i<=r2;i++)//考虑左侧对右侧贡献
            {
                while(j<=mid1&&md[j].pre<qr[i].l)ta.c(md[j].pos,md[j].va),j++;
                qr[i].ans+=ta.q(qr[i].r)-ta.q(qr[i].l-1);
            }for(int i=l1+1;i<=mid1;i++)ta.d(md[i].pos);
        }
    }
    inline void mainsolve()
    {
        colist::ih();for(int i=1;i<=m;i++)
            if(tp[i]==1)colist::stv(lf[i],rt[i],co[i]);else qr[++tp2]=(qry){++cnt,lf[i],rt[i],0};
        sort(qr+1,qr+tp2+1);for(int i=1;i<=n;i++)srt[i]=i;sort(srt+1,srt+n+1,cmp1);
        for(int i=1,j=1;i<=tp2;i++)//初始化一下每个询问的值
        {
            while(j<=n&&pre[srt[j]]<qr[i].l)ta.c(srt[j],1),j++;
            qr[i].ans+=ta.q(qr[i].r)-ta.q(qr[i].l-1);
        }ta.clear();sort(qr+1,qr+tp2+1,cmp);solve(0,tp1,0,tp2,0,cnt);sort(qr+1,qr+tp2+1,cmp);
        for(int i=1;i<=tp2;i++)printf("%d\n",qr[i].ans);
    }
}
int main(){prew::prew();cdq::mainsolve();return 0;}//拜拜程序~
```

### [HNOI2010]城市建设

一句话题意：给定一张图支持动态的修改边权，要求在每次修改边权之后输出这张图的最小生成树的最小代价和

事实上有一个线段树分治套 lct 的做法可以解决这个问题，但是这个实现方式常数过大可能需要精妙的卡常技巧才可以通过本题，因此我们不妨考虑 cdq 分治来解决这个问题

和一般的 cdq 分治解决的问题不同，我们此时 cdq 分治的时候并没有修改和询问的关系来让我们进行分治，因为我们是没有办法单独的考虑修改一个边对整张图的最小生成树有什么贡献，因此似乎传统的 cdq 分治思路似乎不是很好使

那么我们通过刚才的例题可以发现一般的 cdq 分治和线段树有着特殊的联系，我们在 cdq 分治的过程中其实隐式的建了一颗线段树出来（因为 cdq 分治的递归树就是一颗线段树）

通常的 cdq 是考虑线段树左右儿子之间的联系

而对于这道题来讲我们需要考虑的是父亲和孩子之间的关系

换句话来讲，我们在 $solve(l,r)$ 这段区间的时候如果我们可以想办法使图的规模变成和区间长度相关的一个变量的话我们就可以解决这个问题了

那么具体来讲如何设计算法呢？

假设我们正在构造 $(l,r)$ 这段区间的最小生成树边集，并且我们已知它父亲最小生成树的边集

我们将在 $(l,r)$ 这段区间中发生变化的边分别将边权赋成 $+ \infty$ 和 $-\infty$ 分别各跑一边 kruskal 求出那些边在最小生成树当中

对于一条边来讲，如果他没有出现在了所有被修改的边权都被赋成了 $+\infty$ 的最小生成树当中证明它不可能出现在 $(l,r)$ 这些询问的最小生成树当中，所以我们仅仅在 $(l,r)$ 的边集中加入最小生成树的树边

对于一条边来讲，如果它出现在了所有被修改的边权都被赋成了 $- \infty$ 的最小生成树当中，就证明它一定会出现 $(l,r)$ 这段的区间的最小生成树当中，这样的话我们就可以使用并查集将这些边对应的点缩起来，并且将答案加上这些边的边权

如此这般我们就将 $(l,r)$ 这段区间的边集构造出来了，用这些边求出来的最小生成树和直接求原图的最小生成树等价

那么为什么我们的复杂度是对的呢？

首先被修改的边一定会加入到我们的边集当中去，这些边的数目是 $O(len)$ 级别的

接下来我们需要证明的是边集当中不会有过多的未被修改的边

注意到我们只会加入所有边权取 $+\infty$ 最小生成树的树边，因此我们加入的边数目是不会超过当前图的点数的

接下来我们只需证明每递归一层图的点数是 $O(len)$ 级别的就可以说明图的边数是 $O(len)$ 级别的了

证明点数是 $O(len)$ 几倍就变的十分简单了，我们每次向下递归的时侯缩掉的边是在 $-\infty$ 生成树中出现的未被修改边，那么反过来想就是我们割掉了出现在 $-\infty$ 生成树当中的所有的被修改边，显然我们最多割掉 $len$ 条边，整张图最多分裂成 $O(len)$ 个连通块，这样的话新图点数就是 $O(len)$ 级别的了

所以我们就证明了每次我们用来跑 kruskal 的图都是 $O(len)$ 级别的了

从而每一层的时间复杂度都是 $O(n\log n)$ 了

因此我们的时间复杂度就是 $T(n)=T(\lfloor \frac{n}{2} \rfloor)+T(\lceil \frac{n}{2} \rceil)+ O(n\log n)=O(n\log^2n)$ 了

代码实现上可能会有一些难度，需要注意的是并查集不能使用路径压缩，否则就不支持回退操作了，执行缩点操作的时候也没有必要真的执行，而是每一层的 kruskal 都在上一层的并查集里直接做就可以了

```C
#include<cstdio>
#include<algorithm>
#include<vector>
#include<stack>
using namespace std;
typedef long long ll;
int n;int m;int ask;
struct bcj
{
    int fa[20010];int size[20010];
    struct opt{int u;int v;};stack <opt> st;
    inline void ih(){for(int i=1;i<=n;i++)fa[i]=i,size[i]=1;}
    inline int f(int x){return (fa[x]==x)?x:f(fa[x]);}
    inline void u(int x,int y)//带撤回
    {
        int u=f(x);int v=f(y);if(u==v)return;if(size[u]<size[v])swap(u,v);
        size[u]+=size[v];fa[v]=u;opt o;o.u=u;o.v=v;st.push(o);   
    }
    inline void undo(){opt o=st.top();st.pop();fa[o.v]=o.v;size[o.u]-=size[o.v];}
    inline void clear(int tim){while(st.size()>tim){undo();}}
}s,s1;
struct edge//静态边
{
    int u;int v;ll val;int mrk;
    friend bool operator <(edge a,edge b){return a.val<b.val;}
}e[50010];
struct moved{int u;int v;};//动态边
struct query{int num;ll val;ll ans;}q[50010];bool book[50010];//询问
vector <edge> ve[30];vector <moved> vq;vector <edge> tr;ll res[30];int tim[30];
inline void pushdown(int dep)//缩边
{
    tr.clear();//这里要复制一份，以免无法回撤操作
    for(int i=0;i<ve[dep].size();i++){tr.push_back(ve[dep][i]);}
    sort(tr.begin(),tr.end());
    for(int i=0;i<tr.size();i++)//无用边
    {
        if(s1.f(tr[i].u)==s1.f(tr[i].v)){tr[i].mrk=-1;continue;}s1.u(tr[i].u,tr[i].v);
    }s1.clear(0);res[dep+1]=res[dep];
    for(int i=0;i<vq.size();i++){s1.u(vq[i].u,vq[i].v);}vq.clear();
    for(int i=0;i<tr.size();i++)//必须边
    {
        if(tr[i].mrk==-1||s1.f(tr[i].u)==s1.f(tr[i].v))continue;tr[i].mrk=1;
        s1.u(tr[i].u,tr[i].v);s.u(tr[i].u,tr[i].v);res[dep+1]+=tr[i].val;
    }s1.clear(0);ve[dep+1].clear();
    for(int i=0;i<tr.size();i++)//缩边
    {
        if(tr[i].mrk/home/llj/Desktop/OI-wiki-master/docs/misc/!=0)continue;
        edge p;p.u=s.f(tr[i].u);p.v=s.f(tr[i].v);if(p.u==p.v)continue;
        p.val=tr[i].val;p.mrk=0;ve[dep+1].push_back(p);
    }return;
}
inline void solve(int l,int r,int dep)
{
    tim[dep]=s.st.size();int mid=(l+r)/2;
    if(r-l==1)//终止条件
    {
        edge p;p.u=s.f(e[q[r].num].u);p.v=s.f(e[q[r].num].v);p.val=q[r].val;
        e[q[r].num].val=q[r].val;p.mrk=0;ve[dep].push_back(p);pushdown(dep);
        q[r].ans=res[dep+1];s.clear(tim[dep-1]);return;
    }
    for(int i=l+1;i<=mid;i++){book[q[i].num]=true;}
    for(int i=mid+1;i<=r;i++)//动转静
    {
        if(book[q[i].num])continue;
        edge p;p.u=s.f(e[q[i].num].u);p.v=s.f(e[q[i].num].v);
        p.val=e[q[i].num].val;p.mrk=0;ve[dep].push_back(p);
    }
    for(int i=l+1;i<=mid;i++)//询问转动态
    {
        moved p;p.u=s.f(e[q[i].num].u);p.v=s.f(e[q[i].num].v);vq.push_back(p);
    }pushdown(dep);//下面的是回撤
    for(int i=mid+1;i<=r;i++){if(book[q[i].num])continue;ve[dep].pop_back();}
    for(int i=l+1;i<=mid;i++){book[q[i].num]=false;}solve(l,mid,dep+1);
    for(int i=0;i<ve[dep].size();i++){ve[dep][i].mrk=0;}
    for(int i=mid+1;i<=r;i++){book[q[i].num]=true;}
    for(int i=l+1;i<=mid;i++)//动转静
    {
        if(book[q[i].num])continue;
        edge p;p.u=s.f(e[q[i].num].u);p.v=s.f(e[q[i].num].v);
        p.val=e[q[i].num].val;p.mrk=0;ve[dep].push_back(p);
    }
    for(int i=mid+1;i<=r;i++)//询问转动
    {
        book[q[i].num]=false;
        moved p;p.u=s.f(e[q[i].num].u);p.v=s.f(e[q[i].num].v);vq.push_back(p);
    }pushdown(dep);solve(mid,r,dep+1);
    s.clear(tim[dep-1]);return;//时间倒流至上一层
}
int main()
{
    scanf("%d%d%d",&n,&m,&ask);s.ih();s1.ih();
    for(int i=1;i<=m;i++){scanf("%d%d%lld",&e[i].u,&e[i].v,&e[i].val);}
    for(int i=1;i<=ask;i++){scanf("%d%lld",&q[i].num,&q[i].val);}
    for(int i=1;i<=ask;i++)//初始动态边
    {
        book[q[i].num]=true;moved p;p.u=e[q[i].num].u;
        p.v=e[q[i].num].v;vq.push_back(p);
    }
    for(int i=1;i<=m;i++){if(book[i])continue;ve[1].push_back(e[i]);}//初始静态
    for(int i=1;i<=ask;i++){book[q[i].num]=false;}solve(0,ask,1);
    for(int i=1;i<=ask;i++){printf("%lld\n",q[i].ans);}return 0;//拜拜程序~
}
```

# simulated-annealing
## 简介

模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。

* * *

## 实现

根据 [爬山算法](./hill-climbing.md) 的过程，我们发现：对于一个当前最优解附近的非最优解，爬山算法直接舍去了这个解。而很多情况下，我们需要去接受这个非最优解从而跳出这个局部最优解，即为模拟退火算法。

>  **什么是退火？** （选自百度百科）
>
> 退火是一种金属热处理工艺，指的是将金属缓慢加热到一定温度，保持足够时间，然后以适宜速度冷却。目的是降低硬度，改善切削加工性；消除残余应力，稳定尺寸，减少变形与裂纹倾向；细化晶粒，调整组织，消除组织缺陷。准确的说，退火是一种对材料的热处理工艺，包括金属材料、非金属材料。而且新材料的退火目的也与传统金属退火存在异同。

由于退火的规律引入了更多随机因素，那么我们得到最优解的概率会大大增加。于是我们可以去模拟这个过程，将目标函数作为能量函数。

### 模拟退火算法描述

先用一句话概括：如果新状态的解更优则修改答案，否则以一定概率接受新状态。

我们定义当前温度为 $T$ ，新状态与已知状态（由已知状态通过随机的方式得到）之间的能量（值）差为 $\Delta E$ （ $\Delta E\geqslant 0$ ），则发生状态转移（修改最优解）的概率为

$$
P(\Delta E)=
\begin{cases}
1&\text{新状态更优}\\
e^\frac{-\Delta E}{T}&\text{新状态更劣}
\end{cases}
$$

 **注意** ：我们有时为了使得到的解更有质量，会在模拟退火结束后，以当前温度在得到的解附近多次随机状态，尝试得到更优的解（其过程与模拟退火相似）。

### 如何退火（降温）？

模拟退火时我们有三个参数：初始温度 $T_0$ ，降温系数 $d$ ，终止温度 $T_k$ 。其中 $T_0$ 是一个比较大的数， $d$ 是一个非常接近 $1$ 但是小于 $1$ 的数， $T_k$ 是一个接近 $0$ 的正数。

首先让温度 $T=T_0$ ，然后按照上述步骤进行一次转移尝试，再让 $T=d\cdot T$ 。当 $T<T_k$ 时模拟退火过程结束，当前最优解即为最终的最优解。

注意为了使得解更为精确，我们通常不直接取当前解作为答案，而是在退火过程中维护遇到的所有解的最优值。

引用一张 [Wiki - Simulated annealing](https://en.wikipedia.org/wiki/Simulated_annealing) 的图片（随着温度的降低，跳跃越来越不随机，最优解也越来越稳定）。

/home/llj/Desktop/OI-wiki-master/docs/misc/![](./images/simulated-annealing.gif)

* * *

## 代码

此处代码以 [「BZOJ 3680」吊打 XXX](https://www.luogu.org/problem/P1337) （求 $n$ 个点的带权类费马点）为例。

```cpp
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <ctime>

const int N = 10005;
int n, x[N], y[N], w[N];
double ansx, ansy, dis;

double Rand() { return (double)rand() / RAND_MAX; }
double calc(double xx, double yy) {
  double res = 0;
  for (int i = 1; i <= n; ++i) {
    double dx = x[i] - xx, dy = y[i] - yy;
    res += sqrt(dx * dx + dy * dy) * w[i];
  }
  if (res < dis) dis = res, ansx = xx, ansy = yy;
  return res;
}
void simulateAnneal() {
  double t = 100000;
  double nowx = ansx, nowy = ansy;
  while (t > 0.001) {
    double nxtx = nowx + t * (Rand() * 2 - 1);
    double nxty = nowy + t * (Rand() * 2 - 1);
    double delta = calc(nxtx, nxty) - calc(nowx, nowy);
    if (exp(-delta / t) > Rand()) nowx = nxtx, nowy = nxty;
    t *= 0.97;
  }
  for (int i = 1; i <= 1000; ++i) {
    double nxtx = ansx + t * (Rand() * 2 - 1);
    double nxty = ansy + t * (Rand() * 2 - 1);
    calc(nxtx, nxty);
  }
}
int main() {
  srand(time(0));
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) {
    scanf("%d%d%d", &x[i], &y[i], &w[i]);
    ansx += x[i], ansy += y[i];
  }
  ansx /= n, ansy /= n, dis = calc(ansx, ansy);
  simulateAnneal();
  printf("%.3lf %.3lf\n", ansx, ansy);
  return 0;
}
```

* * *

## 一些技巧

### 分块模拟退火

有时函数的峰很多，模拟退火难以跑出最优解。

此时可以把整个值域分成几段，每段跑一遍模拟退火，然后再取最优解。

### 卡时

有一个 `clock()` 函数，返回程序运行时间。

可以把主程序中的 `simulateAnneal();` 换成 `while ((double)clock()/CLOCKS_PER_SEC < MAX_TIME) simulateAnneal();` 。这样子就会一直跑模拟退火，直到用时即将超过时间限制。

这里的 `MAX_TIME` 是一个自定义的略小于时限的数。

* * *

## 习题

-    [「BZOJ 3680」吊打 XXX](https://www.luogu.org/problem/P1337) 
-    [「JSOI 2016」炸弹攻击](https://loj.ac/problem/2076) 
-    [「HAOI 2006」均分数据](https://www.luogu.org/problem/P2503) 

# frac-programming
author: greyqz, Ir1d, hsfzLZH1

分数规划用来求一个分式的极值。

形象一点就是，给出 $a_i$ 和 $b_i$ ，求一组 $w_i\in\{0,1\}$ ，最小化或最大化

$$
\displaystyle\frac{\sum\limits_{i=1}^na_i\times w_i}{\sum\limits_{i=1}^nb_i\times w_i}
$$

另外一种描述：每种物品有两个权值 $a$ 和 $b$ ，选出若干个物品使得 $\displaystyle\frac{\sum a}{\sum b}$ 最小/最大。

一般分数规划问题还会有一些奇怪的限制，比如『分母至少为 $W$ 』。

## 求解

### 二分法

分数规划问题的通用方法是二分。

假设我们要求最大值。二分一个答案 $mid$ ，然后推式子（为了方便少写了上下界）：

$$
\displaystyle
\begin{aligned}
&\frac{\sum a_i\times w_i}{\sum b_i\times w_i}>mid\\
\Longrightarrow&\sum a_i\times w_i-mid\times \sum b_i\cdot w_i>0\\
\Longrightarrow&\sum w_i\times(a_i-mid\times b_i)>0
\end{aligned}
$$

那么只要求出不等号左边的式子的最大值就行了。如果最大值比 $0$ 要大，说明 $mid$ 是可行的，否则不可行。

求最小值的方法和求最大值的方法类似，读者不妨尝试着自己推一下。

### Dinkelbach 算法

Dinkelbach 算法的大概思想是每次用上一轮的答案当做新的 $L$ 来输入，不断地迭代，直至答案收敛。

* * *

分数规划的主要难点就在于如何求 $\displaystyle \sum w_i\times(a_i-mid\times b_i)$ 的最大值/最小值。下面通过一系列实例来讲解该式子的最大值/最小值的求法。

## 实例

### 模板

> 有 $n$ 个物品，每个物品有两个权值 $a$ 和 $b$ 。求一组 $w_i\in\{0,1\}$ ，最大化 $\displaystyle\frac{\sum a_i\times w_i}{\sum b_i\times w_i}$ 的值。

把 $a_i-mid\times b_i$ 作为第 $i$ 个物品的权值，贪心地选所有权值大于 $0$ 的物品即可得到最大值。

为了方便初学者理解，这里放上完整代码：

??? 参考代码
    ```cpp
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    #include <cstdlib>
    #include <cstring>
    #include <iostream>
    using namespace std;
    
    inline int read() {
      int X = 0, w = 1;
      char c = getchar();
      while (c < '0' || c > '9') {
        if (c == '-') w = -1;
        c = getchar();
      }
      while (c >= '0' && c <= '9') X = X * 10 + c - '0', c = getchar();
      return X * w;
    }
    
    const int N = 100000 + 10;
    const double eps = 1e-6;
    
    int n;
    double a[N], b[N];
    
    inline bool check(double mid) {
      double s = 0;
      for (int i = 1; i <= n; ++i)
        if (a[i] - mid * b[i] > 0)  // 如果权值大于 0
          s += a[i] - mid * b[i];   // 选这个物品
      return s > 0;
    }
    
    int main() {
      // 输入
      n = read();
      for (int i = 1; i <= n; ++i) a[i] = read();
      for (int i = 1; i <= n; ++i) b[i] = read();
      // 二分
      double L = 0, R = 1e9;
      while (R - L > eps) {
        double mid = (L + R) / 2;
        if (check(mid))  // mid 可行，答案比 mid 大
          L = mid;
        else  // mid 不可行，答案比 mid 小
          R = mid;
      }
      // 输出
      printf("%.6lf\n", L);
      return 0;
    }
    ```

* * *

为了节省篇幅，下面的代码只保留 `check` 部分。主程序和本题是类似的。

### POJ2976 Dropping tests

> 有 $n$ 个物品，每个物品有两个权值 $a$ 和 $b$ 。
>
> 你可以选 $k$ 个物品 $p_1,p_2,\cdots,p_k$ ，使得 $\displaystyle\frac{\sum a_{p_i}}{\sum b_{p_i}}$ 最大。
>
> 输出答案乘 $100$ 后四舍五入到整数的值。

把第 $i$ 个物品的权值设为 $a_i-mid\times b_i$ ，然后选最大的 $k$ 个即可得到最大值。

```cpp
inline bool cmp(double x, double y) { return x > y; }
inline bool check(double mid) {
  int s = 0;
  for (int i = 1; i <= n; ++i) c[i] = a[i] - mid * b[i];
  sort(c + 1, c + n + 1, cmp);
  for (int i = 1; i <= n - k + 1; ++i) s += c[i];
  return s > 0;
}
```

### 洛谷 4377 Talent Show

> 有 $n$ 个物品，每个物品有两个权值 $a$ 和 $b$ 。
>
> 你需要确定一组 $w_i\in\{0,1\}$ ，使得 $\displaystyle\frac{\sum w_i\times a_i}{\sum w_i\times b_i}$ 最大。
>
> 要求 $\displaystyle\sum w_i\times b_i \geq W$ 。

本题多了分母至少为 $W$ 的限制，因此无法再使用上一题的贪心算法。

可以考虑 01 背包。把 $b_i$ 作为第 $i$ 个物品的重量， $a_i-mid\times b_i$ 作为第 $i$ 个物品的价值，然后问题就转化为背包了。

那么 $dp[n][W]$ 就是最大值。

一个要注意的地方： $\sum w_i\times b_i$ 可能超过 $W$ ，此时直接视为 $W$ 即可。（想一想，为什么？）

```cpp
double f[1010];
inline bool check(double mid) {
  for (int i = 1; i <= W; i++) f[i] = -1e9;
  for (int i = 1; i <= n; i++)
    for (int j = W; j >= 0; j--) {
      int k = min(W, j + b[i]);
      f[k] = max(f[k], f[j] + a[i] - mid * b[i]);
    }
  return f[W] > 0;
}
```

### POJ2728 Desert King

> 每条边有两个权值 $a_i$ 和 $b_i$ ，求一棵生成树 $T$ 使得 $\displaystyle\frac{\sum_{e\in T}a_e}{\sum_{e\in T}b_e}$ 最小。

把 $a_i-mid\times b_i$ 作为每条边的权值，那么最小生成树就是最小值，

代码就是求最小生成树，我就不放代码了。

### [HNOI2009]最小圈

> 每条边的边权为 $w$ ，求一个环 $C$ 使得 $\displaystyle\frac{\sum_{e\in C}w}{|C|}$ 最小。

把 $a_i-mid$ 作为边权，那么权值最小的环就是最小值。

因为我们只需要判最小值是否小于 $0$ ，所以只需要判断图中是否存在负环即可。

另外本题存在一种复杂度 $O(nm)$ 的算法，如果有兴趣可以阅读 [这篇文章](https://www.cnblogs.com/y-clever/p/7043553.html) 。

```cpp
inline int SPFA(int u, double mid) {  //判负环
  vis[u] = 1;
  for (int i = head[u]; i; i = e[i].nxt) {
    int v = e[i].v;
    double w = e[i].w - mid;
    if (dis[u] + w < dis[v]) {
      dis[v] = dis[u] + w;
      if (vis[v] || SPFA(v, mid)) return 1;
    }
  }
  vis[u] = 0;
  return 0;
}

inline bool check(double mid) {  //如果有负环返回 true
  for (int i = 1; i <= n; ++i) dis[i] = 0, vis[i] = 0;
  for (int i = 1; i <= n; ++i)
    if (SPFA(i, mid)) return 1;
  return 0;
}
```

## 总结

分数规划问题是一类既套路又灵活的题目，一般使用二分解决。

分数规划问题的主要难点在于推出式子后想办法求出 $\displaystyle\sum w_i\times(a_i-mid\times b_i)$ 的最大值/最小值，而这个需要具体情况具体分析。

## 习题

-    [JSOI2016 最佳团体](https://loj.ac/problem/2071) 
-    [SDOI2017 新生舞会](https://loj.ac/problem/2003) 
-    [UVa1389 Hard Life](https://www.luogu.org/problem/UVA1389) 

# basic
# stl-sort
## sort

C 标准库实现了快速排序，即 `stdlib.h` 当中的 `qsort` 。

但在 OI 相关比赛当中，更为常见的库排序函数是 C++ `algorithm` 库中的 `std::sort` 函数。

C++ 标准并未严格要求此函数的实现算法，具体实现取决于编译器。

旧版 C++ 标准中仅要求它的 **平均** 时间复杂度达到 $O(n\log n)$ ，但 C++11 标准要求它的 **最坏** 时间复杂度是达到 $O(n\log n)$ 。可以查阅 [std::sort()](https://en.cppreference.com/w/cpp/algorithm/sort) 

在 [libstdc++](https://github.com/mirrors/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h) 和 [libc++](http://llvm.org/svn/llvm-project/libcxx/trunk/include/algorithm) 中使用的都是 [Introsort](https://en.wikipedia.org/wiki/Introsort) 。

Introsort 限制了快速排序的分治深度，当分治达到一定深度之后，改用最坏时间复杂度为 $O(n\log n)$ 的排序算法（比如堆排序）来给子数组排序。

Introsort 的这个限制使得它的最坏时间复杂度是 $O(n\log n)$ 的。

用法：

```cpp
// a[0] .. a[n - 1] 为需要排序的数列
std::sort(a, a + n);
// 上面这句代码直接修改 a 数组里的元素顺序，使得现在它是从小到大排列的

std::sort(a, a + n, cmp);  // cmp 为自定义的比较函数
```

## nth_element

作用是找到选定区间内第 $k$ 大的数，并将所有比它小的数与比它大的数分别置于两侧，返回它的地址。

原理是未完成的快速排序。

用法：

```cpp
std::nth_element(begin, mid, end);
std::nth_element(begin, mid, end, cmp);
```

时间复杂度：期望 $O(n)$ 。

常用于构建 K-DTree。

## stable_sort

稳定的 $O(n\log n)$ 排序，即保证相等元素排序后的相对位置与原序列相同。

用法

```cpp
std::stable_sort(begin, end);
std::stable_sort(begin, end, cmp);
```

## partial_sort

将序列中前 $k$ 小元素按顺序置于前 $k$ 个位置，后面的元素不保证顺序。

复杂度： $O(n\log k)$ 

用法：

```cpp
std::partial_sort(begin, begin + k, end);
std::partial_sort(begin, begin + k, end, cmp);
```

原理：

实现 partial_sort 的思想是：对原始容器内区间为 $[first, middle)$ 的元素执行 make_heap() 操作构造一个大根堆，然后拿 $[middle, last)$ 中的每个元素和 $first$ 进行比较， $first$ 内的元素为堆内的最大值。如果小于该最大值，则互换元素位置，并对 $[first, middle)$ 内的元素进行调整，使其保持最大堆序。比较完之后在对 $[first, middle)$ 内的元素做一次对排序 sort_heap() 操作，使其按增序排列。注意，堆序和增序是不同的。

## 定义运算符

对于内置类型（如 `int` ）和用户定义的结构体，你都可以定义调用 STL 排序函数时使用的 **小于运算符** 。你可以在调用函数时同时传入一个比较运算符的函数（一般是最后一项），也可以直接重载该类型的默认运算符。参见 [cppreference](https://zh.cppreference.com/w/cpp/language/operators) 。
下面是几个例子：

```cpp
int a[1009], n = 10;
// ......
std::sort(a + 1, a + 1 + n);                  // 从小到大排序。
std::sort(a + 1, a + 1 + n, greater<int>());  // 从大到小排序。
```

```cpp
struct data {
  int a, b;
  bool operator<(const data rhs) const {
    return (a == rhs.a) ? (b < rhs.b) : (a < rhs.a);
  }
} da[1009];
bool cmp(const data u1, const data u2) {
  return (u1.a == u2.a) ? (u1.b > u2.b) : (u1.a > u2.a);
}
// ......
std::sort(da + 1, da + 1 + 10);  // 使用结构体中定义的 < 运算符，从小到大排序。
std::sort(da + 1, da + 1 + 10, cmp);  // 使用 cmp 函数进行比较，从大到小排序。
```

### 严格弱序

进行排序的运算符必须满足严格弱序（ [Strict weak orderings](https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings) ），否则会出现不可预料的情况（如运行时错误、无法正确排序）。

严格弱序的要求：

1.   $x \not< x$ （非自反性）
2.  若 $x < y$ ，则 $y \not< x$ （非对称性）
3.  若 $x < y, y < z$ ，则 $x < z$ （传递性）
4.  若 $x \not< y, y \not< x, y \not< z, z \not< y$ ，则 $x \not< z, z \not< x$ （不可比性的传递性）

常见的错误做法：

-   使用 `<=` 来定义排序中的小于运算符。
-   在调用排序运算符时，读取外部数值可能会改变的数组。（常见于最短路算法）
-   将多个数的最大最小值进行比较的结果作为排序运算符。（如，皇后游戏/加工生产调度 中的经典错误，可以参考文章 [浅谈邻项交换排序的应用以及需要注意的问题](https://ouuan.github.io/浅谈邻项交换排序的应用以及需要注意的问题/) ）。

# enumerate
author: frank-xjh

枚举是基于已有知识来猜测答案的一种问题求解策略。

!!! 例题
    求小于 N 的最大素数

找不到合适的一个数学公式来直接计算答案，不妨依次尝试一个数是否是答案。

如果我们从大到小枚举小于 $N$ 的数，那么原问题转化为如何判断一个数是不是素数。

注意到素数的性质要求不能被 $1$ 和它本身之外的数整除，可以直接用于判断。

枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。

## 给出解空间

建立简洁的数学模型。

枚举的时候要想清楚可能的情况是什么，要枚举哪些要素？

## 减少枚举的空间

枚举的范围是什么？是所有的内容都需要枚举吗？

在用枚举法解决问题的时候，一定要想清楚这两件事，否则会带来不必要的时间开销。

!!! 例题
    一个数组中的数互不相同，求其中和为 $0$ 的数对的个数

枚举两个数的代码很容易就可以写出来。

```cpp
for (int i = 0; i < n; ++i)
  for (int j = 0; j < n; ++j)
    if (a[i] + a[j] == 0) ++ans;
```

我们来看看枚举的范围如何优化。原问题的答案由两部分构成，两个数相等的情况和不相等的情况。相等的情况只需要枚举每一个数判断一下是否合法。至于不相等的情况，由于题中没要求数对是有序的，答案就是有序的情况的两倍（考虑如果 `(a, b)` 是答案，那么 `(b, a)` 也是答案）。我们对于这种情况只需统计人为要求有顺序之后的答案，最后再乘上 $2$ 就好了。

我们不妨要求第一个数要出现在靠前的位置。代码如下：

```cpp
for (int i = 0; i < n; ++i)
  for (int j = 0; j < i; ++j)
    if (a[i] + a[j] == 0) ++ans;
```

不难发现这里已经减少了 $j$ 的枚举范围，减少了这段代码的时间开销。

然而这并不是最优的结果。

两个数是否都一定要枚举出来呢？这里我们发现枚举其中一个数之后，题目的条件已经帮我们确定了其他的要素（另一个数），如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。

```cpp
// 要求 a 数组中的数的绝对值都小于 MAXN
bool met[MAXN * 2];
// 初始化 met 数组为 0；
memset(met, 0, sizeof(met));
for (int i = 0; i < n; ++i) {
  if (met[MAXN - a[i]]) ++ans;
  // 为了避免负数下标
  met[a[i] + MAXN] = 1;
}
```

## 选择合适的枚举顺序

比如第一个例题中要求的是最大的符合条件的素数。自然是从大到小枚举比较合适。

# simulate
模拟。顾名思义，就是用计算机来模拟题目中要求的操作，比如 NOIP 2014 的 [生活大爆炸版石头剪刀布](https://uoj.ac/problem/15) ，只需要按照题面的意思来写就可以了。

当然，模拟并不总是很好写，参见经典题目 [魔兽世界](http://bailian.openjudge.cn/practice/3750/) 和 [猪国杀](https://loj.ac/problem/2885) 。

模拟题目通常具有码量大、操作多、思路繁复的特点。并且由于它码量大，会导致很难查错，如果在考试中写错是相当浪费时间的。

所以写模拟题，遵循以下的建议有可能会帮助你提升做题速度：

1.  在动手写代码之前，在草纸上尽可能地写好要实现的流程；
2.  在代码中，尽量把每个部分模块化、写成函数、结构体或类；
3.  对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 "YY-MM-DD 时：分" 把它扔到一个函数处理成秒，会减少概念混淆；
4.  调试时分块调试，模块化的好处就是可以方便的单独调某一部分；
5.  写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。

实际上，上述步骤在解决其它类型的题目时也是很有帮助的。

# radix-sort
基数排序是将待排序的元素拆分为 $k$ 个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第 $k$ 关键字进行稳定排序，再对第 $k-1$ 关键字进行稳定排序，再对第 $k-2$ 关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。

基数排序的正确性可以自己感性理解一下，也可以参考 <https://walkccc.github.io/CLRS/Chap08/8.3/#83-3> 。

一般来说，每个关键字的值域都不大，就可以使用 [计数排序](./counting-sort.md) 作为内层排序，复杂度为 $O(nk+\sum\limits_{i=1}^k w_i)$ ，其中 $w_i$ 为第 $i$ 关键字的值域大小。

（如果关键字值域很大，就可以直接使用基于比较的 $O(nk\log n)$ 排序而无需使用基数排序了。）

伪代码：

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements, where each element has }k\text{ keys.}\\
2 & \textbf{Output. } \text{Array }A\text{ will be sorted in nondecreasing order stably.} \\
3 & \textbf{Method. }  \\
4 & \textbf{for }i\gets k\textbf{ down to }1\\
5 & \qquad\text{sort }A\text{ into nondecreasing order by the }i\text{-th key stably}
\end{array}
$$

C++ 代码：

```cpp
const int N = 100010;
const int W = 100010;
const int K = 100;

int n, w[K], k, cnt[W];

struct Element {
  int key[K];
  bool operator<(const Element& y) const  // shows how two elements are compared
  {
    for (int i = 1; i <= k; ++i) {
      if (key[i] == y.key[i]) continue;
      return key[i] < y.key[i];
    }
    return false;
  }
} a[N], b[N];

void counting_sort(int p) {
  memset(cnt, 0, sizeof(cnt));
  for (int i = 1; i <= n; ++i) ++cnt[a[i].key[p]];
  for (int i = 1; i <= w[p]; ++i) cnt[i] += cnt[i - 1];
  for (int i = 1; i <= n; ++i) b[cnt[a[i].key[p]]--] = a[i];
  memcpy(a, b, sizeof(a));
}

void radix_sort() {
  for (int i = k; i >= 1; --i) {
    counting_sort(i);
  }
}
```

# bucket-sort
桶排序适用于待排序数据值域较大但分布比较均匀的情况，是一个期望时间复杂度为 $O(n)$ 的排序算法。

其大致思想是对值域进行分块，每块分别排序。由于每块元素不多，一般使用插入排序。如果使用稳定的内层排序，并且将元素插入桶中时不改变相对顺序，那么桶排序就是稳定的。

如果待排序数据是随机生成的，将值域平均分成 $n$ 块的期望时间复杂度是 $O(n)$ ，证明可以参考算法导论或 [维基百科](https://en.wikipedia.org/wiki/Bucket_sort) 。

C++ 代码：

```cpp
const int N = 100010;

int n, w, a[N];
vector<int> bucket[N];

void insertion_sort(vector<int>& A) {
  for (int i = 1; i < A.size(); ++i) {
    int key = A[i];
    int j = i - 1;
    while (j >= 0 && A[j] > key) {
      A[j + 1] = A[j];
      --j;
    }
    A[j + 1] = key;
  }
}

void bucket_sort() {
  int bucket_size = w / n + 1;
  for (int i = 0; i < n; ++i) {
    bucket[i].clear();
  }
  for (int i = 1; i <= n; ++i) {
    bucket[a[i] / bucket_size].push_back(a[i]);
  }
  int p = 0;
  for (int i = 0; i < n; ++i) {
    insertion_sort(bucket[i]);
    for (int j = 0; j < bucket[i].size(); ++j) {
      a[++p] = bucket[i][j];
    }
  }
}
```

# selection-sort
每次找出第 $i$ 小的元素（也就是 $A_{i..n}$ 中最小的元素），将这个元素与数组第 $i$ 个位置上的元素交换。

时间复杂度为 $O(n^2)$ 。

由于 swap（交换两个元素）操作的存在，选择排序是一个不稳定排序。

伪代码：

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \\
2 & \textbf{Output. } A\text{ will be sorted in nondecreasing order.} \\
3 & \textbf{Method. }  \\
4 & \textbf{for } i\gets 1\textbf{ to }n-1\\
5 & \qquad ith\gets i\\
6 & \qquad \textbf{for }j\gets i+1\textbf{ to }n\\
7 & \qquad\qquad\textbf{if }A[j]<A[ith]\\
8 & \qquad\qquad\qquad ith\gets j\\
9 & \qquad \text{swap }A[i]\text{ and }A[ith]\\
\end{array}
$$

C++ 代码：

```cpp
void selection_sort(int* a, int n) {
  for (int i = 1; i < n; ++i) {
    int ith = i;
    for (int j = i + 1; j <= n; ++j) {
      if (a[j] < a[ith]) {
        ith = j;
      }
    }
    int t = a[i];
    a[i] = a[ith];
    a[ith] = t;
  }
}
```

# merge-sort
## 算法

归并排序是一种采用了 [分治](./divide-and-conquer.md) 思想的排序算法。

归并排序分为三个过程：

1.  将数列划分为两部分（在均匀划分时时间复杂度为 $O\left(n\log{n}\right)$ ）；
2.  递归地分别对两个子序列进行归并排序；
3.  合并两个子序列。

不难发现，归并排序的核心是如何合并两个子序列，前两步都很好实现。

其实合并的时候也不难操作。注意到两个子序列在第二步中已经保证了都是有序的了，第三步中实际上是想要把两个 **有序** 的序列合并起来。

```cpp
void merge(int ll, int rr) {
  // 用来把 a[ll.. rr - 1] 这一区间的数排序。 t 数组是临时存放有序的版本用的。
  if (rr - ll <= 1) return;
  int mid = ll + (rr - ll >> 1);
  merge(ll, mid);
  merge(mid, rr);
  int p = ll, q = mid, s = ll;
  while (s < rr) {
    if (p >= mid || (q < rr && a[p] > a[q])) {
      t[s++] = a[q++];
      // ans += mid - p;
    } else
      t[s++] = a[p++];
  }
  for (int i = ll; i < rr; ++i) a[i] = t[i];
}
```

关键点在于一次性创建数组，避免在每次递归调用时创建，避免了对象的无谓构造和析构。

## 逆序对

归并排序还可以用来求逆序对的个数。

所谓逆序对，就是满足 $a_{i} > a_{j}$ 且 $i < j$ 的数对 $(i, j)$ 。

可以用 [树状数组](../ds/fenwick.md) 、 [线段树](../ds/seg.md) 等数据结构来求，也可以用归并排序来求。

具体来说，上面归并排序中间注释掉的 `ans += mid - p` 就是在统计逆序对个数。

是因为，那里把靠后的数放到前面了（较小的数放在前面），所以在这个数的原来位置之前的、比它大的数都会和它形成逆序对，而这个个数就是还没有合并进去的数的个数，即为 `mid - p` 。

使用归并排序求逆序对的时间复杂度也是 $O(n \log n)​$ 。

## 参考

 <https://www.geeksforgeeks.org/merge-sort/> 

# counting-sort
计数排序是一种复杂度为 $O(n+w)$ 的稳定排序，其中 $w$ 代表待排序数据的值域大小。

计数排序分为三个步骤：

1.  计算每个数出现了几次。
2.  求出每个数出现次数的前缀和。
3.  利用出现次数的前缀和，从右至左计算每个数的排名。

伪代码：

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ positive integers no greater than } w. \\
2 & \textbf{Output. } \text{Array }A\text{ after sorting in nondecreasing order stably.} \\
3 & \textbf{Method. }  \\
4 & \textbf{for }i\gets0\textbf{ to }w\\
5 & \qquad cnt[i]\gets0\\
6 & \textbf{for }i\gets1\textbf{ to }n\\
7 & \qquad cnt[A[i]]\gets cnt[A[i]]+1\\
8 & \textbf{for }i\gets1\textbf{ to }w\\
9 & \qquad cnt[i]\gets cnt[i]+cnt[i-1]\\
10 & \textbf{for }i\gets n\textbf{ downto }1\\
11 & \qquad B[cnt[A[i]]]\gets A[i]\\
12 & \qquad cnt[A[i]]\gets cnt[A[i]]-1\\
13 & \textbf{return } B
\end{array}
$$

C++ 代码：

```cpp
const int N = 100010;
const int W = 100010;

int n, w, a[N], cnt[W], b[N];

void counting_sort() {
  memset(cnt, 0, sizeof(cnt));
  for (int i = 1; i <= n; ++i) ++cnt[a[i]];
  for (int i = 1; i <= w; ++i) cnt[i] += cnt[i - 1];
  for (int i = n; i >= 1; --i) b[cnt[a[i]]--] = a[i];
}
```

# shell-sort
Shell 排序是以它的发明者命名的，也称为缩小增量排序法。Shell 排序对不相邻的记录进行比较和移动：

1.  将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同）
2.  对这些子序列进行插入排序
3.  减小每个子序列中元素之间的间距，重复上述过程直至间距减少为 1

Shell 排序的复杂度和间距序列的选取（就是间距如何减小到 1）有关，比如“间距每次除以 3”的 Shell 排序的复杂度是 $O(n^{3/2})$ 。

# construction
构造题是比赛中常见的一类题型。

从形式上来看，问题的答案往往具有某种规律性，使得在问题规模迅速增大的时候，仍然有机会比较容易地得到答案。

这要求我们在解题时，要思考问题规模增长对答案的影响，这种影响是否可以推广。（比如在设计动态规划方法的时候，要考虑从一个状态到后继状态的转移会造成什么影响）。

构造题一个很显著的特点就是高自由度，也就是说一道题的构造方式可能有很多种，但是会有一种较为简单的构造方式满足题意。看起来是放宽了要求，让题目变的简单了，但很多时候，正是这种高自由度导致题目没有明确思路而无从下手。

构造题另一个特点就是形式灵活，变化多样。并不存在一个通用解法或套路可以解决所有构造题，甚至很难找出解题思路的共性。因此，下面将列举一些例题帮助读者体会构造题的一些思想内涵，给予思路上的启发。建议大家深入思考后再查看题解，也欢迎大家参与分享有趣的构造题。

## 例题：

### 例题 1

#### 题面

 [Vladik and fractions](http://codeforces.com/problemset/problem/743/C) 

题目大意：构造一组 $x,y,z$ ，使得对于给定的 $n$ ，满足 $\dfrac{1}{x}+\dfrac{1}{y}+\dfrac{1}{z}=\dfrac{2}{n}$ 

#### 做法

样例二已经暴露了此题的本质~~（复读机~~

显然 $n,n+1,n(n+1)$ 为一组合法解。特殊地，当 $n=1$ 时，无解，这是因为 $n+1$ 与 $n(n+1)$ 此时相等。

至于构造思路是怎么产生的，大概就是观察样例加上一点点数感了吧。此题对于数学直觉较强的人来说并不难。

### 例题 2

#### 题面

 [Luogu P3599 Koishi Loves Construction](https://www.luogu.org/problemnew/show/P3599) 

#### 做法

对于 task1：

当 $n$ 为奇数时，无法构造出合法解；

当 $n$ 为偶数时，可以构造一个形如 $n,1,n-2,3,\cdots$ 这样的数列。

首先，我们可以发现 $n$ 必定出现在数列的第一位，否则 $n$ 出现前后的两个前缀和必然会陷入模意义下相等的尴尬境地；

然后，我们考虑构造出整个序列的方式：

考虑通过构造前缀和序列的方式来获得原数列，可以发现前缀和序列两两之间的差在模意义下不能相等，因为前缀和序列的差分序列对应着原来的排列。

因此我们尝试以前缀和数列在模意义下为

$$
0,1,-1,2,-2,\cdots
$$

这样的形式来构造这个序列，不难发现它完美地满足所有限制条件。

对于 task2：

当 $n$ 为除 $4$ 以外的合数时，无法构造出合法解

当 $n$ 为质数或 $4$ 时，可以构造一个形如 $1,\dfrac{2}{1},\dfrac{3}{2},\cdots,\dfrac{n-1}{n-2},n$ 这样的数列

先考虑什么时候有解：

显然，当 $n$ 为合数时无解。因为对于一个合数来说，存在两个比它小的数 $p,q$ 使得 $p\times q \equiv 0 \pmod n$ ，如 $(3\times6)\%9=0$ 。那么，当 $p,q$ 均出现过后，数列的前缀积将一直为 $0$ ，故合数时无解。特殊地，我们可以发现 $4=2\times 2$ ，无满足条件的 $p,q$ ，因此存在合法解。

我们考虑如何构造这个数列：

和 task1 同样的思路，我们发现 $1$ 必定出现在数列的第一位，否则 $1$ 出现前后的两个前缀积必然相等；而 $n$ 必定出现在数列的最后一位，因为 $n$ 出现位置后的所有前缀积在模意义下都为 $0$ 。手玩几组样例以后发现，所有样例中均有一组合法解满足前缀积在模意义下为 $1,2,3,\cdots,n$ ，因此我们可以构造出上文所述的数列来满足这个条件。那么我们只需证明这 $n$ 个数互不相同即可。

我们发现这些数均为 $1 \cdots n-2$ 的逆元 $+1$ ，因此各不相同，此题得解。

### 例题 3

#### 题面

 [AtCoder Grand Contest 032 B](https://atcoder.jp/contests/agc032/tasks/agc032_b) 

#### 做法

手玩一下 $n=3,4,5$ 的情况，我们可以找到一个构造思路。

构造一个完全 $k$ 分图，保证这 $k$ 部分和相等。则每个点的 $S$ 均相等，为 $\dfrac{(k-1)\sum_{i=1}^{n}i}{k}$ 。

如果 $n$ 为偶数，那么我们可以前后两两配对，即 $\{1,n\},\{2,n-1\}\cdots$ 

如果 $n$ 为奇数，那么我们可以把 $n$ 单拿出来作为一组，剩余的 $n-1$ 个两两配对，即 $\{n\},\{1,n-1\},\{2,n-2\}\cdots$ 

这样构造出的图在 $n\ge 3$ 时连通性易证，在此不加赘述。

此题得解。

### 例题 4

#### 题面

 [「Lydsy1708 月赛」记忆中的背包](http://www.lydsy.com/JudgeOnline/problem.php?id=4971) 

#### 做法

这道题是自由度最高的构造题之一了。这就导致了没有头绪，难以入手。

首先，不难发现模数是假的。由于我们自由构造数据，我们一定可以让方案数不超过模数。

通过奇怪的方式，我们想到可以通过构造 $n$ 个 代价为 $1$ 的小物品和几个代价大于 $\dfrac{w}{2}$ 的大物品。

由于大物品只能取一件，所以每个代价为 $x$ 的大物品对方案数的贡献为 $C_{n}^{w-x}$ 。

令 $f_{i,j}$ 表示有 $i$ 个 $1$ ，方案数为 $j$ 的最小大物品数。

用 dp 预处理出 $f$ ，通过计算可知只需预处理 $i\le 20$ 的所有值即可。

此题得解。

# prefix-sum
## 前缀和

前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 n 项的和”。

!!! 例题
    有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。

对于这道题，我们有两种做法：

-   把对数组 A 的累加依次放入数组 B 中。
-   递推： `B[i] = B[i-1] + A[i]` ，前提 `B[0] = A[0]` 。

参考程序：

```cpp
#include <iostream>

using namespace std;

int N, A[10000], B[10000];
int main() {
  cin >> N;
  for (int i = 0; i < N; i++) {
    cin >> A[i];
  }

  B[0] = A[0];

  for (int i = 1; i < N; i++) {
    B[i] = B[i - 1] + A[i];
  }

  for (int i = 0; i < N; i++) {
    cout << B[i] << " ";
  }

  return 0;
}
```

输入：

    5
    1 2 3 4 5

输出：

    1 3 6 10 15 

首先， `B[0] = A[0];` ，前缀和数组的第一项和原数组的第一项是相等的。

 `B[i] = B[i-1] + A[i]` 意思就是：前缀和数组的第 i 项 = 原数组的 0 到 i-1 项的和 + 原数组的第 i 项。

### 习题

-    [洛谷 U53525 前缀和（例题）](https://www.luogu.org/problemnew/show/U53525) 
-    [洛谷 U69096 前缀和的逆](https://www.luogu.org/problemnew/show/U69096) 
-    [AT2412 最大の和](https://www.luogu.org/problemnew/show/AT2412) 
-    [「USACO16JAN」子共七 Subsequences Summing to Sevens](https://www.luogu.org/problemnew/show/P3131) 

### 参考

感谢南海区青少年信息学奥林匹克内部训练教材。

## 二维/多维前缀和

其实前缀和几乎都是基于容斥原理，所以各种拓展自己手推一下就行了。  
这里用二维前缀和为例讲解一下前缀和扩展到多维的方式。

比如我们有这样一个矩阵 $a$ ，可以视为二维数组：

```plain
1 2 4 3
5 1 2 4
6 3 5 9
```

我们定义一个矩阵 $sum$ ， $sum_{x,y} = \sum\limits_{i=1}^x \sum\limits_{j=1}^y a_{i,j}$ ，  
那么这个矩阵长这样：

```plain
1 3 7 10
6 9 15 22
12 18 29 45
```

第一个问题就是递推求 $sum$ 的过程， $sum_{i,j} = sum_{i - 1,j} + sum_{i,j - 1} - sum_{i - 1,j - 1} + a_{i,j}$ 。  
因为加了 $sum_{i - 1,j}$ 和 $sum_{i,j - 1}$ 重复了 $sum_{i - 1,j - 1}$ ，所以减去。

第二个问题就是如何应用，譬如求 $(x1,y1) - (x2,y2)$ 子矩阵的和。  
那么，根据类似的思考过程，易得答案为 $sum_{x2,y2} - sum_{x1 - 1,y2} - sum_{x2,y1 - 1} + sum_{x1 - 1,y1 - 1}$ 。

下面给出 [洛谷 P1387 最大正方形](https://www.luogu.org/problemnew/show/P1387) 这道题目的参考程序来帮助大家理解二维前缀和。

```cpp
#include <algorithm>
#include <iostream>
using namespace std;
int a[103][103];
int b[103][103];  // 前缀和数组，相当于上文的 sum[]
int main() {
  int n, m;
  cin >> n >> m;

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> a[i][j];
      b[i][j] =
          b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1] + a[i][j];  // 求前缀和
    }
  }

  int ans = 1;

  int l = 2;
  while (l <= min(n, m)) {
    for (int i = l; i <= n; i++) {
      for (int j = l; j <= m; j++) {
        if (b[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l) {
          ans = max(ans, l);
        }
      }
    }
    l++;
  }

  cout << ans << endl;
  return 0;
}
```

### 习题

-    [CodeVS 1373. 射命丸文](http://www.joyoi.cn/problem/codevs-1373) 
-    [洛谷 P1387 最大正方形](https://www.luogu.com.cn/problem/P1387) 
-    [「HNOI2003」激光炸弹](https://www.luogu.com.cn/problem/P2280) 

### 基于 DP 计算高维前缀和

前一节方法本质上是基于容斥原理来计算高维前缀和，其优点在于形式较为简单，无需特别记忆，但当维数升高时，其复杂度较高。这里介绍一种基于 DP 计算高维前缀和的方法。该方法即通常语境中所称的 **高维前缀和** 。

设高维空间 $U$ 共有 $D$ 维，需要对 $f[\cdot]$ 求高维前缀和 $\text{sum}[\cdot]$ 。令 $\text{sum}[i][\text{state}]$ 表示同 $\text{state}$ 后 $D - i$ 维相同的所有点对于 $\text{state}$ 点高维前缀和的贡献。由定义可知 $\text{sum}[0][\text{state}] = f[\text{state}]$ ，以及 $\text{sum}[\text{state}] = \text{sum}[D][\text{state}]$ 。

其递推关系为 $\text{sum}[i][\text{state}] = \text{sum}[i - 1][\text{state}] + \text{sum}[i][\text{state}']$ ，其中 $\text{state}'$ 为第 $i$ 维恰好比 $\text{state}$ 少 $1$ 的点。该方法的复杂度为 $O(D \times |U|)$ ，其中 $|U|$ 为高维空间 $U$ 的大小。

其一种实现的伪代码如下：

    for state
    	sum[state] = f[state];
    for(i = 0;i <= D;i += 1)
    	for 以字典序从小到大枚举 state
    		sum[state] += sum[state'];

## 树上前缀和

设 $sum_i$ 表示结点 $i$ 到根节点的权值总和。  
然后若是点权， $x,y$ 路径上的和为 $sum_x + sum_y - sum_{lca} - sum_{fa_{lca}}$ ；  
否则若是边权， $x,y$ 路径上的和为 $sum_x + sum_y - 2sum_{lca}$ 。

至于 lca 的求法请移步 [最近公共祖先](../graph/lca.md) 。

### 习题

-    [LOJ 10134.Dis](https://loj.ac/problem/10134) 
-    [LOJ 2491. 求和](https://loj.ac/problem/2491) 

## 差分

差分，是一种和前缀和相对的策略。  
这种策略是，令 $b_i = a_i - a_{i - 1}$ ，即相邻两数的差。  
易得对这个序列做一遍前缀和就得到了原来的 $a$ 序列。

它可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。（总之修改操作一定要在查询操作之前）  
具体怎么搞？譬如使 $[l,r]$ 每个数加上一个 $k$ ，就是 $b_l \leftarrow b_l + k,b_{r + 1} \leftarrow b_{r + 1} - k$ 。  
最后做一遍前缀和就好了。

### 习题

-    [树状数组 3：区间修改，区间查询](https://loj.ac/problem/132) 
-    [P3397 地毯](https://www.luogu.com.cn/problem/P3397) 
-    [「Poetize6」IncDec Sequence](https://www.luogu.com.cn/problem/P4552) 

## 树上差分

我以前一直以为树上差分也是树上前缀和相对的策略，但是不知道怎么搞。

后来发现还是有点区别的。

至少人家是基于子树和而非到根的和。

如果使 $x,y$ 路径上的点权增加 $k$ ， $b_x \leftarrow b_x + k,b_y \leftarrow b_y + k,b_{lca} \leftarrow b_{lca} - k,b_{fa_{lca}} \leftarrow b_{fa_{lca}} - k$ ，
如果是边权， $b_x \leftarrow b_x + k,b_y \leftarrow b_y + k,b_{lca} \leftarrow b_{lca} - 2k$ 。

然后一遍搜索求一下子树和答案就出来了。

### 习题

-    [洛谷 3128. 最大流](https://www.luogu.org/problemnew/show/P3128) 

# heap-sort
对所有记录建 [堆](../ds/heap.md) 。

依次取出堆顶元素，就可以得到排好序的序列。

时间复杂度为 $O(n\log n)$ 。

# binary-acc
author: Ir1d, ShadowsEpic, Fomalhauthmj, siger-young, MingqiHuang, Xeonacid, hsfzLZH1, orzAtalod

倍增法，通过字面意思来看就是翻倍。这个方法在很多算法中均有应用，其中最常用的就是 RMQ 问题和求 LCA 了。

## 例题

???+note "例题"
    给出一个长度为 $n$ 的环和一个常数 $k$ ，每次会从第 $i$ 个点跳到第 $(i+k)\bmod n+1$ 个点，总共跳了 $m$ 次。每个点都有一个权值，记为 $a_i$ ，求 $m$ 次跳跃的起点的权值之和对 $10^9+7$ 取模的结果。

    数据范围： $1\leq n\leq 10^6$ , $1\leq m\leq 10^{18}$ , $1\leq k\leq n$ , $0\le a_i\le 10^9$ 。

这里显然不能暴力模拟跳 $m$ 次。因为 $m$ 最大可到 $10^{18}$ 级别，如果暴力模拟的话，时间承受不住。

所以就需要进行一些预处理，提前整合一些信息，以便于在查询的时候更快得出结果。如果记录下来每一个可能的跳跃次数的结果的话，不论是时间还是空间都难以承受。

那么应该如何预处理呢？先看另一道例题：

???+note "例题"
    如何用尽可能少的砝码称量出 $[0,31]$ 之间的所有重量？（只能在天平的一端放砝码）

答案是使用 1 2 4 8 16 这五个砝码，可以称量出 $[0,31]$ 之间的所有重量。同样，如果要称量 $[0,127]$ 之间的所有重量，可以使用 1 2 4 8 16 32 64 这七个砝码。每次我们都选择 2 的整次幂作砝码的重量，就可以使用极少的砝码个数量出任意我们所需要的重量。

为什么说是极少呢？因为如果我们要量出 $[0,1023]$ 之间的所有重量，只需要 9 个砝码，需要量出 $[0,1048575]$ 之间的所有重量，只需要 19 个。如果我们的目标重量翻倍，砝码个数只需要增加 1。这叫“对数级”的增长速度，因为砝码的所需个数与目标重量的范围的对数成正比。

回到上面的题。我们要预处理一些信息，然后用预处理的信息尽量快的整合出答案。同时预处理的信息也不能太多。所以可以预处理出以 2 的整次幂为单位的信息，这样的话在预处理的时候只需要处理少量信息，在整合的时候也不需要大费周章。

在这题上，就是我们预处理出从每个点开始跳 1、2、4、8 等等步之后的结果（所处点和点权和），然后如果要跳 13 步，只需要跳 1+4+8 步就好了。也就是说先在起始点跳 1 步，然后再在跳了之后的终点跳 4 步，再接着跳 8 步，同时统计一下预先处理好的点权和，就可以知道跳 13 步的点权和了。

对于每一个点开始的 $2^i$ 步，记录一个 `go[i][x]` 表示第 $x$ 个点跳 $2^i$ 步之后的终点，而 `sum[i][x]` 表示第 $x$ 个点跳 $2^i$ 步之后能获得的点权和。预处理的时候，开两重循环，对于跳 $2^i$ 步的信息，我们可以看作是先跳了 $2^{i-1}$ 步，再跳 $2^{i-1}$ 步，因为显然有 $2^{i-1}+2^{i-1}=2^i$ 。即我们有 `sum[i][x] = sum[i-1][x]+sum[i-1][go[i-1][x]]` ，且 `go[i][x] = go[i-1][go[i-1][x]]` 。

当然还有一些实现细节需要注意。为了保证统计的时候不重不漏，我们一般预处理出“左闭右开”的点权和。亦即，对于跳 1 步的情况，我们只记录该点的点权和；对于跳 2 步的情况，我们只记录该点及其下一个点的点权和。相当于总是不将终点的点权和计入 sum。这样在预处理的时候，只需要将两部分的点权和直接相加就可以了，不需要担心第一段的终点和第二段的起点会被重复计算。

??? note "例题代码"
    ```cpp
    #include <cstdio>
    using namespace std;
    
    const int mod = 1000000007;
    
    int modadd(int a, int b) {
      if (a + b >= mod) return a + b - mod;  // 减法代替取模，加快运算
      return a + b;
    }
    
    int vi[1000005];
    
    int go[75][1000005];  // 将数组稍微开大以避免越界，小的一维尽量定义在前面
    int sum[75][1000005];
    
    int main() {
      int n, k;
      scanf("%d%d", &n, &k);
      for (int i = 1; i <= n; ++i) {
        scanf("%d", vi + i);
      }
    
      for (int i = 1; i <= n; ++i) {
        go[0][i] = (i + k) % n + 1;
        sum[0][i] = vi[i];
      }
    
      int logn = 31 - __builtin_clz(n);  // 一个快捷的取对数的方法
      for (int i = 1; i <= logn; ++i) {
        for (int j = 1; j <= n; ++j) {
          go[i][j] = go[i - 1][go[i - 1][j]];
          sum[i][j] = modadd(sum[i - 1][j], sum[i - 1][go[i - 1][j]]);
        }
      }
    
      long long m;
      scanf("%lld", &m);
    
      int ans = 0;
      int curx = 1;
      for (int i = 0; m; ++i) {
        if (m & (1 << i))  // 参见位运算的相关内容，意为 m 的第 i 位是否为 1
        {
          ans = modadd(ans, sum[i][curx]);
          curx = go[i][curx];
          m ^= 1ll << i;  // 将第 i 位置零
        }
      }
    
      printf("%d\n", ans);
    }
    ```

这题的 $m\leq 10^{18}$ ，虽然看似恐怖，但是实际上只需要预处理出 $65$ 以内的 $i$ ，就可以轻松解决，比起暴力枚举快了很多。用行话讲，这个做法的 [时间复杂度](../misc/complexity.md) 是预处理 $\Theta(n\log m)$ ，查询每次 $\Theta(\log m)$ 。

倍增除了作为一种独立的思想以外，还经常被应用到各种算法里面，例如 LCA 和 RMQ 问题，可以在下面查看。

## RMQ 问题

RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。

使用倍增思想解决 RMQ 问题的方法是 [ST 表](../ds/sparse-table.md) ，解决 RMQ 问题的其它方法还可以参见 [RMQ 专题](../topic/rmq.md) 。

## 树上倍增求 LCA

具体请参见 [最近公共祖先](/graph/lca/#_5) 页面。

# binary
## 二分法

### 二分查找

二分搜索，也称折半搜索、二分查找，是用来在一个有序数组中查找某一元素的算法。

以在一个升序数组中查找一个数为例。

它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需要到右侧去找就好了；如果中间元素大于所查找的值，同理，右侧的只会更大而不会有所查找的元素，所以只需要到左侧去找。

在二分搜索过程中，每次都把查询的区间减半，因此对于一个长度为 $n$ 的数组，至多会进行 $O(\log n)$ 次查找。

```cpp
int binary_search(int start, int end, int key) {
  int ret = -1;  // 未搜索到数据返回-1下标
  int mid;
  while (start <= end) {
    mid = start + ((end - start) >> 1);  //直接平均可能会溢出，所以用这个算法
    if (arr[mid] < key)
      start = mid + 1;
    else if (arr[mid] > key)
      end = mid - 1;
    else {  // 最后检测相等是因为多数搜索情况不是大于就是小于
      ret = mid;
      break;
    }
  }
  return ret;  // 单一出口
}
```

??? note
     `>> 1` 比 `/2` 速度快一些

注意，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做 $1$ ，不满足看做 $0$ ，至少对于这个条件的这一维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。

如果我们要求满足某种条件的最大值的最小可能情况（最大值最小化）呢？首先的想法是从小到大枚举这个作为答案的「最大值」，然后去判断是否合法。要是这个答案是单调的就好了，那样就可以使用二分搜索法来更快地找到答案。

要想使用二分搜索法来解这种「最大值最小化」的题目，需要满足以下三个条件：

1.  答案在一个固定区间内；
2.  可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；
3.  可行解对于区间满足一定的单调性。换言之，如果 $x$ 是符合条件的，那么有 $x + 1$ 或者 $x - 1$ 也符合条件。（这样下来就满足了上面提到的单调性）

当然，最小值最大化是同理的。

二分法把一个寻找极值的问题转化成一个判定的问题（用二分搜索来找这个极值）。类比枚举法，我们当时是枚举答案的可能情况，现在由于单调性，我们不再需要一个个枚举，利用二分的思路，就可以用更优的方法解决「最大值最小」、「最小值最大」。这种解法也成为是「二分答案」，常见于解题报告中。

### STL 的二分查找

补充一个小知识点，对于一个有序的 array 你可以使用 `std::lower_bound()` 来找到第一个大于等于你的值的数， `std::upper_bound()` 来找到第一个大于你的值的数。

请注意，必须是有序数组，否则答案是错误的。

关于具体使用方法，请参见 [STL 页面](../lang/csl/index.md) 。

### 二分答案

解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。如果我们把这里的枚举换成二分，就变成了“二分答案”。

来看一看一道例题 [Luogu P1873 砍树](https://www.luogu.org/problemnew/show/P1873) ，我们可以在 1 到 1000000000（10 亿）中枚举答案，但是这种朴素写法肯定拿不到满分，因为从 1 跑到 10 亿太耗时间。我们可以对答案进行 1 到 10 亿的二分，其中，每次都对其进行检查可行性（一般都是使用贪心法）。 **这就是二分答案。** 

下面就是例题的参考答案。

```cpp
int a[1000005];
int n, m;
bool check(int k) {  //检查可行性，k为锯片高度
  long long sum = 0;
  for (int i = 1; i <= n; i++)       //检查每一棵树
    if (a[i] > k)                    //如果树高于锯片高度
      sum += (long long)(a[i] - k);  //累加树木长度
  return sum >= m;                   //如果满足最少长度代表可行
}
int find() {
  int l = 1, r = 1000000001;  //因为是左闭右开的，所以10亿要加1
  while (l + 1 < r) {         //如果两点不相邻
    int mid = (l + r) / 2;    //取中间值
    if (check(mid))           //如果可行
      l = mid;                //升高锯片高度
    else
      r = mid;  //否则降低锯片高度
  }
  return l;  //返回左边值
}
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i];
  cout << find();
  return 0;
}
```

看完了上面的代码，你肯定会有两个疑问：

1.  为何搜索区间是左闭右开的？

    因为搜到最后，会这样（以合法的最大值为例）：

    /home/llj/Desktop/OI-wiki-master/docs/basic//home/llj/Desktop/OI-wiki-master/docs/basic/![](./images/binary-final-1.png)

    然后会

    /home/llj/Desktop/OI-wiki-master/docs/basic//home/llj/Desktop/OI-wiki-master/docs/basic/![](./images/binary-final-2.png)

    合法的最小值恰恰相反。

2.  为何返回左边值？

    如上图

## 三分法

```cpp
lmid = left + (right - left >> 1);
rmid = lmid + (right - lmid >> 1);  // 对右侧区间取半
if (cal(lmid) > cal(rmid))
  right = rmid;
else
  left = lmid;
```

三分法可以用来查找凸函数的最大（小）值。

画一下图好理解一些（图待补）

-   如果 `lmid` 和 `rmid` 在最大（小）值的同一侧：
    那么由于单调性，一定是二者中较大（小）的那个离最值近一些，较远的那个点对应的区间不可能包含最值，所以可以舍弃。
-   如果在两侧：
    由于最值在二者中间，我们舍弃两侧的一个区间后，也不会影响最值，所以可以舍弃。

## 分数规划

分数规划是这样一类问题，每个物品有两个属性 $c_i$ ， $d_i$ ，要求通过某种方式选出若干个，使得 $\frac{\sum{c_i}}{\sum{d_i}}$ 最大或最小。

经典的例子有 最优比率环、最优比率生成树 等等。

分数规划可以用二分法来解决，详情参见 [分数规划](../misc/frac-programming.md) 页面。

# index
介绍一些基础算法，为之后的进阶内容做铺垫。

一方面，这些内容可以让初学者对 OI 的一些思想有初步的认识；另一方面，其中的很多算法还会在以后的进阶内容中得到运用。

# greedy
贪心算法顾名思义就是用计算机来模拟一个“贪心”的人做出决策的过程。

这个人每一步行动总是按某种指标选取最优的操作，他总是 **只看眼前，并不考虑以后可能造成的影响** 。

可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。

## 常见做法

在提高组难度以下的题目中，最常见的贪心有两种。一种是：「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）处理」。另一种是：「我们每次都取 XXX 中最大/小的东西，并更新 XXX」，有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护。

为啥分成两种？你可以发现，一种是离线的，一种是在线的。

## 证明方法

以下套路请按照题目自行斟酌，一般情况下一道题只会用到其中的一种方法来证明。

1.  运用反证法，如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以发现目前的解已经是最优解了。
2.  运用归纳法，先手算得出边界情况（例如 $n = 1$ ）的最优解 $F_1$ ，然后再证明：对于每个 $n$ ， $F_{n+1}$ 都可以由 $F_{n}$ 推导出结果。

## 排序法

用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。

有些题的排序方法非常显然，如 [「USACO1.3」修理牛棚 Barn Repair](https://www.luogu.org/problemnew/show/P1209) 就是将输入数组差分后排序模拟求值。

然而有些时候很难直接一下子看出排序方法，比如 [NOIP 2012 国王游戏](https://vijos.org/p/1779) 就很容易凭直觉而错误地以 $a$ 或 $b$ 为关键字排序，过样例之后提交就发现 WA 了 QAQ。一个常见办法就是尝试交换数组相邻的两个元素来 **推导** 出正确的排序方法。我们假设这题输入的俩个数用一个结构体来保存

```cpp
struct {
  int a, b;
} v[n];
```

用 $m$ 表示 $i$ 前面所有的 $a$ 的乘积，那么第 $i$ 个大臣得到的奖赏就是

$$
\frac{m} {v[i].b}
$$

第 $i + 1$ 个大臣得到的奖赏就是

$$
\frac{m \cdot v[i].a} {v[i + 1].b}
$$

如果我们交换第 $i$ 个大臣与第 $i + 1$ 个大臣的位置，那么第 $i + 1$ 个大臣得到的奖赏就是

$$
\frac{m} {v[i + 1].b}
$$

第 $i + 1$ 个大臣得到的奖励就是

$$
\frac{m \cdot v[i + 1].a} {v[i].b}
$$

如果交换前更优当且仅当

$$
\max (\frac{m} {v[i].b}, \frac{m \times v[i].a} {v[i + 1].b})  < \max (\frac{m} {v[i + 1].b}, \frac{m \times v[i + 1].a} {v[i].b})
$$

提取出相同的 $m$ 并约分得到

$$
\max(\frac{1} {v[i].b}, \frac{v[i].a} {v[i + 1].b}) < \max(\frac{1} {v[i + 1].b}, \frac{v[i + 1].a} {v[i].b})
$$

然后分式化成整式得到

$$
\max(v[i + 1].b, v[i].a \times v[i].b) < \max(v[i].b, v[i + 1].a \times v[i + 1].b)
$$

于是我们就成功得到排序函数了！

```cpp
struct uv {
  int a, b;
  bool operator<(const uv &x) const {
    return max(x.b, a * b) < max(b, x.a * x.b);
  }
};
```

如果看懂了就可以尝试下一道类似的题： [Luogu P2123 皇后游戏](https://www.luogu.org/problemnew/show/P2123) 

## 后悔法

??? note " 例题[「USACO09OPEN」工作调度 Work Scheduling](https://www.luogu.org/problemnew/show/P2949)"

贪心思想：

-    **1** . 先假设每一项工作都做，将各项工作按截止时间排序后入队。
-    **2** . 在判断第 i 项工作做与不做时，若其截至时间符合条件，则将其与队中报酬最小的元素比较，若第 i 项工作报酬较高（后悔），则 ans+=a[i].p-q.top()。

     **PS** ：用优先队列（小根堆）来维护队首元素最小。

### 代码

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
struct f {
  long long d;
  long long x;
} a[100005];
bool cmp(f A, f B) { return A.d < B.d; }
priority_queue<long long, vector<long long>, greater<long long> > q;
int main() {
  long long n, i, j;
  cin >> n;
  for (i = 1; i <= n; i++) {
    scanf("%d%d", &a[i].d, &a[i].x);
  }
  sort(a + 1, a + n + 1, cmp);
  long long ans = 0;
  for (i = 1; i <= n; i++) {
    if (a[i].d <= q.size()) {
      if (q.top() < a[i].x) {
        ans += a[i].x - q.top();
        q.pop();
        q.push(a[i].x);
      }
    } else {
      ans += a[i].x;
      q.push(a[i].x);
    }
  }
  cout << ans << endl;
  return 0;
}
```

# use-of-sort
借助排序，我们可以降低求解问题所需要的时间复杂度。

考虑一个数列，你需要检查其中是否有元素相等。

一个朴素的做法是检查每一个数对，并判断这一对数是否相等。时间复杂度是 $O(n^2)$ 。

我们不妨先对这一列数排序，之后不难发现：如果有相等的两个数，它们一定在新数列中处于相邻的位置上。这时，只需要 $O(n)$ 地扫一遍新数列了。总的时间复杂度是排序的复杂度（ $O(n\log n)$ ）。

排序也是 [二分查找](./binary.md) 所要做的预处理工作。在排序后使用二分查找，我们可以在 $O(\log n)$ 的时间内在序列中查找指定的元素。

# sort-intro
 **排序算法多种多样** ，性质也大多不同。

## 稳定性

稳定性是指相等的元素经过排序之后相对顺序是否发生了改变。

基数排序、计数排序、插入排序、冒泡排序、归并排序是稳定排序。

选择排序、堆排序、快速排序不是稳定排序。

## 时间复杂度

时间复杂度用来衡量一个算法的运行时间和输入规模的关系，类似的有空间复杂度，用来描述算法的空间消耗的规模。

简单计算复杂度的方法一般是统计“简单操作”的执行次数，有时候也可以直接数循环的层数来近似估计。

时间复杂度分为最坏时间复杂度、平均时间复杂度、最好时间复杂度等等。OI 竞赛中要考虑的一般是最坏时间复杂度，因为它代表的是算法运行水平的下界，在评测中不会出现更差的结果了。

基于比较的排序算法的时间复杂度下限是 $O(n\log n)$ 的。

当然也有不是 $O(n\log n)$ 的，计数排序的时间复杂度是 $O(n+w)$ ，其中 $w$ 代表输入数据的值域大小。

当待排序的关键码序列基本有序时，插入排序最快。

# insertion-sort
插入排序将数列划分为“已排序的”和“未排序的”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。

插入排序的最坏情况时间复杂度和平均情况时间复杂度都为 $O(n^2)$ ，但其在数列几乎有序时效率很高。

插入排序是一个稳定排序。

伪代码：

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \\
2 & \textbf{Output. } A\text{ will be sorted in nondecreasing order stably.} \\
3 & \textbf{Method. }  \\
4 & \textbf{for } i\gets 2\textbf{ to }n\\
5 & \qquad key\gets A[i]\\
6 & \qquad j\gets i-1\\
7 & \qquad\textbf{while }j>0\textbf{ and }A[j]>key\\
8 & \qquad\qquad A[j + 1]\gets A[j]\\
9 & \qquad\qquad j\gets j - 1\\
10 & \qquad A[j + 1]\gets key
\end{array}
$$

C++ 代码：

```cpp
void insertion_sort(int* a, int n) {
  //对 a[1],a[2],...,a[n] 进行插入排序
  for (int i = 2; i <= n; ++i) {
    int key = a[i];
    int j = i - 1;
    while (j > 0 && a[j] > key) {
      a[j + 1] = a[j];
      --j;
    }
    a[j + 1] = key;
  }
}
```

# divide-and-conquer
author: fudonglai, AngelKitty

首先简单阐述一下递归，分治算法，动态规划，贪心算法这几个东西的区别和联系，心里有个印象就好。

递归是一种编程技巧，一种解决问题的思维方式；分治算法和动态规划很大程度上是递归思想基础上的（虽然实现动态规划大都不是递归了，但是我们要注重过程和思想），解决更具体问题的两类算法思想；贪心算法是动态规划算法的一个子集，可以更高效解决一部分更特殊的问题。

分治算法将在这节讲解，以最经典的归并排序为例，它把待排序数组不断二分为规模更小的子问题处理，这就是“分而治之”这个词的由来。显然，排序问题分解出的子问题是不重复的，如果有的问题分解后的子问题有重复的（重叠子问题性质），那么这就交给动态规划算法去解决！

## 递归详解

介绍分治之前，首先要弄清楚递归这个概念。

递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的。递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。

以下会举例说明我对递归的一点理解， **如果你不想看下去了，请记住这几个问题怎么回答：** 

1.  如何给一堆数字排序？答：分成两半，先排左半边再排右半边，最后合并就行了，至于怎么排左边和右边，请重新阅读这句话。
2.  孙悟空身上有多少根毛？答：一根毛加剩下的毛。
3.  你今年几岁？答：去年的岁数加一岁，1999 年我出生。

递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。

```cpp
int func(传入数值) {
  if (终止条件) return 最小子问题解;
  return func(缩小规模);
}
```

其实仔细想想， **递归运用最成功的是什么？我认为是数学归纳法。** 我们高中都学过数学归纳法，使用场景大概是：我们推不出来某个求和公式，但是我们试了几个比较小的数，似乎发现了一点规律，然后猜想了一个公式，看起来应该是正确答案。但是数学是很严谨的，你哪怕穷举了一万个数都是正确的，但是第一万零一个数正确吗？这就要数学归纳法发挥神威了，可以假设我们猜想的这个公式在第 k 个数时成立，如果证明在第 k + 1 时也成立，那么我们猜想的这个公式就是正确的。

那么数学归纳法和递归有什么联系？我们刚才说了，递归代码必须要有结束条件，如果没有的话就会进入无穷无尽的自我调用，直到内存耗尽。而数学证明的难度在于，你可以尝试有穷种情况，但是难以将你的结论延伸到无穷大。这里就可以看出联系了——无穷。

递归代码的精髓在于调用自身去解决规模更小的子问题，直到到达结束条件；而数学归纳法之所以有用，就在于不断把我们的猜测向上加一，扩大结论的规模，没有结束条件，从而把结论延伸到无穷无尽，也就完成了猜测正确性的证明。

### 为什么要写递归

首先为了训练逆向思考的能力。递推的思维是正常人的思维，总是看着眼前的问题思考对策，解决问题是将来时；递归的思维，逼迫我们倒着思考，看到问题的尽头，把解决问题的过程看做过去时。

第二，练习分析问题的结构，当问题可以被分解成相同结构的小问题时，你能敏锐发现这个特点，进而高效解决问题。

第三，跳出细节，从整体上看问题。再说说归并排序，其实可以不用递归来划分左右区域的，但是代价就是代码极其难以理解，大概看一下代码（归并排序在后面讲，这里大致看懂意思就行，体会递归的妙处）：

```java
void sort(Comparable[] a){
    int N = a.length;
    // 这么复杂，是对排序的不尊重。我拒绝研究这样的代码。
    for (int sz = 1; sz < N; sz = sz + sz)
        for (int lo = 0; lo < N - sz; lo += sz + sz)
            merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
}

/* 我还是选择递归，简单，漂亮 */
void sort(Comparable[] a, int lo, int hi) {
    if (lo >= hi) return;
    int mid = lo + (hi - lo) / 2;
    sort(a, lo, mid);
    sort(a, mid + 1, hi);
    merge(a, lo, mid, hi);
}
```

看起来简洁漂亮是一方面，关键是 **可解释性很强** ：把左半边排序，把右半边排序，最后合并两边。而非递归版本看起来不知所云，充斥着各种难以理解的边界计算细节，特别容易出 bug 且难以调试，人生苦短，我更倾向于递归版本。

显然有时候递归处理是高效的，比如归并排序， **有时候是低效的** ，比如数孙悟空身上的毛，因为堆栈会消耗额外空间，而简单的递推不会消耗空间。比如这个例子，给一个链表头，计算它的长度：

```java
/* 典型的递推遍历框架 */
public int size(Node head) {
    int size = 0;
    for (Node p = head; p != null; p = p.next) size++;
    return size;
}
/* 我偏要递归，万物皆递归 */
public int size(Node head) {
    if (head == null) return 0;
    return size(head.next) + 1;
}
```

### 写递归的技巧

我的一点心得是： **明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。** 千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。

先举个最简单的例子：遍历二叉树。

```cpp
void traverse(TreeNode* root) {
  if (root == nullptr) return;
  traverse(root->left);
  traverse(root->right);
}
```

这几行代码就足以扫荡任何一棵二叉树了。我想说的是，对于递归函数 `traverse(root)` ，我们只要相信：给它一个根节点 `root` ，它就能遍历这棵树，因为写这个函数不就是为了这个目的吗？所以我们只需要把这个节点的左右节点再甩给这个函数就行了，因为我相信它能完成任务的。那么遍历一棵 N 叉数呢？太简单了好吧，和二叉树一模一样啊。

```cpp
void traverse(TreeNode* root) {
  if (root == nullptr) return;
  for (child : root->children) traverse(child);
}
```

至于遍历的什么前、中、后序，那都是显而易见的，对于 N 叉树，显然没有中序遍历。

以下 **详解 LeetCode 的一道题来说明** ：给一棵二叉树，和一个目标值，节点上的值有正有负，返回树中和等于目标值的路径条数，让你编写 pathSum 函数：

    /* 来源于 LeetCode PathSum III： https://leetcode.com/problems/path-sum-iii/ */
    root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

          10
         /  \
        5   -3
       / \    \
      3   2   11
     / \   \
    3  -2   1

    Return 3. The paths that sum to 8 are:

    1.  5 -> 3
    2.  5 -> 2 -> 1
    3. -3 -> 11

```cpp
/* 看不懂没关系，底下有更详细的分析版本，这里突出体现递归的简洁优美 */
int pathSum(TreeNode root, int sum) {
  if (root == null) return 0;
  return count(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
}
int count(TreeNode node, int sum) {
  if (node == null) return 0;
  return (node.val == sum) + count(node.left, sum - node.val) +
         count(node.right, sum - node.val);
}
```

题目看起来很复杂吧，不过代码却极其简洁，这就是递归的魅力。我来简单总结这个问题的 **解决过程** ：

首先明确，递归求解树的问题必然是要遍历整棵树的，所以 **二叉树的遍历框架** （分别对左右孩子递归调用函数本身）必然要出现在主函数 pathSum 中。那么对于每个节点，它们应该干什么呢？它们应该看看，自己和脚底下的小弟们包含多少条符合条件的路径。好了，这道题就结束了。

按照前面说的技巧，根据刚才的分析来定义清楚每个递归函数应该做的事：

PathSum 函数：给它一个节点和一个目标值，它返回以这个节点为根的树中，和为目标值的路径总数。

count 函数：给它一个节点和一个目标值，它返回以这个节点为根的树中，能凑出几个以该节点为路径开头，和为目标值的路径总数。

```cpp
/* 有了以上铺垫，详细注释一下代码 */
int pathSum(TreeNode root, int sum) {
  if (root == null) return 0;
  int pathImLeading = count(root, sum);  // 自己为开头的路径数
  int leftPathSum = pathSum(root.left, sum);  // 左边路径总数（相信他能算出来）
  int rightPathSum =
      pathSum(root.right, sum);  // 右边路径总数（相信他能算出来）
  return leftPathSum + rightPathSum + pathImLeading;
}
int count(TreeNode node, int sum) {
  if (node == null) return 0;
  // 我自己能不能独当一面，作为一条单独的路径呢？
  int isMe = (node.val == sum) ? 1 : 0;
  // 左边的小老弟，你那边能凑几个 sum - node.val 呀？
  int leftBrother = count(node.left, sum - node.val);
  // 右边的小老弟，你那边能凑几个 sum - node.val 呀？
  int rightBrother = count(node.right, sum - node.val);
  return isMe + leftBrother + rightBrother;  // 我这能凑这么多个
}
```

还是那句话， **明白每个函数能做的事，并相信它们能够完成。** 

总结下，PathSum 函数提供的二叉树遍历框架，在遍历中对每个节点调用 count 函数，看出先序遍历了吗（这道题什么序都是一样的）；count 函数也是一个二叉树遍历，用于寻找以该节点开头的目标值路径。好好体会吧！

LeetCode 有递归专题练习， [点这里去做题](https://leetcode.com/explore/learn/card/recursion-i/) 

### 递归优化

比较 naive 的递归实现可能递归次数太多，容易超时。

怎么优化呢？详见 [搜索优化](../search/opt.md) 和 [记忆化搜索](../dp/memo.md) 。

## 分治算法

 **归并排序** ，典型的分治算法；分治，典型的递归结构。

分治算法可以分三步走：分解 -> 解决 -> 合并

1.  分解原问题为结构相同的子问题。
2.  分解到某个容易求解的边界之后，进行递归求解。
3.  将子问题的解合并成原问题的解。

归并排序，我们就叫这个函数 `merge_sort` 吧，按照我们上面说的，要明确该函数的职责，即 **对传入的一个数组排序** 。OK，那么这个问题能不能分解呢？当然可以！给一个数组排序，不就等于给该数组的两半分别排序，然后合并就完事了。

```cpp
void merge_sort(一个数组) {
  if (可以很容易处理) return;
  merge_sort(左半个数组);
  merge_sort(右半个数组);
  merge(左半个数组, 右半个数组);
}
```

好了，这个算法也就这样了，完全没有任何难度。记住之前说的，相信函数的能力，传给它半个数组，那么这半个数组就已经被排好了。而且你会发现这不就是个二叉树遍历模板吗？为什么是后序遍历？因为我们分治算法的套路是 **分解 -> 解决（触底）-> 合并（回溯）** 啊，先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于 `merge` 函数，参考两个有序链表的合并，简直一模一样。

LeetCode 上有分治算法的专项练习， [点这里去做题](https://leetcode.com/tag/divide-and-conquer/) 

# quick-sort
## 算法

快速排序是 [分治](./divide-and-conquer.md) 地来将一个数组排序。

快速排序分为三个过程：

1.  将数列划分为两部分（不是直接分，要求保证相对大小关系）
2.  递归到两个子序列中分别进行快速排序
3.  不用合并，因为此时数列已经完全有序

和归并排序不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。

第三步中的序列已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。

具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。

怎么操作呢？为了保证平均时间复杂度，一般是随机选择一个数 m 来当做两个子数列的分界。

之后，维护一前一后两个指针 p 和 q，依次考虑当前的数是否放在了应该放的位置（前还是后），当前位置放对了之后，再移动指针继续处理，直到两个指针相遇。

如果当前的数没放对呢？比如说如果后面的指针 q 遇到了一个比 m 小的数，那么可以交换 p 和 q 位置上的数，再把 p 向后移一位。

其实，快速排序没有指定应如何具体实现第一步，不论是选择 m 的过程还是划分的过程，都不是只有一种实现方法。

一般我们说的快速排序的时间复杂度是平均为 $O(n\log n)$ ，最坏是 $O(n^2)$ ，实践中几乎不可能达到最坏情况。且因为快速排序的内存访问遵循局部性原理，多数情况下快速排序的表现大幅优于堆排序等其他复杂度为 $O(n \log n)$ 的排序算法。

其实，在选择 m 的过程中使用 [Median of Medians](https://en.wikipedia.org/wiki/Median_of_medians) 算法，就可以保证最坏时间复杂度为 $O(n\log n)$ ，但是由于其过于复杂，实践中一般不使用。

## 线性找第 k 大的数

找第 k 大的数（K-th order statistic），最简单的方法是先排序，然后直接找到第 k 大的位置的元素。这样做的时间复杂度是 $O(n\log n)​$ ，对于这个问题来说很不划算。事实上，我们有时间复杂度 $O(n)​$ 的解法。

考虑快速排序的划分过程，在快速排序的“划分”结束后，数列 $A_{p} \cdots A_{r}​$ 被分成了 $A_{p} \cdots A_{q}​$ 和 $A_{q+1} \cdots A_{r}​$ ，此时可以按照左边元素的个数（ $q - p + 1​$ ）和 k 的大小关系来判断是只在左边还是只在右边递归地求解。

可以证明，在期望意义下，程序的时间复杂度为 $O(n)$ 。

### 参考

 <https://stackoverflow.com/questions/22339240/what-algorithms-are-used-in-c11-stdsort-in-different-stl-implementations> 

 <https://en.cppreference.com/w/cpp/algorithm/sort> 

 <http://irootlee.com/juicer_locality/> 

# bubble-sort
冒泡排序是一种稳定的排序方法。

以升序为例，冒泡排序每次检查相邻两个元素，如果前面的元素大于后面的元素，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。

经过 $i$ 次扫描后，数列的末尾 $i$ 项必然是最大的 $i$ 项，因此最多需要扫描 $n-1$ 遍数组就能完成排序。

在序列完全有序时，该算法只需遍历一遍数组，不用执行任何交换操作，时间复杂度为 $O(n)$ 。在最坏情况下，冒泡排序要执行 $\frac{(n-1)n}{2}$ 次交换操作，时间复杂度为 $O(n^2)$ 。在平均情况下，冒泡排序的时间复杂度也是 $O(n^2)$ 。

伪代码：

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \\
2 & \textbf{Output. } A\text{ will be sorted in nondecreasing order stably.} \\
3 & \textbf{Method. }  \\
4 & flag\gets True\\
5 & \textbf{while }flag\\
6 & \qquad flag\gets False\\
7 & \qquad\textbf{for }i\gets1\textbf{ to }n-1\\
8 & \qquad\qquad\textbf{if }A[i]>A[i + 1]\\
9 & \qquad\qquad\qquad flag\gets True\\
10 & \qquad\qquad\qquad \text{Swap } A[i]\text{ and }A[i + 1]
\end{array}
$$

C++ 代码：

```cpp
// 假设数组的大小是n+1，冒泡排序从数组下标1开始
void bubble_sort(int *a, int n) {
  bool flag = true;
  while (flag) {
    flag = false;
    for (int i = 1; i < n; ++i) {
      if (a[i] > a[i + 1]) {
        flag = true;
        int t = a[i];
        a[i] = a[i + 1];
        a[i + 1] = t;
      }
    }
  }
}
```

# ds
# bst
## 二叉搜索树简介

二叉搜索树是一种二叉树的树形数据结构，其定义如下：

1.  空树是二叉搜索树。

2.  若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值。

3.  若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。

4.  二叉搜索树的左右子树均为二叉搜索树。

二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。对于一个有 $n$ 个结点的二叉搜索树中，这些操作的最优时间复杂度为 $O(\log n)$ ，最坏为 $O(n)$ 。随机构造这样一棵二叉搜索树的期望高度为 $O(\log n)$ 。

## 基本操作

在接下来的代码块中，我们约定 $n$ 为结点个数， $h$ 为高度， `val[x]` 为结点 $x$ 处存的数值， `cnt[x]` 为结点 $x$ 存的值所出现的次数， `lc[x]` 和 `rc[x]` 分别为结点 $x$ 的左子结点和右子结点。

### 遍历二叉搜索树

由二叉搜索树的递归定义可得，二叉搜索树的中序遍历权值的序列为非降的序列。时间复杂度为 $O(n)$ 。

遍历一棵二叉搜索树的代码如下：

```cpp
void print(int o) {
  //遍历以 o 为根节点的二叉搜索树
  if (!o) return;  //遇到空树，返回
  print(lc[o]);    //递归遍历左子树
  for (int i = 1; i <= cnt[o]; i++) printf("%d\n", val[o]);  //输出根节点信息
  print(rc[o]);  //递归遍历右子树
}
```

### 查找最小/最大值

由二叉搜索树的性质可得，二叉搜索树上的最小值为二叉搜索树左链的顶点，最大值为二叉搜索树右链的顶点。时间复杂度为 $O(h)$ 。

findmin 和 findmax 函数分别返回最小值和最大值所对应的结点编号 $o$ ，用 `val[o]` 可以获得相应的最小/最大值。

```cpp
int findmin(int o) {
  if (!lc[o]) return o;
  return findmin(lc[o]);  //一直向左儿子跳
}
int findmax(int o) {
  if (!rc[o]) return o;
  return findmax(rc[o]);  //一直向右儿子跳
}
```

### 插入一个元素

定义 `insert(o,v)` 为在以 $o$ 为根节点的二叉搜索树中插入一个值为 $v$ 的新节点。

分类讨论如下：

若 $o$ 为空，直接返回一个值为 $v$ 的新节点。

若 $o$ 的权值等于 $v$ ，该节点的附加域该值出现的次数自增 $1$ 。

若 $o$ 的权值大于 $v$ ，在 $o$ 的左子树中插入权值为 $v$ 的节点。

若 $o$ 的权值小于 $v$ ，在 $o$ 的右子树中插入权值为 $v$ 的节点。

时间复杂度为 $O(h)$ 。

```cpp
void insert(int& o, int v) {
  if (!o) {
    val[o = ++sum] = v;
    cnt[o] = siz[o] = 1;
    return;
  }
  siz[o]++;
  if (val[o] == v) {
    cnt[o]++;
    return;
  }
  if (val[o] > v) insert(lc[o], v);
  if (val[o] < v) insert(rc[o], v);
}
```

### 删除一个元素

定义 `del(o,v)` 为在以 $o$ 为根节点的二叉搜索树中删除一个值为 $v$ 的节点。

先在二叉搜索树中找到权值为 $v$ 的节点，分类讨论如下：

若该节点的附加 $cnt$ 大于 $1$ ，只需要减少 $cnt$ 。

若该节点的附加 $cnt$ 为 $1$ ：

若 $o$ 为叶子节点，直接删除该节点即可。

若 $o$ 为链节点，即只有一个儿子的节点，返回这个儿子。

若 $o$ 有两个非空子节点，一般是用它左子树的最大值或右子树的最小值代替它，然后将它删除。

时间复杂度 $O(h)$ 。

```cpp
int deletemin(int& o) {
  if (!lc[o]) {
    int u = o;
    o = rc[o];
    return u;
  } else {
    int u = deletemin(lc[o]);
    siz[o] -= cnt[u];
    return u;
  }
}
void del(int& o, int v) {
  // 注意 o 有可能会被修改
  siz[o]--;
  if (val[o] == v) {
    if (cnt[o] > 1) {
      cnt[o]--;
      return;
    }
    if (lc[o] && rc[o]) o = deletemin(rc[o]);
    // 这里以找右子树的最小值为例
    else
      o = lc[o] + rc[o];
    return;
  }
  if (val[o] > v) del(lc[o], v);
  if (val[o] < v) del(rc[o], v);
}
```

### 求元素的排名

排名定义为将数组元素排序后第一个相同元素之前的数的个数 $+1$ 。

维护每个根节点的子树大小 $siz$ 。查找一个元素的排名，首先从根节点跳到这个元素，若向右跳，答案加上左儿子节点个数加当前节点重复的数个数，最后答案加上终点的左儿子子树大小 $+1$ 。

时间复杂度 $O(h)$ 。

```cpp
int queryrnk(int o, int v) {
  if (val[o] == v) return siz[lc[o]] + 1;
  if (val[o] > v) return queryrnk(lc[o], v);
  if (val[o] < v) return queryrnk(rc[o], v) + siz[lc[o]] + cnt[o];
}
```

### 查找排名为 k 的元素

在一棵子树中，根节点的排名取决于其左子树的大小。

若其左子树的大小大于等于 $k$ ，则该元素在左子树中；

若其左子树的大小在区间 $[k-cnt,k-1]$ ( $cnt$ 为当前结点的值的出现次数）中，则该元素为子树的根节点；

若其左子树的大小小于 $k-cnt$ ，则该元素在右子树中。

时间复杂度 $O(h)$ 。

```cpp
int querykth(int o, int k) {
  if (siz[lc[o]] >= k) return querykth(lc[o], k);
  if (siz[lc[o]] < k - cnt[o])
    return querykth(rc[o], k - siz[lc[o]] - cnt[o] + 1);
  return val[o];
  // 如要找排名为 k 的元素所对应的结点，直接 return o 即可
}
```

# kdt
author: hsfzLZH1, Ir1d

k-D Tree(KDT , k-Dimension Tree) 是一种可以 **高效处理 $k$ 维空间信息** 的数据结构。

在结点数 $n$ 远大于 $2^k$ 时，应用 k-D Tree 的时间效率很好。

在算法竞赛的题目中，一般有 $k=2$ 。在本页面分析时间复杂度时，将认为 $k$ 是常数。

## 建树

k-D Tree 具有二叉搜索树的形态，二叉搜索树上的每个结点都对应 $k$ 维空间内的一个点。其每个子树中的点都在一个 $k$ 维的超长方体内，这个超长方体内的所有点也都在这个子树中。

假设我们已经知道了 $k$ 维空间内的 $n$ 个不同的点的坐标，要将其构建成一棵 k-D Tree，步骤如下：

1.  若当前超长方体中只有一个点，返回这个点。

2.  选择一个维度，将当前超长方体按照这个维度分成两个超长方体。

3.  选择切割点：在选择的维度上选择一个点，这一维度上的值小于这个点的归入一个超长方体（左子树），其余的归入另一个超长方体（右子树）。

4.  将选择的点作为这棵子树的根节点，递归对分出的两个超长方体构建左右子树，维护子树的信息。

为了方便理解，我们举一个 $k=2$ 时的例子。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/kdt1.jpg)

其构建出 k-D Tree 的形态可能是这样的：

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/kdt2.jpg)

其中树上每个结点上的坐标是选择的分割点的坐标，非叶子结点旁的 $x$ 或 $y$ 是选择的切割维度。

这样的复杂度无法保证。对于 $2,3$ 两步，我们提出两个优化：

1.  选择的维度要满足其内部点的分布的差异度最大，即每次选择的切割维度是方差最大的维度。

2.  每次在维度上选择切割点时选择该维度上的 **中位数** ，这样可以保证每次分成的左右子树大小尽量相等。

可以发现，使用优化 $2$ 后，构建出的 k-D Tree 的树高最多为 $O(\log n)$ 。

现在，构建 k-D Tree 时间复杂度的瓶颈在于快速选出一个维度上的中位数，并将在该维度上的值小于该中位数的置于中位数的左边，其余置于右边。如果每次都使用 `sort` 函数对该维度进行排序，时间复杂度是 $O(n\log^2 n)$ 的。事实上，单次找出 $n$ 个元素中的中位数并将中位数置于排序后正确的位置的复杂度可以达到 $O(n)$ 。

我们来回顾一下快速排序的思想。每次我们选出一个数，将小于该数的置于该数的左边，大于该数的置于该数的右边，保证该数在排好序后正确的位置上，然后递归排序左侧和右侧的值。这样的期望复杂度是 $O(n\log n)$ 的。但是由于 k-D Tree 只要求要中位数在排序后正确的位置上，所以我们只需要递归排序包含中位数的 **一侧** 。可以证明，这样的期望复杂度是 $O(n)$ 的。在 `algorithm` 库中，有一个实现相同功能的函数 `nth_element()` ，要找到 `s[l]` 和 `s[r]` 之间的值按照排序规则 `cmp` 排序后在 `s[mid]` 位置上的值，并保证 `s[mid]` 左边的值小于 `s[mid]` ，右边的值大于 `s[mid]` ，只需写 `nth_element(s+l,s+mid,s+r+1,cmp)` 。

借助这种思想，构建 k-D Tree 时间复杂度是 $O(n\log n)$ 的。

## 插入/删除

如果维护的这个 $k$ 维点集是可变的，即可能会插入或删除一些点，此时 k-D Tree 的平衡性无法保证。由于 k-D Tree 的构造，不能支持旋转，类似与 FHQ Treap 的随机优先级也不能保证其复杂度，可以保证平衡性的手段只有类似于 [替罪羊树](./sgt.md) 的重构思想。

我们引入一个重构常数 $\alpha$ ，对于 k-D Tree 上的一个结点 $x$ ，若其有一个子树的结点数在以 $x$ 为根的子树的结点数中的占比大于 $\alpha$ ，则认为以 $x$ 为根的子树是不平衡的，需要重构。重构时，先遍历子树求出一个序列，然后用以上描述的方法建出一棵 k-D Tree，代替原来不平衡的子树。

在插入一个 $k$ 维点时，先根据记录的分割维度和分割点判断应该继续插入到左子树还是右子树，如果到达了空结点，新建一个结点代替这个空结点。成功插入结点后回溯插入的过程，维护结点的信息，如果发现当前的子树不平衡，则重构当前子树。

如果还有删除操作，则使用 **惰性删除** ，即删除一个结点时打上删除标记，而保留其在 k-D Tree 上的位置。如果这样写，当未删除的结点数在以 $x$ 为根的子树中的占比小于 $\alpha$ 时，同样认为这个子树是不平衡的，需要重构。

类似于替罪羊树，带重构的 k-D Tree 的树高仍然是 $O(\log n)$ 的。

## 邻域查询

???+note " 例题[luogu P1429 平面最近点对（加强版）](https://www.luogu.org/problem/P1429)"
    给定平面上的 $n$ 个点 $(x_i,y_i)$ ，找出平面上最近两个点对之间的 [欧几里得距离](../geometry/distance.md#_1) 。

     $2\le n\le 200000 , 0\le x_i,y_i\le 10^9$ 

首先建出关于这 $n$ 个点的 2-D Tree。

枚举每个结点，对于每个结点找到不等于该结点且距离最小的点，即可求出答案。每次暴力遍历 2-D Tree 上的每个结点的时间复杂度是 $O(n)$ 的，需要剪枝。我们可以维护一个子树中的所有结点在每一维上的坐标的最小值和最大值。假设当前已经找到的最近点对的距离是 $ans$ ，如果查询点到子树内所有点都包含在内的长方形的 **最近** 距离大于等于 $ans$ ，则在这个子树内一定没有答案，搜索时不进入这个子树。

此外，还可以使用一种启发式搜索的方法，即若一个结点的两个子树都有可能包含答案，先在与查询点距离最近的一个子树中搜索答案。可以认为， **查询点到子树对应的长方形的最近距离就是此题的估价函数** 。

 **注意：虽然以上使用的种种优化，但是使用 k-D Tree 单次查询最近点的时间复杂度最坏还是 $O(n)$ 的，但不失为一种优秀的骗分算法，使用时请注意。在这里对邻域查询的讲解仅限于加强对 k-D Tree 结构的认识。** 

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    #include <cstdlib>
    #include <cstring>
    using namespace std;
    const int maxn = 200010;
    int n, d[maxn], lc[maxn], rc[maxn];
    double ans = 2e18;
    struct node {
      double x, y;
    } s[maxn];
    double L[maxn], R[maxn], D[maxn], U[maxn];
    double dist(int a, int b) {
      return (s[a].x - s[b].x) * (s[a].x - s[b].x) +
             (s[a].y - s[b].y) * (s[a].y - s[b].y);
    }
    bool cmp1(node a, node b) { return a.x < b.x; }
    bool cmp2(node a, node b) { return a.y < b.y; }
    void maintain(int x) {
      L[x] = R[x] = s[x].x;
      D[x] = U[x] = s[x].y;
      if (lc[x])
        L[x] = min(L[x], L[lc[x]]), R[x] = max(R[x], R[lc[x]]),
        D[x] = min(D[x], D[lc[x]]), U[x] = max(U[x], U[lc[x]]);
      if (rc[x])
        L[x] = min(L[x], L[rc[x]]), R[x] = max(R[x], R[rc[x]]),
        D[x] = min(D[x], D[rc[x]]), U[x] = max(U[x], U[rc[x]]);
    }
    int build(int l, int r) {
      if (l >= r) return 0;
      int mid = (l + r) >> 1;
      double avx = 0, avy = 0, vax = 0, vay = 0;  // average variance
      for (int i = l; i <= r; i++) avx += s[i].x, avy += s[i].y;
      avx /= (double)(r - l + 1);
      avy /= (double)(r - l + 1);
      for (int i = l; i <= r; i++)
        vax += (s[i].x - avx) * (s[i].x - avx),
            vay += (s[i].y - avy) * (s[i].y - avy);
      if (vax >= vay)
        d[mid] = 1, nth_element(s + l, s + mid, s + r + 1, cmp1);
      else
        d[mid] = 2, nth_element(s + l, s + mid, s + r + 1, cmp2);
      lc[mid] = build(l, mid - 1), rc[mid] = build(mid + 1, r);
      maintain(mid);
      return mid;
    }
    double f(int a, int b) {
      double ret = 0;
      if (L[b] > s[a].x) ret += (L[b] - s[a].x) * (L[b] - s[a].x);
      if (R[b] < s[a].x) ret += (s[a].x - R[b]) * (s[a].x - R[b]);
      if (D[b] > s[a].y) ret += (D[b] - s[a].y) * (D[b] - s[a].y);
      if (U[b] < s[a].y) ret += (s[a].y - U[b]) * (s[a].y - U[b]);
      return ret;
    }
    void query(int l, int r, int x) {
      if (l > r) return;
      int mid = (l + r) >> 1;
      if (mid /home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!= x) ans = min(ans, dist(x, mid));
      if (l == r) return;
      double distl = f(x, lc[mid]), distr = f(x, rc[mid]);
      if (distl < ans && distr < ans) {
        if (distl < distr) {
          query(l, mid - 1, x);
          if (distr < ans) query(mid + 1, r, x);
        } else {
          query(mid + 1, r, x);
          if (distl < ans) query(l, mid - 1, x);
        }
      } else {
        if (distl < ans) query(l, mid - 1, x);
        if (distr < ans) query(mid + 1, r, x);
      }
    }
    int main() {
      scanf("%d", &n);
      for (int i = 1; i <= n; i++) scanf("%lf%lf", &s[i].x, &s[i].y);
      build(1, n);
      for (int i = 1; i <= n; i++) query(1, n, i);
      printf("%.4lf\n", sqrt(ans));
      return 0;
    }
    ```

???+note " 例题[「CQOI2016」K 远点对](https://loj.ac/problem/2043)"
    给定平面上的 $n$ 个点 $(x_i,y_i)$ ，求欧几里得距离下的第 $k$ 远无序点对之间的距离。

     $n\le 100000 , 1\le k\le 100 , 0\le x_i,y_i<2^{31}$ 

和上一道例题类似，从最近点对变成了 $k$ 近点对，估价函数改成了查询点到子树对应的长方形区域的最远距离。用一个小根堆来维护当前找到的前 $k$ 远点对之间的距离，如果当前找到的点对距离大于堆顶，则弹出堆顶并插入这个距离，同样的，使用堆顶的距离来剪枝。

由于题目中强调的是无序点对，即交换前后两点的顺序后仍是相同的点对，则每个有序点对会被计算两次，那么读入的 $k$ 要乘以 $2$ 。

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    using namespace std;
    #define int long long
    const int maxn = 100010;
    int n, k;
    priority_queue<int, vector<int>, greater<int> > q;
    struct node {
      int x, y;
    } s[maxn];
    bool cmp1(node a, node b) { return a.x < b.x; }
    bool cmp2(node a, node b) { return a.y < b.y; }
    int lc[maxn], rc[maxn], L[maxn], R[maxn], D[maxn], U[maxn];
    void maintain(int x) {
      L[x] = R[x] = s[x].x;
      D[x] = U[x] = s[x].y;
      if (lc[x])
        L[x] = min(L[x], L[lc[x]]), R[x] = max(R[x], R[lc[x]]),
        D[x] = min(D[x], D[lc[x]]), U[x] = max(U[x], U[lc[x]]);
      if (rc[x])
        L[x] = min(L[x], L[rc[x]]), R[x] = max(R[x], R[rc[x]]),
        D[x] = min(D[x], D[rc[x]]), U[x] = max(U[x], U[rc[x]]);
    }
    int build(int l, int r) {
      if (l > r) return 0;
      int mid = (l + r) >> 1;
      double av1 = 0, av2 = 0, va1 = 0, va2 = 0;  // average variance
      for (int i = l; i <= r; i++) av1 += s[i].x, av2 += s[i].y;
      av1 /= (r - l + 1);
      av2 /= (r - l + 1);
      for (int i = l; i <= r; i++)
        va1 += (av1 - s[i].x) * (av1 - s[i].x),
            va2 += (av2 - s[i].y) * (av2 - s[i].y);
      if (va1 > va2)
        nth_element(s + l, s + mid, s + r + 1, cmp1);
      else
        nth_element(s + l, s + mid, s + r + 1, cmp2);
      lc[mid] = build(l, mid - 1);
      rc[mid] = build(mid + 1, r);
      maintain(mid);
      return mid;
    }
    int sq(int x) { return x * x; }
    int dist(int a, int b) {
      return max(sq(s[a].x - L[b]), sq(s[a].x - R[b])) +
             max(sq(s[a].y - D[b]), sq(s[a].y - U[b]));
    }
    void query(int l, int r, int x) {
      if (l > r) return;
      int mid = (l + r) >> 1, t = sq(s[mid].x - s[x].x) + sq(s[mid].y - s[x].y);
      if (t > q.top()) q.pop(), q.push(t);
      int distl = dist(x, lc[mid]), distr = dist(x, rc[mid]);
      if (distl > q.top() && distr > q.top()) {
        if (distl > distr) {
          query(l, mid - 1, x);
          if (distr > q.top()) query(mid + 1, r, x);
        } else {
          query(mid + 1, r, x);
          if (distl > q.top()) query(l, mid - 1, x);
        }
      } else {
        if (distl > q.top()) query(l, mid - 1, x);
        if (distr > q.top()) query(mid + 1, r, x);
      }
    }
    main() {
      scanf("%lld%lld", &n, &k);
      k *= 2;
      for (int i = 1; i <= k; i++) q.push(0);
      for (int i = 1; i <= n; i++) scanf("%lld%lld", &s[i].x, &s[i].y);
      build(1, n);
      for (int i = 1; i <= n; i++) query(1, n, i);
      printf("%lld\n", q.top());
      return 0;
    }
    ```

## 高维空间上的操作

???+note " 例题[luogu P4148 简单题](https://www.luogu.org/problem/P4148)"
    在一个初始值全为 $0$ 的 $n\times n$ 的二维矩阵上，进行 $q$ 次操作，每次操作为以下两种之一：

    1.   `1 x y A` ：将坐标 $(x,y)$ 上的数加上 $A$ 。
    2.   `2 x1 y1 x2 y2` ：输出以 $(x1,y1)$ 为左下角， $(x2,y2)$ 为右上角的矩形内（包括矩形边界）的数字和。

    强制在线。内存限制 `20M` 。保证答案及所有过程量在 `int` 范围内。

     $1\le n\le 500000 , 1\le q\le 200000$ 

20M 的空间卡掉了所有树套树，强制在线卡掉了 CDQ 分治，只能使用 k-D Tree。

构建 2-D Tree，支持两种操作：添加一个 $2$ 维点；查询矩形区域内的所有点的权值和。可以使用 **带重构** 的 k-D Tree 实现。

在查询矩形区域内的所有点的权值和时，仍然需要记录子树内每一维度上的坐标的最大值和最小值。如果当前子树对应的矩形与所求矩形没有交点，则不继续搜索其子树；如果当前子树对应的矩形完全包含在所求矩形内，返回当前子树内所有点的权值和；否则，判断当前点是否在所求矩形内，更新答案并递归在左右子树中查找答案。

已经证明，如果在 $2-D$ 树上进行矩阵查询操作，已经被完全覆盖的子树不会继续查询，则单次查询时间复杂度是最优 $O(\log n)$ ，最坏 $O(\sqrt n)$ 的。将结论扩展到 $k$ 维的情况，则最坏时间复杂度是 $O(n^{1-\frac 1 k})$ 的。

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    using namespace std;
    const int maxn = 200010;
    int n, op, xl, xr, yl, yr, lstans;
    struct node {
      int x, y, v;
    } s[maxn];
    bool cmp1(int a, int b) { return s[a].x < s[b].x; }
    bool cmp2(int a, int b) { return s[a].y < s[b].y; }
    double a = 0.725;
    int rt, cur, d[maxn], lc[maxn], rc[maxn], L[maxn], R[maxn], D[maxn], U[maxn],
        siz[maxn], sum[maxn];
    int g[maxn], t;
    void print(int x) {
      if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!x) return;
      print(lc[x]);
      g[++t] = x;
      print(rc[x]);
    }
    void maintain(int x) {
      siz[x] = siz[lc[x]] + siz[rc[x]] + 1;
      sum[x] = sum[lc[x]] + sum[rc[x]] + s[x].v;
      L[x] = R[x] = s[x].x;
      D[x] = U[x] = s[x].y;
      if (lc[x])
        L[x] = min(L[x], L[lc[x]]), R[x] = max(R[x], R[lc[x]]),
        D[x] = min(D[x], D[lc[x]]), U[x] = max(U[x], U[lc[x]]);
      if (rc[x])
        L[x] = min(L[x], L[rc[x]]), R[x] = max(R[x], R[rc[x]]),
        D[x] = min(D[x], D[rc[x]]), U[x] = max(U[x], U[rc[x]]);
    }
    int build(int l, int r) {
      if (l > r) return 0;
      int mid = (l + r) >> 1;
      double av1 = 0, av2 = 0, va1 = 0, va2 = 0;
      for (int i = l; i <= r; i++) av1 += s[g[i]].x, av2 += s[g[i]].y;
      av1 /= (r - l + 1);
      av2 /= (r - l + 1);
      for (int i = l; i <= r; i++)
        va1 += (av1 - s[g[i]].x) * (av1 - s[g[i]].x),
            va2 += (av2 - s[g[i]].y) * (av2 - s[g[i]].y);
      if (va1 > va2)
        nth_element(g + l, g + mid, g + r + 1, cmp1), d[g[mid]] = 1;
      else
        nth_element(g + l, g + mid, g + r + 1, cmp2), d[g[mid]] = 2;
      lc[g[mid]] = build(l, mid - 1);
      rc[g[mid]] = build(mid + 1, r);
      maintain(g[mid]);
      return g[mid];
    }
    void rebuild(int& x) {
      t = 0;
      print(x);
      x = build(1, t);
    }
    bool bad(int x) { return a * siz[x] <= (double)max(siz[lc[x]], siz[rc[x]]); }
    void insert(int& x, int v) {
      if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!x) {
        x = v;
        maintain(x);
        return;
      }
      if (d[x] == 1) {
        if (s[v].x <= s[x].x)
          insert(lc[x], v);
        else
          insert(rc[x], v);
      } else {
        if (s[v].y <= s[x].y)
          insert(lc[x], v);
        else
          insert(rc[x], v);
      }
      maintain(x);
      if (bad(x)) rebuild(x);
    }
    int query(int x) {
      if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!x || xr < L[x] || xl > R[x] || yr < D[x] || yl > U[x]) return 0;
      if (xl <= L[x] && R[x] <= xr && yl <= D[x] && U[x] <= yr) return sum[x];
      int ret = 0;
      if (xl <= s[x].x && s[x].x <= xr && yl <= s[x].y && s[x].y <= yr)
        ret += s[x].v;
      return query(lc[x]) + query(rc[x]) + ret;
    }
    int main() {
      scanf("%d", &n);
      while (~scanf("%d", &op)) {
        if (op == 1) {
          cur++, scanf("%d%d%d", &s[cur].x, &s[cur].y, &s[cur].v);
          s[cur].x ^= lstans;
          s[cur].y ^= lstans;
          s[cur].v ^= lstans;
          insert(rt, cur);
        }
        if (op == 2) {
          scanf("%d%d%d%d", &xl, &yl, &xr, &yr);
          xl ^= lstans;
          yl ^= lstans;
          xr ^= lstans;
          yr ^= lstans;
          printf("%d\n", lstans = query(rt));
        }
        if (op == 3) return 0;
      }
    }
    ```

## 习题

 [「SDOI2010」捉迷藏](https://www.luogu.org/problem/P2479) 

 [「Violet」天使玩偶/SJY 摆棋子](https://www.luogu.org/problem/P4169) 

 [「国家集训队」JZPFAR](https://www.luogu.org/problem/P2093) 

 [「BOI2007」Mokia 摩基亚](https://www.luogu.org/problem/P4390) 

 [luogu P4475 巧克力王国](https://www.luogu.org/problem/P4475) 

 [「CH 弱省胡策 R2」TATT](https://www.luogu.org/problem/P3769) 

# pairing-heap
### 简介

配对堆是一个支持插入，查询/删除最小值，合并，修改元素等操作的数据结构，也就是俗称的可并堆。  
配对堆在 OI 界十分的冷门，但其实跑得比较快，也很好写，但不能可持久化，因为配对堆复杂度是势能分析出来的均摊复杂度。

### 定义

这里给出一个较为简单的定义，严谨的定义可以查阅参考文献[4]。  
配对堆是一棵带权多叉树（如下图），其权值满足堆性质（即每个节点的权值都小于他的所有儿子）。  
/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/pairingheap1.png)

通常我们使用左儿子右兄弟表示法储存一个配对堆（如下图），从下文可以看出这种方式可以方便配对堆的实现。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/pairingheap2.png)

### 各项操作的实现

#### 存储结构定	义

就是普通的带权多叉树的表示方式。

```cpp
struct Node {
  T v;            // T为权值类型
  Node *ch, *xd;  // ch为该节点儿子的指针，xd为该节点兄弟的指针。
                  //若该节点没有儿子/兄弟则指针指向虚拟空节点。
};
```

#### 查询最小值

从配对堆的定义可看出，配对堆的根节点的权值一定最小，所以我们直接返回根节点就行了。

#### 合并

配对堆的合并操作极为简单，直接把根节点权值较大的那个配对堆设成另一个的儿子就好了。（如下图）  
/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/pairingheap3.png)  
复杂度的话，操作本身显然是 $O(1)$ 的，考虑到对势能的影响后还是均摊 $O(1)$ 

```cpp
Node* merge(Node* a, Node* b) {
  // 若有一个为空则直接返回另一个
  if (a == node) return b;
  if (b == node) return a;
  if (a->v > b->v) swap(a, b);  // swap后a为权值小的堆，b为权值大的堆
  //将b设为a的儿子
  b->xd = a->ch;
  a->ch = b;
  return a;
}
```

#### 插入

合并都有了，插入就直接把新元素视为一个新的配对堆和原堆合并就行啦。

#### 删除最小值

到这里我们会发现，前面的几个操作都十分偷懒，几乎完全没有对数据结构进行维护，所以删除最小值是配对堆最重要的（也是最复杂）的一个操作。  
考虑我们拿掉根节点之后会发生什么，根节点原来的所有儿子构成了一片森林，所以我们要把他们合并起来。  
一个很自然的想法是使用 `merge` 函数把儿子们一个一个并在一起，这样做的话正确性是显然的，但是会导致复杂度退化到 $O(n)$ 。为了保证删除操作的均摊复杂度为 $O(\log n)$ ，我们需要：把儿子们 **从左往右** 两两配成一对，用 `merge` 操作把被配成同一对的两个儿子合并到一起（见下图 1)，再将新产生的堆 **从右往左** 暴力合并在一起（见下图 2）。/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/pairingheap4.jpg)/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/pairingheap5.jpg)

先实现一个辅助函数 `merges` ，作用是合并一个节点的所有兄弟。

```cpp
Node* merges(Node* x) {
  if (x == node || x->xd == node)
    return x;  //如果该树为空或他没有兄弟（即他的父亲的儿子数小于2），就直接return。
  Node *a = x->xd, *b = a->xd;  // a：x的一个兄弟，b：x的另一个兄弟
  x->xd = a->xd = node;         //拆散
  return merge(merge(x, a), merges(b));  //核心部分
}
```

最后一句话是该函数的核心，这句话分三部分：

1.   `merge(x,a)` “配对”了 x 和 a。
2.   `merges(b)` 递归合并 b 和他的兄弟们。
3.  将上面 2 个操作产生的 2 个新树合并。

需要注意到的是，上文提到了配对方向和合并方向是有要求的（从左往右配对，从右往左合并），该递归函数的实现已保证了这个顺序，如果读者需要自行实现迭代版本的话请务必注意保证该顺序，否则复杂度将失去保证。

有了 `merges` 函数， `delete-min` 操作就显然了。（因为这个封装实在没啥用，实际在实现时中一般不显式写出这个函数）

```cpp
Node* delete_min(Node* x) { return merges(x->ch); }
```

#### 减小一个元素的值

要实现这个操作，需要给节点添加一个 father 指针，会使实现变得相对复杂。  
首先节点的定义修改为：

```cpp
struct Node {
  T v;
  Node *ch, *xd;
  Node *fa;  //新增：fa指针，指向该节点的父亲，若该节点为根节点则指向虚拟空节点
};
```

 `merge` 操作修改为：

```cpp
Node* merge(Node* a, Node* b) {
  if (a == node) return b;
  if (b == node) return a;
  if (a->v > b->v) swap(a, b);
  a->fa = node;
  b->fa = node;  //新增：维护fa指针
  b->xd = a->ch;
  a->ch->fa = b;  //新增：维护fa指针
  a->ch = b;
  return a;
}
```

 `merges` 操作修改为：

```cpp
Node* merges(Node* x) {
  x->fa = node;  //新增：维护fa指针
  if (x == node || x->xd == node) return x;
  Node *a = x->xd, *b = a->xd;
  x->xd = a->xd = node;
  a->fa = node;  //新增：维护fa指针
  return merge(merge(x, a), merges(b));
}
```

现在我们来考虑如何实现 `decrease-key` 操作。  
首先我们发现，当我们对节点 x 进行 `decrease-key` 操作后，以 $x$ 为根的子树仍然满足配对堆性质，但 $x$ 的父亲和 $x$ 之间可能不再满足堆性质。  
因此我们可以把整棵以 $x$ 为根的子树剖出来，这样现在两棵树都符合配对堆性质了，再把他们 `merge` 起来就做完了。  
这个操作本身复杂度显然为 $O(1)$ ，但会破坏原有的势能分析过程，因此均摊复杂度难以证明（目前学术界还无法给出复杂度的精确值），通常可以简单的认为复杂度为 $o(\log n)$ （注意这里为小 o）。

```cpp
// root为堆的根，x为要操作的节点，v为新的权值，调用时需保证x->v<=v
//返回值为新的根节点
Node* decrease - key(Node* root, Node* x, LL v) {
  x->v = v;                     //修改权值
  if (x->fa == node) return x;  //如果x为根，就不用接下去的步骤了。
  //把x从fa的子节点中剖出去，这里要分x的位置讨论一下。
  if (x->fa->ch == x)
    x->fa->ch = x->xd;
  else
    x->fa->xd = x->xd;
  x->xd->fa = x->fa;
  x->xd = node;
  x->fa = node;
  return merge(root, x);  //合并root和x。
}
```

### 复杂度分析

见 [配对堆的论文](http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf) 。

### 参考文献

1.   [HOOCCOOH 的题解](https://hooccooh.blog.luogu.org/solution-p3377) 
2.  集训队论文《黄源河 -- 左偏树的特点及其应用》
3.   [《配对堆中文版》](https://wenku.baidu.com/view/f2527bc2bb4cf7ec4afed06d.html) 
4.   [维基百科 pairing heap 词条](https://en.wikipedia.org/wiki/Pairing_heap) 
5.   <https://blog.csdn.net/luofeixiongsix/article/details/50640668> 
6.   <https://brilliant.org/wiki/pairing-heap/> （注：本条目所有图片均来自这里）

# sgt
author: Ir1d, 0xis-cn

 **替罪羊树** 是一种依靠重构操作维持平衡的重量平衡树。替罪羊树会在插入、删除操作时，检测途经的节点，若发现失衡，则将以该节点为根的子树重构。

我们在此实现一个可重的权值平衡树。

```cpp
int cnt,                 // 树中元素总数
    rt,                  // 根节点，初值为 0 代表空树
    w[MAXN],             // 点中的数据 / 权值
    lc[MAXN], rc[MAXN],  // 左右子树
    wn[MAXN],            // 本数据出现次数（为 0 代表已删除）
    s[MAXN],             // 以本节点为根的子树大小
    sd[MAXN];            // 已删除节点不计的子树大小

void Calc(int k) {
  // 重新计算以 k 为根的子树大小
  s[k] = s[lc[k]] + s[rc[k]] + wn[k];
  sd[k] = sd[lc[k]] + sd[rc[k]] + wn[k];
}
```

## 重构

首先，如前所述，我们需要判定一个节点是否应重构。为此我们引入一个比例常数 $\alpha$ （取值在 $(0.5,1)$ ，一般采用 $0.7$ 或 $0.8$ ），若某节点的子节点大小占它本身大小的比例超过 $\alpha$ ，则重构。

另外由于我们采用惰性删除（删除只使用 `wn[k]--` ），已删除节点过多也影响效率。因此若未被删除的子树大小占总大小的比例低于 $\alpha$ ，则亦重构。

```cpp
inline bool CanRbu(int k) {
  // 判断节点 k 是否需要重构
  return wn[k] && (alpha * s[k] <= (double)std::max(s[lc[k]], s[rc[k]]) ||
                   (double)sd[k] <= alpha * s[k]);
}
```

重构分为两个步骤——先中序遍历展开存入数组，再二分重建成树。

```cpp
void Rbu_Flatten(int& ldc, int k) {
  // 前序遍历展开以 k 节点为根子树
  if (!k) return;
  Rbu_Flatten(ldc, lc[k]);
  if (wn[k]) ldr[ldc++] = k;
  // 若当前节点已删除则不保留
  Rbu_Flatten(ldc, rc[k]);
}

int Rbu_Build(int l, int r) {
  // 将 ldr[] 数组内 [l, r) 区间重建成树，返回根节点
  int mid = l + r >> 1;  // 选取中间为根使其平衡
  if (l >= r) return 0;
  lc[ldr[mid]] = Rbu_Build(l, mid);
  rc[ldr[mid]] = Rbu_Build(mid + 1, r);  // 建左右子树
  Calc(ldr[mid]);
  return ldr[mid];
}

void Rbu(int& k) {
  // 重构节点 k 的全过程
  int ldc = 0;
  Rbu_Flatten(ldc, k);
  k = Rbu_Build(0, ldc);
}
```

## 基本操作

几种操作的处理方式较为类似，都规定了 **到达空结点** 与 **找到对应结点** 的行为，之后按 **小于向左、大于向右** 的方式向下递归。

### 插入

插入时，到达空结点则新建节点，找到对应结点则 `wn[k]++` 。递归结束后，途经的节点可重构的要重构。

```cpp
void Ins(int& k, int p) {
  // 在以 k 为根的子树内添加权值为 p 节点
  if (!k) {
    k = ++cnt;
    if (!rt) rt = 1;
    w[k] = p;
    lc[k] = rc[k] = 0;
    wn[k] = s[k] = sd[k] = 1;
  } else {
    if (w[k] == p)
      wn[k]++;
    else if (w[k] < p)
      Ins(rc[k], p);
    else
      Ins(lc[k], p);
    Calc(k);
    if (CanRbu(k)) Rbu(k);
  }
}
```

### 删除

惰性删除，到达空结点则忽略，找到对应结点则 `wn[k]--` 。递归结束后，可重构节点要重构。

```cpp
void Del(int& k, int p) {
  // 从以 k 为根子树移除权值为 p 节点
  if (!k)
    return;
  else {
    sd[k]--;
    if (w[k] == p) {
      if (wn[k]) wn[k]--;
    } else {
      if (w[k] < p)
        Del(rc[k], p);
      else
        Del(lc[k], p);
      Calc(k);
    }
  }
  if (CanRbu(k)) Rbu(k);
}
```

### upper_bound

返回权值严格大于某值的最小名次。

到达空结点则返回 1，因为只有该子树左边的数均小于查找数才会递归至此。找到对应结点，则返回该节点所占据的最后一个名次 + 1。

```cpp
int MyUprBd(int k, int p) {
  // 在以 k 为根子树中，大于 p 的最小数的名次
  if (!k)
    return 1;
  else if (w[k] == p && wn[k])
    return sd[lc[k]] + 1 + wn[k];
  else if (p < w[k])
    return MyUprBd(lc[k], p);
  else
    return sd[lc[k]] + wn[k] + MyUprBd(rc[k], p);
}
```

以下是反义函数，相当于采用 `std::greater<>` 比较，即返回权值严格小于某值的最大名次。查询一个数的排名可以用 `MyUprGrt(rt, x) + 1` 。

```cpp
int MyUprGrt(int k, int p) {
  if (!k)
    return 0;
  else if (w[k] == p && wn[k])
    return sd[lc[k]];
  else if (w[k] < p)
    return sd[lc[k]] + wn[k] + MyUprGrt(rc[k], p);
  else
    return MyUprGrt(lc[k], p);
}
```

### at

给定名次，返回该名次上的权值。到达空结点说明无此名次，找到对应结点则返回其权值。

```cpp
int MyAt(int k, int p) {
  // 以 k 为根的子树中，名次为 p 的权值
  if (!k)
    return 0;
  else if (sd[lc[k]] < p && p <= sd[lc[k]] + wn[k])
    return w[k];
  else if (sd[lc[k]] + wn[k] < p)
    return MyAt(rc[k], p - sd[lc[k]] - wn[k]);
  else
    return MyAt(lc[k], p);
}
```

### 前驱后继

以上两种功能结合即可。

```cpp
inline int MyPre(int k, int p) { return MyAt(k, MyUprGrt(k, p)); }
inline int MyPost(int k, int p) { return MyAt(k, MyUprBd(k, p)); }
```

# queue
本文介绍和队列有关的数据结构及其应用。

## 队列

队列，英文名是 queue，在 C++ STL 中有 [std::queue](https://en.cppreference.com/w/cpp/container/queue) 和 [std::priority_queue](https://en.cppreference.com/w/cpp/container/priority_queue) 。

先进入队列的元素一定先出队列，因此队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。

注： `std::stack` 和 `std::queue` 都是容器适配器，默认底层容器为 `std::deque` （双端队列）。

## 双端队列

双端队列是指一个可以在队首/队尾插入或删除元素的队列。相当于是栈与队列功能的结合。具体地，双端队列支持的操作有 4 个：

1.  在队首插入一个元素
2.  在队尾插入一个元素
3.  在队首删除一个元素
4.  在队尾删除一个元素

## 数组模拟队列

通常用一个数组模拟一个队列，用两个变量标记队列的首尾。

```cpp
int q[SIZE], ql = 1, qr;
```

插入元素： `q[++qr]=x;` 

删除元素： `++ql;` 

访问队首/队尾： `q[ql]` / `q[qr]` 

清空队列： `ql=1;qr=0;` 

数组模拟双端队列是同理的。

## 循环队列

这样会导致一个问题：随着时间的推移，整个队列会向数组的尾部移动，一旦到达数组的最末端，即使数组的前端还有空闲位置，再进行入队操作也会导致溢出。（这种数组上实际有空闲位置而发生了上溢的现象称为是“假溢出”。

解决假溢出的办法是采用循环的方式来组织存放队列元素的数组，即将数组下标为 0 的位置看做是最后一个位置的后继。（ `x` 的后继为 `(x + 1) % Size` ）。这样就形成了循环队列。

## 双栈模拟队列

其实不仅仅可以用数组模拟队列，还有一种冷门的方法是双栈模拟队列。

我们使用两个栈 F,S 模拟一个队列，其中 F 是队尾的栈，S 代表队首的栈，支持 push（在队尾插入），pop（在队首弹出）操作：

1.  Push：插入到栈 F 中
2.  Pop：如果 S 非空，让 S 弹栈；否则把 F 的元素倒过来圧到 S 中（其实就是一个一个弹出插入，做完后是首位颠倒的），然后再让 S 弹栈。

容易证明，每个元素只会进入/转移/弹出一次，均摊复杂度 $O(1)$ 。

有人问这个东西有什么用吗？参见下面这道题。这道题顺便可以给大家一个 **双栈模拟双端队列** 的方法。

## 例题

 [LOJ6515「雅礼集训 2018 Day10」贪玩蓝月](https://loj.ac/problem/6515) 

> 一个双端队列（deque），m 个事件：
>
> 1.  在前端插入 (w,v)
> 2.  在后端插入 (w,v)
> 3.  删除前端的二元组
> 4.  删除后端的二元组
> 5.  给定 l,r，在当前 deque 中选择一个子集 S 使得 $\sum_{(w,v)\in S}w\bmod p\in[l,r]$ ，且最大化 $\sum_{(w,v)\in S}v$ .
>
>      $m\leq 5\times 10^4,p\leq 500$ .

### 离线算法

每个二元组是有一段存活时间的，因此对时间建立线段树，每个二元组做 log 个存活标记。因此我们要做的就是对每个询问，求其到根节点的路径上的标记的一个最优子集。显然这个可以 DP 做。 $f[S,j]$ 表示选择集合 S 中的物品余数为 j 的最大价值。（其实实现的时侯是有序的，直接 f[i,j]做）

一共有 $O(m\log m)$ 个标记，因此这么做的话复杂度是 $O(mp\log m)$ 的。

### 在线算法

这是一个在线算法比离线算法快的神奇题目。而且还比离线的好写

上述离线算法其实是略微小题大做的，因为如果把题目的 deque 改成直接维护一个集合的话（即随机删除集合内元素），那么离线算法同样适用。既然是 deque，不妨在数据结构上做点文章。

### 栈

如果题目中维护的数据结构是一个栈呢？

直接 DP 即可。 $f[i,j]$ 表示前 i 个二元组，余数为 j 时的最大价值。

$$
f[i,j]=\max(f[i-1,j],f[i-1,(j-w_i)\bmod p]+v_i)
$$

妥妥的背包啊

删除的时侯直接指针前移即可。这样做的复杂度是 $O(mp)$ 的。

### 队列

如果题目中维护的数据结构是队列？

有一种操作叫双栈模拟队列。这就是这个东西的用武之地。因为用栈是可以轻松维护 DP 过程的，而双栈模拟队列的复杂度是均摊 $O(1)$ 的，因此，复杂度仍是 $O(mp)$ .

### 双端队列

回到原题，那么 Deque 怎么做？

类比推理，我们尝试用栈模拟双端队列，于是似乎把维护队列的方法扩展一下就可以了。但如果每次是全部转移栈中的元素的话，单次操作复杂度很容易退化为 $O(m)$ .

于是乎，神仙的想一想，我们可以丢一半过去啊

这样的复杂度其实均摊下来仍是常数级别。具体地说，丢一半指的是把一个栈靠近栈底的一半倒过来丢到另一个栈中。也就是说要手写栈以支持这样的操作。

### 丢一半的复杂度

似乎可以用 [势能分析法](https://yhx-12243.github.io/OI-transit/records/cf601E.html) 证明。其实本蒟蒻有一个很仙的想法。我们考虑这个双栈结构的整体复杂度。m 个事件，我们希望尽可能增加这个结构的复杂度。

首先，如果全是插入操作的话显然是严格 $\Theta(m)$ 的，因为插入的复杂度是 $O(1)$ 的。

“丢一半”操作是在什么时侯触发的？当某一个栈为空又要求删除元素的时侯。设另一个栈的元素个数是 $O(k)$ ，那么丢一半的复杂度就是 $O(k)\geq O(1)$ 的。因此我们要尽可能增加“丢一半”操作的次数。

为了增加丢一半的操作次数，必然需要不断删元素直到某一个栈为空。由于插入操作对增加复杂度是无意义的，因此我们不考虑插入操作。初始时有 m 个元素，假设全在一个栈中。则第一次丢一半的复杂度是 $O(m)$ 的。然后两个栈就各有 $\frac{m}{2}$ 个元素。这时就需要 $O(\frac{m}{2})$ 删除其中一个栈，然后就又可以触发一次复杂度为 $O(\frac{m}{2})$ 的丢一半操作……

考虑这样做的总复杂度。

$$
T(m)=2\cdot O(m)+T\left(\frac{m}{2}\right)
$$

解得 $T(m)=O(m)$ .

于是，总复杂度仍是 $O(mp)$ .

### 询问操作

在询问的时侯，我们要处理的应该是“在两个栈中选若干个元素的最大价值”的问题。因此要对栈顶的 DP 值做查询，即两个 $f,g$ 对于询问[l,r]的最大价值：

$$
\max_{0\leq i<p}\left\{f[i]+\max_{l\leq i+j\leq r}g_j\right\}
$$

这个问题暴力做是 $O(p^2)$ 的，不过一个妥妥的单调队列可以做到 $O(p)$ .

```cpp
#include <algorithm>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <vector>
using namespace std;
typedef long long lld;
typedef long double lf;
typedef unsigned long long uld;
typedef pair<int, int> pii;
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
#define ROF(i, a, b) for (int i = (a); i >= (b); --i)
/******************heading******************/
const int M = 5e4 + 5, P = 505;
int I, m, p;

inline int _(int d) { return (d + p) % p; }
namespace DQ {       // 双栈模拟双端队列
pii fr[M], bc[M];    // front,back; fi:w,se:v;
int tf = 0, tb = 0;  // top
int ff[M][P], fb[M][P];
void update(pii *s, int f[][P], int i) {  // update f[i] from f[i-1]
  FOR(j, 0, p - 1) {
    f[i][j] = f[i - 1][j];
    if (~f[i - 1][_(j - s[i].fi)])
      f[i][j] = max(f[i][j], f[i - 1][_(j - s[i].fi)] + s[i].se);
  }
}
void push_front(pii x) { fr[++tf] = x, update(fr, ff, tf); }
void push_back(pii x) { bc[++tb] = x, update(bc, fb, tb); }
void pop_front() {
  if (tf) {
    --tf;
    return;
  }
  int mid = (tb + 1) / 2, top = tb;
  ROF(i, mid, 1) push_front(bc[i]);
  tb = 0;
  FOR(i, mid + 1, top) push_back(bc[i]);
  --tf;
}
void pop_back() {
  if (tb) {
    --tb;
    return;
  }
  int mid = (tf + 1) / 2, top = tf;
  ROF(i, mid, 1) push_back(fr[i]);
  tf = 0;
  FOR(i, mid + 1, top) push_front(fr[i]);
  --tb;
}
int q[M], ql, qr;
int query(int l, int r) {
  const int *const f = ff[tf], *const g = fb[tb];
  int ans = -1;
  ql = 1, qr = 0;
  FOR(i, l - p + 1, r - p + 1) {
    int x = g[_(i)];
    while (ql <= qr && g[q[qr]] <= x) --qr;
    q[++qr] = _(i);
  }
  ROF(i, p - 1, 0) {
    if (ql <= qr && ~f[i] && ~g[q[ql]]) ans = max(ans, f[i] + g[q[ql]]);
    // 删 l-i，加 r-i+1
    if (ql <= qr && _(l - i) == q[ql]) ++ql;
    int x = g[_(r - i + 1)];
    while (ql <= qr && g[q[qr]] <= x) --qr;
    q[++qr] = _(r - i + 1);
  }
  return ans;
}
void init() { FOR(i, 1, P - 1) ff[0][i] = fb[0][i] = -1; }
}  // namespace DQ
int main() {
  DQ::init();
  scanf("%d%d%d", &I, &m, &p);
  FOR(i, 1, m) {
    char op[5];
    int x, y;
    scanf("%s%d%d", op, &x, &y);
    if (op[0] == 'I' && op[1] == 'F')
      DQ::push_front(mk(_(x), y));
    else if (op[0] == 'I' && op[1] == 'G')
      DQ::push_back(mk(_(x), y));
    else if (op[0] == 'D' && op[1] == 'F')
      DQ::pop_front();
    else if (op[0] == 'D' && op[1] == 'G')
      DQ::pop_back();
    else
      printf("%d\n", DQ::query(x, y));
  }
  return 0;
}
```

# persistent-block-array


# balanced-in-seg
author: Dev-jqe, HeRaNO

## 常见用途

在算法竞赛中，我们有时需要维护多维度信息。在这种时候，我们经常需要树套树来记录信息。当需要维护前驱，后继，第 $k$ 大，某个数的排名，或者插入删除的时候，我们通常需要使用平衡树来满足我们的需求，即线段树套平衡树。

## 实现原理

我们以 **二逼平衡树** 为例，来解释实现原理。

关于树套树的构建，我们对于外层线段树正常建树，对于线段树上的某一个节点，建立一棵平衡树，包含该节点所覆盖的序列。具体操作时我们可以将序列元素一个个插入，每经过一个线段树节点，就将该元素加入到该节点的平衡树中。

操作一，求某区间中某值的排名：我们对于外层线段树正常操作，对于在某区间中的节点的平衡树，我们返回平衡树中比该值小的元素个数，合并区间时，我们将小的元素个数求和即可。最后将返回值 $+1$ ，即为某值在某区间中的排名。

操作二，求某区间中排名为 $k$ 的值：我们可以采用二分策略。因为一个元素可能存在多个，其排名为一区间，且有些元素原序列不存在。所以我们采取和操作一类似的思路，我们用小于该值的元素个数作为参考进行二分，即可得解。

操作三，将某个数替换为另外一个数：我们只要在所有包含某数的平衡树中删除某数，然后再插入另外一个数即可。外层依旧正常线段树操作。

操作四，求某区间中某值的前驱：我们对于外层线段树正常操作，对于在某区间中的节点的平衡树，我们返回某值在该平衡树中的前驱，线段树的区间结果合并时，我们取最大值即可。

## 空间复杂度

我们每个元素加入 $\log n$ 个平衡树，所以空间复杂度为 $(n + q)\log{n}$ 。

## 时间复杂度

对于 $1,2,4$ 操作，我们考虑我们在外层线段树上进行 $\log{n}$ 次操作，每次操作会在一个内层平衡树树上进行 $\log{n}$ 次操作，所以时间复杂度为 $\log^2{n}$ 。
对于 $3$ 操作，多一个二分过程，为 $\log^3{n}$ 。

## 经典例题

 [二逼平衡树](https://loj.ac/problem/106) 外层线段树，内层平衡树。

## 示例代码

平衡树部分代码请参考 Splay 等其他条目。 [传送至 Splay 条目](./splay.md) 

操作一

```cpp
int vec_rank(int k, int l, int r, int x, int y, int t) {
  if (x <= l && r <= y) {
    return spy[k].chk_rank(t);
  }
  int mid = l + r >> 1;
  int res = 0;
  if (x <= mid) res += vec_rank(k << 1, l, mid, x, y, t);
  if (y > mid) res += vec_rank(k << 1 | 1, mid + 1, r, x, y, t);
  if (x <= mid && y > mid) res--;
  return res;
}
```

操作二

```cpp
int el = 0, er = 100000001, emid;
while (el != er) {
  emid = el + er >> 1;
  if (vec_rank(1, 1, n, tl, tr, emid) - 1 < tk)
    el = emid + 1;
  else
    er = emid;
}
printf("%d\n", el - 1);
```

操作三

```cpp
void vec_chg(int k, int l, int r, int loc, int x) {
  int t = spy[k].find(dat[loc]);
  spy[k].dele(t);
  spy[k].insert(x);
  if (l == r) return;
  int mid = l + r >> 1;
  if (loc <= mid) vec_chg(k << 1, l, mid, loc, x);
  if (loc > mid) vec_chg(k << 1 | 1, mid + 1, r, loc, x);
}
```

操作四

```cpp
int vec_front(int k, int l, int r, int x, int y, int t) {
  if (x <= l && r <= y) return spy[k].chk_front(t);
  int mid = l + r >> 1;
  int res = 0;
  if (x <= mid) res = max(res, vec_front(k << 1, l, mid, x, y, t));
  if (y > mid) res = max(res, vec_front(k << 1 | 1, mid + 1, r, x, y, t));
  return res;
}
```

## 相关算法

面对多维度信息的题目时，如果题目没有要求强制在线，我们还可以考虑 **CDQ 分治** ，或者 **整体二分** 等分治算法，来避免使用高级数据结构，减少代码实现难度。

# linked-list
## 何为链表

链表和数组都可用于存储数据，其中链表通过指针来连接元素，而数组则是把所有元素按次序依次存储。

不同的存储结构令他们有了不同的优势：

链表可以方便地删除、插入数据，操作次数是 $O(1)$ 。但也因为这样寻找读取数据的效率不如数组高，在随机访问数据中的操作次数是 $O(n)$ 。

数组可以方便的寻找读取数据，在随机访问中操作次数是 $O(1)$ 。但删除、插入的操作次数却是却是 $O(n)$ 次。

## 构建链表

关于链表的构建使用到指针的部分比较抽象，光靠文字描述和代码可能难以理解，建议配合作图来理解。

### 单向链表

单向链表中包含数据域和指针域，其中数据域用于存放数据，指针域用来连接当前结点和下一节点。

```c++
struct Node {
  int value;
  Node *next;
};
```

### 双向链表

双向链表中同样有数据域和指针域，不同之处在于指针域有左右（或上一个、下一个）之分，用来连接上一个节点、当前结点、下一个结点。

```c++
struct Node {
  int value;
  Node *left;
  Node *right;
};
```

## 向链表中插入（写入）数据

### 单向链表

```c++
void insertNode(int i, Node *p) {
  Node *node = new Node;
  node->value = i;
  node->next = p->next;
  p->next = node;
}
```

具体过程可参考下面这张图。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/linked-list1.png)

### 单向循环链表

上面介绍了简单的单向链表的插入数据，有时我们会将链表的头尾连接起来将链表变为循环链表

```c++
void insertNode(int i, Node *p) {
  Node *node = new Node;
  node->value = i;
  node->next = NULL;
  if (p == NULL) {
    p = node;
    node->next = node;
  } else {
    node->next = p->next;
    p->next = node;
  }
}
```

由于是循环的链表，我们在插入数据时需要判断原链表是否为空，为空则自身循环，不为空则正常插入数据循环。具体过程可参考下面这张图。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/linked-list2.png)

### 双向循环链表

```c++
void insertNode(int i, Node *p) {
  Node *node = new Node;
  node->value = i;
  if (p == NULL) {
    p = node;
    node->left = node;
    node->right = node;
  } else {
    node->left = p;
    node->right = p->right;
    p->right->left = node;
    p->right = node;
  }
}
```

## 从链表中删除数据

### 单向（循环）链表

```c++
void deleteNode(Node *p) {
  p->value = p->next->value;
  Node *t = p->next;
  p->next = p->next->next;
  delete t;
}
```

从链表中删除某个结点时，将 p 的下一个结点 (p->next) 的值覆盖给 p 即可，与此同时更新 p 的下下个结点。具体过程可参考下面这张图。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/linked-list3.png)

### 双向循环链表

```c++
void deleteNode(Node *&p) {
  p->left->right = p->right;
  p->right->left = p->left;
  Node *t = p;
  p = p->right;
  delete t;
}
```

# heap
author: ouuan

堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。

每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。STL 中的 `priority_queue` 其实就是一个大根堆。

（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。

一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。

一些功能更强大的堆还支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本。

## 堆的分类

|         操作\\数据结构        |                                    配对堆                                    |       二叉堆      |       左偏树      |       二项堆      |     斐波那契堆     |
| :---------------------: | :-----------------------------------------------------------------------: | :------------: | :------------: | :------------: | :-----------: |
|        插入（insert）       |                                   $O(1)$                                  |   $O(\log n)$  |   $O(\log n)$  |     $O(1)$     |     $O(1)$    |
|     查询最小值（find-min）     |                                   $O(1)$                                  |     $O(1)$     |     $O(1)$     |   $O(\log n)$  |     $O(1)$    |
|    删除最小值（delete-min）    |                                $O(\log n)$                                |   $O(\log n)$  |   $O(\log n)$  |   $O(\log n)$  |  $O(\log n)$  |
|        合并 (merge)       |                                   $O(1)$                                  |     $O(n)$     |   $O(\log n)$  |   $O(\log n)$  |     $O(1)$    |
| 减小一个元素的值 (decrease-key) |  $o(\log n) (下界\Omega(\log \log n) ，\\\\上界 O(2^{2\sqrt{\log \log n}}) )$  |   $O(\log n)$  |   $O(\log n)$  |   $O(\log n)$  |     $O(1)$    |
|         是否支持可持久化        |                                  $\times$                                 |  $\checkmark$  |  $\checkmark$  |  $\checkmark$  |    $\times$   |

习惯上，不加限定提到“堆”时往往都指二叉堆。

# lct
## 简介

1.  Link/Cut Tree 是一种数据结构，我们用它来解决<font color="red">动态树问题</font>。
2.  Link/Cut Tree 又称 Link-Cut Tree，简称 LCT，但它不叫动态树，动态树是指一类问题。
3.  Splay Tree 是 LCT 的基础，但是 LCT ⽤的 Splay Tree 和普通的 Splay 在细节处不太一样（进行了一些扩展）。
4.  这是⼀个和 Splay ⼀样只需要写几 (yi) 个 (dui) 核心函数就能实现一切的数据结构。

## 问题引入

-   维护一棵树，支持如下操作。
-   修改两点间路径权值。
-   查询两点间路径权值和。
-   修改某点子树权值。
-   查询某点子树权值和。
      唔，看上去是一道树剖模版题。

那么我们加一个操作

-   断开并连接一些边，保证仍是一棵树。

要求在线求出上面的答案。

——动态树问题的解决方法：Link/Cut Tree!

## 动态树问题

-   维护一个<font color="red">森林</font>, 支持删除某条边，加⼊某条边，并保证加边，删边之后仍是森林。我们要维护这个森林的一些信息。
-   一般的操作有两点连通性，两点路径权值和，连接两点和切断某条边、修改信息等。

* * *

### 从 LCT 的角度回顾一下树链剖分

-   对整棵树按子树⼤小进⾏剖分，并重新标号。
-   我们发现重新标号之后，在树上形成了一些以链为单位的连续区间，并且可以用线段树进⾏区间操作。

### 转向动态树问题

-   我们发现我们刚刚讲的树剖是以子树⼤小作为划分条件。
-   那我们能不能重定义一种剖分，使它更适应我们的动态树问题呢？
-   考虑动态树问题需要什么链。
-   由于动态维护⼀个森林，显然我们希望这个链是我们指定的链，以便利用来求解。

## <font color = "red">实链剖分</font>

-   对于⼀个点连向它所有儿子的边 , 我们自己选择⼀条边进行剖分，我们称被选择的边为实边，其他边则为虚边。
-   对于实边，我们称它所连接的儿子为实儿子。
-   对于⼀条由实边组成的链，我们同样称之为实链。
-   请记住我们选择实链剖分的最重要的原因：它是我们选择的，灵活且可变。
-   正是它的这种灵活可变性，我们采用 Splay Tree 来维护这些实链。

## LCT！

-   我们可以简单的把 LCT 理解成用⼀些 Splay 来维护动态的树链剖分，以期实现动态树上的区间操作。
-   对于每条实链，我们建⼀个 Splay 来维护整个链区间的信息。
-   接下来，我们来学习 LCT 的具体结构。

## - 辅助树

-   我们先来看⼀看辅助树的一些性质，再通过一张图实际了解一下辅助树的具体结构。
-   在本文里，你可以认为一些 Splay 构成了一个辅助树，每棵辅助树维护的是一棵树，一些辅助树构成了 LCT，其维护的是整个森林。

1.  辅助树由多棵 Splay 组成，每棵 Splay 维护原树中的一条路径，且中序遍历这棵 Splay 得到的点序列，从前到后对应原树“从上到下”的一条路径。
2.  原树每个节点与辅助树的 Splay 节点一一对应。
3.  辅助树的各棵 Splay 之间并不是独立的。每棵 Splay 的根节点的父亲节点本应是空，但在 LCT 中每棵 Splay 的根节点的父亲节点指向原树中 **这条链** 的父亲节点（即链最顶端的点的父亲节点）。这类父亲链接与通常 Splay 的父亲链接区别在于儿子认父亲，而父亲不认儿子，对应原树的一条 **虚边** 。因此，每个联通块恰好有一个点的父亲节点为空。
4.  由于辅助树的以上性质，我们维护任何操作都不需要维护原树，辅助树可以在任何情况下拿出一个唯一的原树，我们只需要维护辅助树即可。（本句来源自 @PoPoQQQ 大爷的 PPT)

-   现在我们有⼀棵原树，如图。
-   加粗边是实边，虚线边是虚边。

![lct9](./images/lct9.png)

-   由刚刚的定义，辅助树的结构如下

![lct10](./images/lct10.png)

### 考虑原树和辅助树的结构关系

-   原树中的实链 : 在辅助树中节点都在一棵 Splay 中。
-   原树中的虚链 : 在辅助树中，子节点所在 Splay 的 Father 指向父节点，但是父节点的两个儿子都不指向子节点。
-   注意：原树的根不等于辅助树的根。
-   原树的 Father 指向不等于辅助树的 Father 指向。
-   辅助树是可以在满足辅助树、Splay 的性质下任意换根的。
-   虚实链变换可以轻松在辅助树上完成，这也就是实现了动态维护树链剖分。

### 接下来要用到的变量声明

-    `ch[N][2]` 左右儿子
-    `f[N]` ⽗亲指向
-    `sum[N]` 路径权值和
-    `val[N]` 点权
-    `tag[N]` 翻转标记
-    `laz[N]` 权值标记
-    `siz[N]` 辅助树上子树大小
-   Other_Vars

### 函数声明

#### ⼀般数据结构函数（字面意思）

1.   `PushUp(x)` 
2.   `PushDown(x)` 

#### Splay 系函数（不会多做解释）

1.   `Get(x)` 获取 $x$ 是父亲的哪个儿子。
2.   `Splay(x)` 通过和 Rotate 操作联动实现把 $x$ 旋转到<font color = "red">当前 Splay 的根</font>。
3.   `Rotate(x)` 将 $x$ 向上旋转一层的操作。

#### 新操作

1.   `Access(x)` 把从根到 $x$ 的所有点放在⼀条实链里，使根到 $x$ 成为一条实路径，并且在同一棵 Splay 里。 **只有此操作是必须实现的，其他操作视题目而实现。** 
2.   `IsRoot(x)` 判断 $x$ 是否是所在树的根。
3.   `Update(x)` 在 `Access` 操作之后，递归地从上到下 `Pushdown` 更新信息。
4.   `MakeRoot(x)` 使 $x$ 点成为其所在树的根。
5.   `Link(x, y)` 在 $x, y$ 两点间连一条边。
6.   `Cut(x, y)` 把 $x, y$ 两点间边删掉。
7.   `Find(x)` 找到 $x$ 所在树的根节点编号。
8.   `Fix(x, v)` 修改 $x$ 的点权为 $v$ 。
9.   `Split(x, y)` 提取出 $x, y$ 间的路径，方便做区间操作。

### 宏定义

-    `#define ls ch[p][0]` 
-    `#define rs ch[p][1]` 

## 函数讲解

先从简单的来吧

###  `PushUp()` 

```cpp
inline void PushUp(int p) {
  // maintain other variables
  siz[p] = siz[ls] + siz[rs];
}
```

###  `PushDown()` 

```cpp
inline void PushDown(int p) {
  if (tag[p] != std_tag) {
    // pushdown the tag
    tag[p] = std_tag;
  }
}
```

###  `Splay() && Rotate()` 

有些不一样了哦。

```cpp
#define Get(x) (ch[f[x]][1] == x)
inline void Rotate(int x) {
  int y = f[x], z = f[y], k = Get(x);
  if (!isRoot(y)) ch[z][ch[z][1] == y] = x;
  // 上面这句一定要写在前面，普通的Splay是不用的，因为 isRoot  (后面会讲)
  ch[y][k] = ch[x][!k], f[ch[x][!k]] = y;
  ch[x][!k] = y, f[y] = x, f[x] = z;
  PushUp(x), PushUp(y);
}
inline void Splay(int x) {
  Update(
      x);  // 马上就能看到啦。 在 Splay之前要把旋转会经过的路径上的点都PushDown
  for (int fa; fa = f[x], !isRoot(x); Rotate(x)) {
    if (!isRoot(fa)) Rotate(Get(fa) == Get(x) ? fa : x);
  }
}
```

如果上面的几个函数你看不懂，请移步 [Splay](./splay.md) 。

下面要开始 LCT 独有的函数了哦。

###  `isRoot()` 

```cpp
// 在前面我们已经说过，LCT 具有 如果一个儿子不是实儿子，他的父亲找不到它的性质
// 所以当一个点既不是它父亲的左儿子，又不是它父亲的右儿子，它就是当前 Splay 的根
#define isRoot(x) (ch[f[x]][0] != x && ch[f[x]][1] != x)
```

### <code><font color = "red">Access()</font></code>

```cpp
// Access 是 LCT
// 的核心操作，试想我们像求解一条路径，而这条路径恰好就是我们当前的一棵 Splay，
// 直接调用其信息即可。先来看一下代码，再结合图来看看过程
inline int Access(int x) {
  int p;
  for (p = 0; x; p = x, x = f[x]) {
    Splay(x), ch[x][1] = p, PushUp(x);
  }
  return p;
}
```

我们有这样一棵树，实线为实边，虚线为虚边。

![pic1](./images/lct1.png)

-   它的辅助树可能长成这样（构图方式不同可能 LCT 的结构也不同）。
-   每个绿框里是一棵 Splay。

![pic2](./images/lct2.png)

-   现在我们要 `Access(N)` , 把 $A$ 到 $N$ 路径上的边都变为实边，拉成一棵 Splay。

![pic3](./images/lct3.png)

-   实现的方法是从下到上逐步更新 Splay。
-   首先我们要把 $N$ 旋至当前 Splay 的根。
-   为了保证 AuxTree（辅助树）的性质，原来 $N$ 到 $O$ 的实边要更改为虚边。
-   由于认父不认子的性质，我们可以单方面的把 $N$ 的儿子改为 Null。
-   于是原来的 AuxTree 就从下图变成了下下图。

![pic4](./images/lct4.png)

![pic](./images/lct5.png)

-   下一步，我们把 $N$ 指向的 Father $I$ 也旋转到 $I$ 的 Splay 树根。
-   原来的实边 $I$ — $K$ 要去掉，这时候我们把 $I$ 的右儿子指向 $N$ , 就得到了 $I$ — $L$ 这样一棵 Splay。

![pic](./images/lct8.png)

-   接下来，按照刚刚的操作步骤，由于 $I$ 的 Father 指向 $H$ , 我们把 $H$ 旋转到他所在 Splay Tree 的根，然后把 $H$ 的 rs 设为 $I$ 。
-   之后的树是这样的。

![pic](./images/lct6.png)

-   同理我们 `Splay(A)` , 并把 $A$ 的右儿子指向 $H$ 。
-   于是我们得到了这样一棵 AuxTree。并且发现 $A$ — $N$ 的整个路径已经在同一棵 Splay 中了。大功告成！

![pic](./images/lct7.png)

```cpp
// 回顾一下代码
inline int Access(int x) {
  int p;
  for (p = 0; x; p = x, x = f[x]) {
    Splay(x), ch[x][1] = p, PushUp(x);
  }
  return p;
}
```

我们发现 `Access()` 其实很容易，只有如下四步操作：

1.  把当前节点转到根。
2.  把儿子换成之前的节点。
3.  更新当前点的信息。
4.  把当前点换成当前点的父亲，继续操作。

这里提供的 Access 还有一个返回值。这个返回值相当于最后一次虚实链变换时虚边父亲节点的编号。该值有两个含义：

-   连续两次 Access 操作时，第二次 Access 操作的返回值等于这两个节点的 LCA.
-   表示 $x$ 到根的链所在的 Splay 树的根。这个节点一定已经被旋转到了根节点，且父亲一定为空。

###  `Update()` 

```cpp
// 从上到下一层一层 pushDown 即可
void Update(int p) {
  if (!isRoot(p)) Update(f[p]);
  pushDown(p);
}
```

###  `makeRoot()` 

-    `Make_Root()` 的重要性丝毫不亚于 `Access()` 。我们在需要维护路径信息的时候，一定会出现路径深度无法严格递增的情况，根据 AuxTree 的性质，这种路径是不能出现在一棵 Splay 中的。
-   这时候我们需要用到 `Make_Root()` 。
-    `Make_Root()` 的作用是使指定的点成为原树的根，考虑如何实现这种操作。
-   设 `Access(x)` 的返回值为 $y$ ，则此时 $x$ 到当前根的路径恰好构成一个 Splay，且该 Splay 的根为 $y$ .
-   考虑将树用有向图表示出来，给每条边定一个方向，表示从儿子到父亲的方向。容易发现换根相当于将 $x$ 到根的路径的所有边反向（请仔细思考）。
-   因此将 $x$ 到当前根的路径翻转即可。
-   由于 $y$ 是 $x$ 到当前根的路径所代表的 Splay 的根，因此将以 $y$ 为根的 Splay 树进行区间翻转即可。

```cpp
inline void makeRoot(int p) {
  p = Access(p);
  swap(ch[p][0], ch[p][1]);
  tag[p] ^= 1;
}
```

###  `Link()` 

-   Link 两个点其实很简单，先 `Make_Root(x)` , 然后把 $x$ 的父亲指向 $y$ 即可。显然，这个操作肯定不能发生在同一棵树内，所以记得先判一下。

```cpp
inline void Link(int x, int p) {
  makeRoot(x);
  splay(x);
  f[x] = p;
}
```

###  `Split()` 

-    `Split` 操作意义很简单，就是拿出一棵 Splay , 维护的是 $x$ 到 $y$ 的路径。
-   先 `MakeRoot(x)` ，然后 `Access(y)` 。如果要 $y$ 做根，再 `Splay(y)` 。
-   就这三句话，没写代码，需要的时候可以直接打这三个就好辣！
-   另外 Split 这三个操作直接可以把需要的路径拿出到 $y$ 的子树上，那不是随便干嘛咯。

###  `Cut()` 

-    `Cut` 有两种情况，保证合法和不一定保证合法。（废话）
-   如果保证合法，直接 `Split(x, y)` ，这时候 $y$ 是根， $x$ 一定是它的儿子，双向断开即可。就像这样：

```cpp
inline void Cut(int x, int p) {
  makeRoot(x), Access(p), Splay(p), ls = f[x] = 0;
}
```

如果是不保证合法，我们需要判断一下是否有，我选择使用 `map` 存一下，但是这里有一个利用性质的方法：

想要删边，必须要满足如下三个条件：

1.   $x,y$ 连通。
2.   $x,y$ 的路径上没有其他的链。
3.   $x$ 没有右儿子。

总结一下，上面三句话的意思就一个： $x,y$ 之间有边。

具体实现就留作一个思考题给大家。判断连通需要用到后面的 `Find` , 其他两点稍作思考分析一下结构就知道该怎么判断了。

###  `Find()` 

-    `Find()` 其实就是找到当前辅助树的根。在 `Access(p)` 后，再 `Splay(p)` 。这样根就是树里最小的那个，一直往 ls 走，沿途 `PushDown` 即可。
-   一直走到没有 ls, 非常简单。
-   注意，每次查询之后需要把查询到的答案对应的结点 `Splay` 上去以保证复杂度。

```cpp
inline int Find(int p) {
  Access(p), Splay(p);
  while (ls) pushDown(p), p = ls;
  Splay(p);
  return p;
}
```

### 一些提醒

-   干点啥前一定要想一想需不需要 `PushUp` 或者 `PushDown` , LCT 由于特别灵活的原因，少 `Pushdown` 或者 `Pushup` 一次就可能把修改改到不该改的点上！
-   LCT 的 `Rotate` 和 Splay 的不太一样， `if (z)` 一定要放在前面。
-   LCT 的 `Splay` 操作就是旋转到根，没有旋转到谁儿子的操作，因为不需要。

## 习题

-    [「BZOJ 3282」Tree](https://lydsy.com/JudgeOnline/problem.php?id=3282) 
-    [「HNOI2010」弹飞绵羊](https://www.luogu.org/problem/P3203) 

## 维护树链信息

LCT 通过 `Split(x,y)` 操作，可以将树上从点 $x$ 到点 $y$ 的路径提取到以 $y$ 为根的 Splay 内，树链信息的修改和统计转化为平衡树上的操作，这使得 LCT 在维护树链信息上具有优势。此外，借助 LCT 实现的在树链上二分比树链剖分少一个 $O(\log n)$ 的复杂度。

???+note " 例题[「国家集训队」Tree II](https://www.luogu.org/problemnew/show/P1501)"
    给出一棵有 $n$ 个结点的树，每个点的初始权值为 $1$ 。 $q$ 次操作，每次操作均为以下四种之一：

    1.   `- u1 v1 u2 v2` ：将树上 $u_1,v_1$ 两点之间的边删除，连接 $u_2,v_2$ 两点，保证操作合法且连边后仍是一棵树。
    2.   `+ u v c` ：将树上 $u,v$ 两点之间的路径上的点权都增加 $c$ 。
    3.   `* u v c` ：将树上 $u,v$ 两点之间的路径上的点权都乘以 $c$ 。
    4.   `/u v` ：输出树上 $u,v$ 两点之间的路径上的点权之和对 $51061$ 取模后的值。

     $1\le n,q\le 10^5,0\le c\le 10^4$ 

     `-` 操作可以直接 `Cut(u1,v1),Link(u2,v2)` 。

对树上 $u,v$ 两点之间的路径进行修改时，先 `Split(u,v)` 。

此题要求进行在辅助树上的子树加，子树乘，子树求和操作，所以我们除了一般 LCT 需要维护的子树翻转标记，还要维护子树加法标记和子树乘法标记。处理标记的方法和在 Splay 上是一样的。

在打上和下传加法标记时，子树权值和的变化量和子树中的结点数有关，所以我们还要维护子树的大小 `siz` 。

在下传标记时，需要注意顺序，先下传乘法标记再下传加法标记。子树翻转和子树加乘两种标记没有冲突。

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    using namespace std;
    #define int long long
    const int maxn = 100010;
    const int mod = 51061;
    int n, q, u, v, c;
    char op;
    struct Splay {
      int ch[maxn][2], fa[maxn], siz[maxn], val[maxn], sum[maxn], rev[maxn],
          add[maxn], mul[maxn];
      void clear(int x) {
        ch[x][0] = ch[x][1] = fa[x] = siz[x] = val[x] = sum[x] = rev[x] = add[x] =
            0;
        mul[x] = 1;
      }
      int getch(int x) { return (ch[fa[x]][1] == x); }
      int isroot(int x) {
        clear(0);
        return ch[fa[x]][0] != x && ch[fa[x]][1] != x;
      }
      void maintain(int x) {
        clear(0);
        siz[x] = (siz[ch[x][0]] + 1 + siz[ch[x][1]]) % mod;
        sum[x] = (sum[ch[x][0]] + val[x] + sum[ch[x][1]]) % mod;
      }
      void pushdown(int x) {
        clear(0);
        if (mul[x] != 1) {
          if (ch[x][0])
            mul[ch[x][0]] = (mul[x] * mul[ch[x][0]]) % mod,
            val[ch[x][0]] = (val[ch[x][0]] * mul[x]) % mod,
            sum[ch[x][0]] = (sum[ch[x][0]] * mul[x]) % mod,
            add[ch[x][0]] = (add[ch[x][0]] * mul[x]) % mod;
          if (ch[x][1])
            mul[ch[x][1]] = (mul[x] * mul[ch[x][1]]) % mod,
            val[ch[x][1]] = (val[ch[x][1]] * mul[x]) % mod,
            sum[ch[x][1]] = (sum[ch[x][1]] * mul[x]) % mod,
            add[ch[x][1]] = (add[ch[x][1]] * mul[x]) % mod;
          mul[x] = 1;
        }
        if (add[x]) {
          if (ch[x][0])
            add[ch[x][0]] = (add[ch[x][0]] + add[x]) % mod,
            val[ch[x][0]] = (val[ch[x][0]] + add[x]) % mod,
            sum[ch[x][0]] = (sum[ch[x][0]] + add[x] * siz[ch[x][0]] % mod) % mod;
          if (ch[x][1])
            add[ch[x][1]] = (add[ch[x][1]] + add[x]) % mod,
            val[ch[x][1]] = (val[ch[x][1]] + add[x]) % mod,
            sum[ch[x][1]] = (sum[ch[x][1]] + add[x] * siz[ch[x][1]] % mod) % mod;
          add[x] = 0;
        }
        if (rev[x]) {
          if (ch[x][0]) rev[ch[x][0]] ^= 1, swap(ch[ch[x][0]][0], ch[ch[x][0]][1]);
          if (ch[x][1]) rev[ch[x][1]] ^= 1, swap(ch[ch[x][1]][0], ch[ch[x][1]][1]);
          rev[x] = 0;
        }
      }
      void update(int x) {
        if (!isroot(x)) update(fa[x]);
        pushdown(x);
      }
      void print(int x) {
        if (!x) return;
        pushdown(x);
        print(ch[x][0]);
        printf("%lld ", x);
        print(ch[x][1]);
      }
      void rotate(int x) {
        int y = fa[x], z = fa[y], chx = getch(x), chy = getch(y);
        fa[x] = z;
        if (!isroot(y)) ch[z][chy] = x;
        ch[y][chx] = ch[x][chx ^ 1];
        fa[ch[x][chx ^ 1]] = y;
        ch[x][chx ^ 1] = y;
        fa[y] = x;
        maintain(y);
        maintain(x);
        maintain(z);
      }
      void splay(int x) {
        update(x);
        for (int f = fa[x]; f = fa[x], !isroot(x); rotate(x))
          if (!isroot(f)) rotate(getch(x) == getch(f) ? f : x);
      }
      void access(int x) {
        for (int f = 0; x; f = x, x = fa[x]) splay(x), ch[x][1] = f, maintain(x);
      }
      void makeroot(int x) {
        access(x);
        splay(x);
        swap(ch[x][0], ch[x][1]);
        rev[x] ^= 1;
      }
      int find(int x) {
        access(x);
        splay(x);
        while (ch[x][0]) x = ch[x][0];
        splay(x);
        return x;
      }
    } st;
    main() {
      scanf("%lld%lld", &n, &q);
      for (int i = 1; i <= n; i++) st.val[i] = 1, st.maintain(i);
      for (int i = 1; i < n; i++) {
        scanf("%lld%lld", &u, &v);
        if (st.find(u) != st.find(v)) st.makeroot(u), st.fa[u] = v;
      }
      while (q--) {
        scanf(" %c%lld%lld", &op, &u, &v);
        if (op == '+') {
          scanf("%lld", &c);
          st.makeroot(u), st.access(v), st.splay(v);
          st.val[v] = (st.val[v] + c) % mod;
          st.sum[v] = (st.sum[v] + st.siz[v] * c % mod) % mod;
          st.add[v] = (st.add[v] + c) % mod;
        }
        if (op == '-') {
          st.makeroot(u);
          st.access(v);
          st.splay(v);
          if (st.ch[v][0] == u && !st.ch[u][1]) st.ch[v][0] = st.fa[u] = 0;
          scanf("%lld%lld", &u, &v);
          if (st.find(u) != st.find(v)) st.makeroot(u), st.fa[u] = v;
        }
        if (op == '*') {
          scanf("%lld", &c);
          st.makeroot(u), st.access(v), st.splay(v);
          st.val[v] = st.val[v] * c % mod;
          st.sum[v] = st.sum[v] * c % mod;
          st.mul[v] = st.mul[v] * c % mod;
        }
        if (op == '/')
          st.makeroot(u), st.access(v), st.splay(v), printf("%lld\n", st.sum[v]);
      }
      return 0;
    }
    ```

### 习题

-    [luogu P3690【模板】Link Cut Tree（动态树）](https://www.luogu.org/problemnew/show/P3690) 
-    [「SDOI2011」染色](https://www.luogu.org/problemnew/show/P2486) 
-    [「SHOI2014」三叉神经树](https://loj.ac/problem/2187) 

## 维护连通性质

### 判断是否连通

借助 LCT 的 `Find()` 函数，可以判断动态森林上的两点是否连通。如果有 `Find(x)==Find(y)` ，则说明 $x,y$ 两点在一棵树上，相互连通。

???+note " 例题[「SDOI2008」洞穴勘测](https://www.luogu.org/problemnew/show/P2147)"
    一开始有 $n$ 个独立的点， $m$ 次操作。每次操作为以下之一：

    1.   `Connect u v` ：在 $u,v$ 两点之间连接一条边。
    2.   `Destroy u v` ：删除在 $u,v$ 两点之间的边，保证之前存在这样的一条边。
    3.   `Query u v` ：询问 $u,v$ 两点是否连通。

    保证在任何时刻图的形态都是一个森林。

     $n\le 10^4, m\le 2\times 10^5$ 

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    using namespace std;
    const int maxn = 10010;
    struct Splay {
      int ch[maxn][2], fa[maxn], tag[maxn];
      void clear(int x) { ch[x][0] = ch[x][1] = fa[x] = tag[x] = 0; }
      int getch(int x) { return ch[fa[x]][1] == x; }
      int isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }
      void pushdown(int x) {
        if (tag[x]) {
          if (ch[x][0]) swap(ch[ch[x][0]][0], ch[ch[x][0]][1]), tag[ch[x][0]] ^= 1;
          if (ch[x][1]) swap(ch[ch[x][1]][0], ch[ch[x][1]][1]), tag[ch[x][1]] ^= 1;
          tag[x] = 0;
        }
      }
      void update(int x) {
        if (!isroot(x)) update(fa[x]);
        pushdown(x);
      }
      void rotate(int x) {
        int y = fa[x], z = fa[y], chx = getch(x), chy = getch(y);
        fa[x] = z;
        if (!isroot(y)) ch[z][chy] = x;
        ch[y][chx] = ch[x][chx ^ 1];
        fa[ch[x][chx ^ 1]] = y;
        ch[x][chx ^ 1] = y;
        fa[y] = x;
      }
      void splay(int x) {
        update(x);
        for (int f = fa[x]; f = fa[x], !isroot(x); rotate(x))
          if (!isroot(f)) rotate(getch(x) == getch(f) ? f : x);
      }
      void access(int x) {
        for (int f = 0; x; f = x, x = fa[x]) splay(x), ch[x][1] = f;
      }
      void makeroot(int x) {
        access(x);
        splay(x);
        swap(ch[x][0], ch[x][1]);
        tag[x] ^= 1;
      }
      int find(int x) {
        access(x);
        splay(x);
        while (ch[x][0]) x = ch[x][0];
        splay(x);
        return x;
      }
    } st;
    int n, q, x, y;
    char op[maxn];
    int main() {
      scanf("%d%d", &n, &q);
      while (q--) {
        scanf("%s%d%d", op, &x, &y);
        if (op[0] == 'Q') {
          if (st.find(x) == st.find(y))
            printf("Yes\n");
          else
            printf("No\n");
        }
        if (op[0] == 'C')
          if (st.find(x) != st.find(y)) st.makeroot(x), st.fa[x] = y;
        if (op[0] == 'D') {
          st.makeroot(x);
          st.access(y);
          st.splay(y);
          if (st.ch[y][0] == x && !st.ch[x][1]) st.ch[y][0] = st.fa[x] = 0;
        }
      }
      return 0;
    }
    ```

### 维护边双连通分量

如果要求将边双连通分量缩成点，每次添加一条边，所连接的树上的两点如果相互连通，那么这条路径上的所有点都会被缩成一个点。

???+note " 例题[「AHOI2005」航线规划](https://www.luogu.org/problemnew/show/P2542)"
    给出 $n$ 个点，初始时有 $m$ 条无向边， $q$ 次操作，每次操作为以下之一：

    1.   `0 u v` ：删除 $u,v$ 之间的连边，保证此时存在这样的一条边。
    2.   `1 u v` ：查询此时 $u,v$ 两点之间可能的所有路径必须经过的边的数量。

    保证图在任意时刻都连通。

     $1<n<3\times 10^4,1<m<10^5,0\le q\le 4\times 10^4$ 

可以发现， $u,v$ 两点之间的所有可能路径必须经过的边的数量为将所有边双连通分量缩成点之后 $u$ 所在点和 $v$ 所在点之间的路径上的结点数 $-1$ 。

由于题目中的删边操作不好进行，我们考虑离线逆向进行操作，改删边为加边。

加入一条边时，如果两点原来不连通，则在 LCT 上连接两点；否则提取出加这条边之前 LCT 上这两点之间的路径，遍历辅助树上的这个子树，相当于遍历了这条路径，将这些点合并，利用并查集维护合并的信息。

用合并后并查集的代表元素代替原来树上的路径。注意之后的每次操作都要找到操作点在并查集上的代表元素进行操作。

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <map>
    using namespace std;
    const int maxn = 200010;
    int f[maxn];
    int findp(int x) { return f[x] ? f[x] = findp(f[x]) : x; }
    void merge(int x, int y) {
      x = findp(x);
      y = findp(y);
      if (x != y) f[x] = y;
    }
    struct Splay {
      int ch[maxn][2], fa[maxn], tag[maxn], siz[maxn];
      void clear(int x) { ch[x][0] = ch[x][1] = fa[x] = tag[x] = siz[x] = 0; }
      int getch(int x) { return ch[findp(fa[x])][1] == x; }
      int isroot(int x) {
        return ch[findp(fa[x])][0] != x && ch[findp(fa[x])][1] != x;
      }
      void maintain(int x) {
        clear(0);
        if (x) siz[x] = siz[ch[x][0]] + 1 + siz[ch[x][1]];
      }
      void pushdown(int x) {
        if (tag[x]) {
          if (ch[x][0]) tag[ch[x][0]] ^= 1, swap(ch[ch[x][0]][0], ch[ch[x][0]][1]);
          if (ch[x][1]) tag[ch[x][1]] ^= 1, swap(ch[ch[x][1]][0], ch[ch[x][1]][1]);
          tag[x] = 0;
        }
      }
      void print(int x) {
        if (!x) return;
        pushdown(x);
        print(ch[x][0]);
        printf("%d ", x);
        print(ch[x][1]);
      }
      void update(int x) {
        if (!isroot(x)) update(findp(fa[x]));
        pushdown(x);
      }
      void rotate(int x) {
        x = findp(x);
        int y = findp(fa[x]), z = findp(fa[y]), chx = getch(x), chy = getch(y);
        fa[x] = z;
        if (!isroot(y)) ch[z][chy] = x;
        ch[y][chx] = ch[x][chx ^ 1];
        fa[ch[x][chx ^ 1]] = y;
        ch[x][chx ^ 1] = y;
        fa[y] = x;
        maintain(y);
        maintain(x);
        if (z) maintain(z);
      }
      void splay(int x) {
        x = findp(x);
        update(x);
        for (int f = findp(fa[x]); f = findp(fa[x]), !isroot(x); rotate(x))
          if (!isroot(f)) rotate(getch(x) == getch(f) ? f : x);
      }
      void access(int x) {
        for (int f = 0; x; f = x, x = findp(fa[x]))
          splay(x), ch[x][1] = f, maintain(x);
      }
      void makeroot(int x) {
        x = findp(x);
        access(x);
        splay(x);
        tag[x] ^= 1;
        swap(ch[x][0], ch[x][1]);
      }
      int find(int x) {
        x = findp(x);
        access(x);
        splay(x);
        while (ch[x][0]) x = ch[x][0];
        splay(x);
        return x;
      }
      void dfs(int x) {
        pushdown(x);
        if (ch[x][0]) dfs(ch[x][0]), merge(ch[x][0], x);
        if (ch[x][1]) dfs(ch[x][1]), merge(ch[x][1], x);
      }
    } st;
    int n, m, q, x, y, cur, ans[maxn];
    struct oper {
      int op, a, b;
    } s[maxn];
    map<pair<int, int>, int> mp;
    int main() {
      scanf("%d%d", &n, &m);
      for (int i = 1; i <= n; i++) st.maintain(i);
      for (int i = 1; i <= m; i++)
        scanf("%d%d", &x, &y), mp[{x, y}] = mp[{y, x}] = 1;
      while (scanf("%d", &s[++q].op)) {
        if (s[q].op == -1) {
          q--;
          break;
        }
        scanf("%d%d", &s[q].a, &s[q].b);
        if (!s[q].op) mp[{s[q].a, s[q].b}] = mp[{s[q].b, s[q].a}] = 0;
      }
      reverse(s + 1, s + q + 1);
      for (map<pair<int, int>, int>::iterator it = mp.begin(); it != mp.end(); it++)
        if (it->second) {
          mp[{it->first.second, it->first.first}] = 0;
          x = findp(it->first.first);
          y = findp(it->first.second);
          if (st.find(x) != st.find(y))
            st.makeroot(x), st.fa[x] = y;
          else {
            if (x == y) continue;
            st.makeroot(x);
            st.access(y);
            st.splay(y);
            st.dfs(y);
            int t = findp(y);
            st.fa[t] = findp(st.fa[y]);
            st.ch[t][0] = st.ch[t][1] = 0;
            st.maintain(t);
          }
        }
      for (int i = 1; i <= q; i++) {
        if (s[i].op == 0) {
          x = findp(s[i].a);
          y = findp(s[i].b);
          st.makeroot(x);
          st.access(y);
          st.splay(y);
          st.dfs(y);
          int t = findp(y);
          st.fa[t] = st.fa[y];
          st.ch[t][0] = st.ch[t][1] = 0;
          st.maintain(t);
        }
        if (s[i].op == 1) {
          x = findp(s[i].a);
          y = findp(s[i].b);
          st.makeroot(x);
          st.access(y);
          st.splay(y);
          ans[++cur] = st.siz[y] - 1;
        }
      }
      for (int i = cur; i >= 1; i--) printf("%d\n", ans[i]);
      return 0;
    }
    ```

### 习题

-    [luogu P3950 部落冲突](https://www.luogu.org/problemnew/show/P3950) 
-    [bzoj 4998 星球联盟](https://www.lydsy.com/JudgeOnline/problem.php?id=4998) 
-    [bzoj 2959 长跑](https://www.lydsy.com/JudgeOnline/problem.php?id=2959) 

## 维护边权

LCT 并不能直接处理边权，此时需要对每条边建立一个对应点，方便查询链上的边信息。利用这一技巧可以动态维护生成树。

???+note " 例题[luogu P4234 最小差值生成树](https://www.luogu.org/problemnew/show/P4234)"
    给定一个 $n$ 个点， $m$ 条边的带权无向图，求其边权最大值和边权最小值的差值最小的生成树，输出这个差值。

    数据保证至少存在一棵生成树。

     $1\le n\le 5\times 10^4,1\le m\le 2\times 10^5,1\le w_i\le 10^4$ 

将边按照边权从小到大排序，枚举选择的最右边的一条边，要得到最优解，需要使边权最小边的边权最大。

每次按照顺序添加边，如果将要连接的这两个点已经连通，则删除这两点之间边权最小的一条边。如果整个图已经连通成了一棵树，则用当前边权减去最小边权更新答案。最小边权可用双指针法更新。

LCT 上没有固定的父子关系，所以不能将边权记录在点权中。

记录树链上的边的信息，可以使用 **拆边** 。对每条边建立一个对应的点，从这条边向其两个端点连接一条边，原先的连边与删边操作都变成两次操作。

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <set>
    using namespace std;
    const int maxn = 5000010;
    struct Splay {
      int ch[maxn][2], fa[maxn], tag[maxn], val[maxn], minn[maxn];
      void clear(int x) {
        ch[x][0] = ch[x][1] = fa[x] = tag[x] = val[x] = minn[x] = 0;
      }
      int getch(int x) { return ch[fa[x]][1] == x; }
      int isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }
      void maintain(int x) {
        if (!x) return;
        minn[x] = x;
        if (ch[x][0]) {
          if (val[minn[ch[x][0]]] < val[minn[x]]) minn[x] = minn[ch[x][0]];
        }
        if (ch[x][1]) {
          if (val[minn[ch[x][1]]] < val[minn[x]]) minn[x] = minn[ch[x][1]];
        }
      }
      void pushdown(int x) {
        if (tag[x]) {
          if (ch[x][0]) tag[ch[x][0]] ^= 1, swap(ch[ch[x][0]][0], ch[ch[x][0]][1]);
          if (ch[x][1]) tag[ch[x][1]] ^= 1, swap(ch[ch[x][1]][0], ch[ch[x][1]][1]);
          tag[x] = 0;
        }
      }
      void update(int x) {
        if (!isroot(x)) update(fa[x]);
        pushdown(x);
      }
      void print(int x) {
        if (!x) return;
        pushdown(x);
        print(ch[x][0]);
        printf("%d ", x);
        print(ch[x][1]);
      }
      void rotate(int x) {
        int y = fa[x], z = fa[y], chx = getch(x), chy = getch(y);
        fa[x] = z;
        if (!isroot(y)) ch[z][chy] = x;
        ch[y][chx] = ch[x][chx ^ 1];
        fa[ch[x][chx ^ 1]] = y;
        ch[x][chx ^ 1] = y;
        fa[y] = x;
        maintain(y);
        maintain(x);
        if (z) maintain(z);
      }
      void splay(int x) {
        update(x);
        for (int f = fa[x]; f = fa[x], !isroot(x); rotate(x))
          if (!isroot(f)) rotate(getch(x) == getch(f) ? f : x);
      }
      void access(int x) {
        for (int f = 0; x; f = x, x = fa[x]) splay(x), ch[x][1] = f, maintain(x);
      }
      void makeroot(int x) {
        access(x);
        splay(x);
        tag[x] ^= 1;
        swap(ch[x][0], ch[x][1]);
      }
      int find(int x) {
        access(x);
        splay(x);
        while (ch[x][0]) x = ch[x][0];
        splay(x);
        return x;
      }
      void link(int x, int y) {
        makeroot(x);
        fa[x] = y;
      }
      void cut(int x, int y) {
        makeroot(x);
        access(y);
        splay(y);
        ch[y][0] = fa[x] = 0;
        maintain(y);
      }
    } st;
    const int inf = 2e9 + 1;
    int n, m, ans, nww, x, y;
    struct Edge {
      int u, v, w;
      bool operator<(Edge x) const { return w < x.w; };
    } s[maxn];
    multiset<int> mp;
    int main() {
      scanf("%d%d", &n, &m);
      for (int i = 1; i <= n; i++) st.val[i] = inf, st.maintain(i);
      for (int i = 1; i <= m; i++) scanf("%d%d%d", &s[i].u, &s[i].v, &s[i].w);
      sort(s + 1, s + m + 1);
      for (int i = 1; i <= m; i++) st.val[n + i] = s[i].w, st.maintain(n + i);
      for (int i = 1; i <= m; i++) {
        x = s[i].u;
        y = s[i].v;
        if (x == y) continue;
        if (st.find(x) != st.find(y)) {
          nww++;
          st.link(x, n + i);
          st.link(n + i, y);
          mp.insert(s[i].w);
          if (nww == n - 1) ans = s[i].w - (*(mp.begin()++));
        } else {
          st.makeroot(x);
          st.access(y);
          st.splay(y);
          int t = st.minn[y] - n;
          st.cut(s[t].u, t + n);
          st.cut(t + n, s[t].v);
          mp.erase(mp.find(s[t].w));
          st.link(x, n + i);
          st.link(n + i, y);
          mp.insert(s[i].w);
          if (nww == n - 1) ans = min(ans, s[i].w - (*(mp.begin()++)));
        }
      }
      printf("%d\n", ans);
      return 0;
    }
    ```

### 习题

-    [「WC2006」水管局长](https://www.luogu.org/problem/P4172) 
-    [「BJWC2010」严格次小生成树](https://www.luogu.org/problemnew/show/P4180) 
-    [「NOI2014」魔法森林](https://uoj.ac/problem/3) 

## 维护子树信息

LCT 不擅长维护子树信息。统计一个结点所有虚子树的信息，就可以求得整棵树的信息。

???+note " 例题[「BJOI2014」大融合](https://loj.ac/problem/2230)"
    给定 $n$ 个结点和 $q$ 次操作，每个操作为如下形式：

    1.   `A x y` 在结点 $x$ 和 $y$ 之间连接一条边。
    2.   `Q x y` 给定一条已经存在的边 $(x,y)$ ，求有多少条简单路径，其中包含边 $(x,y)$ 。

    保证在任意时刻，图的形态都是一棵森林。

     $1\le n,q,x,y\le 10^5$ 

为询问 `Q` 考虑另一种表述，我们发现答案等于边 $(x,y)$ 在 $x$ 侧的结点数与 $y$ 侧的结点数的乘积，即将边 $(x,y)$ 断开后分别包含 $x$ 和 $y$ 的树的结点数。为了消除断边的影响，在询问后我们再次连接边 $(x,y)$ 。

题目中的操作既有连边，又有删边，还保证在任意时刻都是一棵森林，我们不由得想到用 LCT 来维护。但是这题中 LCT 维护的是子树的大小，不像我们印象中的维护一条链的信息，而 LCT 的构造 **认父不认子** ，不方便我们直接进行子树的统计。怎么办呢？

方法是统计一个结点 $x$ 所有虚儿子（即父亲为 $x$ ，但 $x$ 在 Splay 中的左右儿子并不包含 $x$ ）所代表的子树的贡献。

定义 $siz2[x]$ 为结点 $x$ 的所有虚儿子代表的子树的结点数， $siz[x]$ 为 结点 $x$ 子树中的结点数。

不同于以往我们维护 Splay 中子树结点个数的方法，我们在计算结点 $x$ 子树中的结点数时，还要加上 $siz2[x]$ ，即

```cpp
void maintain(int x) {
  clear(0);
  if (x) siz[x] = siz[ch[x][0]] + 1 + siz[ch[x][1]] + siz2[x];
}
```

而且在我们 **改变 Splay 的形态** （即改变一个结点在 Splay 上的左右儿子指向时），需要及时修改 $siz2[x]$ 的值。

在 `Rotate(),Splay()` 操作中，我们都只是改变了 Splay 中结点的相对位置，没有改变任意一条边的虚实情况，所以不对 $siz2[x]$ 进行任何修改。

在 `access` 操作中，在每次 splay 完后，都会改变刚刚 splay 完的结点的右儿子，即该结点与其原右儿子的连边和该节点和新右儿子的连边的虚实情况发生了变化，我们需要加上新变成虚边所连的子树的贡献，减去刚刚变成实边所连的子树的贡献。代码如下：

```cpp
void access(int x) {
  for (int f = 0; x; f = x, x = fa[x])
    splay(x), siz2[x] += siz[ch[x][1]] - siz[f], ch[x][1] = f, maintain(x);
}
```

在 `MakeRoot(),Find()` 操作中，我们都只是调用了之前的函数或者在 Splay 上条边，并不用做任何修改。

在连接两点时，我们修改了一个结点的父亲。我们需要在父亲结点的 $siz2$ 值中加上新子结点的子树大小贡献。

```cpp
st.makeroot(x);
st.makeroot(y);
st.fa[x] = y;
st.siz2[y] += st.siz[x];
```

在断开一条边时，我们只是删除了 Splay 上的一条实边， `Maintain` 操作会维护这些信息，不需要做任何修改。

代码修改的细节讲完了，总结一下 LCT 维护子树信息的要求与方法：

1.  维护的信息要有 **可减性** ，如子树结点数，子树权值和，但不能直接维护子树最大最小值，因为在将一条虚边变成实边时要排除原先虚边的贡献。
2.  新建一个附加值存储虚子树的贡献，在统计时将其加入本结点答案，在改变边的虚实时及时维护。
3.  其余部分同普通 LCT，在统计子树信息时一定将其作为根节点。
4.  如果维护的信息没有可减性，如维护区间最值，可以对每个结点开一个平衡树维护结点的虚子树中的最值。

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    using namespace std;
    const int maxn = 100010;
    typedef long long ll;
    struct Splay {
      int ch[maxn][2], fa[maxn], siz[maxn], siz2[maxn], tag[maxn];
      void clear(int x) {
        ch[x][0] = ch[x][1] = fa[x] = siz[x] = siz2[x] = tag[x] = 0;
      }
      int getch(int x) { return ch[fa[x]][1] == x; }
      int isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }
      void maintain(int x) {
        clear(0);
        if (x) siz[x] = siz[ch[x][0]] + 1 + siz[ch[x][1]] + siz2[x];
      }
      void pushdown(int x) {
        if (tag[x]) {
          if (ch[x][0]) swap(ch[ch[x][0]][0], ch[ch[x][0]][1]), tag[ch[x][0]] ^= 1;
          if (ch[x][1]) swap(ch[ch[x][1]][0], ch[ch[x][1]][1]), tag[ch[x][1]] ^= 1;
          tag[x] = 0;
        }
      }
      void update(int x) {
        if (!isroot(x)) update(fa[x]);
        pushdown(x);
      }
      void rotate(int x) {
        int y = fa[x], z = fa[y], chx = getch(x), chy = getch(y);
        fa[x] = z;
        if (!isroot(y)) ch[z][chy] = x;
        ch[y][chx] = ch[x][chx ^ 1];
        fa[ch[x][chx ^ 1]] = y;
        ch[x][chx ^ 1] = y;
        fa[y] = x;
        maintain(y);
        maintain(x);
        maintain(z);
      }
      void splay(int x) {
        update(x);
        for (int f = fa[x]; f = fa[x], !isroot(x); rotate(x))
          if (!isroot(f)) rotate(getch(x) == getch(f) ? f : x);
      }
      void access(int x) {
        for (int f = 0; x; f = x, x = fa[x])
          splay(x), siz2[x] += siz[ch[x][1]] - siz[f], ch[x][1] = f, maintain(x);
      }
      void makeroot(int x) {
        access(x);
        splay(x);
        swap(ch[x][0], ch[x][1]);
        tag[x] ^= 1;
      }
      int find(int x) {
        access(x);
        splay(x);
        while (ch[x][0]) x = ch[x][0];
        splay(x);
        return x;
      }
    } st;
    int n, q, x, y;
    char op;
    int main() {
      scanf("%d%d", &n, &q);
      while (q--) {
        scanf(" %c%d%d", &op, &x, &y);
        if (op == 'A') {
          st.makeroot(x);
          st.makeroot(y);
          st.fa[x] = y;
          st.siz2[y] += st.siz[x];
        }
        if (op == 'Q') {
          st.makeroot(x);
          st.access(y);
          st.splay(y);
          st.ch[y][0] = st.fa[x] = 0;
          st.maintain(x);
          st.makeroot(x);
          st.makeroot(y);
          printf("%lld\n", (ll)(st.siz[x] * st.siz[y]));
          st.makeroot(x);
          st.makeroot(y);
          st.fa[x] = y;
          st.siz2[y] += st.siz[x];
        }
      }
      return 0;
    }
    ```

### 习题

-    [luogu P4299 首都](https://www.luogu.org/problemnew/show/P4299) 
-    [SPOJ QTREE5 - Query on a tree V](https://www.luogu.org/problemnew/show/SP2939) 

# top-tree


# persistent-balanced
Split-Merge Treap

* * *

## 对于无旋 Treap 的提示

看楼上的 [Treap 词条](./treap.md) 

 **OI 常用的可持久化平衡树** 一般就是 **可持久化无旋转 Treap** 所以推荐首先学习楼上的 **无旋转 Treap** 

## 思想/做法

我们来看看旋转的 Treap，为什么不能可持久化呢？

如果带旋转，那么就会 **破环原有的父子关系** ，破环原有的路径和树形态，这是可持久化无法接受的。

如果把 Treap 变为非旋转的，我们发现可以通过可持久化 **Merge** 和 **Split** 操作就可以完成可持久化。

「一切可支持操作都可以通过 **Merge Split Newnode Build** 完成」，而 **Build** 操作只用于建造无需理会， **Newnode** （新建节点）就是用来可持久化的工具。

我们来观察一下 **Merge** 和 **Split** ，我们会发现它们都是由上而下的操作！

因此我们完全可以 **参考线段树的可持久化操作** 对它进行可持久化。

## 可持久化操作

 **可持久化** 是对 **数据结构** 的一种操作，即保留历史信息，使得在后面可以调用之前的历史版本。

对于 **可持久化线段树** 来说，每一次新建历史版本就是把 **沿途的修改路径** 复制出来

那么对可持久化 Treap（目前国内 OI 常用的版本）来说：

在复制一个节点 $X_{a}$ ( $X$ 节点的第 $a$ 个版本）的新版本 $X_{a+1}$ ( $X$ 节点的第 $a+1$ 个版本）以后：

-   如果某个儿子节点 $Y$ 不用修改信息，那么就把 $X_{a+1}$ 的指针直接指向 $Y_{a}$ ( $Y$ 节点的第 $a$ 个版本）即可。
-   反之，如果要修改 $Y$ ，那么就在 **递归到下层** 时 **新建**  $Y_{a+1}$ ( $Y$ 节点的第 $a+1$ 个版本）这个新节点用于 **存储新的信息** ，同时把 $X_{a+1}$ 的指针指向 $Y_{a+1}$ ( $Y$ 节点的第 $a+1$ 个版本）。

## 可持久化

需要的东西：

-   一个 struct 数组 存 **每个节点** 的信息（一般叫做 tree 数组）；（当然写 **指针版** 平衡树的大佬就可以考虑不用这个数组了）

-   一个 **根节点数组** ，存每个版本的_树根_，每次查询版本信息时就从 **根数组存的节点** 开始；

-   split() 分裂 **从树中分裂出两棵树** 

-   merge() 合并 **把两棵树按照随机权值合并** 

-   newNode() 新建一个节点

-   build() 建树

### Split

对于 **分裂操作** ，每次分裂路径时 **新建节点** 指向分出来的路径，用 `std::pair` 存新分裂出来的两棵树的根。

 `split(x,k)` 返回一个 `std::pair` ;

表示把 $_x$ 为根的树的前 $k$ 个元素放在 **一棵树** 中，剩下的节点构成在另一棵树中，返回这两棵树的根（first 是第一棵树的根，second 是第二棵树的）。

-   如果 $x$ 的 **左子树** 的 $key ≥ k$ ，那么 **直接递归进左子树** ，把左子树分出来的第二颗树和当前的 x **右子树** 合并。
-   否则递归 **右子树** 。

```cpp
static std::pair<int, int> _split(int _x, int k) {
  if (_x == 0)
    return std::make_pair(0, 0);
  else {
    int _vs = ++_cnt;  //新建节点（可持久化的精髓）
    _trp[_vs] = _trp[_x];
    std::pair<int, int> _y;
    if (_trp[_vs].key <= k) {
      _y = _split(_trp[_vs].leaf[1], k);
      _trp[_vs].leaf[1] = _y.first;
      _y.first = _vs;
    } else {
      _y = _split(_trp[_vs].leaf[0], k);
      _trp[_vs].leaf[0] = _y.second;
      _y.second = _vs;
    }
    _trp[_vs]._update();
    return _y;
  }
}
```

### Merge

int merge(x,y) 返回 merge 出的树的根。

同样递归实现。如果 **x 的随机权值** > **y 的随机权值** ，则 $merge(x_{rc},y)$ ，否则 $merge(x,y_{lc})$ 。

```cpp
static int _merge(int _x, int _y) {
  if (_x == 0 || _y == 0)
    return _x ^ _y;
  else {
    if (_trp[_x].fix < _trp[_y].fix) {
      _trp[_x].leaf[1] = _merge(_trp[_x].leaf[1], _y);
      _trp[_x]._update();
      return _x;
    } else {
      _trp[_y].leaf[0] = _merge(_x, _trp[_y].leaf[0]);
      _trp[_y]._update();
      return _y;
    }
  }
}
```

## Luogu P3835 可持久化平衡树

### 题目背景

本题为题目 **普通平衡树** 的可持久化加强版。

数据已经经过强化

### 题目描述

您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作（对于各个以往的历史版本）：

1.  插入 x 数

2.  删除 x 数（若有多个相同的数，因只删除一个，如果没有请忽略该操作）

3.  查询 x 数的排名（排名定义为比当前数小的数的个数 + 1。若有多个相同的数，因输出最小的排名）

4.  查询排名为 x 的数

5.  求 x 的前驱（前驱定义为小于 x，且最大的数，如不存在输出 -2147483647）

6.  求 x 的后继（后继定义为大于 x，且最小的数，如不存在输出 2147483647）

和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本（操作 3, 4, 5, 6 即保持原版本无变化）。

每个版本的编号即为操作的序号（版本 0 即为初始状态，空树）

### 输入格式

第一行为 n，表示操作的个数，下面 n 行每行有两个数 opt 和 x，opt 表示操作的序号 $(1 \leq x \leq  le6)$ 。

### 输出格式

对于操作 3,4,5,6 每行输出一个数，表示对应答案。

## 题解简述

就是 **普通平衡树** 一题的可持久化版，操作和该题类似……

只是使用了可持久化的 merge 和 split 操作

## 推荐的练手题

1.   [「Luogu P3919」可持久化数组（模板题）](https://www.luogu.org/problemnew/show/P3919) 

2.   [「Codeforces 702F」T-shirt](http://codeforces.com/problemset/problem/702/F) 

3.   [「Luogu P5055」可持久化文艺平衡树](https://www.luogu.org/problemnew/show/P5055) 

# sbt


# persistent-trie
可持久化 Trie 的方式和可持久化线段树的方式是相似的，即每次只修改被添加或值被修改的节点，而保留没有被改动的节点，在上一个版本的基础上连边，使最后每个版本的 Trie 树的根遍历所能分离出的 Trie 树都是完整且包含全部信息的。

大部分的可持久化 Trie 题中，Trie 都是以 01-Trie 的形式出现的。

??? note " 例题[最大异或和](https://www.luogu.org/problem/P4735)"
    对一个长度为 $n$ 的数组 $a$ 维护以下操作：

    1.  在数组的末尾添加一个数 $x$ ，数组的长度 $n$ 自增 $1$ 。
    2.  给出查询区间 $[l,r]$ 和一个值 $k$ ，求当 $l\le p\le r$ 时， $k \oplus \bigoplus^{n}_{i=p} a_i$ 。

这个求的值可能有些麻烦，利用常用的处理连续异或的方法，记 $s_x=\bigoplus_{i=1}^x a_i$ ，则原式等价于 $s_{p-1}\oplus s_n\oplus k$ ，观察到 $s_n \oplus k$ 在查询的过程中是固定的，题目的查询变化为查询在区间 $[l-1,r-1]$ 中异或定值（ $s_n\oplus k$ ）的最大值。

继续按类似于可持久化线段树的思路，考虑每次的查询都查询整个区间。我们只需把这个区间建一棵 Trie 树，将这个区间中的每个树都加入这棵 Trie 中，查询的时候，尽量往与当前位不相同的地方跳。

查询区间，只需要利用前缀和和差分的思想，用两棵前缀 Trie 树（也就是按顺序添加数的两个历史版本）相减即为该区间的线段树。再利用动态开点的思想，不添加没有计算过的点，以减少空间占用。

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 600010;
int n, q, a[maxn], s[maxn], l, r, x;
char op;
struct Trie {
  int cnt, rt[maxn], ch[maxn * 33][2], val[maxn * 33];
  void insert(int o, int lst, int v) {
    for (int i = 28; i >= 0; i--) {
      val[o] = val[lst] + 1;  //在原版本的基础上更新
      if ((v & (1 << i)) == 0) {
        if (!ch[o][0]) ch[o][0] = ++cnt;
        ch[o][1] = ch[lst][1];
        o = ch[o][0];
        lst = ch[lst][0];
      } else {
        if (!ch[o][1]) ch[o][1] = ++cnt;
        ch[o][0] = ch[lst][0];
        o = ch[o][1];
        lst = ch[lst][1];
      }
    }
    val[o] = val[lst] + 1;
    // printf("%d\n",o);
  }
  int query(int o1, int o2, int v) {
    int ret = 0;
    for (int i = 28; i >= 0; i--) {
      // printf("%d %d %d\n",o1,o2,val[o1]-val[o2]);
      int t = ((v & (1 << i)) ? 1 : 0);
      if (val[ch[o1][!t]] - val[ch[o2][!t]])
        ret += (1 << i), o1 = ch[o1][!t], o2 = ch[o2][!t];  //尽量向不同的地方跳
      else
        o1 = ch[o1][t], o2 = ch[o2][t];
    }
    return ret;
  }
} st;
int main() {
  scanf("%d%d", &n, &q);
  for (int i = 1; i <= n; i++) scanf("%d", a + i), s[i] = s[i - 1] ^ a[i];
  for (int i = 1; i <= n; i++)
    st.rt[i] = ++st.cnt, st.insert(st.rt[i], st.rt[i - 1], s[i]);
  while (q--) {
    scanf(" %c", &op);
    if (op == 'A') {
      n++;
      scanf("%d", a + n);
      s[n] = s[n - 1] ^ a[n];
      st.rt[n] = ++st.cnt;
      st.insert(st.rt[n], st.rt[n - 1], s[n]);
    }
    if (op == 'Q') {
      scanf("%d%d%d", &l, &r, &x);
      l--;
      r--;
      if (l == r && l == 0)
        printf("%d\n", s[n] ^ x);  //记得处理 l=r=1 的情况
      else
        printf("%d\n", st.query(st.rt[r], st.rt[max(l - 1, 0)], x ^ s[n]));
    }
  }
  return 0;
}
```

# leftist-tree
## 什么是左偏树？

 **左偏树** 与 [ **配对堆** ](./pairing-heap.md) 一样，是一种 **可并堆** ，具有堆的性质，并且可以快速合并。

## dist 的定义和性质

对于一棵二叉树，我们定义 **外节点** 为左儿子或右儿子为空的节点，定义一个外节点的 $\mathrm{dist}$ 为 $1$ ，一个不是外节点的节点 $\mathrm{dist}$ 为其到子树中最近的外节点的距离加一。空节点的 $\mathrm{dist}$ 为 $0$ 。

> 注：很多其它教程中定义的 $\mathrm{dist}$ 都是本文中的 $\mathrm{dist}$ 减去 $1$ ，本文这样定义是因为代码写起来方便。

一棵有 $n$ 个节点的二叉树，根的 $\mathrm{dist}$ 不超过 $\left\lceil\log (n+1)\right\rceil$ ，因为一棵根的 $\mathrm{dist}$ 为 $x$ 的二叉树至少有 $x-1$ 层是满二叉树，那么就至少有 $2^x-1$ 个节点。注意这个性质是所有二叉树都具有的，并不是左偏树所特有的。

## 左偏树的定义和性质

左偏树是一棵二叉树，它不仅具有堆的性质，并且是「左偏」的：每个节点左儿子的 $\mathrm{dist}$ 都大于等于右儿子的 $\mathrm{dist}$ 。

因此，左偏树每个节点的 $\mathrm{dist}$ 都等于其右儿子的 $\mathrm{dist}$ 加一。

需要注意的是， $\mathrm{dist}$ 不是深度， **左偏树的深度没有保证** ，一条向左的链也是左偏树。

## 核心操作：合并（merge)

合并两个堆时，由于要满足堆性质，先取值较小（为了方便，本文讨论小根堆）的那个根作为合并后堆的根节点，然后将这个根的左儿子作为合并后堆的左儿子，递归地合并其右儿子与另一个堆，作为合并后的堆的右儿子。为了满足左偏性质，合并后若左儿子的 $\mathrm{dist}$ 小于右儿子的 $\mathrm{dist}$ ，就交换两个儿子。

参考代码：

```cpp
int merge(int x, int y) {
  if (!x || !y) return x | y;  // 若一个堆为空则返回另一个堆
  if (t[x].val > t[y].val) swap(x, y);  // 取值较小的作为根
  t[x].rs = merge(t[x].rs, y);          // 递归合并右儿子与另一个堆
  if (t[t[x].rs].d > t[t[x].ls].d)
    swap(t[x].ls, t[x].rs);   // 若不满足左偏性质则交换左右儿子
  t[x].d = t[t[x].rs].d + 1;  // 更新dist
  return x;
}
```

由于左偏性质，每递归一层，其中一个堆根节点的 $\mathrm{dist}$ 就会减小 $1$ ，而“一棵有 $n$ 个节点的二叉树，根的 $\mathrm{dist}$ 不超过 $\left\lceil\log (n+1)\right\rceil$ ”，所以合并两个大小分别为 $n$ 和 $m$ 的堆复杂度是 $O(\log n+\log m)$ 。

左偏树还有一种无需交换左右儿子的写法：将 $\mathrm{dist}$ 较大的儿子视作左儿子， $\mathrm{dist}$ 较小的儿子视作右儿子：

```cpp
int& rs(int x) { return t[x].ch[t[t[x].ch[1]].d < t[t[x].ch[0]].d]; }

int merge(int x, int y) {
  if (!x || !y) return x | y;
  if (t[x].val < t[y].val) swap(x, y);
  rs(x) = merge(rs(x), y);
  t[x].d = t[rs(x)].d + 1;
  return x;
}
```

## 左偏树的其它操作

### 插入节点

单个节点也可以视为一个堆，合并即可。

### 删除根

合并根的左右儿子即可。

### 删除任意节点

#### 做法

先将左右儿子合并，然后自底向上更新 $\mathrm{dist}$ 、不满足左偏性质时交换左右儿子，当 $\mathrm{dist}$ 无需更新时结束递归：

```cpp
int& rs(int x) { return t[x].ch[t[t[x].ch[1]].d < t[t[x].ch[0]].d]; }

// 有了 pushup，直接 merge 左右儿子就实现了删除节点并保持左偏性质
int merge(int x, int y) {
  if (!x || !y) return x | y;
  if (t[x].val < t[y].val) swap(x, y);
  t[rs(x) = merge(rs(x), y)].fa = x;
  pushup(x);
  return x;
}

void pushup(int x) {
  if (!x) return;
  if (t[x].d != t[rs(x)].d + 1) {
    t[x].d = t[rs(x)].d + 1;
    pushup(t[x].fa);
  }
}
```

#### 复杂度证明

我们令当前 `pushup` 的这个节点为 $x$ ，其父亲为 $y$ ，一个节点的“初始 $\mathrm{dist}$ ”为它在 `pushup` 前的 $\mathrm{dist}$ 。我们先 `pushup` 一下删除的节点，然后从其父亲开始起讨论复杂度。

继续递归下去有两种情况：

1.   $x$ 是 $y$ 的右儿子，此时 $y$ 的初始 $\mathrm{dist}$ 为 $x$ 的初始 $\mathrm{dist}$ 加一。
2.   $x$ 是 $y$ 的左儿子，只有 $y$ 的左右儿子初始 $\mathrm{dist}$ 相等时（此时左儿子 $\mathrm{dist}$ 减一会导致左右儿子互换）才会继续递归下去，因此 $y$ 的初始 $\mathrm{dist}$ 仍然是 $x$ 的初始 $\mathrm{dist}$ 加一。

所以，我们得到，除了第一次 `pushup` （因为被删除节点的父亲的初始 $\mathrm{dist}$ 不一定等于被删除节点左右儿子合并后的初始 $\mathrm{dist}$ 加一），每递归一层 $x$ 的初始 $\mathrm{dist}$ 就会加一，因此最多递归 $O(\log n)$ 层。

### 整个堆加上/减去一个值、乘上一个正数

其实可以打标记且不改变相对大小的操作都可以。

在根打上标记，删除根/合并堆（访问儿子）时下传标记即可：

```cpp
int merge(int x, int y) {
  if (!x || !y) return x | y;
  if (t[x].val > t[y].val) swap(x, y);
  pushdown(x);
  t[x].rs = merge(t[x].rs, y);
  if (t[t[x].rs].d > t[t[x].ls].d) swap(t[x].ls, t[x].rs);
  t[x].d = t[t[x].rs].d + 1;
  return x;
}

int pop(int x) {
  pushdown(x);
  return merge(t[x].ls, t[x].rs);
}
```

## 例题

### 模板题

 [luogu P3377【模板】左偏树（可并堆）](https://www.luogu.org/problemnew/show/P3377) 

 [Monkey King](https://www.luogu.org/problemnew/show/P1456) 

 [罗马游戏](https://www.luogu.org/problemnew/show/P2713) 

需要注意的是：

1.  合并前要检查是否已经在同一堆中。

2.  左偏树的深度可能达到 $O(n)$ ，因此找一个点所在的堆顶要用并查集维护，不能直接暴力跳父亲。（虽然很多题数据水，暴力跳父亲可以过……）（用并查集维护根时要保证原根指向新根，新根指向自己。）

??? "罗马游戏参考代码"
    ```cpp
    #include <algorithm>
    #include <cctype>
    #include <cstdio>
    #include <iostream>
    
    using namespace std;
    
    int read() {
      int out = 0;
      char c;
      while (!isdigit(c = getchar()))
        ;
      for (; isdigit(c); c = getchar()) out = out * 10 + c - '0';
      return out;
    }
    
    const int N = 1000010;
    
    struct Node {
      int val, ch[2], d;
    } t[N];
    
    int& rs(int x);
    int merge(int x, int y);
    
    int find(int x);
    
    int n, m, f[N];
    bool kill[N];
    char op[10];
    
    int main() {
      int i, x, y;
    
      n = read();
    
      for (i = 1; i <= n; ++i) {
        t[i].val = read();
        f[i] = i;
      }
    
      m = read();
    
      while (m--) {
        scanf("%s", op);
        if (op[0] == 'M') {
          x = read();
          y = read();
          if (kill[x] || kill[y] || find(x) == find(y)) continue;
          f[find(x)] = f[find(y)] = merge(find(x), find(y));
        } else {
          x = read();
          if (!kill[x]) {
            x = find(x);
            kill[x] = true;
            f[x] = f[t[x].ch[0]] = f[t[x].ch[1]] = merge(t[x].ch[0], t[x].ch[1]);
            // 由于堆中的点会 find 到 x，所以 f[x] 也要修改
            printf("%d\n", t[x].val);
          } else
            puts("0");
        }
      }
    
      return 0;
    }
    
    int& rs(int x) { return t[x].ch[t[t[x].ch[1]].d < t[t[x].ch[0]].d]; }
    
    int merge(int x, int y) {
      if (!x || !y) return x | y;
      if (t[x].val > t[y].val) swap(x, y);
      rs(x) = merge(rs(x), y);
      t[x].d = t[rs(x)].d + 1;
      return x;
    }
    
    int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }
    ```

### 树上问题

 [「APIO2012」派遣](https://www.luogu.org/problemnew/show/P1552) 

 [「JLOI2015」城池攻占](https://loj.ac/problem/2107) 

这类题目往往是每个节点维护一个堆，与儿子合并，依题意弹出、修改、计算答案，有点像线段树合并的类似题目。

??? "城池攻占参考代码"
    ```cpp
    #include <algorithm>
    #include <cctype>
    #include <cstdio>
    #include <iostream>
    
    using namespace std;
    
    typedef long long ll;
    
    ll read() {
      ll out = 0;
      int f = 1;
      char c;
      for (c = getchar(); !isdigit(c) && c != '-'; c = getchar())
        ;
      if (c == '-') f = -1, c = getchar();
      for (; isdigit(c); c = getchar()) out = out * 10 + c - '0';
      return out * f;
    }
    
    const int N = 300010;
    
    struct Node {
      int ls, rs, d;
      ll val, add, mul;
      Node() {
        ls = rs = add = 0;
        d = mul = 1;
      }
    } t[N];
    
    int merge(int x, int y);
    int pop(int x);
    void madd(int u, ll x);
    void mmul(int u, ll x);
    void pushdown(int x);
    
    void add(int u, int v);
    void dfs(int u);
    
    int head[N], nxt[N], to[N], cnt;
    int n, m, p[N], f[N], a[N], dep[N], c[N], ans1[N],
        ans2[N];  // p是树上每个点对应的堆顶
    ll h[N], b[N];
    
    int main() {
      int i;
    
      n = read();
      m = read();
    
      for (i = 1; i <= n; ++i) h[i] = read();
    
      for (i = 2; i <= n; ++i) {
        f[i] = read();
        add(f[i], i);
        a[i] = read();
        b[i] = read();
      }
    
      for (i = 1; i <= m; ++i) {
        t[i].val = read();
        c[i] = read();
        p[c[i]] = merge(i, p[c[i]]);
      }
    
      dfs(1);
    
      for (i = 1; i <= n; ++i) printf("%d\n", ans1[i]);
      for (i = 1; i <= m; ++i) printf("%d\n", ans2[i]);
    
      return 0;
    }
    
    void dfs(int u) {
      int i, v;
      for (i = head[u]; i; i = nxt[i]) {
        v = to[i];
        dep[v] = dep[u] + 1;
        dfs(v);
      }
      while (p[u] && t[p[u]].val < h[u]) {
        ++ans1[u];
        ans2[p[u]] = dep[c[p[u]]] - dep[u];
        p[u] = pop(p[u]);
      }
      if (a[u])
        mmul(p[u], b[u]);
      else
        madd(p[u], b[u]);
      if (u > 1)
        p[f[u]] = merge(p[u], p[f[u]]);
      else
        while (p[u]) {
          ans2[p[u]] = dep[c[p[u]]] + 1;
          p[u] = pop(p[u]);
        }
    }
    
    void add(int u, int v) {
      nxt[++cnt] = head[u];
      head[u] = cnt;
      to[cnt] = v;
    }
    
    int merge(int x, int y) {
      if (!x || !y) return x | y;
      if (t[x].val > t[y].val) swap(x, y);
      pushdown(x);
      t[x].rs = merge(t[x].rs, y);
      if (t[t[x].rs].d > t[t[x].ls].d) swap(t[x].ls, t[x].rs);
      t[x].d = t[t[x].rs].d + 1;
      return x;
    }
    
    int pop(int x) {
      pushdown(x);
      return merge(t[x].ls, t[x].rs);
    }
    
    void madd(int u, ll x) {
      t[u].val += x;
      t[u].add += x;
    }
    
    void mmul(int u, ll x) {
      t[u].val *= x;
      t[u].add *= x;
      t[u].mul *= x;
    }
    
    void pushdown(int x) {
      mmul(t[x].ls, t[x].mul);
      madd(t[x].ls, t[x].add);
      mmul(t[x].rs, t[x].mul);
      madd(t[x].rs, t[x].add);
      t[x].add = 0;
      t[x].mul = 1;
    }
    ```

###  [「SCOI2011」棘手的操作](https://loj.ac/problem/2441) 

首先，找一个节点所在堆的堆顶要用并查集，而不能暴力向上跳。

再考虑单点查询，若用普通的方法打标记，就得查询点到根路径上的标记之和，最坏情况下可以达到 $O(n)$ 的复杂度。如果只有堆顶有标记，就可以快速地查询了，但如何做到呢？

可以用类似启发式合并的方式，每次合并的时候把较小的那个堆标记暴力下传到每个节点，然后把较大的堆的标记作为合并后的堆的标记。由于合并后有另一个堆的标记，所以较小的堆下传标记时要下传其标记减去另一个堆的标记。由于每个节点每被合并一次所在堆的大小至少乘二，所以每个节点最多被下放 $O(\log n)$ 次标记，暴力下放标记的总复杂度就是 $O(n\log n)$ 。

再考虑单点加，先删除，再更新，最后插入即可。

然后是全局最大值，可以用一个平衡树/支持删除任意节点的堆（如左偏树）/multiset 来维护每个堆的堆顶。

所以，每个操作分别如下：

1.  暴力下传点数较小的堆的标记，合并两个堆，更新 size、tag，在 multiset 中删去合并后不在堆顶的那个原堆顶。
2.  删除节点，更新值，插入回来，更新 multiset。需要分删除节点是否为根来讨论一下。
3.  堆顶打标记，更新 multiset。
4.  打全局标记。
5.  查询值 + 堆顶标记 + 全局标记。
6.  查询根的值 + 堆顶标记 + 全局标记。
7.  查询 multiset 最大值 + 全局标记。

??? "棘手的操作参考代码"
    ```cpp
    #include <algorithm>
    #include <cctype>
    #include <cstdio>
    #include <iostream>
    #include <set>
    
    using namespace std;
    
    int read() {
      int out = 0, f = 1;
      char c;
      for (c = getchar(); !isdigit(c) && c != '-'; c = getchar())
        ;
      if (c == '-') {
        f = -1;
        c = getchar();
      }
      for (; isdigit(c); c = getchar()) out = out * 10 + c - '0';
      return out * f;
    }
    
    const int N = 300010;
    
    struct Node {
      int val, ch[2], d, fa;
    } t[N];
    
    int& rs(int x);
    int merge(int x, int y);
    void pushup(int x);
    void pushdown(int x, int y);
    
    int find(int x);
    
    int n, m, f[N], tag[N], siz[N], delta;
    char op[10];
    multiset<int> s;
    
    int main() {
      int i, x, y;
    
      n = read();
    
      for (i = 1; i <= n; ++i) {
        t[i].val = read();
        f[i] = i;
        siz[i] = 1;
        s.insert(t[i].val);
      }
    
      m = read();
    
      while (m--) {
        scanf("%s", op);
        if (op[0] == 'U') {
          x = find(read());
          y = find(read());
          if (x != y) {
            if (siz[x] > siz[y]) swap(x, y);
            pushdown(x, tag[x] - tag[y]);
            f[x] = f[y] = merge(x, y);
            if (f[x] == x) {
              s.erase(s.find(t[y].val + tag[y]));
              tag[x] = tag[y];
              siz[x] += siz[y];
              tag[y] = siz[y] = 0;
            } else {
              s.erase(s.find(t[x].val + tag[y]));
              siz[y] += siz[x];
              tag[x] = siz[x] = 0;
            }
          }
        } else if (op[0] == 'A') {
          if (op[1] == '1') {
            x = read();
            if (x == find(x)) {
              t[t[x].ch[0]].fa = t[t[x].ch[1]].fa = 0;
              y = merge(t[x].ch[0], t[x].ch[1]);
              s.erase(s.find(t[x].val + tag[x]));
              t[x].val += read();
              t[x].fa = t[x].ch[0] = t[x].ch[1] = 0;
              t[x].d = 1;
              f[x] = f[y] = merge(x, y);
              s.insert(t[f[x]].val + tag[x]);
              if (f[x] == y) {
                tag[y] = tag[x];
                siz[y] = siz[x];
                tag[x] = siz[x] = 0;
              }
            } else {
              t[t[x].ch[0]].fa = t[t[x].ch[1]].fa = t[x].fa;
              t[t[x].fa].ch[x == t[t[x].fa].ch[1]] = merge(t[x].ch[0], t[x].ch[1]);
              t[x].val += read();
              t[x].fa = t[x].ch[0] = t[x].ch[1] = 0;
              t[x].d = 1;
              y = find(x);
              f[x] = f[y] = merge(x, y);
              if (f[x] == x) {
                s.erase(s.find(t[y].val + tag[y]));
                s.insert(t[x].val + tag[y]);
                tag[x] = tag[y];
                siz[x] = siz[y];
                tag[y] = siz[y] = 0;
              }
            }
          } else if (op[1] == '2') {
            x = find(read());
            s.erase(s.find(t[x].val + tag[x]));
            tag[x] += read();
            s.insert(t[x].val + tag[x]);
          } else
            delta += read();
        } else {
          if (op[1] == '1') {
            x = read();
            printf("%d\n", t[x].val + tag[find(x)] + delta);
          } else if (op[1] == '2') {
            x = find(read());
            printf("%d\n", t[x].val + tag[x] + delta);
          } else
            printf("%d\n", *s.rbegin() + delta);
        }
      }
    
      return 0;
    }
    
    int& rs(int x) { return t[x].ch[t[t[x].ch[1]].d < t[t[x].ch[0]].d]; }
    
    int merge(int x, int y) {
      if (!x || !y) return x | y;
      if (t[x].val < t[y].val) swap(x, y);
      t[rs(x) = merge(rs(x), y)].fa = x;
      pushup(x);
      return x;
    }
    
    void pushup(int x) {
      if (!x) return;
      if (t[x].d != t[rs(x)].d + 1) {
        t[x].d = t[rs(x)].d + 1;
        pushup(t[x].fa);
      }
    }
    
    void pushdown(int x, int y) {
      if (!x) return;
      t[x].val += y;
      pushdown(t[x].ch[0], y);
      pushdown(t[x].ch[1], y);
    }
    
    int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }
    ```

###  [「BOI2004」Sequence 数字序列](https://www.luogu.org/problemnew/show/P4331) 

这是一道论文题，详见 [《黄源河 -- 左偏树的特点及其应用》](https://github.com/OI-wiki/libs/blob/master/%E9%9B%86%E8%AE%AD%E9%98%9F%E5%8E%86%E5%B9%B4%E8%AE%BA%E6%96%87/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2005%E8%AE%BA%E6%96%87%E9%9B%86/%E9%BB%84%E6%BA%90%E6%B2%B3--%E5%B7%A6%E5%81%8F%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E9%BB%84%E6%BA%90%E6%B2%B3.pdf) 。

# seg-in-seg
author: Chrogeek, HeRaNO, Dev-XYS, Dev-jqe

## 常见用途

在算法竞赛中，我们有时需要维护多维度信息。在这种时候，我们经常需要树套树来记录信息。

## 实现原理

我们考虑用树套树如何实现在二维平面上进行单点修改，区域查询。我们考虑外层的线段树，最底层的 $1$ 到 $n$ 个节点的子树，分别代表第 $1$ 到第 $n$ 行的线段树。那么这些底层的节点对应的父节点，就代表其两个子节点的子树所在的一片区域。

## 空间复杂度

通常情况下，我们不可能对于外层线段树的每一个结点都建立一颗子线段树，空间需求过大。树套树一般采取动态开点的策略。单次修改，我们会涉及到外层线段树的 $\log{n}$ 个节点，且对于每个节点的子树涉及 $\log{n}$ 个节点，所以单次修改产生的空间最多为 $\log^2{n}$ 。

## 时间复杂度

对于询问操作，我们考虑我们在外层线段树上进行 $\log{n}$ 次操作，每次操作会在一个内层线段树上进行 $\log{n}$ 次操作，所以时间复杂度为 $\log^2{n}$ 。
修改操作，与询问操作复杂度相同，也为 $\log^2{n}$ 。

## 经典例题

 [陌上花开](https://www.luogu.org/problem/P3810) 将第一维排序处理，然后用树套树维护第二维和第三维。

## 示例代码

第二维查询

```cpp
int tree_query(int k, int l, int r, int x) {
  if (k == 0) return 0;
  if (1 <= l && r <= sec[x].y) return vec_query(ou_root[k], 1, p, 1, sec[x].z);
  int mid = l + r >> 1, res = 0;
  if (1 <= mid) res += tree_query(ou_ch[k][0], l, mid, x);
  if (sec[x].y > mid) res += tree_query(ou_ch[k][1], mid + 1, r, x);
  return res;
}
```

第二维修改

```cpp
void tree_insert(int &k, int l, int r, int x) {
  if (k == 0) k = ++ou_tot;
  vec_insert(ou_root[k], 1, p, sec[x].z);
  if (l == r) return;
  int mid = l + r >> 1;
  if (sec[x].y <= mid)
    tree_insert(ou_ch[k][0], l, mid, x);
  else
    tree_insert(ou_ch[k][1], mid + 1, r, x);
}
```

第三维查询

```cpp
int vec_query(int k, int l, int r, int x, int y) {
  if (k == 0) return 0;
  if (x <= l && r <= y) return data[k];
  int mid = l + r >> 1, res = 0;
  if (x <= mid) res += vec_query(ch[k][0], l, mid, x, y);
  if (y > mid) res += vec_query(ch[k][1], mid + 1, r, x, y);
  return res;
}
```

第三维修改

```cpp
void vec_insert(int &k, int l, int r, int loc) {
  if (k == 0) k = ++tot;
  data[k]++;
  if (l == r) return;
  int mid = l + r >> 1;
  if (loc <= mid) vec_insert(ch[k][0], l, mid, loc);
  if (loc > mid) vec_insert(ch[k][1], mid + 1, r, loc);
}
```

## 相关算法

面对多维度信息的题目时，如果题目没有要求强制在线，我们还可以考虑 **CDQ 分治** ，或者 **整体二分** 等分治算法，来避免使用高级数据结构，减少代码实现难度。

# seg-beats
本文讲解吉老师在 2016 年国家集训队论文中提到的线段树处理历史区间最值的问题。

## 区间最值

笼统地说，区间最值操作指，将区间 $[l,r]$ 的数全部对 $x$ 取 $\max$ 或 $\min$ ，即 $a_i=\max(a_i,x)$ 或者 $a_i=\min(a_i,x)$ 。给一道例题吧。

### HDU5306 Gorgeous Sequence

> 维护一个序列 $a$ ：
>
> 1.   `0 l r t`  $\forall l\le i\le r,\ a_i=\min(a_i,t)$ 。
> 2.   `1 l r` 输出区间 $[l,r]$ 中的最大值。
> 3.   `2 l r` 输出区间和。
>
> 多组数据， $T\le 100,n\le 10^6,\sum m\le 10^6$ 。

区间取 min，意味着只对那些大于 $t$ 的数有更改。因此这个操作的对象不再是整个区间，而是“这个区间中大于 $t$ 的数”。于是我们可以有这样的思路：每个结点维护该区间的最大值 $Max$ 、次大值 $Se$ 、区间和 $Sum$ 以及最大值的个数 $Cnt$ 。接下来我们考虑区间对 $t$ 取 $\min$ 的操作。

1.  如果 $Max\le t$ ，显然这个 $t$ 是没有意义的，直接返回；
2.  如果 $Se<t\le Max$ ，那么这个 $t$ 就能更新当前区间中的最大值。于是我们让区间和加上 $Cnt(t-Max)$ ，然后更新 $Max$ 为 $t$ ，并打一个标记。
3.  如果 $t\le Se$ ，那么这时你发现你不知道有多少个数涉及到更新的问题。于是我们的策略就是，暴力递归向下操作。然后上传信息。

这个算法的复杂度如何？使用势能分析法可以得到复杂度是 $O(m\log n)$ 的。具体分析过程见论文。

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
using namespace std;
const int N = 1e6 + 6;

char nc() {
  static char buf[1000000], *p = buf, *q = buf;
  return p == q && (q = (p = buf) + fread(buf, 1, 1000000, stdin), p == q)
             ? EOF
             : *p++;
}
int rd() {
  int res = 0;
  char c = nc();
  while (!isdigit(c)) c = nc();
  while (isdigit(c)) res = res * 10 + c - '0', c = nc();
  return res;
}

int t, n, m;
int a[N];
int mx[N << 2], se[N << 2], cn[N << 2], tag[N << 2];
long long sum[N << 2];
inline void pushup(int u) {  // 向上更新标记
  const int ls = u << 1, rs = u << 1 | 1;
  sum[u] = sum[ls] + sum[rs];
  if (mx[ls] == mx[rs]) {
    mx[u] = mx[rs];
    se[u] = max(se[ls], se[rs]);
    cn[u] = cn[ls] + cn[rs];
  } else if (mx[ls] > mx[rs]) {
    mx[u] = mx[ls];
    se[u] = max(se[ls], mx[rs]);
    cn[u] = cn[ls];
  } else {
    mx[u] = mx[rs];
    se[u] = max(mx[ls], se[rs]);
    cn[u] = cn[rs];
  }
}
inline void pushtag(int u, int tg) {  // 单纯地打标记，不暴搜
  if (mx[u] <= tg) return;
  sum[u] += (1ll * tg - mx[u]) * cn[u];
  mx[u] = tag[u] = tg;
}
inline void pushdown(int u) {
  if (tag[u] == -1) return;
  pushtag(u << 1, tag[u]), pushtag(u << 1 | 1, tag[u]);
  tag[u] = -1;
}
void build(int u = 1, int l = 1, int r = n) {
  tag[u] = -1;
  if (l == r) {
    sum[u] = mx[u] = a[l], se[u] = -1, cn[u] = 1;
    return;
  }
  int mid = (l + r) >> 1;
  build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
  pushup(u);
}
void modify_min(int L, int R, int v, int u = 1, int l = 1, int r = n) {
  if (mx[u] <= v) return;
  if (L <= l && r <= R && se[u] < v) return pushtag(u, v);
  int mid = (l + r) >> 1;
  pushdown(u);
  if (L <= mid) modify_min(L, R, v, u << 1, l, mid);
  if (mid < R) modify_min(L, R, v, u << 1 | 1, mid + 1, r);
  pushup(u);
}
int query_max(int L, int R, int u = 1, int l = 1, int r = n) {
  if (L <= l && r <= R) return mx[u];
  int mid = (l + r) >> 1, r1 = -1, r2 = -1;
  pushdown(u);
  if (L <= mid) r1 = query_max(L, R, u << 1, l, mid);
  if (mid < R) r2 = query_max(L, R, u << 1 | 1, mid + 1, r);
  return max(r1, r2);
}
long long query_sum(int L, int R, int u = 1, int l = 1, int r = n) {
  if (L <= l && r <= R) return sum[u];
  int mid = (l + r) >> 1;
  long long res = 0;
  pushdown(u);
  if (L <= mid) res += query_sum(L, R, u << 1, l, mid);
  if (mid < R) res += query_sum(L, R, u << 1 | 1, mid + 1, r);
  return res;
}
void go() {
  n = rd(), m = rd();
  for (int i = 1; i <= n; i++) a[i] = rd();
  build();
  for (int i = 1; i <= m; i++) {
    int op, x, y, z;
    op = rd(), x = rd(), y = rd();
    if (op == 0)
      z = rd(), modify_min(x, y, z);
    else if (op == 1)
      printf("%d\n", query_max(x, y));
    else
      printf("%lld\n", query_sum(x, y));
  }
}
signed main() {
  t = rd();
  while (t--) go();
  return 0;
}
```

### BZOJ4695 最假女选手

> 长度为 $n$ 的序列，支持区间加 $x$ /区间对 $x$ 取 $\max$ /区间对 $x$ 取 $\min$ /求区间和/求区间最大值/求区间最小值。
>
>  $N,M\le 5\times 10^5,|A_i|\le 10^8$ 。

同样的方法，我们维护最大、次大、最大个数、最小、次小、最小个数、区间和。除了这些信息，我们还需要维护区间 $\max$ 、区间 $\min$ 、区间加的标记。相比上一道题，这就涉及到标记下传的顺序问题了。我们采用这样的策略：

1.  我们认为区间加的标记是最优先的，其余两种标记地位平等。
2.  对一个结点加上一个 $v$ 标记，除了用 $v$ 更新卫星信息和当前结点的区间加标记外，我们用这个 v 更新区间 $\max$ 和区间 $\min$ 的标记。
3.  对一个结点取 $v$ 的 $\min$ （这里忽略暴搜的过程，假定标记满足添加的条件），除了更新卫星信息，我们要与区间 $\max$ 的标记做比较。如果 $v$ 小于区间 $\max$ 的标记，则所有的数最后都会变成 v，那么把区间 $\max$ 的标记也变成 $v$ 。否则不管。
4.  区间取 v 的 $\max$ 同理。

另外，BZOJ 这道题卡常……多数组线段树的常数比结构体线段树的常数大……在维护信息的时侯，当只有一两个数的时侯可能发生数集重合，比如一个数既是最大值又是次小值。这种要特判。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int inline rd() {
  register char act = 0;
  register int f = 1, x = 0;
  while (act = getchar(), act < '0' && act != '-')
    ;
  if (act == '-') f = -1, act = getchar();
  x = act - '0';
  while (act = getchar(), act >= '0') x = x * 10 + act - '0';
  return x * f;
}

const int N = 5e5 + 5, SZ = N << 2, INF = 0x7fffffff;

int n, m;
int a[N];

struct data {
  int mx, mx2, mn, mn2, cmx, cmn, tmx, tmn, tad;
  long long sum;
};
data t[SZ];

void pushup(int u) {
  const int lu = u << 1, ru = u << 1 | 1;
  t[u].sum = t[lu].sum + t[ru].sum;
  if (t[lu].mx == t[ru].mx) {
    t[u].mx = t[lu].mx, t[u].cmx = t[lu].cmx + t[ru].cmx;
    t[u].mx2 = max(t[lu].mx2, t[ru].mx2);
  } else if (t[lu].mx > t[ru].mx) {
    t[u].mx = t[lu].mx, t[u].cmx = t[lu].cmx;
    t[u].mx2 = max(t[lu].mx2, t[ru].mx);
  } else {
    t[u].mx = t[ru].mx, t[u].cmx = t[ru].cmx;
    t[u].mx2 = max(t[lu].mx, t[ru].mx2);
  }
  if (t[lu].mn == t[ru].mn) {
    t[u].mn = t[lu].mn, t[u].cmn = t[lu].cmn + t[ru].cmn;
    t[u].mn2 = min(t[lu].mn2, t[ru].mn2);
  } else if (t[lu].mn < t[ru].mn) {
    t[u].mn = t[lu].mn, t[u].cmn = t[lu].cmn;
    t[u].mn2 = min(t[lu].mn2, t[ru].mn);
  } else {
    t[u].mn = t[ru].mn, t[u].cmn = t[ru].cmn;
    t[u].mn2 = min(t[lu].mn, t[ru].mn2);
  }
}
void push_add(int u, int l, int r, int v) {
  // 更新加法标记的同时，更新 $\min$ 和 $\max$ 标记
  t[u].sum += (r - l + 1ll) * v;
  t[u].mx += v, t[u].mn += v;
  if (t[u].mx2 != -INF) t[u].mx2 += v;
  if (t[u].mn2 != INF) t[u].mn2 += v;
  if (t[u].tmx != -INF) t[u].tmx += v;
  if (t[u].tmn != INF) t[u].tmn += v;
  t[u].tad += v;
}
void push_min(int u, int tg) {
  // 注意比较 $\max$ 标记
  if (t[u].mx <= tg) return;
  t[u].sum += (tg * 1ll - t[u].mx) * t[u].cmx;
  if (t[u].mn2 == t[u].mx) t[u].mn2 = tg;  //!!!
  if (t[u].mn == t[u].mx) t[u].mn = tg;    //!!!!!
  if (t[u].tmx > tg) t[u].tmx = tg;        // 更新取 $\max$ 标记
  t[u].mx = tg, t[u].tmn = tg;
}
void push_max(int u, int tg) {
  if (t[u].mn > tg) return;
  t[u].sum += (tg * 1ll - t[u].mn) * t[u].cmn;
  if (t[u].mx2 == t[u].mn) t[u].mx2 = tg;
  if (t[u].mx == t[u].mn) t[u].mx = tg;
  if (t[u].tmn < tg) t[u].tmn = tg;
  t[u].mn = tg, t[u].tmx = tg;
}
void pushdown(int u, int l, int r) {
  const int lu = u << 1, ru = u << 1 | 1, mid = (l + r) >> 1;
  if (t[u].tad)
    push_add(lu, l, mid, t[u].tad), push_add(ru, mid + 1, r, t[u].tad);
  if (t[u].tmx != -INF) push_max(lu, t[u].tmx), push_max(ru, t[u].tmx);
  if (t[u].tmn != INF) push_min(lu, t[u].tmn), push_min(ru, t[u].tmn);
  t[u].tad = 0, t[u].tmx = -INF, t[u].tmn = INF;
}
void build(int u = 1, int l = 1, int r = n) {
  t[u].tmn = INF, t[u].tmx = -INF;  // 取极限
  if (l == r) {
    t[u].sum = t[u].mx = t[u].mn = a[l];
    t[u].mx2 = -INF, t[u].mn2 = INF;
    t[u].cmx = t[u].cmn = 1;
    return;
  }
  int mid = (l + r) >> 1;
  build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
  pushup(u);
}
void add(int L, int R, int v, int u = 1, int l = 1, int r = n) {
  if (R < l || r < L) return;
  if (L <= l && r <= R) return push_add(u, l, r, v);  //!!! 忘 return
  int mid = (l + r) >> 1;
  pushdown(u, l, r);
  add(L, R, v, u << 1, l, mid), add(L, R, v, u << 1 | 1, mid + 1, r);
  pushup(u);
}
void tomin(int L, int R, int v, int u = 1, int l = 1, int r = n) {
  if (R < l || r < L || t[u].mx <= v) return;
  if (L <= l && r <= R && t[u].mx2 < v) return push_min(u, v);  // BUG: 忘了返回
  int mid = (l + r) >> 1;
  pushdown(u, l, r);
  tomin(L, R, v, u << 1, l, mid), tomin(L, R, v, u << 1 | 1, mid + 1, r);
  pushup(u);
}
void tomax(int L, int R, int v, int u = 1, int l = 1, int r = n) {
  if (R < l || r < L || t[u].mn >= v) return;
  if (L <= l && r <= R && t[u].mn2 > v) return push_max(u, v);
  int mid = (l + r) >> 1;
  pushdown(u, l, r);
  tomax(L, R, v, u << 1, l, mid), tomax(L, R, v, u << 1 | 1, mid + 1, r);
  pushup(u);
}
long long qsum(int L, int R, int u = 1, int l = 1, int r = n) {
  if (R < l || r < L) return 0;
  if (L <= l && r <= R) return t[u].sum;
  int mid = (l + r) >> 1;
  pushdown(u, l, r);
  return qsum(L, R, u << 1, l, mid) + qsum(L, R, u << 1 | 1, mid + 1, r);
}
long long qmax(int L, int R, int u = 1, int l = 1, int r = n) {
  if (R < l || r < L) return -INF;
  if (L <= l && r <= R) return t[u].mx;
  int mid = (l + r) >> 1;
  pushdown(u, l, r);
  return max(qmax(L, R, u << 1, l, mid), qmax(L, R, u << 1 | 1, mid + 1, r));
}
long long qmin(int L, int R, int u = 1, int l = 1, int r = n) {
  if (R < l || r < L) return INF;
  if (L <= l && r <= R) return t[u].mn;
  int mid = (l + r) >> 1;
  pushdown(u, l, r);
  return min(qmin(L, R, u << 1, l, mid), qmin(L, R, u << 1 | 1, mid + 1, r));
}
int main() {
  n = rd();
  for (int i = 1; i <= n; i++) a[i] = rd();
  build();
  m = rd();
  for (int i = 1; i <= m; i++) {
    int op, l, r, x;
    op = rd(), l = rd(), r = rd();
    if (op <= 3) x = rd();  // scanf("%d",&x);
    if (op == 1)
      add(l, r, x);
    else if (op == 2)
      tomax(l, r, x);
    else if (op == 3)
      tomin(l, r, x);
    else if (op == 4)
      printf("%lld\n", qsum(l, r));
    else if (op == 5)
      printf("%lld\n", qmax(l, r));
    else
      printf("%lld\n", qmin(l, r));
  }
  return 0;
}
```

吉老师证出来这个算法的复杂度是 $O(m\log^2 n)$ 的。

### Mzl loves segment tree

> 两个序列 $A,B$ ，一开始 $B$ 中的数都是 $0$ 。维护的操作是：
>
> 1.  对 $A$ 做区间取 $\min$ 
> 2.  对 $A$ 做区间取 $\max$ 
> 3.  对 $A$ 做区间加
> 4.  询问 $B$ 的区间和
>
> 每次操作完后，如果 $A_i$ 的值发生变化，就给 $B_i$ 加 $1$ 。 $n,m\le 3\times 10^5$ 。

先考虑最容易的区间加操作。只要 $x\neq 0$ 那么整个区间的数都变化，所以给 B 作一次区间加即可。

对于区间取最值的操作，你发现你打标记与下传标记是与 $B$ 数组一一对应的。本质上你将序列的数分成三类：最大值、最小值、非最值。并分别维护（只不过你没有建出具体的最值集合而已，但这并不妨碍维护的操作）。因此在打标记的时侯顺便给 $B$ 更新信息即可（注意不是给 $B$ 打标记！是更新信息！）。查询的时侯，你在 $A$ 上查询，下传标记的时侯顺便给 $B$ 更新信息。找到需要的结点后，返回 $B$ 的信息即可。这种操作本质上就是把最值的信息拿给 $B$ 去维护了。另外仍要处理数集的重复问题。

### CTSN loves segment tree

> 两个序列 $A,B$ ：
>
> 1.  对 $A$ 做区间取 $\min$ 
> 2.  对 $B$ 做区间取 $\min$ 
> 3.  对 $A$ 做区间加
> 4.  对 $B$ 做区间加
> 5.  询问区间的 $A_i+B_i$ 的最大值
>
>      $n,m\le 3\times 10^5$ 。

我们把区间中的 **位置** 分成四类：在 $A,B$ 中同是区间最大值的位置、在 $A$ 中是区间最大值在 $B$ 中不是的位置、在 $B$ 中是区间最大值在 $A$ 中不是的位置、在 $A,B$ 中都不是区间最大值的位置。对这四类数分别维护 **答案** 和 **标记** 即可。举个例子，我们维护 $C_{1\sim 4},M_{1\sim 4},A_{max},B_{max}$ 分别表示当前区间中四类数的个数，四类数的答案的最大值， $A$ 序列的最大值、 $B$ 序列的最大值。然后合并信息该怎么合并就怎么合并了。

复杂度仍是 $O(m\log^2 n)$ 。

### 小结

在第本章节中我们给出了四道例题，分别讲解了基本区间最值操作的维护、多个标记的优先级处理、数集分类的思想以及多个分类的维护。本质上处理区间最值的基本思想就是数集信息的分类维护与高效合并。在下一章节中，我们将探讨历史区间最值的相关问题。

## 历史最值问题

### 历史最值不等于可持久化

注意，本章所讲到的历史最值问题不同于所谓的可持久化数据结构。这类特殊的问题我们将其称为历史最值问题。历史最值的问题可以分为三类。

#### 历史最大值

简单地说，一个位置的历史最大值就是当前位置下曾经出现过的数的最大值。形式化地定义，我们定义一个辅助数组 $B$ ，一开始与 $A$ 完全相同。在 $A$ 的每次操作后，我们对整个数组取 $\max$ ：

$$
\forall i\in[1,n],\ B_i=\max(B_i,A_i)
$$

这时，我们将 $B_i$ 称作这个位置的历史最大值，

#### 历史最小值

定义与历史最大值类似，在 $A$ 的每次操作后，我们对整个数组取 $\min$ 。这时，我们将 $B_i$ 称作这个位置的历史最小值，

#### 历史版本和

辅助数组 $B$ 一开始全部是 $0$ 。在每一次操作后，我们把整个 $A$ 数组累加到 $B$ 数组上

$$
\forall i\in[1,n], \ B_i=B_i+A_i
$$

我们称 $B_i$ 为 $i$ 这个位置上的历史版本和。

接下来，我们将历史最值问题分成四类讨论。

### 可以用标记处理的问题

#### CPU 监控

> 序列 $A,B$ 一开始相同：
>
> 1.  对 $A$ 做区间覆盖 $x$ 
> 2.  对 $A$ 做区间加 $x$ 
> 3.  询问 $A$ 的区间 $\max$ 
> 4.  询问 $B$ 的区间 $\max$ 
>
> 每次操作后，我们都进行一次更新， $\forall i\in [1,n],\ B_i=\max(B_i,A_i)$ 。 $n,m\le 10^5$ 。

我们先不考虑操作 1。那么只有区间加的操作，我们维护标记 $Add$ 表示当前区间增加的值，这个标记可以解决区间 $\max$ 的问题。接下来考虑历史区间 $\max$ 。我们定义标记 $Pre$ ，该标记的含义是：在该标记的生存周期内， $Add$ 标记的历史最大值。

这个定义可能比较模糊。因此我们先解释一下标记的生存周期。一个标记会经历这样的过程：

1.  在结点 $u$ 被建立。
2.  在结点 $u$ 接受若干个新的标记的同时，与新的标记合并（指同类标记）
3.  结点 $u$ 的标记下传给 $u$ 的儿子， $u$ 的标记清空

我们认为在这个过程中，从 1 开始到 3 之前，都是结点 $u$ 的标记的生存周期。两个标记合并后，成为同一个标记，那么他们的生存周期也会合并（即取建立时间较早的那个做为生存周期的开始）。一个与之等价的说法是，从上次把这个结点的标记下传的时刻到当前时刻这一时间段。

为什么要定义生存周期？利用这个概念，我们可以证明：在一个结点标记的生存周期内，其子结点均不会发生任何变化，并保留在这个生存周期之前的状态。道理很简单，因为在这个期间你是没有下传标记的。

于是，你就可以保证，在当前标记生存周期内的历史 $Add$ 的最大值是可以更新到子结点的标记和信息上的。因为子结点的标记和信息在这个时间段内都没有变过。于是我们把 $u$ 的标记下传给它的儿子 $s$ ，不难发现

$$
Pre_s=\max(Pre_s,Pre_u+Add_s),Add_s=Add_u+Add_s
$$

那么信息的更新也是类似的，拿对应的标记更新即可。

接下来，我们考虑操作 1。

区间覆盖操作，会把所有的数变成一个数。在这之后，无论是区间加减还是覆盖，整个区间的数仍是同一个（除非你结束当前标记的生存周期，下传标记）。因此我们可以把第一次区间覆盖后的所有标记都看成区间覆盖标记。也就是说一个标记的生存周期被大致分成两个阶段：

1.  若干个加减操作标记的合并，没有接收过覆盖标记。
2.  覆盖操作的标记，没有所谓的加减标记（加减标记转化为覆盖标记）

于是我们把这个结点的 Pre 标记拆成 $(P_1,P_2)$ 。 $P_1$ 表示第一阶段的最大加减标记； $P_2$ 表示第二阶段的最大覆盖标记。利用相似的方法，我们可以对这个做标记下传和信息更新。时间复杂度是 $O(m\log n)$ 的（这个问题并没有区间对 $x$ 取最值的操作哦～）

# sparse-table
## 简介

ST 表是用于解决 **可重复贡献问题** 的数据结构。

???+note "什么是可重复贡献问题？"
     **可重复贡献问题** 是指对于运算 $\operatorname{opt}$ ，满足 $x\operatorname{opt} x=x$ ，则对应的区间询问就是一个可重复贡献问题。例如，最大值有 $\max(x,x)=x$ ，gcd 有 $\operatorname{gcd}(x,x)=x$ ，所以 RMQ 和区间 GCD 就是一个可重复贡献问题。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿意看到的。另外， $\operatorname{opt}$ 还必须满足结合律才能使用 ST 表求解。

???+note "什么是RMQ？"
    RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。解决 RMQ 问题有很多种方法，可以参考 [RMQ 专题](../topic/rmq.md) 。

## 引入

 [ST 表模板题](https://www.luogu.org/problemnew/show/P3865) 

题目大意：给定 $n$ 个数，有 $m$ 个询问，对于每个询问，你需要回答区间 $[l,r]$ 中的最大值。

考虑暴力做法。每次都对区间 $[l,r]$ 扫描一遍，求出最大值。

显然，这个算法会超时。

## ST 表

ST 表基于 [倍增](../basic/binary-acc.md) 思想，可以做到 $\Theta(n\log n)$ 预处理， $\Theta(1)$ 回答每个询问。但是不支持修改操作。

基于倍增思想，我们考虑如何求出区间最大值。可以发现，如果按照一般的倍增流程，每次跳 $2^i$ 步的话，询问时的复杂度仍旧是 $\Theta(\log n)$ ，并没有比线段树更优，反而预处理一步还比线段树慢。

我们发现 $\max(x,x)=x$ ，也就是说，区间最大值是一个具有“可重复贡献”性质的问题。即使用来求解的预处理区间有重叠部分，只要这些区间的并是所求的区间，最终计算出的答案就是正确的。

如果手动模拟一下，可以发现我们能使用至多两个预处理过的区间来覆盖询问区间，也就是说询问时的时间复杂度可以被降至 $\Theta(1)$ ，在处理有大量询问的题目时十分有效。

具体实现如下：

令 $f(i,j)$ 表示区间 $[i,i+2^j-1]$ 的最大值。

显然 $f(i,0)=a_i$ 。

根据定义式，第二维就相当于倍增的时候“跳了 $2^j-1$ 步”，依据倍增的思路，写出状态转移方程： $f(i,j)=\max(f(i,j-1),f(i+2^{j-1},j-1))$ 。

/home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/st1.png)

以上就是预处理部分。而对于查询，可以简单实现如下：

对于每个询问 $[l,r]$ ，我们把它分成两部分： $f[l,l+2^s-1]$ 与 $f[r-2^s+1,r]$ 。

其中 $s=\left\lfloor\log_2(r-l+1)\right\rfloor$ 。

根据上面对于“可重复贡献问题”的论证，由于最大值是“可重复贡献问题”，重叠并不会对区间最大值产生影响。又因为这两个区间完全覆盖了 $[l,r]$ ，可以保证答案的正确性。

## 模板代码

 [ST 表模板题](https://www.luogu.org/problemnew/show/P3865) 

```cpp
#include <bits/stdc++.h>
using namespace std;
const int logn = 21;
const int maxn = 2000001;
int f[maxn][logn], Logn[maxn];
inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  while (c < '0' || c > '9') {
    if (c == '-') f = -1;
    c = getchar();
  }
  while (c >= '0' && c <= '9') {
    x = x * 10 + c - '0';
    c = getchar();
  }
  return x * f;
}
void pre() {
  Logn[1] = 0;
  Logn[2] = 1;
  for (int i = 3; i < maxn; i++) {
    Logn[i] = Logn[i / 2] + 1;
  }
}
int main() {
  int n = read(), m = read();
  for (int i = 1; i <= n; i++) f[i][0] = read();
  pre();
  for (int j = 1; j <= logn; j++)
    for (int i = 1; i + (1 << j) - 1 <= n; i++)
      f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
  for (int i = 1; i <= m; i++) {
    int x = read(), y = read();
    int s = Logn[y - x + 1];
    printf("%d\n", max(f[x][s], f[y - (1 << s) + 1][s]));
  }
  return 0;
}
```

## 注意点

1.  输入输出数据一般很多，建议开启输入输出优化。

2.  每次用 [std::log](https://en.cppreference.com/w/cpp/numeric/math/log) 重新计算 log 函数值并不值得，建议进行如下的预处理：

$$
\left\{\begin{aligned}
Logn[1] &=0, \\
Logn\left[i\right] &=Logn[\frac{i}{2}] + 1.
\end{aligned}\right.
$$

## ST 表维护其他信息

除 RMQ 以外，还有其它的“可重复贡献问题”。例如“区间按位和”、“区间按位或”、“区间 GCD”，ST 表都能高效地解决。

需要注意的是，对于“区间 GCD”，ST 表的查询复杂度并没有比线段树更优（令值域为 $w$ ，ST 表的查询复杂度为 $\Theta(\log w)$ ，而线段树为 $\Theta(\log n+\log w)$ ，且值域一般是大于 $n$ 的），但是 ST 表的预处理复杂度也没有比线段树更劣，而编程复杂度方面 ST 表比线段树简单很多。

如果分析一下，“可重复贡献问题”一般都带有某种类似 RMQ 的成分。例如“区间按位与”就是每一位取最小值，而“区间 GCD”则是每一个质因数的指数取最小值。

## 总结

ST 表能较好的维护“可重复贡献”的区间信息（同时也应满足结合律），时间复杂度较低，代码量相对其他算法很小。但是，ST 表能维护的信息非常有限，不能较好地扩展，并且不支持修改操作。

## 练习

 [RMQ 模板题](https://www.luogu.org/problemnew/show/P3865) 

 [「SCOI2007」降雨量](https://loj.ac/problem/2279) 

 [\[USACO07JAN\]平衡的阵容 Balanced Lineup](https://www.luogu.org/problem/P2880) 

## 附录：ST 表求区间 GCD 的时间复杂度分析

在算法运行的时候，可能要经过 $\Theta(\log n)$ 次迭代。每一次迭代都可能会使用 GCD 函数进行递归，令值域为 $w$ ，GCD 函数的时间复杂度最高是 $\Omega(\log w)$ 的，所以总时间复杂度看似有 $O(n\log n\log w)$ 。

但是，在 GCD 的过程中，每一次递归（除最后一次递归之外）都会使数列中的某个数至少减半，而数列中的数最多减半的次数为 $\log_2 (w^n)=\Theta(n\log w)$ ，所以，GCD 的递归部分最多只会运行 $O(n\log w)$ 次。再加上循环部分（以及最后一层递归）的 $\Theta(n\log n)$ ，最终时间复杂度则是 $O(n(\log w+\log x))$ ，由于可以构造数据使得时间复杂度为 $\Omega(n(\log w+\log x))$ ，所以最终的时间复杂度即为 $\Theta(n(\log w+\log x))$ 。

而查询部分的时间复杂度很好分析，考虑最劣情况，即每次询问都询问最劣的一对数，时间复杂度为 $\Theta(\log w)$ 。因此，ST 表维护“区间 GCD”的时间复杂度为预处理 $\Theta(n(\log n+\log w))$ ，单次查询 $\Theta(\log w)$ 。

线段树的相应操作是预处理 $\Theta(n\log x)$ ，查询 $\Theta(n(\log n+\log x))$ 。

这并不是一个严谨的数学论证，更为严谨的附在下方：

??? note "更严谨的证明"
    理解本段，可能需要具备 [时间复杂度](../misc/complexity.md) 的关于“势能分析法”的知识。

    先分析预处理部分的时间复杂度：

    设“待考虑数列”为在预处理 ST 表的时候当前层循环的数列。例如，第零层的数列就是原数列，第一层的数列就是第零层的数列经过一次迭代之后的数列，即 `st[1..n][1]` ，我们将其记为 $A$ 。

    而势能函数就定义为“待考虑数列”中所有数的累乘的以二为底的对数。即： $\Phi(A)=\log_2\left(\prod\limits_{i=1}^n A_i\right)$ 。

    在一次迭代中，所花费的时间相当于迭代循环所花费的时间与 GCD 所花费的时间之和。其中，GCD 花费的时间有长有短。最短可能只有两次甚至一次递归，而最长可能有 $O(\log w)$ 次递归。但是，GCD 过程中，除最开头一层与最末一层以外，每次递归都会使“待考虑数列”中的某个结果至少减半。即， $\Phi(A)$ 会减少至少 $1$ ，该层递归所用的时间可以被势能函数均摊。

    同时，我们可以看到， $\Phi(A)$ 的初值最大为 $\log_2 (w^n)=\Theta(n\log w)$ ，而 $\Phi(A)$ 不增。所以，ST 表预处理部分的时间复杂度为 $O(n(\log w+\log n))$ 。

# dsu-complexity
author: orzAtalod

本部分内容转载并修改自 [时间复杂度 - 势能分析浅谈](https://www.luogu.com.cn/blog/Atalod/shi-jian-fu-za-du-shi-neng-fen-xi-qian-tan) ，已取得原作者授权同意。

这里，先给出 $\alpha(n)$ 的定义。为了给出这个定义，先给出 $A_k(j)$ 的定义。

定义 $A_k(j)$ 为：

$$
A_k(j)=\left\{
\begin{aligned}
&j+1& &k=0&\\
&A_{k-1}^{(j+1)}(j)& &k\geq1&
\end{aligned}
\right.
$$

即阿克曼函数。

这里， $f^i(x)$ 表示将 $f$ 连续应用在 $x$ 上 $i$ 次，即 $f^0(x)=x$ ， $f^i(x)=f(f^{i-1}(x))$ 。

再定义 $\alpha(n)$ 为使得 $A_{\alpha(n)}(1)\geq n$ 的最小整数值。注意，我们之前将它描述为 $A_{\alpha(n)}(\alpha(n))\geq n$ ，反正他们的增长速度都很慢，值都不超过 4。

## 基础定义

每个节点都有一个 rank。这里的 rank 不是节点个数，而是深度。节点的初始 rank 为 0，在合并的时候，如果两个节点的 rank 不同，则将 rank 小的节点合并到 rank 大的节点上，并且不更新大节点的 rank 值。否则，随机将某个节点合并到另外一个节点上，将根节点的 rank 值 +1。这里根节点的 rank 给出了该树的高度。记 x 的 rank 为 $rnk(x)$ ，类似的，记 x 的父节点为 $fa(x)$ 。我们总有 $rnk(x)+1\leq rnk(fa(x))$ 。

为了定义势函数，需要预先定义一个辅助函数 $level(x)$ 。其中， $level(x)=\max(k:rnk(fa(x))\geq A_k(rnk(x)))$ 。当 $rnk(x)\geq1$ 的时候，再定义一个辅助函数 $iter(x)=\max(i:rnk(fa(x))\geq A_{level(x)}^i(rnk(x))$ 。这些函数定义的 $x$ 都满足 $rnk(x)>0$ 且 $x$ 不是某个树的根。

上面那些定义可能让你有点头晕。再理一下，对于一个 $x$ 和 $fa(x)$ ，如果 $rnk(x)>0$ ，总是可以找到一对 $i,k$ 令 $rnk(fa(x))\geq A_k^i(rnk(x))$ ，而 $level(x)=\max(k)$ ，在这个前提下， $iter(x)=\max(i)$ 。 $level$ 描述了 $A$ 的最大迭代级数，而 $iter$ 描述了在最大迭代级数时的最大迭代次数。

对于这两个函数， $level(x)$ 总是随着操作的进行而增加或不变，如果 $level(x)$ 不增加， $iter(x)$ 也只会增加或不变。并且，它们总是满足以下两个不等式：

$$
0\leq level(x)<\alpha(n)
$$

$$
1\leq iter(x)\leq rnk(x)
$$

考虑 $level(x)$ 、 $iter(x)$ 和 $A_k^j$ 的定义，这些很容易被证明出来，就留给读者用于熟悉定义了。

定义势能函数 $\Phi(S)=\sum\limits_{x\in S}\Phi(x)$ ，其中 $S$ 表示一整个并查集，而 $x$ 为并查集中的一个节点。定义 $\Phi(x)$ 为：

$$
\Phi(x)=\left\{
\begin{aligned}
&\alpha(n)\times rnk(x)& &rnk(x)=0\text{ 或 x为某棵树的根节点}&\\
&(\alpha(n)-level(x))\times rnk(x)-iter(x)& &otherwise&
\end{aligned}\right.
$$

然后就是通过操作引起的势能变化来证明摊还时间复杂度为 $\Theta(\alpha(n))$ 啦。注意，这里我们讨论的 $union(x,y)$ 操作保证了 $x$ 和 $y$ 都是某个树的根，因此不需要额外执行 $find(x)$ 和 $find(y)$ 。

可以发现，势能总是个非负数。另，在开始的时候，并查集的势能为 $0$ 。

## union(x,y) 操作

其花费的时间为 $\Theta(1)$ ，因此我们考虑其引起的势能的变化。

这里，我们假设 $rnk(x)\leq rnk(y)$ ，即 $x$ 被接到 $y$ 上。这样，势能增加的节点仅有 $x$ （从树根变成非树根）， $y$ （秩可能增加）和操作前 $y$ 的子节点（父节点的秩可能增加）。我们先证明操作前 $y$ 的子节点 $c$ 的势能不可能增加，并且如果减少了，至少减少 $1$ 。

设操作前 $c$ 的势能为 $\Phi(c)$ ，操作后为 $\Phi(c')$ ，这里 $c$ 可以是任意一个 $rnk(c)>0$ 的非根节点，操作可以是任意操作，包括下面的 find 操作。我们分三种情况讨论。

1.   $iter(c)$ 和 $level(c)$ 并未增加。显然有 $\Phi(c)=\Phi(c')$ 。
2.   $iter(c)$ 增加了， $level(c)$ 并未增加。这里 $iter(c)$ 至少增加一，即 $\Phi(c')\leq \Phi(c)-1$ ，势能函数减少了，并且至少减少 1。
3.   $level(c)$ 增加了， $iter(c)$ 可能减少。但是由于 $0<iter(c)\leq rnk(c)$ ， $iter(c)$ 最多减少 $rnk(c)-1$ ，而 $level(c)$ 至少增加 $1$ 。由定义 $\Phi(c)=(\alpha(n)-level(c))\times rnk(c)-iter(c)$ ，可得 $\Phi(c')\leq\Phi(c)-1$ 。
4.  其他情况。由于 $rnk(c)$ 不变， $rnk(fa(c))$ 不减，所以不存在。

所以，势能增加的节点仅可能是 $x$ 或 $y$ 。而 $x$ 从树根变成了非树根，如果 $rnk(x)=0$ ，则一直有 $\Phi(x)=\Phi(x')=0$ 。否则，一定有 $\alpha(x)\times rnk(x)\geq(\alpha(n)-level(x))\times rnk(x)-iter(x)$ 。即， $\Phi(x')\leq \Phi(x)$ 。

因此，唯一势能可能增加的点就是 $y$ 。而 $y$ 的势能最多增加 $\alpha(n)$ 。因此，可得 $union$ 操作均摊后的时间复杂度为 $\Theta(\alpha(n))$ 。

## find(a) 操作

如果查找路径包含 $\Theta(s)$ 个节点，显然其查找的时间复杂度是 $\Theta(s)$ 。如果由于查找操作，没有节点的势能增加，且至少有 $s-\alpha(n)$ 个节点的势能至少减少 $1$ ，就可以证明 $find(a)$ 操作的时间复杂度为 $\Theta(\alpha(n))$ 。为了避免混淆，这里用 $a$ 作为参数，而出现的 $x$ 都是泛指某一个并查集内的结点。

首先证明没有节点的势能增加。很显然，我们在上面证明过所有非根节点的势能不增，而根节点的 $rnk$ 没有改变，所以没有节点的势能增加。

接下来证明至少有 $s-\alpha(n)$ 个节点的势能至少减少 $1$ 。我们上面证明过了，如果 $level(x)$ 或者 $iter(x)$ 有改变的话，它们的势能至少减少 $1$ 。所以，只需要证明至少有 $s-\alpha(n)$ 个节点的 $level(x)$ 或者 $iter(x)$ 有改变即可。

回忆一下非根节点势能的定义， $\Phi(x)=(\alpha(n)-level(x))\times rnk(x)-iter(x)$ ，而 $level(x)$ 和 $iter(x)$ 是使 $rnk(fa(x))\geq A_{level(x)}^{iter(x)}(rnk(x))$ 的最大数。

所以，如果 $root_x$ 代表 $x$ 所处的树的根节点，只需要证明 $rnk(root_x)\geq A_{level(x)}^{iter(x)+1}(rnk(x))$ 就好了。根据 $A_k^i$ 的定义， $A_{level(x)}^{iter(x)+1}(rnk(x))=A_{level(x)}(A_{level(x)}^{iter(x)}(rnk(x)))$ 。

注意，我们可能会用 $k(x)$ 代表 $level(x)$ ， $i(x)$ 代表 $iter(x)$ 以避免式子过于冗长。这里，就是 $rnk(root_x)\geq A_{k(x)}(A_{k(x)}^{i(x)}(x))$ 。

当你看到这的时候，可能会有一种“这啥玩意”的感觉。这意味着你可能需要多看几遍，或者跳过一些内容以后再看。

这里，我们需要一个外接的 $A_{k(x)}$ ，意味着我们可能需要再找一个点 $y$ 。令 $y$ 是搜索路径上在 $x$ 之后的满足 $k(y)=k(x)$ 的点，这里“搜索路径之后”相当于“是 $x$ 的祖先”。显然，不是每一个 $x$ 都有这样一个 $y$ 。很容易证明，没有这样的 $y$ 的 $x$ 不超过 $\alpha(n)-2$ 个。因为只有每个 $k$ 的最后一个 $x$ 和 $a$ 以及 $root_a$ 没有这样的 $y$ 。

我们再强调一遍 $fa(x)$ 指的是路径压缩 **之前**  $x$ 的父节点，路径压缩 **之后**  $x$ 的父节点一律用 $root_x$ 表示。对于每个存在 $y$ 的 $x$ ，总是有 $rnk(y)\geq rnk(fa(x))$ 。同时，我们有 $rnk(fa(x))\geq A_{k(x)}^{i(x)}(rnk(x))$ 。由于 $k(x)=k(y)$ ，我们用 $k$ 来统称，即， $rnk(fa(x))\geq A_k^{i(x)}(rnk(x))$ 。我们需要造一个 $A_k$ 出来，所以我们可以不关注 $iter(y)$ 的值，直接使用弱化版的 $rnk(fa(y))\geq A_k(rnk(y))$ 。

如果我们将不等式组合起来，神奇的事情就发生了。我们发现， $rnk(fa(y))\geq A_k^{i(x)+1}(rnk(x))$ 。也就是说，为了从 $rnk(x)$ 迭代到 $rnk(fa(y))$ ，至少可以迭代 $A_k$ 不少于 $i(x)+1$ 次而不超过 $rnk(fa(y))$ 。

显然，有 $rnk(root_y)\geq rnk(fa(y))$ ，且 $rnk(x)$ 在路径压缩时不变。因此，我们可以得到 $rnk(root_x)\geq A_k^{i(x)+1}(rnk(x))$ ，也就是说 $iter(x)$ 的值至少增加 1，如果 $rnk(x)$ 没有增加，一定是 $level(x)$ 增加了。

所以， $\Phi(x)$ 至少减少了 1。由于这样的 $x$ 节点至少有 $s-\alpha(n)-2$ 个，所以最后 $\Phi(S)$ 至少减少了 $s-\alpha(n)-2$ ，均摊后的时间复杂度即为 $\Theta(\alpha(n)+2)=\Theta(\alpha(n))$ 。

## 为何并查集会被卡

这个问题也就是问，如果我们不按秩合并，会有哪些性质被破坏，导致并查集的时间复杂度不能保证为 $\Theta(m\alpha(n))$ 。

如果我们在合并的时候， $rnk$ 较大的合并到了 $rnk$ 较小的节点上面，我们就将那个 $rnk$ 较小的节点的 $rnk$ 值设为另一个节点的 $rnk$ 值加一。这样，我们就能保证 $rnk(fa(x))\geq rnk(x)+1$ ，从而不会出现类似于满地 complie error 一样的性质不符合。

显然，如果这样子的话，我们破坏的就是 $union(x,y)$ 函数「y 的势能最多增加 $\alpha(n)$ 」这一句。

存在一个能使路径压缩并查集时间复杂度降至 $\Omega(m\log_{1+\frac{m}{n}}n)$ 的结构，定义如下：

二项树（实际上和一般的二项树不太一样），其中 j 是常数， $T_k$ 为一个 $T_{k-1}$ 加上一个 $T_{k-j}$ 作为根节点的儿子。

![我们的二项树](./images/dsu_complexy1.png)

边界条件， $T_1$ 到 $T_j$ 都是一个单独的点。

令 $rnk(T_k)=r_k$ ，这里我们有 $r_k=(k-1)/j$ （证明略）。每轮操作，我们将它接到一个单节点上，然后查询底部的 $j$ 个节点。也就是说，我们接到单节点上的时候，单节点的势能提高了 $(k-1)/j+1$ 。在 $j=\lfloor\frac{m}{n}\rfloor$ ， $i=\lfloor\log_{j+1}\frac{n}{2}\rfloor$ ， $k=ij$ 的时候，势能增加量为：

$$
\alpha(n)\times((ij-1)/j+1)=\alpha(n)\times((\lfloor\log_{\lfloor\frac{m}{n}\rfloor+1}\frac{n}{2}\rfloor\times \lfloor\frac{m}{n}\rfloor-1)/\lfloor\frac{m}{n}\rfloor+1)
$$

变换一下，去掉所有的取整符号，就可以得出，势能增加量 $\geq \alpha(n)\times(\log_{1+\frac{m}{n}}n-\frac{n}{m})$ ，m 次操作就是 $\Omega(m\log_{1+\frac{m}{n}}n-n)=\Omega(m\log_{1+\frac{m}{n}}n)$ 。

## 关于启发式合并

由于按秩合并比启发式合并难写，所以很多 dalao 会选择使用启发式合并来写并查集。具体来说，则是对每个根都维护一个 $size(x)$ ，每次将 $size$ 小的合并到大的上面。

所以，启发式合并会不会被卡？

首先，~~手推一下我们就可以发现那个数据卡不掉启发式合并~~可以从秩参与证明的性质来说明。如果 $size$ 可以代替 $rnk$ 的地位，则可以使用启发式合并。快速总结一下，秩参与证明的性质有以下三条：

1.  每次合并，最多有一个节点的秩上升，而且最多上升 1。
2.  总有 $rnk(fa(x))\geq rnk(x)+1$ 。
3.  节点的秩不减。

关于第二条和第三条， $siz$ 显然满足，然而第一条不满足，如果将 $x$ 合并到 $y$ 上面，则 $siz(y)$ 会增大 $siz(x)$ 那么多。

所以，可以考虑使用 $\log_2 siz(x)$ 代替 $rnk(x)$ 。

关于第一条性质，由于节点的 $siz$ 最多翻倍，所以 $\log_2 siz(x)$ 最多上升 1。关于第二三条性质，~~既得易见平凡~~。

所以说，如果不想写按秩合并，就写启发式合并好了，时间复杂度仍旧是 $\Theta(m\alpha(n))$ 。

# dsu
author: HeRaNO, JuicyMio, Xeonacid, sailordiary, ouuan

并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 **合并** 及 **查询** 问题。
它支持两种操作：

-   查找（Find）：确定某个元素处于哪个子集；

-   合并（Union）：将两个子集合并成一个集合。

!!! warning
    并查集不支持集合的分离，但是并查集在经过修改后可以支持集合中单个元素的删除操作（详见 UVA11987 Almost Union-Find）。使用动态开点线段树还可以实现可持久化并查集。

## 初始化

```cpp
void makeSet(int size) {
  for (int i = 0; i < size; i++) fa[i] = i;  // i就在它本身的集合里
  return;
}
```

## 查找

通俗地讲一个故事：几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。

在这样的思想下，并查集的查找算法诞生了。

此处给出一种 C++ 的参考实现：

```cpp
int fa[MAXN];  //记录某个人的爸爸是谁，特别规定，祖先的爸爸是他自己
int find(int x) {
  //寻找x的祖先
  if (fa[x] == x)  //如果x是祖先则返回
    return x;
  else
    return find(fa[x]);  //如果不是则x的爸爸问x的爷爷
}
```

显然这样最终会返回 $x$ 的祖先。

### 路径压缩

这样的确可以达成目的，但是显然效率实在太低。为什么呢？因为我们使用了太多没用的信息，我的祖先是谁与我父亲是谁没什么关系，这样一层一层找太浪费时间，不如我直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。 **把在路径上的每个节点都直接连接到根上** ，这就是路径压缩。

此处给出一种 C++ 的参考实现：

```cpp
int find(int x) {
  if (x != fa[x])  // x不是自身的父亲，即x不是该集合的代表
    fa[x] = find(fa[x]);  //查找x的祖先直到找到代表,于是顺手路径压缩
  return fa[x];
}
```

上两张图：

![p1](./images/dsu1.png)

![p2](./images/dsu2.png)

## 合并

宴会上，一个家族的祖先突然对另一个家族说：我们两个家族交情这么好，不如合成一家好了。另一个家族也欣然接受了。  
我们之前说过，并不在意祖先究竟是谁，所以只要其中一个祖先变成另一个祖先的儿子就可以了。

此处给出一种 C++ 的参考实现：

```cpp
void unionSet(int x, int y) {
  // x 与 y 所在家族合并
  x = find(x);
  y = find(y);
  if (x == y)  //原本就在一个家族里就不管了
    return;
  fa[x] = y;  //把 x 的祖先变成 y 的祖先的儿子
}
```

### 启发式合并（按秩合并）

一个祖先突然抖了个机灵：「你们家族人比较少，搬家到我们家族里比较方便，我们要是搬过去的话太费事了。」

由于需要我们支持的只有集合的合并、查询操作，当我们需要将两个集合合二为一时，无论将哪一个集合连接到另一个集合的下面，都能得到正确的结果。但不同的连接方法存在时间复杂度的差异。具体来说，如果我们将一棵点数与深度都较小的集合树连接到一棵更大的集合树下，显然相比于另一种连接方案，接下来执行查找操作的用时更小（也会带来更优的最坏时间复杂度）。

当然，我们不总能遇到恰好如上所述的集合————点数与深度都更小。鉴于点数与深度这两个特征都很容易维护，我们常常从中择一，作为估价函数。而无论选择哪一个，时间复杂度都为 $\Theta (m\alpha(m,n))$ ，具体的证明可参见 References 中引用的论文。

在算法竞赛的实际代码中，即便不使用启发式合并，代码也往往能够在规定时间内完成任务。在 Tarjan 的论文[1]中，证明了不使用启发式合并、只使用路径压缩的最坏时间复杂度是 $\Theta (m \log n)$ 。在姚期智的论文[2]中，证明了不使用启发式合并、只使用路径压缩，在平均情况下，时间复杂度依然是 $\Theta (m\alpha(m,n))$ 。

如果只使用启发式合并，而不使用路径压缩，时间复杂度为 $\Theta(m\log n)$ 。由于路径压缩单次合并可能造成大量修改，有时路径压缩并不适合使用。例如，在可持久化并查集、线段树分治 + 并查集中，一般使用只启发式合并的并查集。

此处给出一种 C++ 的参考实现，其选择点数作为估价函数：

```cpp
std::vector<int> size(N, 1);  //记录并初始化子树的大小为 1
void unionSet(int x, int y) {
  int xx = find(x), yy = find(y);
  if (xx == yy) return;
  if (size[xx] > size[yy])  //保证小的合到大的里
    swap(xx, yy);
  fa[xx] = yy;
  size[yy] += size[xx];
}
```

## 时间复杂度及空间复杂度

### 时间复杂度

同时使用路径压缩和启发式合并之后，并查集的每个操作平均时间仅为 $O(\alpha(n))$ ，其中 $\alpha$ 为阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。

 [Ackermann 函数](https://en.wikipedia.org/wiki/Ackermann_function)  $A(n, m)$ 的定义是这样的：

 $A(m, n) = \begin{cases}n+1&\text{if }m=0\\A(m-1,1)&\text{if }m>0\text{ and }n=0\\A(m-1,A(m,n-1))&\text{otherwise}\end{cases}$ 

而反 Ackermann 函数 $\alpha(n)$ 的定义是阿克曼函数的反函数，即为最大的整数 $m$ 使得 $A(m, m) \leqslant n$ 。

时间复杂度的证明 [在这个页面中](./dsu-complexity.md) 。

### 空间复杂度

显然为 $O(n)$ 。

## 带权并查集

我们还可以在并查集的边上定义某种权值、以及这种权值在路径压缩时产生的运算，从而解决更多的问题。比如对于经典的「NOI2001」食物链，我们可以在边权上维护模 3 意义下的加法群。

## 经典题目

 [「NOI2015」程序自动分析](https://uoj.ac/problem/127) 

 [「JSOI2008」星球大战](https://www.luogu.org/problem/P1197) 

 [「NOI2001」食物链](https://www.luogu.org/problem/P2024) 

 [「NOI2002」银河英雄传说](https://www.luogu.org/problemnew/show/P1196) 

 [UVA11987 Almost Union-Find](https://www.luogu.com.cn/problem/UVA11987) 

## 其他应用

 [最小生成树算法](../graph/mst.md) 中的 Kruskal 和 [最近公共祖先](../graph/lca.md) 中的 Tarjan 算法是基于并查集的算法。

## References

-   [1]Tarjan, R. E., & Van Leeuwen, J. (1984). Worst-case analysis of set union algorithms. Journal of the ACM (JACM), 31(2), 245-281. [ResearchGate PDF](https://www.researchgate.net/profile/Jan_Van_Leeuwen2/publication/220430653_Worst-case_Analysis_of_Set_Union_Algorithms/links/0a85e53cd28bfdf5eb000000/Worst-case-Analysis-of-Set-Union-Algorithms.pdf) 
-   [2]Yao, A. C. (1985). On the expected performance of path compression algorithms. [SIAM Journal on Computing, 14(1), 129-133.](https://epubs.siam.org/doi/abs/10.1137/0214010?journalCode=smjcat) 
-   [3][知乎回答：是否在并查集中真的有二分路径压缩优化？]( <https://www.zhihu.com/question/28410263/answer/40966441> )
-   [4]Gabow, H. N., & Tarjan, R. E. (1985). A Linear-Time Algorithm for a Special Case of Disjoint Set Union. JOURNAL OF COMPUTER AND SYSTEM SCIENCES, 30, 209-221. [CORE PDF](https://core.ac.uk/download/pdf/82125836.pdf) 

# ett
一般提到动态树，我们会不约而同的想到 `LCT` ，这算是比较通用，实用，能力较为广泛的一种写法了。当然，掌握 `LCT` 就需要熟悉掌握 `Splay` 和各种操作和知识。 `ETT` （中文常用称呼：欧拉游览树）是一种及其睿智且暴力，可以用暴力数据结构维护的一种除了能胜任普通动态树的 `Link & Cut` 操作还可以支持换子树操作（此操作 `LCT` 无法完成）的动态树。

大家对这括号序很熟悉吧，如：

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/ett1.png)

其括号序为： `1 2 5 5 6 6 2 3 3 4 7 8 8 7 4 1` 。

括号序其实是一个父亲包含儿子的一种树的顺序。

然后我们看一下，如果把 `4` 的子树移给 `3` 会怎样？如图：

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/ett2.png)

原图括号序： `1 2 5 5 6 6 2 3 3 4 7 8 8 7 4 1` 

后者括号序： `1 2 5 5 6 6 2 3 7 8 8 7 3 4 4 1` 

可以发现， `7 7 8 8` 平移到了 `3` 的后面，而 `4` 合拢。这就是所谓换子树操作（同样可以用于 `Link & Cut` 操作）。现在只需要一个数据结构可以做到区间平移且维护一些值，众大佬肯定会说用 `Splay` ，其确实效率很高，不过这里用块状链表维护会简单很多，对于一些数据低于 $2 \times 10^5$ 的题目都可以码得很快。

那怎么维护点到根的信息呢？

其实仔细想想， `DFS` 序也可以达到平移的效果，那么为什么需要括号序？其实，假如你要查询图中 `1` 到 `8` 的和，那么你从括号序中 `1` 到 `8` （第一个出现的）中出现两次的数的贡献抹去。如果维护的是 $\operatorname{xor}$ ，那么直接 $\operatorname{xor}$ 两次即可。如果维护的是 $\operatorname{sum}$ ，那么第一个出现的数字的贡献为正，第二个为负，然后用块状链表维护区间和即可。

用块状链表后除了单点修改是 $O(1)$ 外其他都是 $O(n^{\frac{1}{2}})$ 的。

 `ETT` 不支持换根操作。对于链（区间）修改，分为两种情况，一是贡献相同（如 $\operatorname{xor}$ ) 是可以的，二是贡献不同（如 $\operatorname{sum}$ ) 是不行的。现在的主流做法毕竟是 `LCT` ，所以这些操作比较多，在避开这种操作的情况下运用这种做法还是不错的。

注：标准的 ETT（用欧拉回路而不是 dfs 括号序实现）是支持换根操作的，但是实现较为复杂。

# persistent-in-bit
 [静态区间 k 小值 (POJ 2104 K-th Number)](http://poj.org/problem?id=2104) 的问题可以用 [主席树](./persistent-seg.md) 在 $O(n\log n)$ 的时间复杂度内解决。

如果区间变成动态的呢？即，如果还要求支持一种操作：单点修改某一位上的值，又该怎么办呢？

??? note " 例题[二逼平衡树（树套树）](https://loj.ac/problem/106)"

??? note " 例题[ZOJ 2112 Dynamic Rankings](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1112)"

如果用 [线段树套平衡树](./balanced-in-seg.md) 中所论述的，用线段树套平衡树，即对于线段树的每一个节点，对于其所表示的区间维护一个平衡树，然后用二分来查找 $k$ 小值。由于每次查询操作都要覆盖多个区间，即有多个节点，但是平衡树并不能多个值一起查找，所以时间复杂度是 $O(n\log^3 n)$ ，并不是最优的。

思路是，把二分答案的操作和查询小于一个值的数的数量两种操作结合起来。最好的方法是使用 **线段树套主席树** 。

说是主席树其实不准确，因为并不是对线段树的可持久化，各个线段树之间也没有像主席树各版本之间的强关联性，所以称为 **动态开点权值线段树** 更为确切。

思路类似于线段树套平衡树，即对于线段树所维护的每个区间，建立一个动态开点权值线段树，表示其所维护的区间的值。

在修改操作进行时，先在线段树上从上往下跳到被修改的点，删除所经过的点所指向的动态开点权值线段树上的原来的值，然后插入新的值，要经过 $O(\log n)$ 个线段树上的节点，在动态开点权值线段树上一次修改操作是 $O(\log n)$ 的，所以修改操作的时间复杂度为 $O(\log^2 n)$ 。

在查询答案时，先取出该区间覆盖在线段树上的所有点，然后用类似于静态区间 $k$ 小值的方法，将这些点一起向左儿子或向右儿子跳。如果所有这些点左儿子存储的值大于等于 $k$ ，则往左跳，否则往右跳。由于最多只能覆盖 $O(\log n)$ 个节点，所以最多一次只有这么多个节点向下跳，时间复杂度为 $O(\log^2 n)$ 。

由于线段树的常数较大，在实现中往往使用常数更小且更方便处理前缀和的 **树状数组** 实现。

给出一种代码实现：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <map>
#include <set>
#define LC o << 1
#define RC o << 1 | 1
using namespace std;
const int maxn = 1000010;
int n, m, a[maxn], u[maxn], x[maxn], l[maxn], r[maxn], k[maxn], cur, cur1, cur2,
    q1[maxn], q2[maxn], v[maxn];
char op[maxn];
set<int> ST;
map<int, int> mp;
struct segment_tree  //封装的动态开点权值线段树
{
  int cur, rt[maxn * 4], sum[maxn * 60], lc[maxn * 60], rc[maxn * 60];
  void build(int& o) { o = ++cur; }
  void print(int o, int l, int r) {
    if (!o) return;
    if (l == r && sum[o]) printf("%d ", l);
    int mid = (l + r) >> 1;
    print(lc[o], l, mid);
    print(rc[o], mid + 1, r);
  }
  void update(int& o, int l, int r, int x, int v) {
    if (!o) o = ++cur;
    sum[o] += v;
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (x <= mid)
      update(lc[o], l, mid, x, v);
    else
      update(rc[o], mid + 1, r, x, v);
  }
} st;
//树状数组实现
inline int lowbit(int o) { return (o & (-o)); }
void upd(int o, int x, int v) {
  for (; o <= n; o += lowbit(o)) st.update(st.rt[o], 1, n, x, v);
}
void gtv(int o, int* A, int& p) {
  p = 0;
  for (; o; o -= lowbit(o)) A[++p] = st.rt[o];
}
int qry(int l, int r, int k) {
  if (l == r) return l;
  int mid = (l + r) >> 1, siz = 0;
  for (int i = 1; i <= cur1; i++) siz += st.sum[st.lc[q1[i]]];
  for (int i = 1; i <= cur2; i++) siz -= st.sum[st.lc[q2[i]]];
  // printf("j %d %d %d %d\n",cur1,cur2,siz,k);
  if (siz >= k) {
    for (int i = 1; i <= cur1; i++) q1[i] = st.lc[q1[i]];
    for (int i = 1; i <= cur2; i++) q2[i] = st.lc[q2[i]];
    return qry(l, mid, k);
  } else {
    for (int i = 1; i <= cur1; i++) q1[i] = st.rc[q1[i]];
    for (int i = 1; i <= cur2; i++) q2[i] = st.rc[q2[i]];
    return qry(mid + 1, r, k - siz);
  }
}
/*
线段树实现
void build(int o,int l,int r)
{
    st.build(st.rt[o]);
    if(l==r)return;
    int mid=(l+r)>>1;
    build(LC,l,mid);
    build(RC,mid+1,r);
}
void print(int o,int l,int r)
{
    printf("%d %d:",l,r);
    st.print(st.rt[o],1,n);
    printf("\n");
    if(l==r)return;
    int mid=(l+r)>>1;
    print(LC,l,mid);
    print(RC,mid+1,r);
}
void update(int o,int l,int r,int q,int x,int v)
{
    st.update(st.rt[o],1,n,x,v);
    if(l==r)return;
    int mid=(l+r)>>1;
    if(q<=mid)update(LC,l,mid,q,x,v);
    else update(RC,mid+1,r,q,x,v);
}
void getval(int o,int l,int r,int ql,int qr)
{
    if(l>qr||r<ql)return;
    if(ql<=l&&r<=qr){q[++cur]=st.rt[o];return;}
    int mid=(l+r)>>1;
    getval(LC,l,mid,ql,qr);
    getval(RC,mid+1,r,ql,qr);
}
int query(int l,int r,int k)
{
    if(l==r)return l;
    int mid=(l+r)>>1,siz=0;
    for(int i=1;i<=cur;i++)siz+=st.sum[st.lc[q[i]]];
    if(siz>=k)
    {
        for(int i=1;i<=cur;i++)q[i]=st.lc[q[i]];
        return query(l,mid,k);
    }
    else
    {
        for(int i=1;i<=cur;i++)q[i]=st.rc[q[i]];
        return query(mid+1,r,k-siz);
    }
}
*/
int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; i++) scanf("%d", a + i), ST.insert(a[i]);
  for (int i = 1; i <= m; i++) {
    scanf(" %c", op + i);
    if (op[i] == 'C')
      scanf("%d%d", u + i, x + i), ST.insert(x[i]);
    else
      scanf("%d%d%d", l + i, r + i, k + i);
  }
  for (set<int>::iterator it = ST.begin(); it != ST.end(); it++)
    mp[*it] = ++cur, v[cur] = *it;
  for (int i = 1; i <= n; i++) a[i] = mp[a[i]];
  for (int i = 1; i <= m; i++)
    if (op[i] == 'C') x[i] = mp[x[i]];
  n += m;
  // build(1,1,n);
  for (int i = 1; i <= n; i++) upd(i, a[i], 1);
  // print(1,1,n);
  for (int i = 1; i <= m; i++) {
    if (op[i] == 'C') {
      upd(u[i], a[u[i]], -1);
      upd(u[i], x[i], 1);
      a[u[i]] = x[i];
    } else {
      gtv(r[i], q1, cur1);
      gtv(l[i] - 1, q2, cur2);
      printf("%d\n", v[qry(1, n, k[i])]);
    }
  }
  return 0;
}
```

# seg
author: TrisolarisHD, Ir1d, Ycrpro, Xeonacid, konnyakuxzy, CJSoft, HeRaNO, ethan-enhe, ChungZH, Chrogeek, hsfzLZH1, billchenchina, orzAtalod

线段树是算法竞赛中常用的用来维护 **区间信息** 的数据结构。

线段树可以在 $O(\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。

线段树维护的信息，需要满足可加性，即能以可以接受的速度合并信息和修改信息，包括在使用懒惰标记时，标记也要满足可加性（例如取模就不满足可加性，对 $4$ 取模然后对 $3$ 取模，两个操作就不能合并在一起做）。

## 线段树

### 线段树的基本结构与建树

线段树将每个长度不为 $1$ 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。

有个大小为 $5$ 的数组 $a=\{10,11,12,13,14\}$ ，要将其转化为线段树，有以下做法：设线段树的根节点编号为 $1$ ，用数组 $d$ 来保存我们的线段树， $d_i$ 用来保存线段树上编号为 $i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和），如图所示：

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt1.png)

图中 $d_1$ 表示根节点，紫色方框是数组 $a$ ，红色方框是数组 $d$ ，红色方框中的括号中的黄色数字表示它所在的那个红色方框表示的线段树节点所表示的区间，如 $d_1$ 所表示的区间就是 $[1,5]$ （ $a_1,a_2, \cdots ,a_5$ ），即 $d_1$ 所保存的值是 $a_1+a_2+ \cdots +a_5$ ， $d_1=60$ 表示的是 $a_1+a_2+ \cdots +a_5=60$ 。

通过观察不难发现， $d_i$ 的左儿子节点就是 $d_{2\times i}$ ， $d_i$ 的右儿子节点就是 $d_{2\times i+1}$ 。如果 $d_i$ 表示的是区间 $[s,t]$ （即 $d_i=a_s+a_{s+1}+ \cdots +a_t$ ) 的话，那么 $d_i$ 的左儿子节点表示的是区间 $[ s, \frac{s+t}{2} ]$ ， $d_i$ 的右儿子表示的是区间 $[ \frac{s+t}{2} +1,t ]$ 。

具体要怎么用代码实现呢？

我们继续观察，有没有发现如果 $d_i$ 表示的区间大小等于 $1$ 的话（区间大小指的是区间包含的元素的个数，即 $a$ 的个数。设 $d_j$ 表示区间 $[s,t]$ ，它的区间大小就是 $t-s+1$ ），那么 $d_i$ 所表示的区间 $[s,t]$ 中肯定有 $s=t$ ，且 $d_i=a_s=a_t$ 。这就是线段树的递归边界。

 **思路如下：** 

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt2.png)

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt3.png)

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt4.png)

此处给出 C++ 的代码实现，可参考注释理解：

```cpp
void build(int s, int t, int p) {
  // 对 [s,t] 区间建立线段树,当前根的编号为 p
  if (s == t) {
    d[p] = a[s];
    return;
  }
  int m = (s + t) / 2;
  build(s, m, p * 2), build(m + 1, t, p * 2 + 1);
  // 递归对左右区间建树
  d[p] = d[p * 2] + d[(p * 2) + 1];
}
```

关于线段树的空间：如果采用堆式存储（ $2p$ 是 $p$ 的左儿子， $2p+1$ 是 $p$ 的右儿子），若有 $n$ 个叶子结点，则 d 数组的范围最大为 $2^{\left\lceil\log{n}\right\rceil+1}$ 。

分析：容易知道线段树的深度是 $\left\lceil\log{n}\right\rceil$ 的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 $2^{\left\lceil\log{n}\right\rceil}$ 个，又由于其为一棵完全二叉树，则其总节点个数 $2^{\left\lceil\log{n}\right\rceil+1}-1$ 。当然如果你懒得计算的话可以直接把数组长度设为 $4n$ ，因为 $\frac{2^{\left\lceil\log{n}\right\rceil+1}-1}{n}$ 的最大值在 $n=2^{x}+1(x\in N_{+})$ 时取到，此时节点数为 $2^{\left\lceil\log{n}\right\rceil+1}-1=2^{x+2}-1=4n-5$ 。

### 线段树的区间查询

区间查询，比如求区间 $[l,r]$ 的总和（即 $a_l+a_{l+1}+ \cdots +a_r$ ）、求区间最大值/最小值等操作。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt5.png)

以上面这张图为例，如果要查询区间 $[1,5]$ 的和，那直接获取 $d_1$ 的值（ $60$ ）即可。

如果要查询的区间为 $[3,5]$ ，此时就不能直接获取区间的值，但是 $[3,5]$ 可以拆成 $[3,3]$ 和 $[4,5]$ ，可以通过合并这两个区间的答案来求得这个区间的答案。

一般地，如果要查询的区间是 $[l,r]$ ，则可以将其拆成最多为 $O(\log n)$ 个 **极大** 的区间，合并这些区间即可求出 $[l,r]$ 的答案。

此处给出 C++ 的代码实现，可参考注释理解：

```cpp
int getsum(int l, int r, int s, int t, int p) {
  // [l,r] 为查询区间,[s,t] 为当前节点包含的区间,p 为当前节点的编号
  if (l <= s && t <= r)
    return d[p];  // 当前区间为询问区间的子集时直接返回当前区间的和
  int m = (s + t) / 2, sum = 0;
  if (l <= m) sum += getsum(l, r, s, m, p * 2);
  // 如果左儿子代表的区间 [l,m] 与询问区间有交集,则递归查询左儿子
  if (r > m) sum += getsum(l, r, m + 1, t, p * 2 + 1);
  // 如果右儿子代表的区间 [m+1,r] 与询问区间有交集,则递归查询右儿子
  return sum;
}
```

### 线段树的区间修改与懒惰标记

如果要求修改区间 $[l,r]$ ，把所有包含在区间 $[l,r]$ 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里要引入一个叫做 **「懒惰标记」** 的东西。

我们设一个数组 $b$ ， $b_i$ 表示编号为 $i$ 的节点的懒惰标记值。为了加强对懒惰标记的理解，此处举个例子：

> A 有两个儿子，一个是 B，一个是 C。
>
> 有一天 A 要建一个新房子，没钱。刚好过年嘛，有人要给 B 和 C 红包，两个红包的钱数相同都是 $1$ 元，然而因为 A 是父亲所以红包肯定是先塞给 A 咯~
>
> 理论上来讲 A 应该把两个红包分别给 B 和 C，但是……缺钱嘛，A 就把红包偷偷收到自己口袋里了。
>
> A 高兴地说：「我现在有 $2$ 份红包了！我又多了 $2\times 1=2$ 元了！哈哈哈~」
>
> 但是 A 知道，如果他不把红包给 B 和 C，那 B 和 C 肯定会不爽然后导致家庭矛盾最后崩溃，所以 A 对儿子 B 和 C 说：「我欠你们每人 $1$ 份 $1$ 元的红包，下次有新红包给过来的时候再给你们！这里我先做下记录……嗯……我欠你们各 $1$ 元……」
>
> 儿子 B、C 有点恼怒：「可是如果有同学问起我们我们收到了多少红包咋办？你把我们的红包都收了，我们还怎么装？」
>
> 父亲 A 赶忙说：「有同学问起来我就会给你们的！我欠条都写好了不会不算话的！」
>
> 这样 B、C 才放了心。

在这个故事中我们不难看出，A 就是父亲节点，B 和 C 是 A 的儿子节点，而且 B 和 C 是叶子节点，分别对应一个数组中的值（就是之前讲的数组 $a$ ），我们假设节点 A 表示区间 $[1,2]$ （即 $a_1+a_2$ ），节点 B 表示区间 $[1,1]$ （即 $a_1$ ），节点 C 表示区间 $[2,2]$ （即 $a_2$ ），它们的初始值都为 $0$ （现在才刚开始呢，还没拿到红包，所以都没钱）。

如图：

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt6.png)

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt7.png)

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt8.png)

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt9.png)

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt10.png)

注：这里 D 表示当前节点的值（即所表示区间的区间和）。
为什么节点 A 的 D 是 $2\times 1=2$ 呢？原因很简单：节点 A 表示的区间是 $[1,2]$ ，一共包含 $2$ 个元素。我们是让 $[1,2]$ 这个区间的每个元素都加上 $1$ ，所以节点 A 的值就加上了 $2\times 1=2$ 咯。

如果这时候我们要查询区间 $[1,1]$ （即节点 B 的值），A 就把它欠的还给 B，此时的操作称为 **下传懒惰标记** 。

具体是这样操作（如图）：

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt11.png)

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt12.png)

注：为什么是加上 $1\times 1=1$ 呢？因为 B 和 C 表示的区间中只有 $1$ 个元素。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/segt13.png)

由此我们可以得到，区间 $[1,1]$ 的区间和就是 $1$ 。

区间修改（区间加上某个值）：

```cpp
void update(int l, int r, int c, int s, int t, int p) {
  // [l,r] 为修改区间,c 为被修改的元素的变化量,[s,t] 为当前节点包含的区间,p
  // 为当前节点的编号
  if (l <= s && t <= r) {
    d[p] += (t - s + 1) * c, b[p] += c;
    return;
  }  // 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改
  int m = (s + t) / 2;
  if (b[p] && s /home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!= t) {
    // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值
    d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m);
    b[p * 2] += b[p], b[p * 2 + 1] += b[p];  // 将标记下传给子节点
    b[p] = 0;                                // 清空当前节点的标记
  }
  if (l <= m) update(l, r, c, s, m, p * 2);
  if (r > m) update(l, r, c, m + 1, t, p * 2 + 1);
  d[p] = d[p * 2] + d[p * 2 + 1];
}
```

区间查询（区间求和）：

```cpp
int getsum(int l, int r, int s, int t, int p) {
  // [l,r] 为修改区间,c 为被修改的元素的变化量,[s,t] 为当前节点包含的区间,p
  // 为当前节点的编号
  if (l <= s && t <= r) return d[p];
  // 当前区间为询问区间的子集时直接返回当前区间的和
  int m = (s + t) / 2;
  if (b[p]) {
    // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值
    d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m),
        b[p * 2] += b[p], b[p * 2 + 1] += b[p];  // 将标记下传给子节点
    b[p] = 0;                                    // 清空当前节点的标记
  }
  int sum = 0;
  if (l <= m) sum = getsum(l, r, s, m, p * 2);
  if (r > m) sum += getsum(l, r, m + 1, t, p * 2 + 1);
  return sum;
}
```

如果你是要实现区间修改为某一个值而不是加上某一个值的话，代码如下：

```cpp
void update(int l, int r, int c, int s, int t, int p) {
  if (l <= s && t <= r) {
    d[p] = (t - s + 1) * c, b[p] = c;
    return;
  }
  int m = (s + t) / 2;
  if (b[p]) {
    d[p * 2] = b[p] * (m - s + 1), d[p * 2 + 1] = b[p] * (t - m),
          b[p * 2] = b[p * 2 + 1] = b[p];
    b[p] = 0;
  }
  if (l <= m) update(l, r, c, s, m, p * 2);
  if (r > m) update(l, r, c, m + 1, t, p * 2 + 1);
  d[p] = d[p * 2] + d[p * 2 + 1];
}
int getsum(int l, int r, int s, int t, int p) {
  if (l <= s && t <= r) return d[p];
  int m = (s + t) / 2;
  if (b[p]) {
    d[p * 2] = b[p] * (m - s + 1), d[p * 2 + 1] = b[p] * (t - m),
          b[p * 2] = b[p * 2 + 1] = b[p];
    b[p] = 0;
  }
  int sum = 0;
  if (l <= m) sum = getsum(l, r, s, m, p * 2);
  if (r > m) sum += getsum(l, r, m + 1, t, p * 2 + 1);
  return sum;
}
```

## 一些优化

这里总结几个线段树的优化：

-   在叶子节点处无需下放懒惰标记，所以懒惰标记可以不下传到叶子节点。

-   下放懒惰标记可以写一个专门的函数 `pushdown` ，从儿子节点更新当前节点也可以写一个专门的函数 `maintain` （或者对称地用 `pushup` ），降低代码编写难度。

-   标记永久化，如果确定懒惰标记不会在中途被加到溢出（即超过了该类型数据所能表示的最大范围），那么就可以将标记永久化。标记永久化可以避免下传懒惰标记，只需在进行询问时把标记的影响加到答案当中，从而降低程序常数。具体如何处理与题目特性相关，需结合题目来写。这也是树套树和可持久化数据结构中会用到的一种技巧。

## 线段树基础题推荐

###  [luogu P3372【模板】线段树 1](https://www.luogu.org/problem/P3372) 

??? "参考代码"
    ```cpp
    #include <iostream>
    typedef long long LL;
    LL n, a[100005], d[270000], b[270000];
    void build(LL l, LL r, LL p) {
      if (l == r) {
        d[p] = a[l];
        return;
      }
      LL m = (l + r) >> 1;
      build(l, m, p << 1), build(m + 1, r, (p << 1) | 1);
      d[p] = d[p << 1] + d[(p << 1) | 1];
    }
    void update(LL l, LL r, LL c, LL s, LL t, LL p) {
      if (l <= s && t <= r) {
        d[p] += (t - s + 1) * c, b[p] += c;
        return;
      }
      LL m = (s + t) >> 1;
      if (b[p])
        d[p << 1] += b[p] * (m - s + 1), d[(p << 1) | 1] += b[p] * (t - m),
            b[p << 1] += b[p], b[(p << 1) | 1] += b[p];
      b[p] = 0;
      if (l <= m) update(l, r, c, s, m, p << 1);
      if (r > m) update(l, r, c, m + 1, t, (p << 1) | 1);
      d[p] = d[p << 1] + d[(p << 1) | 1];
    }
    LL getsum(LL l, LL r, LL s, LL t, LL p) {
      if (l <= s && t <= r) return d[p];
      LL m = (s + t) >> 1;
      if (b[p])
        d[p << 1] += b[p] * (m - s + 1), d[(p << 1) | 1] += b[p] * (t - m),
            b[p << 1] += b[p], b[(p << 1) | 1] += b[p];
      b[p] = 0;
      LL sum = 0;
      if (l <= m) sum = getsum(l, r, s, m, p << 1);
      if (r > m) sum += getsum(l, r, m + 1, t, (p << 1) | 1);
      return sum;
    }
    int main() {
      std::ios::sync_with_stdio(0);
      LL q, i1, i2, i3, i4;
      std::cin >> n >> q;
      for (LL i = 1; i <= n; i++) std::cin >> a[i];
      build(1, n, 1);
      while (q--) {
        std::cin >> i1 >> i2 >> i3;
        if (i1 == 2)
          std::cout << getsum(i2, i3, 1, n, 1) << std::endl;
        else
          std::cin >> i4, update(i2, i3, i4, 1, n, 1);
      }
      return 0;
    }
    ```

###  [luogu P3373【模板】线段树 2](https://www.luogu.org/problem/P3373) 

??? "参考代码"
    ```cpp
    #include <cstdio>
    #define ll long long
    ll read() {
      ll w = 1, q = 0;
      char ch = ' ';
      while (ch /home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!= '-' && (ch < '0' || ch > '9')) ch = getchar();
      if (ch == '-') w = -1, ch = getchar();
      while (ch >= '0' && ch <= '9') q = (ll)q * 10 + ch - '0', ch = getchar();
      return (ll)w * q;
    }
    int n, m;
    ll mod;
    ll a[100005], sum[400005], mul[400005], laz[400005];
    void up(int i) { sum[i] = (sum[(i << 1)] + sum[(i << 1) | 1]) % mod; }
    void pd(int i, int s, int t) {
      int l = (i << 1), r = (i << 1) | 1, mid = (s + t) >> 1;
      if (mul[i] /home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!= 1) {
        mul[l] *= mul[i];
        mul[l] %= mod;
        mul[r] *= mul[i];
        mul[r] %= mod;
        laz[l] *= mul[i];
        laz[l] %= mod;
        laz[r] *= mul[i];
        laz[r] %= mod;
        sum[l] *= mul[i];
        sum[l] %= mod;
        sum[r] *= mul[i];
        sum[r] %= mod;
        mul[i] = 1;
      }
      if (laz[i]) {
        sum[l] += laz[i] * (mid - s + 1);
        sum[l] %= mod;
        sum[r] += laz[i] * (t - mid);
        sum[r] %= mod;
        laz[l] += laz[i];
        laz[l] %= mod;
        laz[r] += laz[i];
        laz[r] %= mod;
        laz[i] = 0;
      }
      return;
    }
    void build(int s, int t, int i) {
      mul[i] = 1;
      if (s == t) {
        sum[i] = a[s];
        return;
      }
      int mid = (s + t) >> 1;
      build(s, mid, i << 1);
      build(mid + 1, t, (i << 1) | 1);
      up(i);
    }
    void chen(int l, int r, int s, int t, int i, ll z) {
      int mid = (s + t) >> 1;
      if (l <= s && t <= r) {
        mul[i] *= z;
        mul[i] %= mod;
        laz[i] *= z;
        laz[i] %= mod;
        sum[i] *= z;
        sum[i] %= mod;
        return;
      }
      pd(i, s, t);
      if (mid >= l) chen(l, r, s, mid, (i << 1), z);
      if (mid + 1 <= r) chen(l, r, mid + 1, t, (i << 1) | 1, z);
      up(i);
    }
    void add(int l, int r, int s, int t, int i, ll z) {
      int mid = (s + t) >> 1;
      if (l <= s && t <= r) {
        sum[i] += z * (t - s + 1);
        sum[i] %= mod;
        laz[i] += z;
        laz[i] %= mod;
        return;
      }
      pd(i, s, t);
      if (mid >= l) add(l, r, s, mid, (i << 1), z);
      if (mid + 1 <= r) add(l, r, mid + 1, t, (i << 1) | 1, z);
      up(i);
    }
    ll getans(int l, int r, int s, int t, int i) {
      int mid = (s + t) >> 1;
      ll tot = 0;
      if (l <= s && t <= r) return sum[i];
      pd(i, s, t);
      if (mid >= l) tot += getans(l, r, s, mid, (i << 1));
      tot %= mod;
      if (mid + 1 <= r) tot += getans(l, r, mid + 1, t, (i << 1) | 1);
      return tot % mod;
    }
    int main() {
      int i, j, x, y, bh;
      ll z;
      n = read();
      m = read();
      mod = read();
      for (i = 1; i <= n; i++) a[i] = read();
      build(1, n, 1);
      for (i = 1; i <= m; i++) {
        bh = read();
        if (bh == 1) {
          x = read();
          y = read();
          z = read();
          chen(x, y, 1, n, 1, z);
        } else if (bh == 2) {
          x = read();
          y = read();
          z = read();
          add(x, y, 1, n, 1, z);
        } else if (bh == 3) {
          x = read();
          y = read();
          printf("%lld\n", getans(x, y, 1, n, 1));
        }
      }
      return 0;
    }
    ```

###  [HihoCoder 1078 线段树的区间修改](https://cn.vjudge.net/problem/HihoCoder-1078) 

??? "参考代码"
    ```cpp
    #include <iostream>
    
    int n, a[100005], d[270000], b[270000];
    void build(int l, int r, int p) {
      if (l == r) {
        d[p] = a[l];
        return;
      }
      int m = (l + r) >> 1;
      build(l, m, p << 1), build(m + 1, r, (p << 1) | 1);
      d[p] = d[p << 1] + d[(p << 1) | 1];
    }
    void update(int l, int r, int c, int s, int t, int p) {
      if (l <= s && t <= r) {
        d[p] = (t - s + 1) * c, b[p] = c;
        return;
      }
      int m = (s + t) >> 1;
      if (b[p]) {
        d[p << 1] = b[p] * (m - s + 1), d[(p << 1) | 1] = b[p] * (t - m);
        b[p << 1] = b[(p << 1) | 1] = b[p];
        b[p] = 0;
      }
      if (l <= m) update(l, r, c, s, m, p << 1);
      if (r > m) update(l, r, c, m + 1, t, (p << 1) | 1);
      d[p] = d[p << 1] + d[(p << 1) | 1];
    }
    int getsum(int l, int r, int s, int t, int p) {
      if (l <= s && t <= r) return d[p];
      int m = (s + t) >> 1;
      if (b[p]) {
        d[p << 1] = b[p] * (m - s + 1), d[(p << 1) | 1] = b[p] * (t - m);
        b[p << 1] = b[(p << 1) | 1] = b[p];
        b[p] = 0;
      }
      int sum = 0;
      if (l <= m) sum = getsum(l, r, s, m, p << 1);
      if (r > m) sum += getsum(l, r, m + 1, t, (p << 1) | 1);
      return sum;
    }
    int main() {
      std::ios::sync_with_stdio(0);
      std::cin >> n;
      for (int i = 1; i <= n; i++) std::cin >> a[i];
      build(1, n, 1);
      int q, i1, i2, i3, i4;
      std::cin >> q;
      while (q--) {
        std::cin >> i1 >> i2 >> i3;
        if (i1 == 0)
          std::cout << getsum(i2, i3, 1, n, 1) << endl;
        else
          std::cin >> i4, update(i2, i3, i4, 1, n, 1);
      }
      return 0;
    }
    ```

###  [2018 Multi-University Training Contest 5 Problem G. Glad You Came](http://acm.hdu.edu.cn/showproblem.php?pid=6356) 

维护一下每个区间的永久标记就可以了，最后在线段树上跑一边 dfs 统计结果即可。注意打标记的时候加个剪枝优化，否则会 T。

## 拓展 - 猫树

众所周知线段树可以支持高速查询某一段区间的信息和，比如区间最大子段和，区间和，区间矩阵的连乘积等等。

但是有一个问题在于普通线段树的区间询问在某些毒瘤的眼里可能还是有些慢了。

简单来说就是线段树建树的时候需要做 $O(n)$ 次合并操作，而每一次区间询问需要做 $O(\log{n})$ 次合并操作，询问区间和这种东西的时候还可以忍受，但是当我们需要询问区间线性基这种合并复杂度高达 $O(\log^2{w})$ 的信息的话，此时就算是做 $O(\log{n})$ 次合并有些时候在时间上也是不可接受的。

而所谓 "猫树" 就是一种不支持修改，仅仅支持快速区间询问的一种静态线段树。

构造一棵这样的静态线段树需要 $O(n\log{n})$ 次合并操作，但是此时的查询复杂度被加速至 $O(1)$ 次合并操作。

在处理线性基这样特殊的信息的时候甚至可以将复杂度降至 $O(n\log^2{w})$ 。

### 原理

在查询 $[l,r]$ 这段区间的信息和的时候，将线段树树上代表 $[l,l]$ 的节点和代表 $[r,r]$ 这段区间的节点在线段树上的 lca 求出来，设这个节点 $p$ 代表的区间为 $[L,R]$ ，我们会发现一些非常有趣的性质：

 **1. $[L,R]$ 这个区间一定包含 $[l,r]$ ** 

显然，因为它既是 $l$ 的祖先又是 $r$ 的祖先。

 **2. $[l,r]$ 这个区间一定跨越 $[L,R]$ 的中点** 

由于 $p$ 是 $l$ 和 $r$ 的 lca，这意味着 $p$ 的左儿子是 $l$ 的祖先而不是 $r$ 的祖先， $p$ 的右儿子是 $r$ 的祖先而不是 $l$ 的祖先。

因此 $l$ 一定在 $[L,MID]$ 这个区间内， $r$ 一定在 $(MID,R]$ 这个区间内。

有了这两个性质，我们就可以将询问的复杂度降至 $O(1)$ 了。

### 实现

具体来讲我们建树的时候对于线段树树上的一个节点，设它代表的区间为 $(l,r]$ 。

不同于传统线段树在这个节点里只保留 $[l,r]$ 的和，我们在这个节点里面额外保存 $（l,mid]$ 的后缀和数组和 $(mid,r]$ 的前缀和数组。

这样的话建树的复杂度为 $T(n)=2T(n/2)+O(n)=O(n\log{n})$ 同理空间复杂度也从原来的 $O(n)$ 变成了 $O(n\log{n})$ 。

下面是最关键的询问了~

如果我们询问的区间是 $[l,r]$ 那么我们把代表 $[l,l]$ 的节点和代表 $[r,r]$ 的节点的 lca 求出来，记为 $p$ 。

根据刚才的两个性质， $l,r$ 在 $p$ 所包含的区间之内并且一定跨越了 $p$ 的中点。

这意味这一个非常关键的事实是我们可以使用 $p$ 里面的前缀和数组和后缀和数组，将 $[l,r]$ 拆成 $[l,mid]+(mid,r]$ 从而拼出来 $[l,r]$ 这个区间。

而这个过程仅仅需要 $O(1)$ 次合并操作！

不过我们好像忽略了点什么？

似乎求 lca 的复杂度似乎还不是 $O(1)$ ，暴力求是 $O(\log{n})$ 的，倍增法则是 $O(\log{\log{n}})$ 的，转 ST 表的代价又太大……

### 堆式建树

具体来将我们将这个序列补成 2 的整次幂，然后建线段树。

此时我们发现线段树上两个节点的 lca 编号，就是两个节点二进制编号的 lcp。

稍作思考即可发现发现在 $x$ 和 $y$ 的二进制下 `lcp(x,y)=x>>log[x^y]` 。

所以我们预处理一个 `log` 数组即可轻松完成求 lca 的工作。

这样我们就完成了一个猫树。

由于建树的时候涉及到求前缀和和求后缀和，所以对于线性基这种虽然合并是 $O(\log^2{w})$ 但是求前缀和却是 $O(n\log{n})$ 的信息，使用猫树可以将静态区间线性基从 $O(n\log^2{w}+m\log^2{w}\log{n})$ 优化至 $O(n\log{n}\log{w}+m\log^2{w})$ 的复杂度。

### 参考

 [immortalCO 大爷的博客](https://immortalco.blog.uoj.ac/blog/2102) 

# monotonous-stack
## 何为单调栈

顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。

为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。

## 如何使用单调栈

### 插入

将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。

例如，栈中自顶向下的元素为 ${1,3,5,10,30,50}$ ，插入元素 $20$ 时为了保证单调性需要依次弹出元素 $1,3,5,10$ ，操作后栈变为 $20,30,50$ 。

用伪代码描述如下：

```text
insert x
while !sta.empty() && sta.top()<x
    sta.pop()
sta.push(x)
```

### 使用

自然就是从栈顶读出来一个元素，该元素满足单调性的某一端。

例如举例中取出的即栈中的最小值。

## 应用

??? note "[POJ3250 Bad Hair Day](http://poj.org/problem?id=3250)"
    有 $N$ 头牛从左到右排成一排，每头牛有一个高度 $h_i$ ，设左数第 $i$ 头牛与「它右边第一头高度 $≥h_i$ 」的牛之间有 $c_i$ 头牛，试求 $\sum_{i=1}^{N} c_i$ 。

比较基础的应用有这一题，就是个单调栈的简单应用，记录每头牛被弹出的位置，如果没有被弹出过则为最远端，稍微处理一下即可计算出题目所需结果。

另外，单调栈也可以用于离线解决 RMQ 问题。

我们可以把所有询问按右端点排序，然后每次在序列上从左往右扫描到当前询问的右端点处，并把扫描到的元素插入到单调栈中。这样，每次回答询问时，单调栈中存储的值都是位置 $\le r$ 的、可能成为答案的决策点，并且这些元素满足单调性质。此时，单调栈上第一个位置 $\ge l$ 的元素就是当前询问的答案，这个过程可以用二分查找实现。使用单调栈解决 RMQ 问题的时间复杂度为 $O(q\log q + q\log n)$ ，空间复杂度为 $O(n)$ 。

# divide-combine
解释一下本文可能用到的符号： $\wedge$ 逻辑与， $\vee$ 逻辑或。

## 关于段的问题

我们由一个小清新的问题引入：

> 对于一个 $1-n$ 的排列，我们称一个值域连续的区间为段。问一个排列的段的个数。比如， $\{5 ,3 ,4, 1 ,2\}$ 的段有： $[1,1],[2,2],[3,3],[4,4],[5,5],[2,3],[4,5],[1,3],[2,5],[1,5]$ 。

看到这个东西，感觉要维护区间的值域集合，复杂度好像挺不友好的。线段树可以查询某个区间是否为段，但不太能统计段的个数（也可能是因为我太菜了不会用线段树）

这里我们引入这个神奇的数据结构——析合树！

## 连续段

在介绍析合树之前，我们先做一些前提条件的限定。鉴于 LCA 的课件的定义十分玄乎，为保证读者的身心健康，我就~~口糊~~一些人性化的定义吧。

### 排列与连续段

 **排列** ：定义一个 $n$ 阶排列 $P$ 是一个大小为 $n$ 的序列，使得 $P_i$ 取遍 $1,2,\cdots,n$ 。说得形式化一点， $n$ 阶排列 $P$ 是一个有序集合满足：

1.   $|P|=n$ .
2.   $\forall i,P_i\in[1,n]$ .
3.   $\nexists i,j\in[1,n],P_i=P_j$ .

     **连续段** ：对于排列 $P$ ，定义连续段 $(P,[l,r])$ 表示一个区间 $[l,r]$ ，要求 $P_{l\sim r}$ 值域是连续的。说得更形式化一点，对于排列 $P$ ，连续段表示一个区间 $[l,r]$ 满足：

$$
(\nexists\ x,z\in[l,r],y\notin[l,r],\ P_x<P_y<P_z)
$$

特别地，当 $l>r$ 时，我们认为这是一个空的连续段，记作 $(P,\varnothing)$ 。

我们称排列 $P$ 的所有连续段的集合为 $I_P$ ，并且我们认为 $(P,\varnothing)\in I_P$ 。

### 连续段的运算

连续段是依赖区间和值域定义的，于是我们可以定义连续段的交并差的运算。

定义 $A=(P,[a,b]),B=(P,[x,y])$ ，且 $A,B\in I_P$ 。于是连续段的关系和运算可以表示为：

1.   $A\subseteq B\Leftrightarrow x\le a\wedge b\le y$ .
2.   $A=B\Leftrightarrow a=x\wedge b=y$ .
3.   $A\cap B=(P,[\max(a,x),\min(b,y)])$ .
4.   $A\cup B=(P,[\min(a,x),\max(b,y)])$ .
5.   $A\setminus B=(P,\{i|i\in[a,b]\wedge i\notin[x,y]\})$ .

其实这些运算就是普通的集合交并差放在区间上而已。

### 连续段的性质

连续段的一些显而易见的性质。我们定义 $A,B\in I_P,A \cap B \neq \varnothing$ ，那么有 $A\cup B,A\cap B,A\setminus B,B\setminus A\in I_P$ 。

证明？证明的本质就是集合的交并差的运算。

## 析合树

好的，现在讲到重点了。你可能已经猜到了，析合树正是由连续段组成的一棵树。但是要知道一个排列可能有多达 $O(n^2)$ 个连续段，因此我们就要抽出其中更基本的连续段组成析合树。

### 本原段

其实这个定义全称叫作 **本原连续段** 。但笔者认为本原段更为简洁。

对于排列 $P$ ，我们认为一个本原段 $M$ 表示在集合 $I_P$ 中，不存在与之相交且不包含的连续段。形式化地定义，我们认为 $X\in I_P$ 且满足 $\forall A\in I_P,\ X\cap A= (P,\varnothing)\vee X\subseteq A\vee A\subseteq X$ 。

所有本原段的集合为 $M_P$ . 显而易见， $(P,\varnothing)\in M_P$ 。

显然，本原段之间只有相离或者包含关系。并且你发现 **一个连续段可以由几个互不相交的本原段构成** 。最大的本原段就是整个排列本身，它包含了其他所有本原段，因此我们认为本原段可以构成一个树形结构，我们称这个结构为 **析合树** 。更严格地说，排列 $P$ 的析合树由排列 $P$ 的 **所有本原段** 组成。

前面干讲这么多的定义，不来点图怎么行。考虑排列 $P=\{9,1,10,3,2,5,7,6,8,4\}$ . 它的本原段构成的析合树如下：

![p1](./images/div-com1.png)

在图中我们没有标明本原段。而图中 **每个结点都代表一个本原段** 。我们只标明了每个本原段的值域。举个例子，结点 $[5,8]$ 代表的本原段就是 $(P,[6,9])=\{5,7,6,8\}$ 。于是这里就有一个问题： **什么是析点合点？** 

### 析点与合点

这里我们直接给出定义，稍候再来讨论它的正确性。

1.   **值域区间** ：对于一个结点 $u$ ，用 $[u_l,u_r]$ 表示该结点的值域区间。
2.   **儿子序列** ：对于析合树上的一个结点 $u$ ，假设它的儿子结点是一个 **有序** 序列，该序列是以值域区间为元素的（单个的数 $x$ 可以理解为 $[x,x]$ 的区间）。我们把这个序列称为儿子序列。记作 $S_u$ 。
3.   **儿子排列** ：对于一个儿子序列 $S_u$ ，把它的元素离散化成正整数后形成的排列称为儿子排列。举个例子，对于结点 $[5,8]$ ，它的儿子序列为 $\{[5,5],[6,7],[8,8]\}$ ，那么把区间排序标个号，则它的儿子排列就为 $\{1,2,3\}$ ；类似的，结点 $[4,8]$ 的儿子排列为 $\{2,1\}$ 。结点 $u$ 的儿子排列记为 $P_u$ 。
4.   **合点** ：我们认为，儿子排列为顺序或者逆序的点为合点。形式化地说，满足 $P_u=\{1,2,\cdots,|S_u|\}$ 或者 $P_u=\{|S_u|,|S_u-1|,\cdots,1\}$ 的点称为合点。 **叶子结点没有儿子排列，我们也认为它是合点** 。
5.   **析点** ：不是合点的就是析点。

从图中可以看到，只有 $[1,10]$ 不是合点。因为 $[1,10]$ 的儿子排列是 $\{3,1,4,2\}$ 。

### 析点与合点的性质

析点与合点的命名来源于他们的性质。首先我们有一个非常显然的性质：对于析合树中任何的结点 $u$ ，其儿子序列区间的并集就是结点 $u$ 的值域区间。即 $\bigcup_{i=1}^{|S_u|}S_u[i]=[u_l,u_r]$ 。

对于一个合点 $u$ ：其儿子序列的任意 **子区间** 都构成一个 **连续段** 。形式化地说， $\forall S_u[l\sim r]$ ，有 $\bigcup_{i=l}^rS_u[i]\in I_P$ 。

对于一个析点 $u$ ：其儿子序列的任意 **长度大于 1（这里的长度是指儿子序列中的元素数，不是下标区间的长度）** 的子区间都 **不** 构成一个 **连续段** 。形式化地说， $\forall S_u[l\sim r],l<r$ ，有 $\bigcup_{i=l}^rS_u[i]\notin I_P$ 。

合点的性质不难~~口糊~~证明。因为合点的儿子排列要么是顺序，要么是倒序，而值域区间也是首位相接，因此只要是连续的一段子序列（区间）都是一个连续段。

对于析点的性质可能很多读者就不太能理解了：为什么 **任意** 长度大于 $1$ 的子区间都不构成连续段？

使用反证法。假设对于一个点 $u$ ，它的儿子序列中有一个 **最长的** 区间 $S_u[l\sim r]$ 构成了连续段。那么这个 $A=\bigcup_{i=l}^rS_u[i]\in I_P$ ，也就意味着 $A$ 是一个本原段！（因为 $A$ 是儿子序列中最长的，因此找不到一个与它相交又不包含的连续段）于是你就没有使用所有的本原段构成这个析合树。矛盾。

### 析合树的构造

前面讲了这么多零零散散的东西，现在就来具体地讲如何构造析合树。LCA 大佬的线性构造算法我是没看懂的，今天就讲一下比较好懂的 $O(n\log n)$ 的算法。

#### 增量法

我们考虑增量法。用一个栈维护前 $i-1$ 个元素构成的析合森林。在这里我需要 **着重强调** ，析合森林的意思是，在任何时侯，栈中结点要么是析点要么是合点。现在考虑当前结点 $P_i$ 。

1.  我们先判断它能否成为栈顶结点的儿子，如果能就变成栈顶的儿子，然后把栈顶取出，作为当前结点。重复上述过程直到栈空或者不能成为栈顶结点的儿子。
2.  如果不能成为栈顶的儿子，就看能不能把栈顶的若干个连续的结点都合并成一个结点（判断能否合并的方法在后面），把合并后的点，作为当前结点。
3.  重复上述过程直到不能进行为止。然后结束此次增量，直接把当前结点圧栈。

接下来我们仔细解释一下。

#### 具体的策略

我们认为，如果当前点能够成为栈顶结点的儿子，那么栈顶结点是一个合点。如果是析点，那么你合并后这个析点就存在一个子连续段，不满足析点的性质。因此一定是合点。

如果无法成为栈顶结点的儿子，那么我们就看栈顶连续的若干个点能否与当前点一起合并。设 $l$ 为当前点所在区间的左端点。我们计算 $L$ 表示右端点下标为 $i$ 的连续段中，左端点 $\lt l$ 的最大值。当前结点为 $P_i$ ，栈顶结点记为 $t$ 。

1.  如果 $L$ 不存在，那么显然当前结点无法合并；
2.  如果 $t_l=L$ ，那么这就是两个结点合并，合并后就是一个 **合点** ；
3.  否则在栈中一定存在一个点 $t'$ 的左端点 ${t'}_l=L$ ，那么一定可以从当前结点合并到 $t’$ 形成一个 **析点** ；

#### 判断能否合并

最后，我们考虑如何处理 $L$ 。事实上，一个连续段 $(P,[l,r])$ 等价于区间极差与区间长度 -1 相等。即

$$
\max_{l\le i\le r}P_i-\min_{l\le i\le r}P_i=r-l
$$

而且由于 P 是一个排列，因此对于任意的区间 $[l,r]$ 都有

$$
\max_{l\le i\le r}P_i-\min_{l\le i\le r}P_i\ge r-l
$$

于是我们就维护 $\max_{l\le i\le r}P_i-\min_{l\le i\le r}P_i-(r-l)$ ，那么要找到一个连续段相当于查询一个最小值！

有了上述思路，不难想到这样的算法。对于增量过程中的当前的 $i$ ，我们维护一个数组 $Q$ 表示区间 $[j,i]$ 的极差减长度。即

$$
Q_j=\max_{j\le k\le i}P_k-\min_{j\le k\le i}P_k-(i-j),\ \ 0<j<i
$$

现在我们想知道在 $1\sim i-1$ 中是否存在一个最小的 $j$ 使得 $Q_j=0$ 。这等价于求 $Q_{1\sim i-1}$ 的最小值。求得最小的 $j$ 就是 $L_i$ 。如果没有，那么 $L_i=i$ 。

但是当第 $i$ 次增量结束时，我们需要快速把 $Q$ 数组更新到 i+1 的情况。原本的区间从 $[j,i]$ 变成 $[j,i+1]$ ，如果 $P_{i+1}>\max$ 或者 $P_{i+1}<\min$ 都会造成 $Q_j$ 发生变化。如何变化？如果 $P_{i+1}>\max$ ，相当于我们把 $Q_j$ 先减掉 $\max$ 再加上 $P_{i+1}$ 就完成了 $Q_j$ 的更新； $P_{i+1}<\min$ 同理，相当于 $Q_j=Q_j+\min-P_{i+1}$ .

那么如果对于一个区间 $[x,y]$ ，满足 $P_{x\sim i},P_{x+1\sim i},P_{x+2\sim i},\cdots,P_{y\sim i}$ 的区间 $\max$ 都相同呢？你已经发现了，那么相当于我们在做一个区间加的操作；同理，当 $P_{x\sim i},P_{x+1\sim i},\cdots,P_{y\sim i}$ 的区间 $\min$ 都想同时也是一个区间加的操作。同时， $\max$ 和 $\min$ 的更新是相互独立的，因此可以各自更新。

因此我们对 $Q$ 的维护可以这样描述：

1.  找到最大的 $j$ 使得 $P_{j}>P_{i+1}$ ，那么显然， $P_{j+1\sim i}$ 这一段数全部小于 $P_{i+1}$ ，于是就需要更新 $Q_{j+1\sim i}$ 的最大值。由于 $P_{i},\max(P_i,P_{i-1}),\max(P_i,P_{i-1},P_{i-2}),\cdots,\max(P_i,P_{i-1},\cdots,P_{j+1})$ 是（非严格）单调递增的，因此可以每一段相同的 $\max$ 做相同的更新，即区间加操作。
2.  更新 $\min$ 同理。
3.  把每一个 $Q_j$ 都减 $1$ 。因为区间长度加 $1$ 。
4.  查询 $L_i$ ：即查询 $Q$ 的最小值的所在的 **下标** 。

没错，我们可以使用线段树维护 $Q$ ！现在还有一个问题：怎么找到相同的一段使得他们的 $\max/\min$ 都相同？使用单调栈维护！维护两个单调栈分别表示 $\max/\min$ 。那么显然，栈中以相邻两个元素为端点的区间的 $\max/\min$ 是相同的，于是在维护单调栈的时侯顺便更新线段树即可。

具体的维护方法见代码。

讲这么多干巴巴的想必小伙伴也听得云里雾里的，那么我们就先上图吧。长图警告！

![p2](./images/div-com2.jpg)

### 实现

最后放一个实现的代码供参考。代码转自 [大米饼的博客](https://www.cnblogs.com/Paul-Guderian/p/11020708.html) ，被我加了一些注释。

```cpp
#include <bits/stdc++.h>
#define rg register
using namespace std;
const int N = 200010;

int n, m, a[N], st1[N], st2[N], tp1, tp2, rt;
int L[N], R[N], M[N], id[N], cnt, typ[N], bin[20], st[N], tp;
//本篇代码原题应为 CERC2017 Intrinsic Interval
// a数组即为原题中对应的排列
// st1和st2分别两个单调栈，tp1、tp2为对应的栈顶，rt为析合树的根
// L、R数组表示该析合树节点的左右端点，M数组的作用在析合树构造时有提到
// id存储的是排列中某一位置对应的节点编号，typ用于标记析点还是合点
// st为存储析合树节点编号的栈，tp为其栈顶
struct RMQ {  // 预处理 RMQ（Max & Min）
  int lg[N], mn[N][17], mx[N][17];
  void chkmn(int& x, int y) {
    if (x > y) x = y;
  }
  void chkmx(int& x, int y) {
    if (x < y) x = y;
  }
  void build() {
    for (int i = bin[0] = 1; i < 20; ++i) bin[i] = bin[i - 1] << 1;
    for (int i = 2; i <= n; ++i) lg[i] = lg[i >> 1] + 1;
    for (int i = 1; i <= n; ++i) mn[i][0] = mx[i][0] = a[i];
    for (int i = 1; i < 17; ++i)
      for (int j = 1; j + bin[i] - 1 <= n; ++j)
        mn[j][i] = min(mn[j][i - 1], mn[j + bin[i - 1]][i - 1]),
        mx[j][i] = max(mx[j][i - 1], mx[j + bin[i - 1]][i - 1]);
  }
  int ask_mn(int l, int r) {
    int t = lg[r - l + 1];
    return min(mn[l][t], mn[r - bin[t] + 1][t]);
  }
  int ask_mx(int l, int r) {
    int t = lg[r - l + 1];
    return max(mx[l][t], mx[r - bin[t] + 1][t]);
  }
} D;
// 维护 L_i

struct SEG {  // 线段树
#define ls (k << 1)
#define rs (k << 1 | 1)
  int mn[N << 1], ly[N << 1];  // 区间加；区间最小值
  void pushup(int k) { mn[k] = min(mn[ls], mn[rs]); }
  void mfy(int k, int v) { mn[k] += v, ly[k] += v; }
  void pushdown(int k) {
    if (ly[k]) mfy(ls, ly[k]), mfy(rs, ly[k]), ly[k] = 0;
  }
  void update(int k, int l, int r, int x, int y, int v) {
    if (l == x && r == y) {
      mfy(k, v);
      return;
    }
    pushdown(k);
    int mid = (l + r) >> 1;
    if (y <= mid)
      update(ls, l, mid, x, y, v);
    else if (x > mid)
      update(rs, mid + 1, r, x, y, v);
    else
      update(ls, l, mid, x, mid, v), update(rs, mid + 1, r, mid + 1, y, v);
    pushup(k);
  }
  int query(int k, int l, int r) {  // 询问 0 的位置
    if (l == r) return l;
    pushdown(k);
    int mid = (l + r) >> 1;
    if (!mn[ls])
      return query(ls, l, mid);
    else
      return query(rs, mid + 1, r);
    // 如果不存在 0 的位置就会自动返回当前你查询的位置
  }
} T;

int o = 1, hd[N], dep[N], fa[N][18];
struct Edge {
  int v, nt;
} E[N << 1];
void add(int u, int v) {  // 树结构加边
  E[o] = (Edge){v, hd[u]};
  hd[u] = o++;
}
void dfs(int u) {
  for (int i = 1; bin[i] <= dep[u]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1];
  for (int i = hd[u]; i; i = E[i].nt) {
    int v = E[i].v;
    dep[v] = dep[u] + 1;
    fa[v][0] = u;
    dfs(v);
  }
}
int go(int u, int d) {
  for (int i = 0; i < 18 && d; ++i)
    if (bin[i] & d) d ^= bin[i], u = fa[u][i];
  return u;
}
int lca(int u, int v) {
  if (dep[u] < dep[v]) swap(u, v);
  u = go(u, dep[u] - dep[v]);
  if (u == v) return u;
  for (int i = 17; ~i; --i)
    if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
  return fa[u][0];
}

// 判断当前区间是否为连续段
bool judge(int l, int r) { return D.ask_mx(l, r) - D.ask_mn(l, r) == r - l; }

// 建树
void build() {
  for (int i = 1; i <= n; ++i) {
    // 单调栈
    // 在区间 [st1[tp1-1]+1,st1[tp1]] 的最小值就是 a[st1[tp1]]
    // 现在把它出栈，意味着要把多减掉的 Min 加回来。
    // 线段树的叶结点位置 j 维护的是从 j 到当前的 i 的
    // Max{j,i}-Min{j,i}-(i-j)
    // 区间加只是一个 Tag。
    // 维护单调栈的目的是辅助线段树从 i-1 更新到 i。
    // 更新到 i 后，只需要查询全局最小值即可知道是否有解

    while (tp1 && a[i] <= a[st1[tp1]])  // 单调递増的栈，维护 Min
      T.update(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], a[st1[tp1]]), tp1--;
    while (tp2 && a[i] >= a[st2[tp2]])
      T.update(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], -a[st2[tp2]]), tp2--;

    T.update(1, 1, n, st1[tp1] + 1, i, -a[i]);
    st1[++tp1] = i;
    T.update(1, 1, n, st2[tp2] + 1, i, a[i]);
    st2[++tp2] = i;

    id[i] = ++cnt;
    L[cnt] = R[cnt] = i;  // 这里的 L,R 是指值域的上下界
    int le = T.query(1, 1, n), now = cnt;
    while (tp && L[st[tp]] >= le) {
      if (typ[st[tp]] && judge(M[st[tp]], i)) {
        // 判断是否能成为儿子，如果能就做
        R[st[tp]] = i, add(st[tp], now), now = st[tp--];
      } else if (judge(L[st[tp]], i)) {
        typ[++cnt] = 1;  // 合点一定是被这样建出来的
        L[cnt] = L[st[tp]], R[cnt] = i, M[cnt] = L[now];
        //这里M数组的作用是保证合点的儿子排列是单调的
        add(cnt, st[tp--]), add(cnt, now);
        now = cnt;
      } else {
        add(++cnt, now);  // 新建一个结点，把 now 添加为儿子
        // 如果从当前结点开始不能构成连续段，就合并。
        // 直到找到一个结点能构成连续段。而且我们一定能找到这样
        // 一个结点。
        do
          add(cnt, st[tp--]);
        while (tp && !judge(L[st[tp]], i));
        L[cnt] = L[st[tp]], R[cnt] = i, add(cnt, st[tp--]);
        now = cnt;
      }
    }
    st[++tp] = now;  // 增量结束，把当前点圧栈

    T.update(1, 1, n, 1, i, -1);  // 因为区间右端点向后移动一格，因此整体 -1
  }

  rt = st[1];  // 栈中最后剩下的点是根结点
}
void query(int l, int r) {
  int x = id[l], y = id[r];
  int z = lca(x, y);
  if (typ[z] & 1)
    l = L[go(x, dep[x] - dep[z] - 1)], r = R[go(y, dep[y] - dep[z] - 1)];
  //合点这里特判的原因是因为这个合点不一定是最小的包含l，r的连续段.
  //具体可以在上面的例图上试一下查询7,10
  else
    l = L[z], r = R[z];
  printf("%d %d\n", l, r);
}  // 分 lca 为析或和，这里把叶子看成析的

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
  D.build();
  build();
  dfs(rt);
  scanf("%d", &m);
  for (int i = 1; i <= m; ++i) {
    int x, y;
    scanf("%d%d", &x, &y);
    query(x, y);
  }
  return 0;
}
// 20190612
// 析合树
```

## 参考文献

刘承奥。简单的连续段数据结构。WC2019 营员交流。

 [大米饼的博客 -【学习笔记】析合树](https://www.cnblogs.com/Paul-Guderian/p/11020708.html) 

# cartesian-tree
author: sshwy, zhouyuyang2002, StudyingFather, Ir1d, ouuan, Enter-tainer

本文介绍一种不太常用，但是与大家熟知的平衡树与堆密切相关的数据结构——笛卡尔树。

笛卡尔树是一种二叉树，每一个结点由一个键值二元组 $(k,w)$ 构成。要求 $k$ 满足二叉搜索树的性质，而 $w$ 满足堆的性质。一个有趣的事实是，如果笛卡尔树的 $k,w$ 键值确定，且 $k$ 互不相同， $w$ 互不相同，那么这个笛卡尔树的结构是唯一的。上图：

![eg](./images/cartesian-tree1.png)

（图源自维基百科）

上面这棵笛卡尔树相当于把数组元素值当作键值 $w$ ，而把数组下标当作键值 $k$ 。显然可以发现，这棵树的键值 $k$ 满足二叉搜索树的性质，而键值 $w$ 满足小根堆的性质。

其实图中的笛卡尔树是一种特殊的情况，因为二元组的键值 $k$ 恰好对应数组下标，这种特殊的笛卡尔树有一个性质，就是一棵子树内的下标是连续的一个区间（这样才能满足二叉搜索树的性质）。更一般的情况则是任意二元组构建的笛卡尔树。

## 构建

## 栈构建

我们考虑将元素按照键值 $k$ 排序。然后一个一个插入到当前的笛卡尔树中。那么每次我们插入的元素必然在这个树的右链（右链：即从根结点一直往右子树走，经过的结点形成的链）的末端。于是我们执行这样一个过程，从下往上比较右链结点与当前结点 $u$ 的 $w$ ，如果找到了一个右链上的结点 $x$ 满足 $x_w<u_w$ ，就把 $u$ 接到 x 的右儿子上，而 x 原本的右子树就变成 u 的左子树。

具体不解释，我们直接上图。图中红色框框部分就是我们始终维护的右链：

![build](./images/cartesian-tree2.png)

显然每个数最多进出右链一次（或者说每个点在右链中存在的是一段连续的时间）。这个过程我们可以用栈维护，栈中维护当前笛卡尔树的右链上的结点。一个点不在右链上了就把它弹掉。这样每个点最多进出一次，复杂度 $O(n)$ 。伪代码如下：

```text
新建一个大小为 n 的空栈。用 top 来标操作前的栈顶，k 来标记当前栈顶。
For i := 1 to n
    k := top
    While 栈非空 且 栈顶元素 > 当前元素 
        k--
    if 栈非空
        栈顶元素.右儿子 := 当前元素
    if k < top
        当前元素.左儿子 := 栈顶元素
    当前元素入栈
    top := k
```

```cpp
for (int i = 1; i <= n; i++) {
  int k = top;
  while (k > 0 && h[stk[k]] > h[i]) k--;
  if (k) rs[stk[k]] = i;  // rs代表笛卡尔树每个节点的右儿子
  if (k < top) ls[i] = stk[k + 1];  // ls代表笛卡尔树每个节点的左儿子
  stk[++k] = i;
  top = k;
}
```

## 笛卡尔树与 Treap

谈到笛卡尔树，很容易让人想到一种家喻户晓的结构——Treap。没错，Treap 是笛卡尔树的一种，只不过 w 的值完全随机。Treap 也有线性的构建算法，如果提前将元素排好序，显然可以使用上述单调栈算法完成构建过程，只不过很少会这么用。

## 例题

HDU 1506 最大子矩形

> 题目大意：n 个位置，每个位置上的高度是 $h_i$ ，求最大子矩阵。举一个例子，如下图：
>
> ![eg](./images/cartesian-tree3.jpeg)
>
> 阴影部分就是图中的最大子矩阵。

这道题你可 DP，可单调栈，但你万万没想到的是它也可以笛卡尔树！具体地，我们把下标作为键值 $k$ ， $h_i$ 作为键值 $w$ 满足小根堆性质，构建一棵 $(i,h_i)$ 的笛卡尔树。

这样我们枚举每个结点 $u$ ，把 $u_w$ （即结点 u 的高度键值 $h$ ）作为最大子矩阵的高度。由于我们建立的笛卡尔树满足小根堆性质，因此 $u$ 的子树内的结点的高度都大于等于 $u$ 。而我们又知道 $u$ 子树内的下标是一段连续的区间。于是我们只需要知道子树的大小，然后就可以算这个区间的最大子矩阵的面积了。用每一个点计算出来的值更新答案即可。显然这个可以一次 DFS 完成，因此复杂度仍是 $O(n)$ 的。

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 100000 + 10, INF = 0x3f3f3f3f;

struct node {
  int idx, val, par, ch[2];
  friend bool operator<(node a, node b) { return a.idx < b.idx; }
  void init(int _idx, int _val, int _par) {
    idx = _idx, val = _val, par = _par, ch[0] = ch[1] = 0;
  }
} tree[N];

int root, top, stk[N];
ll ans;
int cartesian_build(int n) {
  for (int i = 1; i <= n; i++) {
    int k = i - 1;
    while (tree[k].val > tree[i].val) k = tree[k].par;
    tree[i].ch[0] = tree[k].ch[1];
    tree[k].ch[1] = i;
    tree[i].par = k;
    tree[tree[i].ch[0]].par = i;
  }
  return tree[0].ch[1];
}
int dfs(int x) {
  if (!x) return 0;
  int sz = dfs(tree[x].ch[0]);
  sz += dfs(tree[x].ch[1]);
  ans = max(ans, (ll)(sz + 1) * tree[x].val);
  return sz + 1;
}
int main() {
  int n, hi;
  while (scanf("%d", &n), n) {
    tree[0].init(0, 0, 0);
    for (int i = 1; i <= n; i++) {
      scanf("%d", &hi);
      tree[i].init(i, hi, 0);
    }
    root = cartesian_build(n);
    ans = 0;
    dfs(root);
    printf("%lld\n", ans);
  }
  return 0;
}
```

## 参考资料

 [维基百科 - 笛卡尔树](https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91) 

# block-list
author: HeRaNO, konnyakuxzy

 [![./images/kuaizhuanglianbiao.png](./images/kuaizhuanglianbiao.png "./images/kuaizhuanglianbiao.png")](./images/kuaizhuanglianbiao.png "./images/kuaizhuanglianbiao.png") 

大概就长这样……

不难发现块状链表就是一个链表，每个节点指向一个数组。
我们把原来长度为 n 的数组分为 $\sqrt{n}$ 个节点，每个节点对应的数组大小为 $\sqrt{n}$ 。
所以我们这么定义结构体，代码见下。
其中 `sqn` 表示 `sqrt(n)` 即 $\sqrt{n}$ ， `pb` 表示 `push_back` ，即在这个 `node` 中加入一个元素。

```cpp
struct node {
  node* nxt;
  int size;
  char d[(sqn << 1) + 5];
  node() { size = 0, nxt = NULL, memset(d, 0, sizeof(d)); }
  void pb(char c) { d[size++] = c; }
};
```

块状链表应该至少支持：分裂、插入、查找。
什么是分裂？分裂就是分裂一个 `node` ，变成两个小的 `node` ，以保证每个 `node` 的大小都接近 $\sqrt{n}$ （否则可能退化成普通数组）。当一个 `node` 的大小超过 $2\times \sqrt{n}$ 时执行分裂操作。

分裂操作怎么做呢？先新建一个节点，再把被分裂的节点的后 $\sqrt{n}$ 个值 `copy` 到新节点，然后把被分裂的节点的后 $\sqrt{n}$ 个值删掉（ `size--` ），最后把新节点插入到被分裂节点的后面即可。

块状链表的所有操作的复杂度都是 $\sqrt{n}$ 的。

还有一个要说的。
随着元素的插入（或删除）， $n$ 会变， $\sqrt{n}$ 也会变。这样块的大小就会变化，我们难道还要每次维护块的大小？

其实不然，把 $\sqrt{n}$ 设置为一个定值即可。比如题目给的范围是 $10^6$ ，那么 $\sqrt{n}$ 就设置为大小为 $10^3$ 的常量，不用更改它。

```cpp
list<vector<char> > orz_list;
```

## 例题

Big String POJ - 2887

题解：
很简单的模板题。代码如下：

```cpp
#include <cctype>
#include <cstdio>
#include <cstring>
using namespace std;
static const int sqn = 1e3;
struct node {
  node* nxt;
  int size;
  char d[(sqn << 1) + 5];
  node() { size = 0, nxt = NULL; }
  void pb(char c) { d[size++] = c; }
}* head = NULL;
char inits[(int)1e6 + 5];
int llen, q;
void readch(char& ch) {
  do
    ch = getchar();
  while (!isalpha(ch));
}
void check(node* p) {
  if (p->size >= (sqn << 1)) {
    node* q = new node;
    for (int i = sqn; i < p->size; i++) q->pb(p->d[i]);
    p->size = sqn, q->nxt = p->nxt, p->nxt = q;
  }
}
void insert(char c, int pos) {
  node* p = head;
  int tot, cnt;
  if (pos > llen++) {
    while (p->nxt != NULL) p = p->nxt;
    p->pb(c), check(p);
    return;
  }
  for (tot = head->size; p != NULL && tot < pos; p = p->nxt, tot += p->size)
    ;
  tot -= p->size, cnt = pos - tot - 1;
  for (int i = p->size - 1; i >= cnt; i--) p->d[i + 1] = p->d[i];
  p->d[cnt] = c, p->size++;
  check(p);
}
char query(int pos) {
  node* p;
  int tot, cnt;
  for (p = head, tot = head->size; p != NULL && tot < pos;
       p = p->nxt, tot += p->size)
    ;
  tot -= p->size;
  return p->d[pos - tot - 1];
}
int main() {
  scanf("%s %d", inits, &q), llen = strlen(inits);
  node* p = new node;
  head = p;
  for (int i = 0; i < llen; i++) {
    if (i % sqn == 0 && i) p->nxt = new node, p = p->nxt;
    p->pb(inits[i]);
  }
  char a;
  int k;
  while (q--) {
    readch(a);
    if (a == 'Q')
      scanf("%d", &k), printf("%c\n", query(k));
    else
      readch(a), scanf("%d", &k), insert(a, k);
  }
  return 0;
}
```

# tree-decompose
author: ouuan, Ir1d, TrisolarisHD, Xeonacid

## 树分块的方式

可以参考 [真 - 树上莫队](../misc/mo-algo.md#_14) 。

也可以参考 [ouuan 的博客/莫队、带修莫队、树上莫队详解/树上莫队](https://ouuan.github.io/莫队、带修莫队、树上莫队详解/#树上莫队) 。

树上莫队同样可以参考以上两篇文章。

## 树分块的应用

树分块除了应用于莫队，还可以灵活地运用到某些树上问题中。但可以用树分块解决的题目往往都有更优秀的做法，所以相关的题目较少。

顺带提一句，“gty 的妹子树”的树分块做法可以被菊花图卡掉。

###  [BZOJ4763 雪辉](https://www.luogu.org/problem/P3603) 

先进行树分块，然后对每个块的关键点，预处理出它到祖先中每个关键点的路径上颜色的 bitset，以及每个关键点的最近关键点祖先，复杂度是 $O(n\sqrt n+\frac{nc}{32})$ ，其中 $n\sqrt n$ 是暴力从每个关键点向上跳的复杂度， $\frac{nc}{32}$ 是把 $O(n)$ 个 `bitset` 存下来的复杂度。

回答询问的时候，先从路径的端点暴力跳到所在块的关键点，再从所在块的关键点一块一块地向上跳，直到 $lca$ 所在块，然后再暴力跳到 $lca$ 。关键点之间的 `bitset` 已经预处理了，剩下的在暴力跳的过程中计算。单次询问复杂度是 $O(\sqrt n+\frac c{32})$ ，其中 $\sqrt n$ 是块内暴力跳以及块直接向上跳的复杂度， $O(\frac c{32})$ 是将预处理的结果与暴力跳的结果合并的复杂度。数颜色个数可以用 `bitset` 的 `count()` ，求 $\operatorname{mex}$ 可以用 `bitset` 的 `_Find_first()` 。

所以，总复杂度为 $O((n+m)(\sqrt n+\frac c{32}))$ 。

??? "参考代码"
    ```cpp
    #include <algorithm>
    #include <bitset>
    #include <cctype>
    #include <cstdio>
    #include <iostream>
    
    using namespace std;
    
    int read() {
      int out = 0;
      char c;
      while (!isdigit(c = getchar()))
        ;
      for (; isdigit(c); c = getchar()) out = out * 10 + c - '0';
      return out;
    }
    
    const int N = 100010;
    const int B = 666;
    const int C = 30000;
    
    void add(int u, int v);
    void dfs(int u);
    
    int head[N], nxt[N << 1], to[N << 1], cnt;
    int n, m, type, c[N], fa[N], dep[N], sta[N], top, tot, bl[N], key[N / B + 5],
        p[N], keyid[N];
    bool vis[N];
    bitset<C> bs[N / B + 5][N / B + 5], temp;
    
    int main() {
      int i, u, v, x, y, k, lastans = 0;
    
      n = read();
      m = read();
      type = read();
    
      for (i = 1; i <= n; ++i) c[i] = read();
    
      for (i = 1; i < n; ++i) {
        u = read();
        v = read();
        add(u, v);
        add(v, u);
      }
    
      dfs(1);
    
      if (!tot) ++tot;
      if (keyid[key[tot]] == tot) keyid[key[tot]] = 0;
      key[tot] = 1;
      keyid[1] = tot;
      while (top) bl[sta[top--]] = tot;
    
      for (i = 1; i <= tot; ++i)  //预处理
      {
        if (vis[key[i]]) continue;
        vis[key[i]] = true;
        temp.reset();
        for (u = key[i]; u; u = fa[u]) {
          temp[c[u]] = 1;
          if (keyid[u]) {
            if (!p[key[i]] && u != key[i]) p[key[i]] = u;
            bs[keyid[key[i]]][keyid[u]] = temp;
          }
        }
      }
    
      while (m--) {
        k = read();
        temp.reset();
        while (k--) {
          u = x = read() ^ lastans;
          v = y = read() ^ lastans;
    
          while (key[bl[x]] != key[bl[y]]) {
            if (dep[key[bl[x]]] > dep[key[bl[y]]]) {
              if (x == u)  //若是第一次跳先暴力跳到关键点
              {
                while (x != key[bl[u]]) {
                  temp[c[x]] = 1;
                  x = fa[x];
                }
              } else
                x = p[x];  //否则跳一整块
            } else {
              if (y == v) {
                while (y != key[bl[v]]) {
                  temp[c[y]] = 1;
                  y = fa[y];
                }
              } else
                y = p[y];
            }
          }
    
          if (keyid[x]) temp |= bs[keyid[key[bl[u]]]][keyid[x]];
          if (keyid[y]) temp |= bs[keyid[key[bl[v]]]][keyid[y]];
    
          while (x != y) {
            if (dep[x] > dep[y]) {
              temp[c[x]] = 1;
              x = fa[x];
            } else {
              temp[c[y]] = 1;
              y = fa[y];
            }
          }
          temp[c[x]] = true;
        }
        int ans1 = temp.count(), ans2 = (~temp)._Find_first();
        printf("%d %d\n", ans1, ans2);
        lastans = (ans1 + ans2) * type;
      }
    
      return 0;
    }
    
    void dfs(int u) {
      int i, v, t = top;
      for (i = head[u]; i; i = nxt[i]) {
        v = to[i];
        if (v == fa[u]) continue;
        fa[v] = u;
        dep[v] = dep[u] + 1;
        dfs(v);
        if (top - t >= B) {
          key[++tot] = u;
          if (!keyid[u]) keyid[u] = tot;
          while (top > t) bl[sta[top--]] = tot;
        }
      }
      sta[++top] = u;
    }
    
    void add(int u, int v) {
      nxt[++cnt] = head[u];
      head[u] = cnt;
      to[cnt] = v;
    }
    ```

###  [BZOJ4812 由乃打扑克](https://www.lydsy.com/JudgeOnline/problem.php?id=4812) 

这题和上一题基本一样，唯一的区别是得到 `bitset` 后如何计算答案。

~~由于 BZOJ 是计算所有测试点总时限，不好卡，所以可以用 `_Find_next()` 水过去。~~

正解是每 $16$ 位一起算，先预处理出 $2^{16}$ 种可能的情况高位连续 $1$ 的个数、低位连续 $1$ 的个数以及中间的贡献。只不过这样要手写 `bitset` ，因为标准库的 `bitset` 不能取某 $16$ 位……

代码可以参考 [这篇博客](https://www.cnblogs.com/FallDream/p/bzoj4763.html) 。

# persistent
author: morris821028

## 简介

可持久化数据结构 (Persistent data structure) 总是可以保留每一个历史版本，并且支持操作的不可变特性 (immutable)。

## 可持久化分类

### 部分可持久化 (Partially Persistent)

所有版本都可以访问，但是只有最新版本可以修改。

### 完全可持久化 (Fully Persistent)

所有版本都既可以访问又可以修改。

若支持将两个历史版本合并，则又称为 Confluently Persistent

## 实际应用

### 几何计算

在几何计算中有许多离线算法，如扫描线算法一次扫过去回答所有询问，在时间复杂度分析上相当优异。但强迫在线的情况下，每一次都扫描一次，询问操作的时间复杂度就从对数时间降成线性。为了解决这一种情况，持久化技术给了另一种思维，我们将扫描线的时间轴作为一个变动依据，持久化相关的结构，只要我们能将询问在对数时间内穿梭于这个时间轴，必能动态解决先前的问题。

### 字串处理

为了达到非常高效率的合并操作，防止大量重复性字串的生成伴随的效能退化，使得各方面的操作都能远低于线性操作。如 C++ rope 就是一个持久化的数据结构。不只是字串操作，若处理类型有大量重复的情况，持久化的概念便能派上用场。

### 版本回溯

实际上就是对应大部分的应用软体中的 redo/undo。如果资料库/操作变动为了高效率操作而会配上复杂的结构（并不像 hash, set 反转操作只需要常数或对数时间），那么为了快速回推变动结果，持久化结构就是要减少 redo/undo 的花费。

资料库本身可以常数回推，纪录变动的部分情况即可。而应用层的计算，大部分实作都是砍掉快取，并且重新计算出一份新的结构，有时候回推的变动大小为 m，为了重新计算结构而消耗了 n+m，如果 n 和 m 的差距非常大，那连续回推的体感就很糟糕。

### 函数式编程

函数式编程需要特别的数据结构以符合语言特性，其中不可变的性质更为重要，以利于并行环境与除错。如面向对象编程的 Java 8 后引入 stream 类，支援写出函数式的语法设计，可提供惰性求值、无限值域等的特殊功能。

## 参考

-    <https://en.wikipedia.org/wiki/Persistent_data_structure> 
-   MIT 课程 <https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2005/lecture-notes/persistent.pdf> 

# persistent-seg
## 主席树

主席树全称是可持久化权值线段树，参见 [知乎讨论](https://www.zhihu.com/question/59195374) 。

???+warning "关于函数式线段树"
     **函数式线段树** 是指使用函数式编程思想的线段树。在函数式编程思想中，将计算机运算视为数学函数，并避免可改变的状态或变量。不难发现，函数式线段树是 [完全可持久化](./persistent.md#_2) 的

面对眼前的区间第 $k$ 小问题，你该何从下手？

一种可行的方案是：使用主席树。  
主席树的主要思想就是：保存每次插入操作时的历史版本，以便查询区间第 $k$ 小。

怎么保存呢？简单暴力一点，每次开一棵线段树呗。  
那空间还不爆掉？

那么我们分析一下，发现每次修改操作修改的点的个数是一样的。  
（例如下图，修改了 $[1,8]$ 中对应权值为 1 的结点，红色的点即为更改的点）  
/home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/persistent-seg.png)

只更改了 $O(\log{n})$ 个结点，形成一条链，也就是说每次更改的结点数 = 树的高度。  
注意主席树不能使用堆式存储法，就是说不能用 $x\times 2$ , $x\times 2+1$ 来表示左右儿子，而是应该动态开点，并保存每个节点的左右儿子编号。  
所以我们只要在记录左右儿子的基础上存一下插入每个数的时候的根节点就可以持久化辣。

我们把问题简化一下：每次求 $[1,r]$ 区间内的 $k$ 小值。  
怎么做呢？只需要找到插入 r 时的根节点版本，然后用普通权值线段树（有的叫键值线段树/值域线段树）做就行了。

那么这个相信大家很简单都能理解，把问题扩展到原问题——求 $[l,r]$ 区间 $k$ 小值。  
这里我们再联系另外一个知识理解： **前缀和** 。  
这个小东西巧妙运用了区间减法的性质，通过预处理从而达到 $O(1)$ 回答每个询问。

那么我们阔以发现，主席树统计的信息也满足这个性质。  
所以……如果需要得到 $[l,r]$ 的统计信息，只需要用 $[1,r]$ 的信息减去 $[1,l - 1]$ 的信息就行了。

那么至此，该问题解决！（完结撒花）

关于空间问题，我们分析一下：由于我们是动态开点的，所以一棵线段树只会出现 $2n-1$ 个结点。  
然后，有 $n$ 次修改，每次至多增加 $\lceil\log_2{n}\rceil+1$ 个结点。因此，最坏情况下 $n$ 次修改后的结点总数会达到 $2n-1+n(\lceil\log_2{n}\rceil+1)$ 。
此题的 $n \leq 10^5$ ，单次修改至多增加 $\lceil\log_2{10^5}\rceil+1 = 18$ 个结点，故 $n$ 次修改后的结点总数为 $2\times 10^5-1+18\times 10^5$ ，忽略掉 $-1$ ，大概就是 $20\times 10^5$ 。

最后给一个忠告：千万不要吝啬空间！保守一点，直接上个 $2^5\times 10^5$ ，接近原空间的两倍（即 `n << 5` ）。  
（较真的同学请注意，如果你真的很吝啬，可以自己造个数据输出一下结点数量，但是如果数据没造好把自己卡掉了就~~尴尬了~~赖你了）

代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 1e5;  //数据范围
int tot, n, m;
int sum[(maxn << 5) + 10], rt[maxn + 10], ls[(maxn << 5) + 10],
    rs[(maxn << 5) + 10];
int a[maxn + 10], ind[maxn + 10], len;
inline int getid(const int &val)  //离散化
{
  return lower_bound(ind + 1, ind + len + 1, val) - ind;
}
int build(int l, int r)  //建树
{
  int root = ++tot;
  if (l == r) return root;
  int mid = l + r >> 1;
  ls[root] = build(l, mid);
  rs[root] = build(mid + 1, r);
  return root;  //返回该子树的根节点
}
int update(int k, int l, int r, int root)  //插入操作
{
  int dir = ++tot;
  ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + 1;
  if (l == r) return dir;
  int mid = l + r >> 1;
  if (k <= mid)
    ls[dir] = update(k, l, mid, ls[dir]);
  else
    rs[dir] = update(k, mid + 1, r, rs[dir]);
  return dir;
}
int query(int u, int v, int l, int r, int k)  //查询操作
{
  int mid = l + r >> 1,
      x = sum[ls[v]] - sum[ls[u]];  //通过区间减法得到左儿子的信息
  if (l == r) return l;
  if (k <= x)  //说明在左儿子中
    return query(ls[u], ls[v], l, mid, k);
  else  //说明在右儿子中
    return query(rs[u], rs[v], mid + 1, r, k - x);
}
inline void init() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; ++i) scanf("%d", a + i);
  memcpy(ind, a, sizeof ind);
  sort(ind + 1, ind + n + 1);
  len = unique(ind + 1, ind + n + 1) - ind - 1;
  rt[0] = build(1, len);
  for (int i = 1; i <= n; ++i) rt[i] = update(getid(a[i]), 1, len, rt[i - 1]);
}
int l, r, k;
inline void work() {
  while (m--) {
    scanf("%d%d%d", &l, &r, &k);
    printf("%d\n", ind[query(rt[l - 1], rt[r], 1, len, k)]);  //回答询问
  }
}
int main() {
  init();
  work();
  return 0;
}
```

## 参考

 <https://en.wikipedia.org/wiki/Persistent_data_structure> 

 <https://www.cnblogs.com/zinthos/p/3899565.html> 

# index
author: HeRaNO, Zhoier, hsfzLZH1

数据结构是在计算机中存储、组织数据的方式。小到变量、数组，大到线段树、平衡树，都是数据结构。

程序运行离不开数据结构，不同的数据结构又各有优劣，能够处理的问题各不相同，而根据具体问题选取合适的数据结构，可以大大提升程序的效率。所以，学习各种各样的数据结构是很有必要的。

# wblt
author: hsfzLZH1, cesonic

WBLT，全称 Weight Balanced Leafy Tree，一种不常见的平衡树写法，但是具有常数较小，可以当做可并堆使用的优点。

类似于 WBT（weight-balanced trees），WBLT 体现了 leafy 的性质，即节点多，怎么多呢？

对于 n 个数，不同于 treap 等，WBLT 会建立 2n 个节点，每个节点的权值为其右儿子的权值，且右儿子的权值大于等于左儿子

每次插入，类似于堆，逐次向下交换并向上 pushup 更新即可，删除也是同理

当然，如果输入数据递增或递减，WBLT 会退化成链状，于是我们采用旋转来维护平衡。

因为 WBLT 同时满足堆的性质，我们可以用它来实现堆和可并堆。

而在旋转的过程中，会产生很多垃圾节点，我们采用垃圾回收的方式就可以回收废弃节点，将建立节点的操作稍作修改即可。

附上普通平衡树代码：

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

const int maxn = 400005;

const int ratio = 5;
int n, cnt, fa, root;
int size[maxn], ls[maxn], rs[maxn], val[maxn];

void newnode(int &cur, int v) {
  cur = ++cnt;
  size[cur] = 1;
  val[cur] = v;
}
void copynode(int x, int y) {
  size[x] = size[y];
  ls[x] = ls[y];
  rs[x] = rs[y];
  val[x] = val[y];
}
void merge(int l, int r) {
  size[++cnt] = size[l] + size[r];
  val[cnt] = val[r];
  ls[cnt] = l, rs[cnt] = r;
}
void rotate(int cur, bool flag) {
  if (flag) {
    merge(ls[cur], ls[rs[cur]]);
    ls[cur] = cnt;
    rs[cur] = rs[rs[cur]];
  } else {
    merge(rs[ls[cur]], rs[cur]);
    rs[cur] = cnt;
    ls[cur] = ls[ls[cur]];
  }
}
void maintain(int cur) {
  if (size[ls[cur]] > size[rs[cur]] * ratio)
    rotate(cur, 0);
  else if (size[rs[cur]] > size[ls[cur]] * ratio)
    rotate(cur, 1);
  if (size[ls[cur]] > size[rs[cur]] * ratio)
    rotate(ls[cur], 1), rotate(cur, 0);
  else if (size[rs[cur]] > size[ls[cur]] * ratio)
    rotate(rs[cur], 0), rotate(cur, 1);
}
void pushup(int cur) {
  if (!size[ls[cur]]) return;
  size[cur] = size[ls[cur]] + size[rs[cur]];
  val[cur] = val[rs[cur]];
}
void insert(int cur, int x) {
  if (size[cur] == 1) {
    newnode(ls[cur], min(x, val[cur]));
    newnode(rs[cur], max(x, val[cur]));
    pushup(cur);
    return;
  }
  maintain(cur);
  insert(x > val[ls[cur]] ? rs[cur] : ls[cur], x);
  pushup(cur);
}
void erase(int cur, int x) {
  if (size[cur] == 1) {
    cur = ls[fa] == cur ? rs[fa] : ls[fa];
    copynode(fa, cur);
    return;
  }
  maintain(cur);
  fa = cur;
  erase(x > val[ls[cur]] ? rs[cur] : ls[cur], x);
  pushup(cur);
}
int find(int cur, int x) {
  if (size[cur] == x) return val[cur];
  maintain(cur);
  if (x > size[ls[cur]]) return find(rs[cur], x - size[ls[cur]]);
  return find(ls[cur], x);
}
int rnk(int cur, int x) {
  if (size[cur] == 1) return 1;
  maintain(cur);  // asdasdasdasd
  if (x > val[ls[cur]]) return rnk(rs[cur], x) + size[ls[cur]];
  return rnk(ls[cur], x);
}
int main() {
  scanf("%d", &n);
  newnode(root, 2147383647);  //使根不改变
  while (n--) {
    int s, a;
    scanf("%d %d", &s, &a);
    if (s == 1) insert(root, a);
    if (s == 2) erase(root, a);
    if (s == 3) printf("%d\n", rnk(root, a));
    if (s == 4) printf("%d\n", find(root, a));
    if (s == 5) printf("%d\n", find(root, rnk(root, a) - 1));
    if (s == 6) printf("%d\n", find(root, rnk(root, a + 1)));
  }
  return 0;
}
```

# treap
author: Dev-XYS

treap 是一种弱平衡的二叉搜索树。treap 这个单词是 tree 和 heap 的组合，表明 treap 是一种由树和堆组合形成的数据结构。treap 的每个结点上要额外储存一个值 $priority$ 。treap 除了要满足二叉搜索树的性质之外，还需满足父节点的 $priority$ 大于等于两个儿子的 $priority$ 。而 $priority$ 是每个结点建立时随机生成的，因此 treap 是期望平衡的。

treap 分为旋转式和无旋式两种。两种 treap 都易于编写，但无旋式 treap 的操作方式使得它天生支持维护序列、可持久化等特性。这里以重新实现 `set<int>` （不可重集合）为例，介绍无旋式 treap。

## 无旋式 treap 的核心操作

无旋式 treap 又称分裂合并 treap。它仅有两种核心操作，即为分裂与合并。下面逐一介绍这两种操作。

### 分裂（split）

分裂过程接受两个参数：根指针 $u$ 、关键值 $key$ 。结果为将根指针指向的 treap 分裂为两个 treap，第一个 treap 所有结点的关键值小于等于 $key$ ，第二个 treap 所有结点的关键值大于 $key$ 。该过程首先判断 $key$ 是否小于 $u$ 的关键值，若小于，则说明 $u$ 及其右子树全部属于第二个 treap，否则说明 $u$ 及其左子树全部属于第一个 treap。根据此判断决定应向左子树递归还是应向右子树递归，继续分裂子树。待子树分裂完成后按刚刚的判断情况连接 $u$ 的左子树或右子树到递归分裂所得的子树中。

```cpp
pair<node *, node *> split(node *u, int key) {
  if (u == nullptr) {
    return make_pair(nullptr, nullptr);
  }
  if (key < u->key) {
    pair<node *, node *> o = split(u->lch, key);
    u->lch = o.second;
    return make_pair(o.first, u);
  } else {
    pair<node *, node *> o = split(u->rch, key);
    u->rch = o.first;
    return make_pair(u, o.second);
  }
}
```

### 合并（merge）

合并过程接受两个参数：左 treap 的根指针 $u$ 、右 treap 的根指针 $v$ 。必须满足 $u$ 中所有结点的关键值小于等于 $v$ 中所有结点的关键值。因为两个 treap 已经有序，我们只需要考虑 $priority$ 来决定哪个 treap 应与另一个 treap 的儿子合并。若 $u$ 的根结点的 $priority$ 大于 $v$ 的，那么 $u$ 即为新根结点， $v$ 应与 $u$ 的右子树合并；反之，则 $v$ 作为新根结点，然后让 $u$ 与 $v$ 的左子树合并。不难发现，这样合并所得的树依然满足 $priority$ 的大根堆性质。

```cpp
node *merge(node *u, node *v) {
  if (u == nullptr) {
    return v;
  }
  if (v == nullptr) {
    return u;
  }
  if (u->priority > v->priority) {
    u->rch = merge(u->rch, v);
    return u;
  } else {
    v->lch = merge(u, v->lch);
    return v;
  }
}
```

### 建树（build）

将一个有 $n$ 个节点的序列 $\{a_n\}$ 转化为一棵 treap。

可以依次暴力插入这 $n$ 个节点，每次插入一个权值为 $v$ 的节点时，将整棵 treap 按照权值分裂成权值小于等于 $v$ 的和权值大于 $v$ 的两部分，然后新建一个权值为 $v$ 的节点，将两部分和新节点按从小到大的顺序依次合并，单次插入时间复杂度 $O(\log n)$ ，总时间复杂度 $O(n\log n)$ 。

在某些题目内，可能会有多次插入一段有序序列的操作，这是就需要在 $O(n)$ 的时间复杂度内完成建树操作。

方法一：在递归建树的过程中，每次选取当前区间的中点作为该区间的树根，并对每个节点钦定合适的优先值，使得新树满足堆的性质。这样能保证树高为 $O(\log n)$ 。

方法二：在递归建树的过程中，每次选取当前区间的中点作为该区间的树根，然后给每个节点一个随机优先级。这样能保证树高为 $O(\log n)$ ，但不保证其满足堆的性质。这样也是正确的，因为无旋式 treap 的优先级是用来使 `merge` 操作更加随机一点，而不是用来保证树高的。

方法三：观察到 treap 是笛卡尔树，利用笛卡尔树的 $O(n)$ 建树方法即可，用单调栈维护右脊柱即可。

## 将 treap 包装成为 `set<int>` 

### count 函数

直接依靠二叉搜索树的性质查找即可。

```cpp
int find(node *u, int key) {
  if (u == nullptr) {
    return 0;
  }
  if (key == u->key) {
    return 1;
  }
  if (key < u->key) {
    return find(u->lch, key);
  } else {
    return find(u->rch, key);
  }
}

int count(int key) { return find(root, key); }
```

### insert 函数

先在待插入的关键值处将整棵 treap 分裂，判断关键值是否已插入过之后新建一个结点，包含待插入的关键值，然后进行两次合并操作即可。

```cpp
void insert(int key) {
  pair<node*, node*> o = split(root, key);
  if (find(root, key) == 0) {
    o.first = merge(o.first, new node(key));
  }
  root = merge(o.first, o.second);
}
```

### erase 函数

将具有待删除的关键值的结点从整棵 treap 中孤立出来（进行两侧分裂操作），删除中间的一段（具有待删除关键值），再将左右两端合并即可。

```cpp
void erase(int key) {
  pair<node*, node*> o = split(root, key - 1);
  pair<node*, node*> p = split(o.second, key);
  delete p.first;
  root = merge(o.first, p.second);
}
```

## 旋转 treap

旋转 treap 在做普通平衡树题的时候，是所有平衡树中常数较小的

维护平衡的方式为旋转。性质与普通二叉搜索树类似

因为普通的二叉搜索树会被递增或递减的数据卡，用 treap 对每个节点定义一个权值，由 rand 得到，从而防止特殊数据卡。

每次删除/插入时通过 rand 值决定要不要旋转即可，其他操作与二叉搜索树类似

以下是 bzoj 普通平衡树模板代码

```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>

#define maxn 100005
#define INF (1 << 30)

int n;

struct treap {
  int l[maxn], r[maxn], val[maxn], rnd[maxn], size[maxn], w[maxn];
  int sz, ans, rt;
  inline void pushup(int x) { size[x] = size[l[x]] + size[r[x]] + w[x]; }
  void lrotate(int &k) {
    int t = r[k];
    r[k] = l[t];
    l[t] = k;
    size[t] = size[k];
    pushup(k);
    k = t;
  }
  void rrotate(int &k) {
    int t = l[k];
    l[k] = r[t];
    r[t] = k;
    size[t] = size[k];
    pushup(k);
    k = t;
  }
  void insert(int &k, int x) {
    if (!k) {
      sz++;
      k = sz;
      size[k] = 1;
      w[k] = 1;
      val[k] = x;
      rnd[k] = rand();
      return;
    }
    size[k]++;
    if (val[k] == x) {
      w[k]++;
    } else if (val[k] < x) {
      insert(r[k], x);
      if (rnd[r[k]] < rnd[k]) lrotate(k);
    } else {
      insert(l[k], x);
      if (rnd[l[k]] < rnd[k]) rrotate(k);
    }
  }

  void del(int &k, int x) {
    if (!k) return;
    if (val[k] == x) {
      if (w[k] > 1) {
        w[k]--;
        size[k]--;
        return;
      }
      if (l[k] == 0 || r[k] == 0)
        k = l[k] + r[k];
      else if (rnd[l[k]] < rnd[r[k]]) {
        rrotate(k);
        del(k, x);
      } else {
        lrotate(k);
        del(k, x);
      }
    } else if (val[k] < x) {
      size[k]--;
      del(r[k], x);
    } else {
      size[k]--;
      del(l[k], x);
    }
  }

  int queryrank(int k, int x) {
    if (!k) return 0;
    if (val[k] == x)
      return size[l[k]] + 1;
    else if (x > val[k]) {
      return size[l[k]] + w[k] + queryrank(r[k], x);
    } else
      return queryrank(l[k], x);
  }

  int querynum(int k, int x) {
    if (!k) return 0;
    if (x <= size[l[k]])
      return querynum(l[k], x);
    else if (x > size[l[k]] + w[k])
      return querynum(r[k], x - size[l[k]] - w[k]);
    else
      return val[k];
  }

  void querypre(int k, int x) {
    if (!k) return;
    if (val[k] < x)
      ans = k, querypre(r[k], x);
    else
      querypre(l[k], x);
  }

  void querysub(int k, int x) {
    if (!k) return;
    if (val[k] > x)
      ans = k, querysub(l[k], x);
    else
      querysub(r[k], x);
  }
} T;

int main() {
  srand(123);
  scanf("%d", &n);
  int opt, x;
  for (int i = 1; i <= n; i++) {
    scanf("%d%d", &opt, &x);
    if (opt == 1)
      T.insert(T.rt, x);
    else if (opt == 2)
      T.del(T.rt, x);
    else if (opt == 3) {
      printf("%d\n", T.queryrank(T.rt, x));
    } else if (opt == 4) {
      printf("%d\n", T.querynum(T.rt, x));
    } else if (opt == 5) {
      T.ans = 0;
      T.querypre(T.rt, x);
      printf("%d\n", T.val[T.ans]);
    } else if (opt == 6) {
      T.ans = 0;
      T.querysub(T.rt, x);
      printf("%d\n", T.val[T.ans]);
    }
  }
  return 0;
}
```

## 练习题

 [普通平衡树](https://loj.ac/problem/104) 

 [文艺平衡树（Splay）](https://loj.ac/problem/105) 

 [「ZJOI2006」书架](https://www.luogu.org/problem/P2596) 

 [「NOI2005」维护数列](https://www.luogu.org/problem/P2042) 

 [CF 702F T-Shirts](http://codeforces.com/problemset/problem/702/F) 

# decompose
author: Ir1d, HeRaNO, Xeonacid

## 简介

其实，分块是一种思想，而不是一种数据结构。

从 NOIP 到 NOI 到 IOI，各种难度的分块思想都有出现。

通常的分块算法的复杂度带根号，或者其他奇怪的复杂度，而不是 $\log$ 。

分块是一种很灵活的思想，几乎什么都能分块，并且不难实现。

你想写出什么数据结构就有什么，缺点是渐进意义的复杂度不够好。

当然，在 $n=10^5$ 时，由于常数小，跟线段树可能差不多。

这不是建议你们用分块的意思，在 OI 中，可以作为一个备用方案，首选肯定是线段树等高级的数据结构。

以下通过几个例子来介绍～

## 区间和

动机：线段树太难写？

将序列分段，每段长度 $T$ ，那么一共有 $\frac{n}{T}$ 段。

维护每一段的区间和。

单点修改：显然。

区间询问：会涉及一些完整的段，和最多两个段的一部分。

完整段使用维护的信息，一部分暴力求。

复杂度 $O(\frac{n}{T}+T)$ 。

区间修改：同样涉及这些东西，使用打标记和暴力修改，同样的复杂度。

当 $T=\sqrt{n}$ 时，复杂度 $O(\sqrt{n})$ 。

## 区间和 2

上一个做法的复杂度是 $\Omega(1) , O(\sqrt{n})$ 。

我们在这里介绍一种 $O(\sqrt{n}) - O(1)$ 的算法。

为了 $O(1)$ 询问，我们可以维护各种前缀和。

然而在有修改的情况下，不方便维护，只能维护单个块内的前缀和。

以及整块作为一个单位的前缀和。

每次修改 $O(T+\frac{n}{T})$ 。

询问：涉及三部分，每部分都可以直接通过前缀和得到，时间复杂度 $O(1)$ 。

## 对询问分块

同样的问题，现在序列长度为 $n$ ，有 $m$ 个操作。

如果操作数量比较少，我们可以把操作记下来，在询问的时候加上这些操作的影响。

假设最多记录 $T$ 个操作，则修改 $O(1)$ ，询问 $O(T)$ 。

 $T$ 个操作之后，重新计算前缀和， $O(n)$ 。

总复杂度： $O(mT+n\frac{m}{T})$ 。

 $T=\sqrt{n}$ 时，总复杂度 $O(m \sqrt{n})$ 。

# binary-heap
auhor: HeRaNO, Xeonacid

### 结构

从二叉堆的结构说起，它是一棵二叉树，并且是完全二叉树，每个结点中存有一个元素（或者说，有个权值）。

堆性质：父亲的权值不小于儿子的权值（大根堆）。同样的，我们可以定义小根堆。本文以大根堆为例。

由堆性质，树根存的是最大值（getmax 操作就解决了）。

### 插入操作

插入操作是指向二插堆中插入一个元素，要保证插入后也是一棵完全二叉树。

最简单的方法就是，最下一层最右边的叶子之后插入。

如果最下一层已满，就新增一层。

插入之后可能会不满足堆性质？

 **向上调整** ：如果这个结点的权值大于它父亲的权值，就交换，重复此过程直到不满足或者到根。

可以证明，插入之后向上调整后，没有其他结点会不满足堆性质。

向上调整的时间复杂度是 $O(\log n)$ 的。

### 删除操作

删除操作指删除堆中最大的元素，即删除根结点。

但是如果直接删除，则变成了两个堆，难以处理。

所以不妨考虑插入操作的逆过程，设法将根结点移到最后一个结点，然后直接删掉。

然而实际上不好做，我们通常采用的方法是，把根结点和最后一个结点直接交换。

于是直接删掉（在最后一个结点处的）根结点，但是新的根结点可能不满足堆性质……

 **向下调整** ：在该结点的儿子中，找一个最大的，与该结点交换，重复此过程直到底层。

可以证明，删除并向下调整后，没有其他结点不满足堆性质。

时间复杂度 $O(\log n)$ 。

### 减小某个点的权值

很显然，直接修改后，向上调整一次即可，时间复杂度为 $O(\log n)$ 。

### 实现

我们发现，上面介绍的几种操作主要依赖于两个核心：向上调整和向下调整。

考虑使用一个序列 $h$ 来表示堆。 $h_i$ 的两个儿子分别是 $h_{2i}$ 和 $h_{2i+1}$ ， $1$ 是根结点：

![h 的堆结构](./images/binary-heap1.png)

参考代码：

```cpp
void up(int x) {
  while (x > 1 && h[x] > h[x / 2]) {
    swap(h[x], h[x / 2]);
    x /= 2;
  }
}
void down(int x) {
  while (x * 2 <= n) {
    t = x * 2;
    if (t + 1 <= n && h[t + 1] > h[t]) t++;
    if (h[t] <= h[x]) break;
    std::swap(h[x], h[t]);
    x = t;
  }
}
```

### 建堆

考虑这么一个问题，从一个空的堆开始，插入 $n$ 个元素，不在乎顺序。

直接一个一个插入需要 $O(n \log n)$ 的时间，有没有更好的方法？

#### 方法一：使用 decreasekey（即，向上调整）

从根开始，按 BFS 序进行。

```cpp
void build_heap_1() {
  for (i = 1; i <= n; i++) up(i);
}
```

为啥这么做：对于第 $k$ 层的结点，向上调整的复杂度为 $O(k)$ 而不是 $O(\log n)$ 。

总复杂度： $\log 1 + \log 2 + \cdots + \log n = \Theta(n \log n)$ 。

（在「基于比较的排序」中证明过）

#### 方法二：使用向下调整

这时换一种思路，从叶子开始，逐个向下调整

```cpp
void build_heap_2() {
  for (i = n; i >= 1; i--) down(i);
}
```

换一种理解方法，每次「合并」两个已经调整好的堆，这说明了正确性。

注意到向下调整的复杂度，为 $O(\log n - k)$ 。

$$
\begin{aligned}
总复杂度 & = n \log n - \log 1 - \log 2 - \cdots - \log n \\
& \leq n \log n - 0 \times 2^0 - 1 \times 2^1 -\cdots - (\log n - 1) \times \frac{n}{2} \\\
& = n \log n - (n-1) - (n-2) - (n-4) - \cdots - (n-\frac{n}{2}) \\
& = n \log n - n \log n + 1 + 2 + 4 + \cdots + \frac{n}{2} \\
& = n - 1 \\ &  = O(n)
\end{aligned}
$$

之所以能 $O(n)$ 建堆，是因为堆性质很弱，二叉堆并不是唯一的。

要是像排序那样的强条件就难说了。

# stack
## 栈

栈是 OI 中常用的一种线性数据结构，请注意，本文主要讲的是栈这种数据结构，而非程序运行时的系统栈/栈空间

栈的修改是按照后进先出的原则进行的，因此栈通常被称为是后进先出（last in first out）表，简称 LIFO 表。

!!! warning
    LIFO 表达的是 **当前在容器** 内最后进来的最先出去。
    
    我们考虑这样一个栈
    
    ```text
    push(1)
    pop(1)
    push(2)
    pop(2)
    ```
    
    如果从整体考虑，1 最先入栈，最先出栈，2 最后入栈，最后出栈，这样就成了一个先进先出表，显然是错误的。
    
    所以，在考虑数据结构是 LIFO 还是 FIFO 的时候，应当考虑在当前容器内的情况。

我们可以方便的使用数组来模拟一个栈，如下：

```cpp
int stk[N];
// 这里使用 stk[0]( 即 *stk ) 代表栈中元素数量，同时也是栈顶下标
// 压栈 ：
stk[++*stk] = var1;
// 取栈顶 ：
int u = stk[*stk];
// 弹栈 ：注意越界问题, *stk == 0 时不能继续弹出
if (*stk) --*stk;
// 清空栈
*stk = 0;
```

同时 STL 也提供了一个方法 `std::stack` 

```cpp
#include <stack>
// stack 构造 ：
1. stack<Typename T> s;
2. stack<Typename T, Container> s;
/* stack 的 Container 需要满足有如下接口 ：
 * back()
 * push_back()
 * pop_back()
 * 标准容器 std::vector / deque / list 满足这些要求
 * 如使用 1 方式构造，默认容器使用 deque
 */
```

 `std::stack` 支持赋值运算符 `=` 

元素访问：

 `s.top()` 返回栈顶

容量：

 `s.empty()` 返回是否为空

 `s.size()` 返回元素数量

修改：

 `s.push()` 插入传入的参数到栈顶

 `s.pop()` 弹出栈顶

其他运算符：

 `==` 、 `!=` 、 `<` 、 `<=` 、 `>` 、 `>=` 可以按照字典序比较两个 `stack` 的值

# persistent-heap
可持久化可并堆一般用于求解 $k$ 短路问题。

如果一种可并堆的时间复杂度不是均摊的，那么它在可持久化后单次操作的时间复杂度就保证是 $O(\log n)$ 的，即不会因为特殊数据而使复杂度退化。

## 可持久化左偏树

在学习本内容前，请先了解 [左偏树](./leftist-tree.md) 的相关内容。

回顾左偏树的合并过程，假设我们要合并分别以 $x,y$ 为根节点的两棵左偏树，且维护的左偏树满足小根堆的性质：

1.  如果 $x,y$ 中有结点为空，返回 $x+y$ 。

2.  选择 $x,y$ 两结点中权值更小的结点，作为合并后左偏树的根。

3.  递归合并 $x$ 的右子树与 $y$ ，将合并后的根节点作为 $x$ 的右儿子。

4.  维护当前合并后左偏树的左偏性质，维护 `dist` 值，返回选择的根节点。

由于每次递归都会使 `dist[x]+dist[y]` 减少一，而 `dist[x]` 是 $O(\log n)$ 的，一次最多只会修改 $O(\log n)$ 个结点，所以这样做的时间复杂度是 $O(\log n)$ 的。

可持久化要求保留历史信息，使得之后能够访问之前的版本。要将左偏树可持久化，就要将其沿途修改的路径复制一遍。

所以可持久化左偏树的合并过程是这样的：

1.  如果 $x,y$ 中有结点为空，返回 $x+y$ 。

2.  选择 $x,y$ 两结点中权值更小的结点，新建该结点的一个复制 $p$ ，作为合并后左偏树的根。

3.  递归合并 $p$ 的右子树与 $y$ ，将合并后的根节点作为 $p$ 的右儿子。

4.  维护以 $p$ 为根的左偏树的左偏性质，维护其 `dist` 值，返回 $p$ 。

由于左偏树一次最多只会修改并新建 $O(\log n)$ 个结点，设操作次数为 $m$ ，则可持久化左偏树的时间复杂度和空间复杂度均为 $O(m\log n)$ 。

### 参考实现

```cpp
int merge(int x, int y) {
  if (!x || !y) return x + y;
  if (v[x] > v[y]) swap(x, y);
  int p = ++cnt;
  lc[p] = lc[x];
  v[p] = v[x];
  rc[p] = merge(rc[x], y);
  if (dist[lc[p]] < dist[rc[p]]) swap(lc[p], rc[p]);
  dist[p] = dist[rc[p]] + 1;
  return p;
}
```

# block-array
## 建立块状数组

块状数组，即把一个数组分为几个块，块内信息整体保存，若查询时遇到两边不完整的块直接暴力查询。一般情况下，块的长度为 $O(\sqrt{n})$ 。详细分析可以阅读 2017 年国家集训队论文中徐明宽的《非常规大小分块算法初探》。

下面直接给出一种建立块状数组的代码。

```cpp
num = sqrt(n);
for (int i = 1; i <= num; i++)
  st[i] = n / num * (i - 1) + 1, ed[i] = n / num * i;
ed[num] = n;
for (int i = 1; i <= num; i++) {
  for (int j = st[i]; j <= ed[i]; j++) {
    belong[j] = i;
  }
  size[i] = ed[i] - st[i] + 1;
}
```

其中 `st[i] ed[i]` 为块的起点和终点， `size[i]` 为块的大小。

## 保存与修改块内信息

### 例题 1： [教主的魔法](https://www.luogu.org/problemnew/show/P2801) 

我们要询问一个块内大于等于一个数的数的个数，所以需要一个 `t` 数组对块内排序。对于整块的修改，使用类似于标记永久化的方式保存。时间复杂度 $O(n\sqrt{n}\log n)$ 

```cpp
void Sort(int k) {
  for (int i = st[k]; i <= ed[k]; i++) t[i] = a[i];
  sort(t + st[k], t + ed[k] + 1);
}
void Modify(int l, int r, int c) {
  int x = belong[l], y = belong[r];
  if (x == y) {
    for (int i = l; i <= r; i++) a[i] += c;
    Sort(x);
    return;
  }
  for (int i = l; i <= ed[x]; i++) a[i] += c;
  for (int i = st[y]; i <= r; i++) a[i] += c;
  for (int i = x + 1; i < y; i++) dlt[i] += c;
  Sort(x);
  Sort(y);
}
int Answer(int l, int r, int c) {
  int ans = 0, x = belong[l], y = belong[r];
  if (x == y) {
    for (int i = l; i <= r; i++)
      if (a[i] + dlt[x] >= c) ans++;
    return ans;
  }
  for (int i = l; i <= ed[x]; i++)
    if (a[i] + dlt[x] >= c) ans++;
  for (int i = st[y]; i <= r; i++)
    if (a[i] + dlt[y] >= c) ans++;
  for (int i = x + 1; i <= y - 1; i++)
    ans += ed[i] - (lower_bound(t + st[i], t + ed[i] + 1, c - dlt[i]) - t) + 1;
  return ans;
}
```

### 例题 2：寒夜方舟

两种操作：

1.  区间 $[x,y]$ 每个数都变成 $z$ 
2.  查询区间 $[x,y]$ 内小于等于 $z$ 的数的个数

用 `dlt` 保存现在块内是否被整体赋值了。用一个值表示没有。对于边角块，查询前要 `pushdown` ，把块内存的信息下放到每一个数上。赋值之后记得重新 `sort` 一遍。其他方面同上题。

```cpp
void Sort(int k) {
  for (int i = st[k]; i <= ed[k]; i++) t[i] = a[i];
  sort(t + st[k], t + ed[k] + 1);
}
void PushDown(int x) {
  if (dlt[x] != 0x3f3f3f3f3f3f3f3fll)
    for (int i = st[x]; i <= ed[x]; i++) a[i] = t[i] = dlt[x];
  dlt[x] = 0x3f3f3f3f3f3f3f3fll;
}
void Modify(int l, int r, int c) {
  int x = belong[l], y = belong[r];
  PushDown(x);
  if (x == y) {
    for (int i = l; i <= r; i++) a[i] = c;
    Sort(x);
    return;
  }
  PushDown(y);
  for (int i = l; i <= ed[x]; i++) a[i] = c;
  for (int i = st[y]; i <= r; i++) a[i] = c;
  Sort(x);
  Sort(y);
  for (int i = x + 1; i < y; i++) dlt[i] = c;
}
int Binary_Search(int l, int r, int c) {
  int ans = l - 1, mid;
  while (l <= r) {
    mid = (l + r) / 2;
    if (t[mid] <= c)
      ans = mid, l = mid + 1;
    else
      r = mid - 1;
  }
  return ans;
}
int Answer(int l, int r, int c) {
  int ans = 0, x = belong[l], y = belong[r];
  PushDown(x);
  if (x == y) {
    for (int i = l; i <= r; i++)
      if (a[i] <= c) ans++;
    return ans;
  }
  PushDown(y);
  for (int i = l; i <= ed[x]; i++)
    if (a[i] <= c) ans++;
  for (int i = st[y]; i <= r; i++)
    if (a[i] <= c) ans++;
  for (int i = x + 1; i <= y - 1; i++) {
    if (0x3f3f3f3f3f3f3f3fll == dlt[i])
      ans += Binary_Search(st[i], ed[i], c) - st[i] + 1;
    else if (dlt[i] <= c)
      ans += size[i];
  }
  return ans;
}
```

## 练习

1.   [单点修改，区间查询](https://loj.ac/problem/130) 
2.   [区间修改，区间查询](https://loj.ac/problem/132) 
3.   [【模板】线段树 2](https://www.luogu.org/problemnew/show/P3373) 
4.   [「Ynoi2019 模拟赛」Yuno loves sqrt technology III](https://www.luogu.org/problemnew/show/P5048) 
5.   [「Violet」蒲公英](https://www.luogu.org/problemnew/show/P4168) 
6.   [作诗](https://www.luogu.org/problemnew/show/P4135) 

# hash
## 哈希表

哈希表是又称散列表，一种以 "key-value" 形式存储数据的数据结构。所谓以 "key-value" 形式存储数据，是指任意的 key 都唯一对应到内存中的某个位置。只需要输入查找的值 key，就可以快速地找到其对应的 value。可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。

## 哈希函数

要让 key 对应到内存中的位置，就要为 key 计算索引，也就是计算这个数据应该放到哪里。这个根据 key 计算索引的函数就叫做哈希函数，也称散列函数。举个例子，比如 key 是一个人的身份证号码，哈希函数就可以是号码的后四位，当然也可以是号码的前四位。生活中常用的“手机尾号”也是一种哈希函数。在实际的应用中，key 可能是更复杂的东西，比如浮点数、字符串、结构体等，这时候就要根据具体情况设计合适的哈希函数。哈希函数应当易于计算，并且尽量使计算出来的索引均匀分布。

在 OI 中，最常见的情况应该是 key 为整数的情况。当 key 的范围比较小的时候，可以直接把 key 作为数组的下标，但当 key 的范围比较大，比如以 $10^9$ 范围内的整数作为 key 的时候，就需要用到哈希表。一般把 key 模一个较大的质数作为索引，也就是取 $f(x)=x \bmod M$ 作为哈希函数。另一种比较常见的情况是 key 为字符串的情况，在 OI 中，一般不直接把字符串作为 key，而是先算出字符串的哈希值，再把其哈希值作为 key 插入到哈希表里。

能为 key 计算索引之后，我们就可以知道每个 value 应该放在哪里了。假设我们用数组 a 存放数据，哈希函数是 f，那键值对 (key,value) 就应该放在 a[f(key)]上。不论 key 是什么类型，范围有多大，f(key) 都是在可接受范围内的整数，可以作为数组的下标。

## 冲突

如果对于任意的 key，哈希函数计算出来的索引都不相同，那只用根据索引把 (key,value) 放到对应的位置就行了。但实际上，常常会出现两个不同的 key，他们用哈希函数计算出来的索引是相同的。这时候就需要一些方法来处理冲突。在 OI 中，最常用的方法是拉链法。

### 拉链法

拉链法也称开散列法（open hashing）。

拉链法是在每个存放数据的地方开一个链表，如果有多个 key 索引到同一个地方，只用把他们都放到那个位置的链表里就行了。查询的时候需要把对应位置的链表整个扫一遍，对其中的每个数据比较其 key 与查询的 key 是否一致。如果索引的范围是 1~M，哈希表的大小为 N，那么一次插入/查询需要进行期望 $O(\frac{N}{M})$ 次比较。

### 闭散列法

闭散列方法把所有记录直接存储在散列表中，如果发生冲突则根据某种方式继续进行探查。

比如线性探查法：如果在 `d` 处发生冲突，就依次检查 `d + 1` ， `d+2` ……

## 实现

### 拉链法

```cpp
const int SIZE = 1000000;
const int M = 999997;
struct HashTable {
  struct Node {
    int next, value, key;
  } data[SIZE];
  int head[M], size;
  int f(int key) { return key % M; }
  int get(int key) {
    for (int p = head[f(key)]; p; p = data[p].next)
      if (data[p].key == key) return data[p].value;
    return -1;
  }
  int modify(int key, int value) {
    for (int p = head[f(key)]; p; p = data[p].next)
      if (data[p].key == key) return data[p].value = value;
  }
  int add(int key, int value) {
    if (get(key) != -1) return -1;
    data[++size] = (Node){head[f(key)], value, key};
    head[f(key)] = size;
    return value;
  }
};
```

这边再为大家提供一个封装过的模板，可以像 map 一样用，并且较短

```cpp
struct hash_map {  // 哈希表模板
  struct data {
    long long u;
    int v, nex;
  };                // 前向星结构
  data e[SZ << 1];  // SZ 是 const int 表示大小
  int h[SZ], cnt;
  int hash(long long u) { return u % SZ; }
  int& operator[](long long u) {
    int hu = hash(u);  // 获取头指针
    for (int i = h[hu]; i; i = e[i].nex)
      if (e[i].u == u) return e[i].v;
    return e[++cnt] = (data){u, -1, h[hu]}, h[hu] = cnt, e[cnt].v;
  }
  hash_map() {
    cnt = 0;
    memset(h, 0, sizeof(h));
  }
};
```

解释一下，hash 函数是针对 key 的类型设计的，并且返回一个链表头指针用于查询。在这个模板中我们写了一个 $\text{(long long , int)}$ 式的 hash 表，并且当某个 key 不存在的时侯初始化对应的 val 成 -1。hash_map() 函数是在定义的时侯初始化用的。

## 例题

 [「JLOI2011」不重复数字](https://www.luogu.org/problem/P4305) 

# monotonous-queue
author: Link-cute, Xeonacid, ouuan

在学习单调队列前，让我们先来看一道例题。

## 例题

 [Sliding Window](http://poj.org/problem?id=2823) 

本题大意是给出一个长度为 $n$ 的数组，编程输出每 $k$ 个连续的数中的最大值和最小值。

最暴力的想法很简单，对于每一段 $i \sim i+k-1$ 的序列，逐个比较来找出最大值（和最小值），时间复杂度约为 $O(n \times k)$ 。

很显然，这其中进行了大量重复工作，除了开头 $k-1$ 个和结尾 $k-1$ 个数之外，每个数都进行了 $k$ 次比较，而题中 $100\%$ 的数据为 $n \le 1000000$ ，当 $k$ 稍大的情况下，显然会 TLE。

这时所用到的就是单调队列了。

## 概念

顾名思义，单调队列的重点分为 "单调" 和 "队列"

"单调" 指的是元素的的 "规律"——递增（或递减）

"队列" 指的是元素只能从队头和队尾进行操作

Ps. 单调队列中的 "队列" 与正常的队列有一定的区别，稍后会提到

## 例题分析

有了上面 "单调队列" 的概念，很容易想到用单调队列进行优化。

要求的是每连续的 $k$ 个数中的最大（最小）值，很明显，当一个数进入所要 "寻找" 最大值的范围中时，若这个数比其前面（先进队）的数要大，显然，前面的数会比这个数先出队且不再可能是最大值。

也就是说——当满足以上条件时，可将前面的数 "弹出"，再将该数真正 push 进队尾。

这就相当于维护了一个递减的队列，符合单调队列的定义，减少了重复的比较次数，不仅如此，由于维护出的队伍是查询范围内的且是递减的，队头必定是该查询区域内的最大值，因此输出时只需输出队头即可。

显而易见的是，在这样的算法中，每个数只要进队与出队各一次，因此时间复杂度被降到了 $O(N)$ 。

而由于查询区间长度是固定的，超出查询空间的值再大也不能输出，因此还需要 site 数组记录第 $i$ 个队中的数在原数组中的位置，以弹出越界的队头。

例如我们构造一个单调递增的队列会如下：

原序列为：

```text
1 3 -1 -3 5 3 6 7
```

因为我们始终要维护队列保证其 **递增** 的特点，所以会有如下的事情发生：

| 操作                              | 队列状态        |
| ------------------------------- | ----------- |
| 1 入队                            |  `{1}`      |
| 3 比 1 大，3 入队                    |  `{1 3}`    |
| -1 比队列中所有元素小，所以清空队列 -1 入队       |  `{-1}`     |
| -3 比队列中所有元素小，所以清空队列 -3 入队       |  `{-3}`     |
| 5 比 -3 大，直接入队                   |  `{-3 5}`   |
| 3 比 5 小，5 出队，3 入队               |  `{-3 3}`   |
| -3 已经在窗体外，所以 -3 出队；6 比 3 大，6 入队 |  `{3 6}`    |
| 7 比 6 大，7 入队                    |  `{3 6 7}`  |

??? "例题参考代码"
    ```cpp
    #include <cstdio>
    #include <cstdlib>
    #include <cstring>
    #include <iostream>
    #define maxn 1000100
    using namespace std;
    int q[maxn], a[maxn];
    int n, k;
    void getmin() {
      int head = 0, tail = 0;
      for (int i = 1; i < k; i++) {
        while (head <= tail && a[q[tail]] >= a[i]) tail--;
        q[++tail] = i;
      }
      for (int i = k; i <= n; i++) {
        while (head <= tail && a[q[tail]] >= a[i]) tail--;
        q[++tail] = i;
        while (q[head] <= i - k) head++;
        printf("%d ", a[q[head]]);
      }
    }
    
    void getmax() {
      int head = 0, tail = 0;
      for (int i = 1; i < k; i++) {
        while (head <= tail && a[q[tail]] <= a[i]) tail--;
        q[++tail] = i;
      }
      for (int i = k; i <= n; i++) {
        while (head <= tail && a[q[tail]] <= a[i]) tail--;
        q[++tail] = i;
        while (q[head] <= i - k) head++;
        printf("%d ", a[q[head]]);
      }
    }
    
    int main() {
      scanf("%d%d", &n, &k);
      for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
      getmin();
      printf("\n");
      getmax();
      printf("\n");
      return 0;
    }
    ```

Ps. 此处的 "队列" 跟普通队列的一大不同就在于可以从队尾进行操作，STL 中有类似的数据结构 deque。

# seg-in-balanced


# llrbt
左偏红黑树是红黑树的一种变体，它的对红边（点）的位置做了一定限制，使得其插入与删除操作可以与 2-3-4 树构成一一对应。

我们假设读者已经至少掌握了一种基于旋转的平衡树，因此本文不会对旋转操作进行讲解。

## 红黑树

### 性质

一棵红黑树满足如下性质：

1.  节点是红色或黑色；
2.  红色的节点的所有儿子的颜色必须是黑色，即从每个叶子到根的所有路径上不能有两个连续的红色节点；
3.  从任一节点到其子树中的每个叶子的所有简单路径上都包含相同数目的黑色节点。（黑高平衡）

这保证了从根节点到任意叶子的最长路径（红黑交替）不会超过最短路径（全黑）的二倍。从而保证了树的平衡性。

维护这些性质是比较复杂的，如果我们要插入一个节点，首先，它一定会被染色成红色，否则会破坏性质 3。即使这样，我们还是有可能会破坏性质 2。因此需要进行调整。而删除节点就更加麻烦，与插入类似，我们不能删除黑色节点，否则会破坏黑高的平衡。如何方便地解决这些问题呢？

## 左偏红黑树（Left Leaning Red Black Tree）

左偏红黑树是一种容易实现的红黑树变体。

与普通的红黑树不同的是，在左偏红黑树中，是边具有颜色而不是节点具有颜色。我们习惯用一个节点的颜色代指它的父亲边的颜色。

左偏红黑树对红黑树进行了进一步限制，一个黑色节点的左右儿子：

-   要么全是黑色；
-   要么左儿子是红色，右儿子是黑色。

符合条件的情况：

![llrbt1](./images/llrbt-1.png)

不符合条件的情况：

![llrbt2](./images/llrbt-2.png)

这是左偏树的「左偏」性质：红色边只能是左偏的。

### 插入

我们首先使用普通的 BST 插入方法，在树的底部插入一个红色的叶子节点，然后通过从下向上的调整，使得插入后的树仍然符合左偏红黑树的性质。下面描述调整的过程：

![llrbt3](./images/llrbt-3.png)

插入后，可能会产生一条右偏的红色边，因此需要对红边右偏的情况进行一次左旋：

![llrbt4](./images/llrbt-4.png)

考虑左旋后会产生两条连续的左偏红色边：

![llrbt5](./images/llrbt-5.png)

因此需要把它进行一次右旋。而对于右旋后的情况，我们应该对它进行 `color_filp` ：即翻转该节点和它的两个儿子的颜色

![llrbt6](./images/llrbt-6.png)

从而消灭右偏的红边。

??? note "参考代码（部分）"
    ```cpp
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::fix_up(
        Set::Node *root) const {
      if (is_red(root->rc) && !is_red(root->lc))  // fix right leaned red link
        root = rotate_left(root);
      if (is_red(root->lc) &&
          is_red(root->lc->lc))  // fix doubly linked left leaned red link
        // if (root->lc == nullptr), then the second expr won't be evaluated
        root = rotate_right(root);
      if (is_red(root->lc) && is_red(root->rc))
        // break up 4 node
        color_flip(root);
      root->size = size(root->lc) + size(root->rc) + 1;
      return root;
    }
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node_Set<Key, Compare>::insert(
        Set::Node_root, const Key &key) const {
      if (root == nullptr) return new Node(key, kRed, 1);
      if (root->key == key)
        ;
      else if (cmp\_(key, root->key))  // if (key < root->key)
        root->lc = insert(root->lc, key);
      else
        root->rc = insert(root->rc, key);
      return fix_up(root);
    }
    ```

### 删除

删除操作基于这样的思想：我们不能删除黑色的节点，因为这样会破坏黑高。所以我们需要保证我们最后删除的节点是红色的。

#### 删除最小值节点

首先来试一下删除整棵树里的最小值。

怎么才能保证最后删除的节点是红色的呢？我们需要在向下递归的过程中保证一个性质：如果当前节点是 `h` ，那么需要保证 `h` 是红色，或者 `h->lc` 是红色。

考虑这样做的正确性，如果我们能够通过各种旋转和反转颜色操作成功维护这个性质，那么当我们到达最小的节点 `h_min` 的时候，有 `h_min` 是红色，或者 `h_min` 的左子树——但是 `h_min` 根本没有左子树！所以这就保证了最小值节点一定是红的，既然它是红色的，我们就可以大胆的删除它，然后用与插入操作相同的调整思路对树进行调整。

下面我们来考虑怎么满足这个性质，注意，我们会在向下递归的时候 **临时地** 破坏左偏红黑树的若干性质，但是当我们从递归中返回时还会将其恢复。

![llrbt-7](./images/llrbt-7.png)

下图描述一种简单的情况，我们只需要一次翻转颜色即可。

但如果 `h->rc->lc` 是红色，情况会比较复杂：

![llrbt-8](./images/llrbt-8.png)

如果只进行翻转颜色，会产生连续的红边，而考虑我们递归返回的时候，是无法修复这样的情况的，因此需要进行处理。

然后就可以进行删除了：

??? note "参考代码（部分）"
    ```cpp
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::move_red_left(
        Set::Node *root) const {
      color_flip(root);
      if (is_red(root->rc->lc)) {
        // assume that root->rc != nullptr when calling this function
        root->rc = rotate_right(root->rc);
        root = rotate_left(root);
        color_flip(root);
      }
      return root;
    }
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::delete_min(
        Set::Node *root) const {
      if (root->lc == nullptr) {
        delete root;
        return nullptr;
      }
      if (!is_red(root->lc) && !is_red(root->lc->lc)) {
        // make sure either root->lc or root->lc->lc is red
        // thus make sure we will delete a red node in the end
        root = move_red_left(root);
      }
      root->lc = delete_min(root->lc);
      return fix_up(root);
    }
    ```

#### 删除任意节点

我们首先考虑删除叶子：与删最小值类似，我们在删除任意值的过程中也要维护一个性质，不过这次比较特殊，因为我们不是只向左边走，而是可以向左右两个方向走，因此在删除过程中维护的性质是这样的：如果往左走，当前节点是 `h` ，那么需要保证 `h` 是红色，或者 `h->lc` 是红色；如果往右走，当前节点是 `h` ，那么需要保证 `h` 是红色，或者 `h->rc` 是红色。这样可以保证我们最后总会删掉一个红色节点。

下面考虑删除非叶子节点，我们只需要找到其右子树（如果有）里的最小节点，然后用右子树的最小节点的值代替该节点的值，最后删除右子树里的最小节点。

![llrbt-9](./images/llrbt-9.png)

那如果没有右子树怎么办？我们需要把左子树旋转过来，这样就不会出现这个问题了。

??? note "参考代码（部分）"
    ```cpp
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::delete_arbitrary(
        Set::Node *root, Key key) const {
      if (cmp_(key, root->key)) {
        // key < root->key
        if (!is_red(root->lc) && !(is_red(root->lc->lc)))
          root = move_red_left(root);
        // ensure the invariant: either root->lc or root->lc->lc (or root and
        // root->lc after dive into the function) is red, to ensure we will
        // eventually delete a red node. therefore we will not break the black
        // height balance
        root->lc = delete_arbitrary(root->lc, key);
      } else {
        // key >= root->key
        if (is_red(root->lc)) root = rotate_right(root);
        if (key == root->key && root->rc == nullptr) {
          delete root;
          return nullptr;
        }
        if (!is_red(root->rc) && !is_red(root->rc->lc)) root = move_red_right(root);
        if (key == root->key) {
          root->key = get_min(root->rc);
          root->rc = delete_min(root->rc);
        } else {
          root->rc = delete_arbitrary(root->rc, key);
        }
      }
      return fix_up(root);
    }
    ```

## 参考代码

下面的代码是用左偏红黑树实现的 `Set` ，即有序不可重集合：

??? note "参考代码"
    ```cpp
    #include <algorithm>
    #include <memory>
    #include <vector>
    template <class Key, class Compare = std::less<Key>>
    class Set {
     private:
      enum NodeColor { kBlack = 0, kRed = 1 };
    
      struct Node {
        Key key;
        Node *lc{nullptr}, *rc{nullptr};
        size_t size{0};
        NodeColor color;  // the color of the parent link
    
        Node(Key key, NodeColor color, size_t size)
            : key(key), color(color), size(size) {}
    
        Node() = default;
      };
    
      void destroyTree(Node *root) const {
        if (root != nullptr) {
          destroyTree(root->lc);
          destroyTree(root->rc);
          root->lc = root->rc = nullptr;
          delete root;
        }
      }
    
      bool is_red(const Node *nd) const {
        return nd == nullptr ? false : nd->color;  // kRed == 1, kBlack == 0
      }
    
      size_t size(const Node *nd) const { return nd == nullptr ? 0 : nd->size; }
    
      Node *rotate_left(Node *node) const {
        // left rotate a red link
        //          <1>                   <2>
        //        /    \\               //    \
        //       *      <2>    ==>     <1>     *
        //             /   \          /   \
        //            *     *        *     *
        Node *res = node->rc;
        node->rc = res->lc;
        res->lc = node;
        res->color = node->color;
        node->color = kRed;
        res->size = node->size;
        node->size = size(node->lc) + size(node->rc) + 1;
        return res;
      }
    
      Node *rotate_right(Node *node) const {
        // right rotate a red link
        //            <1>               <2>
        //          //    \           /    \\
        //         <2>     *   ==>   *      <1>
        //        /   \                    /   \
        //       *     *                  *     *
        Node *res = node->lc;
        node->lc = res->rc;
        res->rc = node;
        res->color = node->color;
        node->color = kRed;
        res->size = node->size;
        node->size = size(node->lc) + size(node->rc) + 1;
        return res;
      }
    
      NodeColor neg_color(NodeColor n) const { return n == kBlack ? kRed : kBlack; }
    
      void color_flip(Node *node) const {
        node->color = neg_color(node->color);
        node->lc->color = neg_color(node->lc->color);
        node->rc->color = neg_color(node->rc->color);
      }
    
      Node *insert(Node *root, const Key &key) const;
      Node *delete_arbitrary(Node *root, Key key) const;
      Node *delete_min(Node *root) const;
      Node *move_red_right(Node *root) const;
      Node *move_red_left(Node *root) const;
      Node *fix_up(Node *root) const;
      const Key &get_min(Node *root) const;
      void serialize(Node *root, std::vector<Key> *) const;
      void print_tree(Set::Node *root, int indent) const;
      Compare cmp_ = Compare();
      Node *root_{nullptr};
    
     public:
      typedef Key KeyType;
      typedef Key ValueType;
      typedef std::size_t SizeType;
      typedef std::ptrdiff_t DifferenceType;
      typedef Compare KeyCompare;
      typedef Compare ValueCompare;
      typedef Key &Reference;
      typedef const Key &ConstReference;
    
      Set() = default;
    
      Set(Set &) = default;
    
      Set(Set &&) noexcept = default;
    
      ~Set() { destroyTree(root_); }
    
      SizeType size() const;
    
      SizeType count(const KeyType &key) const;
    
      SizeType erase(const KeyType &key);
    
      void clear();
    
      void insert(const KeyType &key);
    
      bool empty() const;
    
      std::vector<Key> serialize() const;
    
      void print_tree() const;
    };
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::SizeType Set<Key, Compare>::count(
        ConstReference key) const {
      Node *x = root_;
      while (x != nullptr) {
        if (key == x->key) return 1;
        if (cmp_(key, x->key))  // if (key < x->key)
          x = x->lc;
        else
          x = x->rc;
      }
      return 0;
    }
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::SizeType Set<Key, Compare>::erase(
        const KeyType &key) {
      if (count(key) > 0) {
        if (!is_red(root_->lc) && !(is_red(root_->rc))) root_->color = kRed;
        root_ = delete_arbitrary(root_, key);
        if (root_ != nullptr) root_->color = kBlack;
        return 1;
      } else {
        return 0;
      }
    }
    
    template <class Key, class Compare>
    void Set<Key, Compare>::clear() {
      destroyTree(root_);
      root_ = nullptr;
    }
    
    template <class Key, class Compare>
    void Set<Key, Compare>::insert(const KeyType &key) {
      root_ = insert(root_, key);
      root_->color = kBlack;
    }
    
    template <class Key, class Compare>
    bool Set<Key, Compare>::empty() const {
      return size(root_) == 0;
    }
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::insert(
        Set::Node *root, const Key &key) const {
      if (root == nullptr) return new Node(key, kRed, 1);
      if (root->key == key)
        ;
      else if (cmp_(key, root->key))  // if (key < root->key)
        root->lc = insert(root->lc, key);
      else
        root->rc = insert(root->rc, key);
      return fix_up(root);
    }
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::delete_min(
        Set::Node *root) const {
      if (root->lc == nullptr) {
        delete root;
        return nullptr;
      }
      if (!is_red(root->lc) && !is_red(root->lc->lc)) {
        // make sure either root->lc or root->lc->lc is red
        // thus make sure we will delete a red node in the end
        root = move_red_left(root);
      }
      root->lc = delete_min(root->lc);
      return fix_up(root);
    }
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::move_red_right(
        Set::Node *root) const {
      color_flip(root);
      if (is_red(root->lc->lc)) {  // assume that root->lc != nullptr when calling
                                   // this function
        root = rotate_right(root);
        color_flip(root);
      }
      return root;
    }
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::move_red_left(
        Set::Node *root) const {
      color_flip(root);
      if (is_red(root->rc->lc)) {
        // assume that root->rc != nullptr when calling this function
        root->rc = rotate_right(root->rc);
        root = rotate_left(root);
        color_flip(root);
      }
      return root;
    }
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::fix_up(
        Set::Node *root) const {
      if (is_red(root->rc) && !is_red(root->lc))  // fix right leaned red link
        root = rotate_left(root);
      if (is_red(root->lc) &&
          is_red(root->lc->lc))  // fix doubly linked left leaned red link
        // if (root->lc == nullptr), then the second expr won't be evaluated
        root = rotate_right(root);
      if (is_red(root->lc) && is_red(root->rc))
        // break up 4 node
        color_flip(root);
      root->size = size(root->lc) + size(root->rc) + 1;
      return root;
    }
    
    template <class Key, class Compare>
    const Key &Set<Key, Compare>::get_min(Set::Node *root) const {
      Node *x = root;
      // will crash as intended when root == nullptr
      for (; x->lc != nullptr; x = x->lc)
        ;
      return x->key;
    }
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::SizeType Set<Key, Compare>::size() const {
      return size(root_);
    }
    
    template <class Key, class Compare>
    typename Set<Key, Compare>::Node *Set<Key, Compare>::delete_arbitrary(
        Set::Node *root, Key key) const {
      if (cmp_(key, root->key)) {
        // key < root->key
        if (!is_red(root->lc) && !(is_red(root->lc->lc)))
          root = move_red_left(root);
        // ensure the invariant: either root->lc or root->lc->lc (or root and
        // root->lc after dive into the function) is red, to ensure we will
        // eventually delete a red node. therefore we will not break the black
        // height balance
        root->lc = delete_arbitrary(root->lc, key);
      } else {
        // key >= root->key
        if (is_red(root->lc)) root = rotate_right(root);
        if (key == root->key && root->rc == nullptr) {
          delete root;
          return nullptr;
        }
        if (!is_red(root->rc) && !is_red(root->rc->lc)) root = move_red_right(root);
        if (key == root->key) {
          root->key = get_min(root->rc);
          root->rc = delete_min(root->rc);
        } else {
          root->rc = delete_arbitrary(root->rc, key);
        }
      }
      return fix_up(root);
    }
    
    template <class Key, class Compare>
    std::vector<Key> Set<Key, Compare>::serialize() const {
      std::vector<int> v;
      serialize(root_, &v);
      return v;
    }
    
    template <class Key, class Compare>
    void Set<Key, Compare>::serialize(Set::Node *root,
                                      std::vector<Key> *res) const {
      if (root == nullptr) return;
      serialize(root->lc, res);
      res->push_back(root->key);
      serialize(root->rc, res);
    }
    
    template <class Key, class Compare>
    void Set<Key, Compare>::print_tree(Set::Node *root, int indent) const {
      if (root == nullptr) return;
      print_tree(root->lc, indent + 4);
      std::cout << std::string(indent, '-') << root->key << std::endl;
      print_tree(root->rc, indent + 4);
    }
    
    template <class Key, class Compare>
    void Set<Key, Compare>::print_tree() const {
      print_tree(root_, 0);
    }
    ```

## 参考资料与拓展阅读

-    [Left-Leaning Red-Black Trees](https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf) -  Robert Sedgewick Princeton University
-    [Balanced Search Trees](https://algs4.cs.princeton.edu/lectures/33BalancedSearchTrees-2x2.pdf) -\_Algorithms_Robert Sedgewick | Kevin Wayne

# fenwick
author: HeRaNO, Zhoier, Ir1d, Xeonacid, wangdehu, ouuan, ranwen, ananbaobeichicun, Ycrpro

## 简介

树状数组和下面的线段树可是亲兄弟了，但他俩毕竟还有一些区别：  
树状数组能有的操作，线段树一定有；  
线段树有的操作，树状数组不一定有。

这么看来选择线段树不就 **「得天下了」** ？

事实上，树状数组的代码要比线段树短得多，思维也更清晰，在解决一些单点修改的问题时，树状数组是不二之选。

* * *

## 原理

如果要具体了解树状数组的工作原理，请看下面这张图：

/home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/fenwick1.png)

这个结构的思想和线段树有些类似：用一个大节点表示一些小节点的信息，进行查询的时候只需要查询一些大节点而不是更多的小节点。

最下面的八个方块就代表存入 $a$ 中的八个数，现在都是十进制。

他们上面的参差不齐的剩下的方块就代表 $a$ 的上级—— $c$ 数组。

很显然看出：  
 $c[2]$ 管理的是 $a[1]$ & $a[2]$ ；  
 $c[4]$ 管理的是 $a[1]$ & $a[2]$ & $a[3]$ & $a[4]$ ；  
 $c[6]$ 管理的是 $a[5]$ & $a[6]$ ； $c[8]$ 则管理全部 $8$ 个数。

所以，如果你要算区间和的话，比如说要算 $a[51]$ ~ $a[91]$ 的区间和，暴力算当然可以，那上百万的数，那就 RE 喽。

那么这种类似于跳一跳的连续跳到中心点而分值不断变大的原理是一样的（倍增）。

你从 $91$ 开始往前跳，发现 $c[n]$ （ $n$ 我也不确定是多少，算起来太麻烦，就意思一下）只管 $a[91]$ 这个点，那么你就会找 $a[90]$ ，发现 $c[n - 1]$ 管的是 $a[90]$ & $a[89]$ ；那么你就会直接跳到 $a[88]$ ， $c[n - 2]$ 就会管 $a[81]$ ~ $a[88]$ 这些数，下次查询从 $a[80]$ 往前找，以此类推。

* * *

## 用法及操作

那么问题来了，你是怎么知道 $c$ 管的 $a$ 的个数分别是多少呢？你那个 $1$ 个， $2$ 个， $8$ 个……是怎么来的呢？
这时，我们引入一个函数—— `lowbit` ：

```cpp
int lowbit(int x) {
  //算出x二进制的从右往左出现第一个1以及这个1之后的那些0组成数的二进制对应的十进制的数
  return x & -x;
}
```

 `lowbit` 的意思注释说明了，咱们就用这个说法来证明一下 $a[88]$ ：  
 $88_{(10)}=1011000_{(2)}$   
发现第一个 $1$ 以及他后面的 $0$ 组成的二进制是 $1000$   
 $1000_{(2)} = 8_{(10)}$   
 $1000$ 对应的十进制是 $8$ ，所以 $c$ 一共管理 $8$ 个 $a$ 。

这就是 `lowbit` 的用处，仅此而已（但也相当有用）。

 **你可能又问了：x & -x 是什么意思啊？** 

>  $-x$ 代表 $x$ 的负数，计算机中负数使用对应的正数的补码来表示。

例如 :  
 $x =88_{(10)}=1011000_{(2)}$ ；  
 $-x = -88_{(10)} = (0100111_{(2)} + 1_{(2)}) =101000_{(2)}$ ；  
 $x\ \& \ (-x) = 1000_{(2)} = 8_{(10)}$ 。

神奇吧，我也觉得神奇！

那么对于 **单点修改** 就更轻松了：

```cpp
void add(int x, int k) {
  while (x <= n) {  //不能越界
    c[x] = c[x] + k;
    x = x + lowbit(x);
  }
}
```

每次只要在他的上级那里更新就行，自己就可以不用管了。

```cpp
int getsum(int x) {  // a[1]……a[x]的和
  int ans = 0;
  while (x >= 1) {
    ans = ans + c[x];
    x = x - lowbit(x);
  }
  return ans;
}
```

## 区间加 & 区间求和

若维护序列 $a$ 的差分数组 $b$ ，此时我们对 $a$ 的一个前缀 $r$ 求和，即 $\sum_{i=1}^{r} a_i$ ，由差分数组定义得 $a_i=\sum_{j=1}^i b_j$ 

进行推导

$$
\sum_{i=1}^{r} a_i\\=\sum_{i=1}^r\sum_{j=1}^i b_j\\=\sum_{i=1}^r b_i\times(r-i+1)
\\=\sum_{i=1}^r b_i\times (r+1)-\sum_{i=1}^r b_i\times i
$$

区间和可以用两个前缀和相减得到，因此只需要用两个树状数组分别维护 $\sum b_i$ 和 $\sum i \times b_i$ ，就能实现区间求和。

代码如下

```cpp
int t1[MAXN], t2[MAXN], n;

inline int lowbit(int x) { return x & (-x); }

void add(int k, int v) {
  int v1 = k * v;
  while (k <= n) {
    t1[k] += v, t2[k] += v1;
    k += lowbit(k);
  }
}

int getsum(int *t, int k) {
  int ret = 0;
  while (k) {
    ret += t[k];
    k -= lowbit(k);
  }
  return ret;
}

void add1(int l, int r, int v) {
  add(l, v), add(r + 1, -v);  //将区间加差分为两个前缀加
}

long long getsum1(int l, int r) {
  return (r + 1ll) * getsum(t1, r) - 1ll * l * getsum(t1, l - 1) -
         (getsum(t2, r) - getsum(t2, l - 1));
}
```

## Tricks

 $O(n)$ 建树：

每一个节点的值是由所有与自己直接相连的儿子的值求和得到的。因此可以倒着考虑贡献，即每次确定完儿子的值后，用自己的值更新自己的直接父亲。

```cpp
// O(n)建树
void init() {
  for (int i = 1; i <= n; ++i) {
    t[i] += a[i];
    int j = i + lowbit(i);
    if (j <= n) t[j] += t[i];
  }
}
```

 $O(\log n)$ 查询第 $k$ 小/大元素。在此处只讨论第 $k$ 小，第 $k$ 大问题可以通过简单计算转化为第 $k$ 小问题。

参考 "可持久化线段树" 章节中，关于求区间第 $k$ 小的思想。将所有数字看成一个可重集合，即定义数组 $a$ 表示值为 $i$ 的元素在整个序列重出现了 $a_i$ 次。找第 $k$ 大就是找到最小的 $x$ 恰好满足 $\sum_{i=1}^{x}a_i \geq k$ 

因此可以想到算法：如果已经找到 $x$ 满足 $\sum_{i=1}^{x}a_i \le k$ ，考虑能不能让 $x$ 继续增加，使其仍然满足这个条件。找到最大的 $x$ 后， $x+1$ 就是所要的值。
在树状数组中，节点是根据 2 的幂划分的，每次可以扩大 2 的幂的长度。令 $sum$ 表示当前的 $x$ 所代表的前缀和，有如下算法找到最大的 $x$ ：

1.  求出 $depth=\left \lfloor log_2n \right \rfloor$ 
2.  计算 $t=\sum_{i=x+1}^{x+2^{depth}}a_i$ 
3.  如果 $sum+t \le k$ ，则此时扩展成功，将 $2^{depth}$ 累加到 $x$ 上；否则扩展失败，对 $x$ 不进行操作
4.  将 $depth$ 减 1，回到步骤 2，直至 $depth$ 为 0

```cpp
//权值树状数组查询第k小
int kth(int k) {
  int cnt = 0, ret = 0;
  for (int i = log2(n); ~i; --i) {      // i与上文depth含义相同
    ret += 1 << i;                      //尝试扩展
    if (ret >= n || cnt + t[ret] >= k)  //如果扩展失败
      ret -= 1 << i;
    else
      cnt += t[ret];  //扩展成功后 要更新之前求和的值
  }
  return ret + 1;
}
```

时间戳优化：

对付多组数据很常见的技巧。如果每次输入新数据时，都暴力清空树状数组，就可能会造成超时。因此使用 $tag$ 标记，存储当前节点上次使用时间（即最近一次是被第几组数据使用）。每次操作时判断这个位置 $tag$ 中的时间和当前时间是否相同，就可以判断这个位置应该是 0 还是数组内的值。

```cpp
//时间戳优化
int tag[MAXN], t[MAXN], Tag;
void reset() { ++Tag; }
void add(int k, int v) {
  while (k <= n) {
    if (tag[k] /home/llj/Desktop/OI-wiki-master/docs/ds/!= Tag) t[k] = 0;
    t[k] += v, tag[k] = Tag;
    k += lowbit(k);
  }
}
int getsum(int k) {
  int ret = 0;
  while (k) {
    if (tag[k] == Tag) ret += t[k];
    k -= lowbit(k);
  }
  return ret;
}
```

## 例题

-    [树状数组 1：单点修改，区间查询](https://loj.ac/problem/130) 
-    [树状数组 2：区间修改，单点查询](https://loj.ac/problem/131) 
-    [树状数组 3：区间修改，区间查询](https://loj.ac/problem/132) 
-    [二维树状数组 1：单点修改，区间查询](https://loj.ac/problem/133) 
-    [二维树状数组 3：区间修改，区间查询](https://loj.ac/problem/135) 

# avl
AVL 树，是一种平衡的二叉搜索树。由于各种算法教材上对 AVL 的介绍十分冗长，造成了很多人对 AVL 树复杂、不实用的印象。但实际上，AVL 树的原理简单，实现也并不复杂。

## 性质

1.  空二叉树是一个 AVL 树
2.  如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \leq 1$ ，h 是其左右子树的高度
3.  树高为 $O(\log n)$ 

平衡因子：右子树高度 - 左子树高度

 **树高的证明** 设 $f_n$ 为高度为 $n$ 的 AVL 树所包含的最少节点数，则有

$$
f_n=
\begin{cases}
  1&(n=1)\\
  2&(n=2)\\
  f_{n-1}+f_{n-2}+1& (n>2)
\end{cases}
$$

显然 $\{f_n+1\}$ 是一个斐波那契数列。众所周知，斐波那契数列是以指数的速度增长的，因此 AVL 树的高度为 $O(\log n)$ 。

## 插入结点

与 BST（二叉搜索树）中类似，先进行一次失败的查找来确定插入的位置，插入节点后根据平衡因子来决定是否需要调整。

## 删除结点

删除和 BST 类似，将结点与后继交换后再删除。

删除会导致树高以及平衡因子变化，这时需要沿着被删除结点到根的路径来调整这种变化。

## 平衡的维护

插入或删除节点后，可能会造成 AVL 树的性质 2 被破坏。因此，需要沿着从被插入/删除的节点到根的路径对树进行维护。如果对于某一个节点，性质 2 不再满足，由于我们只插入/删除了一个节点，对树高的影响不超过 1，因此该节点的平衡因子的绝对值至多为 2。由于对称性，我们在此只讨论左子树的高度比右子树大 2 的情况，即下图中 $h(B)-h(E)=2$ 。此时，还需要根据 $h(A)$ 和 $h(C)$ 的大小关系分两种情况讨论。需要注意的是，由于我们是自底向上维护平衡的，因此对节点 D 的所有后代来说，性质 2 仍然是被满足的。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/avl1.jpg)

###  $h(A)\geq h(C)$ 

设 $h(E)=x$ ，则有

$$
\begin{cases}
    h(B)=x+2\\
    h(A)=x+1\\
    x\leq h(C)\leq x+1
\end{cases}
$$

其中 $h(C)\geq x$ 是由于节点 B 满足性质 2，因此 $h(C)$ 和 $h(A)$ 的差不会超过 1。此时我们对节点 D 进行一次右旋操作（旋转操作与其它类型的平衡二叉搜索树相同），如下图所示。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/avl2.jpg)

显然节点 A、C、E 的高度不发生变化，并且有

$$
\begin{cases}
    0\leq h(C)-h(E)\leq 1\\
    x+1\leq h'(D)=\max(h(C),h(E))+1=h(C)+1\leq x+2\\
    0\leq h'(D)-h(A)\leq 1
\end{cases}
$$

因此旋转后的节点 B 和 D 也满足性质 2。

###  $h(A)<h(C)$ 

设 $h(E)=x$ ，则与刚才同理，有

$$
\begin{cases}
    h(B)=x+2\\
    h(C)=x+1\\
    h(A)=x
\end{cases}
$$

此时我们先对节点 B 进行一次左旋操作，再对节点 D 进行一次右旋操作，如下图所示。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/avl3.jpg)

显然节点 A、E 的高度不发生变化，并且 B 的新右儿子和 D 的新左儿子分别为 C 原来的左右儿子，则有

$$
\begin{cases}
    x-1\leq h'(rs_B),h'(ls_D)\leq x\\
    0\leq h(A)-h'(rs_B)\leq 1\\
    0\leq h(E)-h'(ls_D)\leq 1\\
    h'(B)=\max(h(A),h'(rs_B))+1=x+1\\
    h'(D)=\max(h(E),h'(ls_D))+1=x+1\\
    h'(B)-h'(D)=0
\end{cases}
$$

因此旋转后的节点 B、C、D 也满足性质 2。最后给出对于一个节点维护平衡操作的伪代码。

```text
Maintain-Balanced(p)
    if h[ls[p]] - h[rs[p]] == 2
        if h[ls[ls[p]]] >= h[rs[ls[p]]]
            Right-Rotate(p)
        else
            Left-Rotate(ls[p])
            Right-Rotate(p)
    else if h[ls[p]] - h[rs[p]] == -2
        if h[ls[rs[p]]] <= h[rs[rs[p]]]
            Left-Rotate(p)
        else
            Right-Rotate(rs[p])
            Left-Rotate(p)
```

与其他平衡二叉搜索树相同，AVL 树中节点的高度、子树大小等信息需要在旋转时进行维护。

## 其他操作

AVL 树的其他操作（Pred、Succ、Select、Rank 等）与普通的二叉搜索树相同。

## 其他资料

在 [AVL Tree Visualization](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html) 可以观察 AVL 树维护平衡的过程。

# sqrt-tree
给你一个长度为 n 的序列 $\left\langle a_i\right\rangle_{i=1}^n$ ，再给你一个满足结合律的运算 $\circ$ （比如 $\gcd,\min,\max,+,\operatorname{and},\operatorname{or},\operatorname{xor}$ 均满足结合律），然后对于每一次区间询问 $[l,r]$ ，我们需要计算 $a_l\circ a_{l+1}\circ\dotsb\circ a_{r}$ 。

Sqrt Tree 可以在 $O(n\log\log n)$ 的时间内预处理，并在 $O(1)$ 的时间内回答询问。

## 描述

### 序列分块

首先我们把整个序列分成 $O(\sqrt{n})$ 个块，每一块的大小为 $O(\sqrt{n})$ 。对于每个块，我们计算：

1.   $P_i$ 块内的前缀区间询问
2.   $S_i$ 块内的后缀区间询问
3.  维护一个额外的数组 $\left\langle B_{i,j}\right\rangle$ 表示第 $i$ 个块到第 $j$ 个块的区间答案。

举个例子，假设 $\circ$ 代表加法运算 $+$ ，序列为 $\{1,2,3,4,5,6,7,8,9\}$ 。

首先我们将序列分成三块，变成了 $\{1,2,3\},\{4,5,6\},\{7,8,9\}$ 。

那么每一块的前缀区间答案和后缀区间答案分别为

$$
\begin{split}
&P_1=\{1,3,6\},S_1=\{6,5,3\}\\
&P_2=\{4,9,15\},S_2=\{15,11,6\}\\
&P_3=\{7,15,24\},S_3=\{24,17,9\}\\
\end{split}
$$

 $B$ 数组为：

$$
B=\begin{bmatrix}
6 & 21 & 45\\
0 & 15 & 39\\
0 & 0 & 24\\
\end{bmatrix}
$$

（对于 $i>j$ 的不合法的情况我们假设答案为 0）

显然我们可以在 $O(n)$ 的时间内预处理这些值，空间复杂度同样是 $O(n)$ 的。处理好之后，我们可以利用它们在 $O(1)$ 的时间内回答一些跨块的询问。但对于那些整个区间都在一个块内的询问我们仍不能处理，因此我们还需要处理一些东西。

### 构建一棵树

容易想到我们在每个块内递归地构造上述结构以支持块内的查询。对于大小为 $1$ 的块我们可以 $O(1)$ 地回答询问。这样我们就建出了一棵树，每一个结点代表序列的一个区间。叶子结点的区间长度为 $1$ 或 $2$ 。一个大小为 $k$ 的结点有 $O(\sqrt{k})$ 个子节点，于是整棵树的高度是 $O(\log\log n)$ 的，每一层的区间总长是 $O(n)$ 的，因此我们构建这棵树的复杂度是 $O(n\log\log n)$ 的。

现在我们可以在 $O(\log\log n)$ 的时间内回答询问。对于询问 $[l,r]$ ，我们只需要快速找到一个区间长度最小的结点 $u$ 使得 $u$ 能包含 $[l,r]$ ，这样 $[l,r]$ 在 $u$ 的分块区间中一定是跨块的，就可以 $O(1)$ 地计算答案了。查询一次的总体复杂度是 $O(\log\log n)$ ，因为树高是 $O(\log\log n)$ 的。不过我们仍可以优化这个过程。

### 优化询问复杂度

容易想到二分高度，然后可以 $O(1)$ 判断是否合法。这样复杂度就变成了 $O(\log\log\log n)$ 。不过我们仍可以进一步加速这一过程。

我们假设

1.  每一块的大小都是 $2$ 的整数幂次；
2.  每一层上的块大小是相同的。

为此我们需要在序列的末位补充一些 $0$ 元素，使得它的长度变成 $2$ 的整数次幂。尽管有些块可能会变成原来的两倍大小，但这样仍是 $O(\sqrt{k})$ 的，于是预处理分块的复杂度仍是 $O(n)$ 的。

现在我们可以轻松地确定一个询问区间是否被整个地包含在一个块中。对于区间 $[l,r]$ （以 0 为起点），我们把端点写为二进制形式。举一个例子，对于 $k=4, l=39, r=46$ ，二进制表示为

$$
l = 39_{10} = 100111_2\\
r = 46_{10} = 101110_2
$$

我们知道每一层的区间长度是相同的，而分块的大小也是相同的（在上述示例中 $2^k=2^4=16$ ）。这些块完全覆盖了整个序列，因此第一块代表的元素为 $[0,15]$ （二进制表示为 $[000000_2,001111_2]$ ），第二个块代表的元素区间为 $[16,31]$ （二进制表示为 $[010000_2,011111_2]$ ），以此类推。我们发现这些在同一个块内的元素的位置在二进制上只有后 $k$ 位不同（上述示例中 $k=4$ ）。而示例的 $l,r$ 也只有后 $k$ 位不同，因此他们在同一个块中。

因此我们需要检查区间两个端点是否只有后 $k$ 位不同，即 $l\oplus r\le 2^k-1$ 。因此我们可以快速找到答案区间所在的层：

1.  对于每个 $i\in [1,n]$ ，我们找到找到 $i$ 最高位上的 $1$ ；
2.  现在对于一个询问 $[l,r]$ ，我们计算 $l\oplus r$ 的最高位，这样就可以快速确定答案区间所在的层。

这样我们就可以在 $O(1)$ 的时间内回答询问啦。

## 更新元素

我们可以在 Sqrt Tree 上更新元素，单点修改和区间修改都是支持的。

### 单点修改

考虑一次单点赋值操作 $a_x=val$ ，我们希望高效更新这个操作的信息。

#### 朴素实现

首先我们来看看在做了一次单点修改后 Sqrt Tree 会变成什么样子。

考虑一个长度为 $l$ 的结点以及对应的序列： $\left\langle P_i\right\rangle,\left\langle S_i\right\rangle,\left\langle B_{i,j}\right\rangle$ 。容易发现在 $\left\langle P_i\right\rangle$ 和 $\left\langle S_i \right\rangle$ 中都只有 $O(\sqrt{l})$ 个元素改变。而在 $\left\langle B_{i,j}\right\rangle$ 中则有 $O(l)$ 个元素被改变。因此有 $O(l)$ 个元素在树上被更新。因此在 Sqrt Tree 上单点修改的复杂度是 $O(n+\sqrt{n}+\sqrt{\sqrt{n}}+\dotsb)=O(n)$ 。

#### 使用 Sqrt Tree 替代 B 数组

注意到单点更新的瓶颈在于更新根结点的 $\left\langle B_{i,j}\right\rangle$ 。因此我们尝试用另一个 Sqrt Tree 代替根结点的 $\left\langle B_{i,j}\right\rangle$ ，称其为 $index$ 。它的作用和原来的二维数组一样，维护整段询问的答案。其他非根结点仍然使用 $\left\langle B_{i,j}\right\rangle$ 维护。注意，如果一个 Sqrt Tree 根结点有 $index$ 结构，称其 Sqrt Tree 是 **含有索引** 的；如果一个 Sqrt Tree 的根结点有 $\left\langle B_{i,j}\right\rangle$ 结构，称其是 **没有索引** 的。而 $index$ 这棵树本身是没有索引的。

因此我们可以这样更新 $index$ 树：

1.  在 $O(\sqrt{n})$ 的时间内更新 $\left\langle P_i\right\rangle$ 和 $\left\langle S_i\right\rangle$ 。
2.  更新 $index$ ，它的长度是 $O(n)$ 的，但我们只需要更新其中的一个元素（这个元素代表了被改变的块），这一步的时间复杂度是 $O(\sqrt{n})$ 的（使用朴素实现的算法）。
3.  进入产生变化的子节点并使用朴素实现的算法在 $O(\sqrt{n})$ 的时间内更新信息。

注意，查询的复杂度仍是 $O(1)$ 的，因为我们最多使用 $index$ 树一次。于是单点修改的复杂度就是 $O(\sqrt{n})$ 的。

### 更新一个区间

Sqrt Tree 也支持区间覆盖操作 $\operatorname{Update}(l,r,x)$ ，即把区间 $[l,r]$ 的数全部变成 $x$ 。对此我们有两种实现方式，其中一种会花费 $O(\sqrt{n}\log\log n)$ 的复杂度更新信息， $O(1)$ 的时间查询；另一种则是 $O(\sqrt{n})$ 更新信息，但查询的时间会增加到 $O(\log\log n)$ 。

我们可以像线段树一样在 Sqrt Tree 上打懒标记。但是在 Sqrt Tree 上有一点不同。因为下传一个结点的懒标记，复杂度可能达到 $O(\sqrt{n})$ ，因此我们不是在询问的时侯下传标记，而是看父节点是否有标记，如果有标记就把它下传。

#### 第一种实现

在第一种实现中，我们只会给第 $1$ 层的结点（结点区间长度为 $O(\sqrt{n})$ ）打懒标记，在下传标记的时侯直接更新整个子树，复杂度为 $O(\sqrt{n}\log\log n)$ 。操作过程如下：

1.  考虑第 $1$ 层上的结点，对于那些被修改区间完全包含的结点，给他们打一个懒标记；

2.  有两个块只有部分区间被覆盖，我们直接在 $O(\sqrt{n}\log\log n)$ 的时间内 **重建** 这两个块。如果它本身带有之前修改的懒标记，就在重建的时侯顺便下传标记；

3.  更新根结点的 $\left\langle P_i\right\rangle$ 和 $\left\langle S_i\right\rangle$ ，时间复杂度 $O(\sqrt{n})$ ；

4.  重建 $index$ 树，时间复杂度 $O(\sqrt{n}\log\log n)$ 。

现在我们可以高效完成区间修改了。那么如何利用懒标记回答询问？操作如下：

1.  如果我们的询问被包含在一个有懒标记的块内，可以利用懒标记计算答案；

2.  如果我们的询问包含多个块，那么我们只需要关心最左边和最右边不完整块的答案。中间的块的答案可以在 $index$ 树中查询（因为 $index$ 树在每次修改完后会重建），复杂度是 $O(1)$ 。

因此询问的复杂度仍为 $O(1)$ 。

#### 第二种实现

在这种实现中，每一个结点都可以被打上懒标记。因此在处理一个询问的时侯，我们需要考虑祖先中的懒标记，那么查询的复杂度将变成 $O(\log\log n)$ 。不过更新信息的复杂度就会变得更快。操作如下：

1.  被修改区间完全包含的块，我们把懒标记添加到这些块上，复杂度 $O(\sqrt{n})$ ；
2.  被修改区间部分覆盖的块，更新 $\left\langle P_i\right\rangle$ 和 $\left\langle S_i\right\rangle$ ，复杂度 $O(\sqrt{n})$ （因为只有两个被修改的块）；
3.  更新 $index$ 树，复杂度 $O(\sqrt{n})$ （使用同样的更新算法）；
4.  对于没有索引的子树更新他们的 $\left\langle B_{i,j}\right\rangle$ ；
5.  递归地更新两个没有被完全覆盖的区间。

时间复杂度是 $O(\sqrt{n}+\sqrt{\sqrt{n}}+\dotsb)=O(\sqrt{n})$ 。

## 代码实现

下面的实现在 $O(n\log\log n)$ 的时间内建树，在 $O(1)$ 的时间内回答询问，在 $O(\sqrt{n})$ 的时间内单点修改。

```cpp
SqrtTreeItem op(const SqrtTreeItem &a, const SqrtTreeItem &b);

inline int log2Up(int n) {
  int res = 0;
  while ((1 << res) < n) {
    res++;
  }
  return res;
}

class SqrtTree {
 private:
  int n, lg, indexSz;
  vector<SqrtTreeItem> v;
  vector<int> clz, layers, onLayer;
  vector<vector<SqrtTreeItem> > pref, suf, between;

  inline void buildBlock(int layer, int l, int r) {
    pref[layer][l] = v[l];
    for (int i = l + 1; i < r; i++) {
      pref[layer][i] = op(pref[layer][i - 1], v[i]);
    }
    suf[layer][r - 1] = v[r - 1];
    for (int i = r - 2; i >= l; i--) {
      suf[layer][i] = op(v[i], suf[layer][i + 1]);
    }
  }

  inline void buildBetween(int layer, int lBound, int rBound, int betweenOffs) {
    int bSzLog = (layers[layer] + 1) >> 1;
    int bCntLog = layers[layer] >> 1;
    int bSz = 1 << bSzLog;
    int bCnt = (rBound - lBound + bSz - 1) >> bSzLog;
    for (int i = 0; i < bCnt; i++) {
      SqrtTreeItem ans;
      for (int j = i; j < bCnt; j++) {
        SqrtTreeItem add = suf[layer][lBound + (j << bSzLog)];
        ans = (i == j) ? add : op(ans, add);
        between[layer - 1][betweenOffs + lBound + (i << bCntLog) + j] = ans;
      }
    }
  }

  inline void buildBetweenZero() {
    int bSzLog = (lg + 1) >> 1;
    for (int i = 0; i < indexSz; i++) {
      v[n + i] = suf[0][i << bSzLog];
    }
    build(1, n, n + indexSz, (1 << lg) - n);
  }

  inline void updateBetweenZero(int bid) {
    int bSzLog = (lg + 1) >> 1;
    v[n + bid] = suf[0][bid << bSzLog];
    update(1, n, n + indexSz, (1 << lg) - n, n + bid);
  }

  void build(int layer, int lBound, int rBound, int betweenOffs) {
    if (layer >= (int)layers.size()) {
      return;
    }
    int bSz = 1 << ((layers[layer] + 1) >> 1);
    for (int l = lBound; l < rBound; l += bSz) {
      int r = min(l + bSz, rBound);
      buildBlock(layer, l, r);
      build(layer + 1, l, r, betweenOffs);
    }
    if (layer == 0) {
      buildBetweenZero();
    } else {
      buildBetween(layer, lBound, rBound, betweenOffs);
    }
  }

  void update(int layer, int lBound, int rBound, int betweenOffs, int x) {
    if (layer >= (int)layers.size()) {
      return;
    }
    int bSzLog = (layers[layer] + 1) >> 1;
    int bSz = 1 << bSzLog;
    int blockIdx = (x - lBound) >> bSzLog;
    int l = lBound + (blockIdx << bSzLog);
    int r = min(l + bSz, rBound);
    buildBlock(layer, l, r);
    if (layer == 0) {
      updateBetweenZero(blockIdx);
    } else {
      buildBetween(layer, lBound, rBound, betweenOffs);
    }
    update(layer + 1, l, r, betweenOffs, x);
  }

  inline SqrtTreeItem query(int l, int r, int betweenOffs, int base) {
    if (l == r) {
      return v[l];
    }
    if (l + 1 == r) {
      return op(v[l], v[r]);
    }
    int layer = onLayer[clz[(l - base) ^ (r - base)]];
    int bSzLog = (layers[layer] + 1) >> 1;
    int bCntLog = layers[layer] >> 1;
    int lBound = (((l - base) >> layers[layer]) << layers[layer]) + base;
    int lBlock = ((l - lBound) >> bSzLog) + 1;
    int rBlock = ((r - lBound) >> bSzLog) - 1;
    SqrtTreeItem ans = suf[layer][l];
    if (lBlock <= rBlock) {
      SqrtTreeItem add =
          (layer == 0) ? (query(n + lBlock, n + rBlock, (1 << lg) - n, n))
                       : (between[layer - 1][betweenOffs + lBound +
                                             (lBlock << bCntLog) + rBlock]);
      ans = op(ans, add);
    }
    ans = op(ans, pref[layer][r]);
    return ans;
  }

 public:
  inline SqrtTreeItem query(int l, int r) { return query(l, r, 0, 0); }

  inline void update(int x, const SqrtTreeItem &item) {
    v[x] = item;
    update(0, 0, n, 0, x);
  }

  SqrtTree(const vector<SqrtTreeItem> &a)
      : n((int)a.size()), lg(log2Up(n)), v(a), clz(1 << lg), onLayer(lg + 1) {
    clz[0] = 0;
    for (int i = 1; i < (int)clz.size(); i++) {
      clz[i] = clz[i >> 1] + 1;
    }
    int tlg = lg;
    while (tlg > 1) {
      onLayer[tlg] = (int)layers.size();
      layers.push_back(tlg);
      tlg = (tlg + 1) >> 1;
    }
    for (int i = lg - 1; i >= 0; i--) {
      onLayer[i] = max(onLayer[i], onLayer[i + 1]);
    }
    int betweenLayers = max(0, (int)layers.size() - 1);
    int bSzLog = (lg + 1) >> 1;
    int bSz = 1 << bSzLog;
    indexSz = (n + bSz - 1) >> bSzLog;
    v.resize(n + indexSz);
    pref.assign(layers.size(), vector<SqrtTreeItem>(n + indexSz));
    suf.assign(layers.size(), vector<SqrtTreeItem>(n + indexSz));
    between.assign(betweenLayers, vector<SqrtTreeItem>((1 << lg) + bSz));
    build(0, 0, n, 0);
  }
};
```

## 习题

 [CodeChef - SEGPROD](https://www.codechef.com/NOV17/problems/SEGPROD) 

 **本页面主要译自 [Sqrt Tree](https://cp-algorithms.com/data_structures/sqrt-tree.html) ，版权协议为 CC-BY-SA 4.0。** 

# odt
## 名称简介

老司机树，ODT(Old Driver Tree)，又名珂朵莉树（Chtholly Tree)。
起源自 [CF896C](https://codeforces.com/problemset/problem/896/C) 。

## 前置知识

会用 STL 的 set 就行。

## 核心思想

把值相同的区间合并成一个结点保存在 set 里面。

## 用处

骗分。
只要是有区间赋值操作的数据结构题都可以用来骗分。
一般出题人不会 **刻意** 卡，但是不小心卡了就……

如果要保证复杂度正确，必须保证数据随机。
证明在 [此](http://codeforces.com/blog/entry/56135?#comment-398940) 。
补充一个更详细的严格证明： [看这里](https://zhuanlan.zhihu.com/p/102786071) 。对于 add，assign 和 sum 操作，用 set 实现的珂朵莉树的复杂度为 $O(n \log \log n)$ ，而用链表实现的复杂度为 $O(n \log n)$ 。

## 正文

首先，结点的保存方式：

```cpp
struct Node_t {
  int l, r;
  mutable int v;
  Node_t(const int &il, const int &ir, const int &iv) : l(il), r(ir), v(iv) {}
  inline bool operator<(const Node_t &o) const { return l < o.l; }
};
```

其中， `int v` 是你自己指定的附加数据。

注意，其中的 `mutable` 关键字如果不加的话，在修改时会导致 CE。 `mutable` 的意思是“可变的”，让我们可以在后面的操作中修改 `v` 的值。因为在 C++ 中，mutable 是为了突破 const 的限制而设置的。被 mutable 修饰的变量（mutable 只能用于修饰类中的非静态数据成员），将永远处于可变的状态，即使在一个 const 函数中。

然后，我们定义一个 `set<Node_t> odt;` 来维护这些结点。
为简化代码，可以 `typedef set<Node_t>::iterator iter` ，当然在题目支持 C++11 时也可以使用 `auto` 。

### split

 `split` 是最核心的操作之一，它用于将原本包含点 $x$ 的区间（设为 $[l, r]$ ）分裂为两个区间 $[l, x)$ 和 $[x, r]$ 并返回指向后者的迭代器。
参考代码如下：

```cpp
auto split(int x) {
  if (x > n) return odt.end();
  auto it = --odt.upper_bound((Node_t){x, 0, 0});
  if (it->l == x) return it;
  int l = it->l, r = it->r, v = it->v;
  odt.erase(it);
  odt.insert(Node_t(l, x - 1, v));
  return odt.insert(Node_t(x, r, v)).first;
}
```

这个玩意有什么用呢？
任何对于 $[l,r]$ 的区间操作，都可以转换成 set 上 $[split(l),split(r + 1))$ 的操作。

### assign

另外一个重要的操作 `assign` 用于对一段区间进行赋值。
对于 ODT 来说，区间操作只有这个比较特殊，也是保证复杂度的关键。
如果 ODT 里全是长度为 $1$ 的区间，就成了暴力，但是有了 `assign` ，可以使 ODT 的大小下降。
参考代码如下：

```cpp
void assign(int l, int r, int v) {
  auto itr = split(r + 1), itl = split(l);
  odt.erase(itl, itr);
  odt.insert(Node_t(l, r, v));
}
```

### 其他操作

套模板就好了，参考代码如下：

```cpp
void performance(int l, int r) {
  auto itr = split(r + 1), itl = split(l);
  for (; itl != itr; ++itl) {
    // Perform Operations here
  }
}
```

 **注：珂朵莉树在进行求取区间左右端点操作时，必须先 split 右端点，再 split 左端点。否则在处理边界情况时会导致 RE。** 

## 习题

-    [「SCOI2010」序列操作](https://www.luogu.org/problem/P2572) 
-    [「SHOI2015」脑洞治疗仪](https://loj.ac/problem/2037) 
-    [「Luogu 2787」理理思维](https://www.luogu.org/problemnew/show/P2787) 
-    [「Luogu 4979」矿洞：坍塌](https://www.luogu.org/problemnew/show/P4979) 

# splay
> 如何用 $\text{Splay}$ 维护二叉查找树。

* * *

## 简介

 $\text{Splay}$ 是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链，它由 Daniel Sleator 和 Robert Tarjan 发明。

* * *

## 结构

### 二叉查找树的性质

首先肯定是一棵二叉树！

能够在这棵树上查找某个值的性质：左儿子的值 $<$ 根节点的值 $<$ 右儿子的值。

### 节点维护信息

|  $rt$  |  $tot$  |  $fa[i]$  |  $ch[i][0/1]$  |  $val[i]$  |  $cnt[i]$  |  $sz[i]$  |
| :----- | :------ | :-------- | :------------- | :--------- | :--------- | :-------- |
| 根节点编号  | 节点个数    | 父亲        | 左右儿子编号         | 节点权值       | 权值出现次数     | 子树大小      |

* * *

## 操作

### 基本操作

-    $\text{maintain}(x)$ ：在改变节点位置后，将节点 $x$ 的 $\text{size}$ 更新。
-    $\text{get}(x)$ ：判断节点 $x$ 是父亲节点的左儿子还是右儿子。
-    $\text{clear}(x)$ ：销毁节点 $x$ 。

```cpp
void maintain(int x) { sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + cnt[x]; }
bool get(int x) { return x == ch[fa[x]][1]; }
void clear(int x) { ch[x][0] = ch[x][1] = fa[x] = val[x] = sz[x] = cnt[x] = 0; }
```

### 旋转操作

为了使 $\text{Splay}$ 保持平衡而进行旋转操作，旋转的本质是将某个节点上移一个位置。

 **旋转需要保证** ：

-   整棵 $\text{Splay}$ 的中序遍历不变（不能破坏二叉查找树的性质）。
-   受影响的节点维护的信息依然正确有效。
-    $\text{root}$ 必须指向旋转后的根节点。

在 $\text{Splay}$ 中旋转分为两种：左旋和右旋。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/splay2.png)

 **具体分析旋转步骤** （假设需要旋转的节点为 $x$ ，其父亲为 $y$ ，以右旋为例）

1.  将 $y$ 的左儿子指向 $x$ 的右儿子，且 $x$ 的右儿子的父亲指向 $y$ 。 `ch[y][0]=ch[x][1]; fa[ch[x][1]]=y;` 
2.  将 $x$ 的右儿子指向 $y$ ，且 $y$ 的父亲指向 $x$ 。 `ch[x][chk^1]=y; fa[y]=x;` 
3.  如果原来的 $y$ 还有父亲 $z$ ，那么把 $z$ 的某个儿子（原来 $y$ 所在的儿子位置）指向 $x$ ，且 $x$ 的父亲指向 $z$ 。 `fa[x]=z; if(z) ch[z][y==ch[z][1]]=x;` 

```cpp
void rotate(int x) {
  int y = fa[x], z = fa[y], chk = get(x);
  ch[y][chk] = ch[x][chk ^ 1];
  fa[ch[x][chk ^ 1]] = y;
  ch[x][chk ^ 1] = y;
  fa[y] = x;
  fa[x] = z;
  if (z) ch[z][y == ch[z][1]] = x;
  maintain(y);
  maintain(x);
}
```

### Splay 操作

 $\text{Splay}$ 规定：每访问一个节点后都要强制将其旋转到根节点。此时旋转操作具体分为 $6$ 种情况讨论（其中 $x$ 为需要旋转到根的节点）

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/splay1.png)

-   如果 $x$ 的父亲是根节点，直接将 $x$ 左旋或右旋（图 $1,2$ ）。
-   如果 $x$ 的父亲不是根节点，且 $x$ 和父亲的儿子类型相同，首先将其父亲左旋或右旋，然后将 $x$ 右旋或左旋（图 $3,4$ ）。
-   如果 $x$ 的父亲不是根节点，且 $x$ 和父亲的儿子类型不同，将 $x$ 左旋再右旋、或者右旋再左旋（图 $5,6$ ）。

分析起来一大串，其实代码一小段。大家可以自己模拟一下 $6$ 种旋转情况，就能理解 $\text{Splay}$ 的基本思想了。

```cpp
void splay(int x) {
  for (int f = fa[x]; f = fa[x], f; rotate(x))
    if (fa[f]) rotate(get(x) == get(f) ? f : x);
  rt = x;
}
```

### 插入操作

插入操作是一个比较复杂的过程，具体步骤如下（插入的值为 $k$ ）：

-   如果树空了则直接插入根并退出。
-   如果当前节点的权值等于 $k$ 则增加当前节点的大小并更新节点和父亲的信息，将当前节点进行 $\text{Splay}$ 操作。
-   否则按照二叉查找树的性质向下找，找到空节点就插入即可（当然别忘了 $\text{Splay}$ 操作哦）。

```cpp
void ins(int k) {
  if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!rt) {
    val[++tot] = k;
    cnt[tot]++;
    rt = tot;
    maintain(rt);
    return;
  }
  int cnr = rt, f = 0;
  while (1) {
    if (val[cnr] == k) {
      cnt[cnr]++;
      maintain(cnr);
      maintain(f);
      splay(cnr);
      break;
    }
    f = cnr;
    cnr = ch[cnr][val[cnr] < k];
    if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!cnr) {
      val[++tot] = k;
      cnt[tot]++;
      fa[tot] = f;
      ch[f][val[f] < k] = tot;
      maintain(tot);
      maintain(f);
      splay(tot);
      break;
    }
  }
}
```

### 查询 x 的排名

根据二叉查找树的定义和性质，显然可以按照以下步骤查询 $x$ 的排名：

-   如果 $x$ 比当前节点的权值小，向其左子树查找。
-   如果 $x$ 比当前节点的权值大，将答案加上左子树（ $size$ ）和当前节点（ $cnt$ ）的大小，向其右子树查找。
-   如果 $x$ 与当前节点的权值相同，将答案加 $1$ 并返回。

注意最后需要进行 $\text{Splay}$ 操作。

```cpp
int rk(int k) {
  int res = 0, cnr = rt;
  while (1) {
    if (k < val[cnr]) {
      cnr = ch[cnr][0];
    } else {
      res += sz[ch[cnr][0]];
      if (k == val[cnr]) {
        splay(cnr);
        return res + 1;
      }
      res += cnt[cnr];
      cnr = ch[cnr][1];
    }
  }
}
```

### 查询排名 x 的数

设 $k$ 为剩余排名，具体步骤如下：

-   如果左子树非空且剩余排名 $k$ 不大于左子树的大小 $size$ ，那么向左子树查找。
-   否则将 $k$ 减去左子树的和根的大小。如果此时 $k$ 的值小于等于 $0$ ，则返回根节点的权值，否则继续向右子树查找。

```cpp
int kth(int k) {
  int cnr = rt;
  while (1) {
    if (ch[cnr][0] && k <= sz[ch[cnr][0]]) {
      cnr = ch[cnr][0];
    } else {
      k -= cnt[cnr] + sz[ch[cnr][0]];
      if (k <= 0) {
        splay(cnr);
        return val[cnr];
      }
      cnr = ch[cnr][1];
    }
  }
}
```

### 查询前驱

前驱定义为小于 $x$ 的最大的数，那么查询前驱可以转化为：将 $x$ 插入（此时 $x$ 已经在根的位置了），前驱即为 $x$ 的左子树中最右边的节点，最后将 $x$ 删除即可。

```cpp
int pre() {
  int cnr = ch[rt][0];
  while (ch[cnr][1]) cnr = ch[cnr][1];
  splay(cnr);
  return cnr;
}
```

### 查询后继

后继定义为大于 $x$ 的最小的数，查询方法和前驱类似： $x$ 的右子树中最左边的节点。

```cpp
int nxt() {
  int cnr = ch[rt][1];
  while (ch[cnr][0]) cnr = ch[cnr][0];
  splay(cnr);
  return cnr;
}
```

### 删除操作

删除操作也是一个比较复杂的操作，具体步骤如下：

-   首先将 $x$ 旋转到根的位置。
-   接下来分为多个情况考虑：

1.  如果有不止一个 $x$ ，那么将 $cnt[x]$ 减 $1$ 并退出。
2.  如果 $x$ 没有儿子节点，那么直接将当前节点 $\text{clear}$ 并退出。
3.  如果 $x$ 只有一个儿子，那么先将当前节点 $\text{clear}$ 再把唯一的儿子作为根节点。
4.  否则将 $x$ 的前驱旋转到根并作为根节点，将 $x$ 的右子树接到根节点的右子树上，最后要将根的信息更新。

```cpp
void del(int k) {
  rk(k);
  if (cnt[rt] > 1) {
    cnt[rt]--;
    maintain(rt);
    return;
  }
  if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!ch[rt][0] && /home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!ch[rt][1]) {
    clear(rt);
    rt = 0;
    return;
  }
  if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!ch[rt][0]) {
    int cnr = rt;
    rt = ch[rt][1];
    fa[rt] = 0;
    clear(cnr);
    return;
  }
  if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!ch[rt][1]) {
    int cnr = rt;
    rt = ch[rt][0];
    fa[rt] = 0;
    clear(cnr);
    return;
  }
  int cnr = rt, x = pre();
  splay(x);
  fa[ch[cnr][1]] = x;
  ch[x][1] = ch[cnr][1];
  clear(cnr);
  maintain(rt);
}
```

* * *

## 完整代码

```cpp
#include <cstdio>
const int N = 100005;
int rt, tot, fa[N], ch[N][2], val[N], cnt[N], sz[N];
struct Splay {
  void maintain(int x) { sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + cnt[x]; }
  bool get(int x) { return x == ch[fa[x]][1]; }
  void clear(int x) {
    ch[x][0] = ch[x][1] = fa[x] = val[x] = sz[x] = cnt[x] = 0;
  }
  void rotate(int x) {
    int y = fa[x], z = fa[y], chk = get(x);
    ch[y][chk] = ch[x][chk ^ 1];
    fa[ch[x][chk ^ 1]] = y;
    ch[x][chk ^ 1] = y;
    fa[y] = x;
    fa[x] = z;
    if (z) ch[z][y == ch[z][1]] = x;
    maintain(x);
    maintain(y);
  }
  void splay(int x) {
    for (int f = fa[x]; f = fa[x], f; rotate(x))
      if (fa[f]) rotate(get(x) == get(f) ? f : x);
    rt = x;
  }
  void ins(int k) {
    if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!rt) {
      val[++tot] = k;
      cnt[tot]++;
      rt = tot;
      maintain(rt);
      return;
    }
    int cnr = rt, f = 0;
    while (1) {
      if (val[cnr] == k) {
        cnt[cnr]++;
        maintain(cnr);
        maintain(f);
        splay(cnr);
        break;
      }
      f = cnr;
      cnr = ch[cnr][val[cnr] < k];
      if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!cnr) {
        val[++tot] = k;
        cnt[tot]++;
        fa[tot] = f;
        ch[f][val[f] < k] = tot;
        maintain(tot);
        maintain(f);
        splay(tot);
        break;
      }
    }
  }
  int rk(int k) {
    int res = 0, cnr = rt;
    while (1) {
      if (k < val[cnr]) {
        cnr = ch[cnr][0];
      } else {
        res += sz[ch[cnr][0]];
        if (k == val[cnr]) {
          splay(cnr);
          return res + 1;
        }
        res += cnt[cnr];
        cnr = ch[cnr][1];
      }
    }
  }
  int kth(int k) {
    int cnr = rt;
    while (1) {
      if (ch[cnr][0] && k <= sz[ch[cnr][0]]) {
        cnr = ch[cnr][0];
      } else {
        k -= cnt[cnr] + sz[ch[cnr][0]];
        if (k <= 0) {
          splay(cnr);
          return val[cnr];
        }
        cnr = ch[cnr][1];
      }
    }
  }
  int pre() {
    int cnr = ch[rt][0];
    while (ch[cnr][1]) cnr = ch[cnr][1];
    splay(cnr);
    return cnr;
  }
  int nxt() {
    int cnr = ch[rt][1];
    while (ch[cnr][0]) cnr = ch[cnr][0];
    splay(cnr);
    return cnr;
  }
  void del(int k) {
    rk(k);
    if (cnt[rt] > 1) {
      cnt[rt]--;
      maintain(rt);
      return;
    }
    if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!ch[rt][0] && /home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!ch[rt][1]) {
      clear(rt);
      rt = 0;
      return;
    }
    if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!ch[rt][0]) {
      int cnr = rt;
      rt = ch[rt][1];
      fa[rt] = 0;
      clear(cnr);
      return;
    }
    if (/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/!ch[rt][1]) {
      int cnr = rt;
      rt = ch[rt][0];
      fa[rt] = 0;
      clear(cnr);
      return;
    }
    int cnr = rt;
    int x = pre();
    splay(x);
    fa[ch[cnr][1]] = x;
    ch[x][1] = ch[cnr][1];
    clear(cnr);
    maintain(rt);
  }
} tree;

int main() {
  int n, opt, x;
  for (scanf("%d", &n); n; --n) {
    scanf("%d%d", &opt, &x);
    if (opt == 1)
      tree.ins(x);
    else if (opt == 2)
      tree.del(x);
    else if (opt == 3)
      printf("%d\n", tree.rk(x));
    else if (opt == 4)
      printf("%d\n", tree.kth(x));
    else if (opt == 5)
      tree.ins(x), printf("%d\n", val[tree.pre()]), tree.del(x);
    else
      tree.ins(x), printf("%d\n", val[tree.nxt()]), tree.del(x);
  }
  return 0;
}
```

* * *

## 例题

以下题目都是裸的 $\text{Splay}$ 维护二叉查找树。~~（直接套板子即可）~~

-    [【模板】普通平衡树](https://loj.ac/problem/104) 
-    [【模板】文艺平衡树](https://loj.ac/problem/105) 
-    [「HNOI2002」营业额统计](https://loj.ac/problem/10143) 
-    [「HNOI2004」宠物收养所](https://loj.ac/problem/10144) 

## 练习题

 [「Cerc2007」robotic sort 机械排序](https://www.luogu.org/problemnew/show/P4402) 

 [二逼平衡树（树套树）](https://loj.ac/problem/106) 

 [bzoj 2827 千山鸟飞绝](https://www.lydsy.com/JudgeOnline/problem.php?id=2827) 

 [「Lydsy1706 月赛」K 小值查询](https://www.lydsy.com/JudgeOnline/problem.php?id=4923) 

* * *

> 本文部分内容引用于 [algocode 算法博客](https://algocode.net) ，特别鸣谢！

# dividing
author: Xarfa

划分树是一种来解决区间第 $K$ 大的一种数据结构，其常数、理解难度都要比主席树低很多。同时，划分树紧贴“第 $K$ 大”，所以是一种基于排序的一种数据结构。

 **建议先学完主席树再看划分树哦** 

## 建树

划分树的建树比较简单，但是相对于其他树来说比较复杂。/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/dividing1.png)

如图，每一层都有一个看似无序的数组。其实，每一个被红色标记的数字都是 **要分配到左儿子的** 。而分配的规则是什么？就是与 **这一层的中位数** 做比较， $\leq$ 左边，否则右边。但是这里要注意一下：并不是严格的 $\leq$  **左边，否则右边** 。因为中位数可能有相同，而且与 $N$ 的奇偶有一定关系。下面的代码展示会有一个巧妙的运用，大家可以参照代码。

我们不肯能每一次都对每一层排序，这样子不说常数，就算是理论复杂度也过不去。我们想，找中位数，一次排序就够了。为什么？比如，我们求 $l,r$ 的中位数，其实就是在排完序过后的 $num[mid]$ 。

两个关键数组：

```text
tree[log(N),N]   : 也就是树,要存下所有的值,空间复杂度 $O(n\log n)$。
toleft[log(N),n] : 也就是每一层 1~i 进入左儿子的数量,这里需要理解一下,这是一个前缀和。
```

```pascal
procedure Build(left,right,deep:longint); // left,right 是左右区间,deep是第几层
var
	i,mid,same,ls,rs,flag:longint; // 其中 flag 是用来平衡左右两边的数量的
begin
	if left=right then exit; // 到底层了
	mid:=(left+right) >> 1;
	same:=mid-left+1;
	for i:=left to right do 
		if tree[deep,i]<num[mid] then
			dec(same);

	ls:=left; // 分配到左儿子的第一个指针
	rs:=mid+1; // 分配到右儿子的第一个指针
	for i:=left to right do
	begin
		flag:=0;
		if (tree[deep,i]<num[mid])or((tree[deep,i]=num[mid])and(same>0)) then // 分配到左边的条件
		begin
			flag:=1; tree[deep+1,ls]:=tree[deep,i]; inc(ls);
			if tree[deep,i]=num[mid] then // 平衡左右个数
				dec(same);
		end
		else
		begin
			tree[deep+1,rs]:=tree[deep,i]; inc(rs);
		end;
		toleft[deep,i]:=toleft[deep,i-1]+flag;
	end;
	Build(left,mid,deep+1); // 继续
	Build(mid+1,right,deep+1);
end;
```

## 查询

那我们先扯一下主席树的内容。在用主席树求区间第 $K$ 小的时候，我们以 $K$ 为基准，向左就向左，向右要减去向左的值，在划分树中也是这样子的。

查询难理解的，在于 **区间缩小** 这种东西。下图，我查询的是 $3$ 到 $7$ , 那么下一层我就只需要查询 $2$ 到 $3$ 了。当然，我们定义 $left,right$ 为缩小后的区间（目标区间）， $l,r$ 还是我所在节点的区间。那为什么要标出目标区间呢？因为那是 **判定答案在左边，右边的基准** 。

/home/llj/Desktop/OI-wiki-master/docs/ds//home/llj/Desktop/OI-wiki-master/docs/ds/![](./images/dividing2.png)

```pascal
function Query(left,right,k,l,r,deep:longint):longint;
var
	mid,x,y,cnt,rx,ry:longint;
begin
	if left=right then // 写成 l=r 也无妨,因为目标区间也一定有答案
		exit(tree[deep,left]);
	mid:=(l+r) >> 1;
	x:=toleft[deep,left-1]-toleft[deep,l-1]; // l 到 left 的去左儿子的个数
	y:=toleft[deep,right]-toleft[deep,l-1]; // l 到 right 的去左儿子的个数
	ry:=right-l-y; rx:=left-l-x; // ry 是 l 到 right 去右儿子的个数,rx 则是 l 到 lefr 去右儿子的个数
	cnt:=y-x; // left 到 right 左儿子的个数
	if cnt>=k then // 主席树常识啦
		Query:=Query(l+x,l+y-1,k,l,mid,deep+1) // l+x 就是缩小左边界,l+y-1 就是缩小右区间。对于上图来说,就是把 1 和 2 放弃了。
	else
		Query:=Query(mid+rx+1,mid+ry+1,k-cnt,mid+1,r,deep+1); // 同样是缩小区间,只不过变成了右边而已。注意要 k-cnt。
end;
```

## 理论复杂度和亲测结果

时间复杂度 : 一次查询只需要 $O(\log n)$ , $m$ 次询问，就是 $O(m\log n)$ 。

空间复杂度 : 只需要存储 $O(n\log n)$ 个数字。

亲测结果：主席树 : $1482 \text{ms}$ 、划分树 : $889 \text{ms}$ 。（非递归，常数比较小）

## 后记

大家可以试着去写非递归版哦。参考博文 : [传送门](https://blog.csdn.net/littlewhite520/article/details/70250722) 。

