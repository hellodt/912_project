#选择题
---
下列选项中，操作系统提供给应用程序的接口是
- [x] A.系统调用 B.中断 C.库函数 D.原语

> 知识点：中断、异常与系统调用。

特权指令
- [x] A.是可能影响系统安全的一类指令 
- [ ] B.既允许操作系统程序使用，又允许用户程序使用 
- [ ] C.是管态和目态运行的基本单位 
- [ ] D.是一种存储保护方法

> 知识点：操作系统概述。
> A

把资源按类型排序编号，并要求进程严格按序申请资源，这种方法摒弃了下述哪一个条件？
- [x] A.互斥条件 B.部分分配条件 C.不剥夺条件 D.环路等待条件

> 知识点：处理机调度。

把资源按类型排序编号，并要求进程严格按序申请资源，这种方法摒弃了下述哪一个条件？
- [x] A.互斥条件 B.部分分配条件 C.不剥夺条件 D.环路等待条件

> 知识点：处理机调度。

使用户所编制的程序与实际使用的物理设备无关是由﹎﹎﹎﹎功能实现的。
- [ ] A.设备分配 
- [ ] B.缓冲管理 
- [ ] C.设备管理 
- [x] D.设备独立性

> 知识点：I/O子系统。
> D

(20150309_操作系统试题_doc)通常，用户进程被创建后，【 】。
- [x] A.便一直存在于系统中，直到被操作员撤消 B.随着进程的阻塞与唤醒而撤消与建立 C.随着时间片轮转而撤消与建立 D.随着作业运行正常或不正常结束而撤消

> 知识点：进程状态与控制。

任何两个并发进程之间(　　)
- [x] A.一定存在互斥关系　　 B.一定存在同步关系　　 C.一定彼此独立无关　　 D.可能存在同步或互斥关系

> 知识点：进程状态与控制。

可以使用银行家算法_____ 死锁。
- [x] A.预防 B.检测 C.解除 D.避免

> 知识点：进程状态与控制。

所谓并发是指两个或两个以上的事件在同一时刻发生。
- [x] A.对 B.错

> 知识点：处理机调度。

为了使系统中各部分资源得到均衡使用，就必须选择对资源需求不同的作业进行合理搭配。这项工作是由_____ 完成的。
- [x] A.作业调度 B.中级调度 C.进程调度 D.内存调度

> 知识点：处理机调度。

(20150309_操作系统原理习题集及答案_笔试必需品_doc)下列关于虚拟存储器的论述中，正确的论述﹎﹎﹎﹎。
- [ ] A.在请求段页式系统中，以页为单位管理用户的虚空间，以段为单位管理内存空间。 
- [x] B.在请求段页式系统中，以段为单位管理用户的虚空间，以页为单位管理内存空间。
- [ ] C.为提高请求分页系统中内存的利用率，允许用户使用不同大小的页面。 
- [ ] D.实现虚拟存储器的最常用的算法是最佳适应算法OPT。

> 知识点：缺页中断。
> B

设备分配问题中，算法实现时，同样要考虑安全性问题，防止在多个进程进行设备请求时，因相互等待对方释放所占设备所造成的()现象
- [ ] A.瓶颈 
- [ ] B.碎片 
- [ ] C.系统抖动 
- [x] D.死锁

> 知识点：死锁。
> D

作业调度选中一个作业并把它装入主存，就为该作业创建一个进程，这个进程的初始状态为_____ 。
- [x] A.收容状态 B.就绪状态 C.执行状态 D.等待状态

> 知识点：进程管理实验。

一系统处于死锁状态则一定是不安全状态。
- [x] A.对 B.错

> 知识点：死锁。

(20150309_操作系统原理习题集及答案_笔试必需品_doc)分时系统中，当用户数目为100时，为保证响应不超过2秒；此时的时间片最大应为﹎﹎﹎﹎。
- [ ] A.10ms 
- [x] B.20ms 
- [ ] C.50ms 
- [ ] D.100ms 
- [ ] E.200ms

> 知识点：操作系统概述。
> B

文件信息的逻辑块号到磁盘物理块号的变换是由( )决定。
- [ ] A. 逻辑结构 
- [ ] B. 页表 
- [x] C. 物理结构 
- [ ] D. 重定位寄存器

> 知识点：文件系统。
> C

(20150309_操作系统原理习题集及答案_笔试必需品_doc)有一类操作系统的系统响应时间的重要性超过系统资源的利用率，它被广泛地应用于卫星控制、导弹发
射、飞机飞行控制、飞机订票业务等领域是﹎﹎﹎﹎。
- [ ] A.分时操作系统 
- [x] B.实时操作系统 
- [ ] C.批处理系统 
- [ ] D.网络操作系统

> 知识点：操作系统概述。
> B

以下哪种存储管理不可用于多道程序系统中？
- [x] A.固定式区存储管理 B.单一连续区存储管理 C.可变分区存储管理 D.段式存储管理

> 知识点：连续内存分配。

采用多道程序设计后，可能（　　　）
- [x] A.缩短对用户请求的响应时间 B.降低了系统资源的利用率 C.缩短了每道程序执行时间 D.延长了每道程序执行时间

> 知识点：进程状态与控制。

操作系统是一种(　　)
- [x] A.系统软件　 B.系统硬件　　 C.应用软件　 D.支援软件

> 知识点：操作系统概述。

把逻辑地址转变为内存的物理地址的过程称作_____ 。
- [x] A.编译 B.连接 C.运行 D.重定位

> 知识点：缺页中断。

哪种设备属于块设备？
- [x] A.键盘 B.磁盘 C.显示器 D.打印机

> 知识点：操作系统概述。

索引式(随机)文件组织的一个主要优点是_____ 。
- [x] A.不需要链接指针 B.能实现物理块的动态分配 C.回收实现比较简单 D.用户存取方便

> 知识点：文件系统。

下面有关选择进程调度算法的准则错误的是
- [ ] A.尽量提高处理器利用率 
- [ ] B.尽可能提高系统吞吐量 
- [x] C.适当增长进程在就绪队列中的等待时间 
- [ ] D.尽快响应交互式用户的请求

> 知识点：处理机调度。
> C

系统为用户提供“虚拟设备”后，能（　　　　　）
- [x] A.提高独占设备的利用率 B.有利于多道程序设计 C.缩短作业的执行时间 D.充分利用外设与CPU并行工作能力 E.提高单位时间内处理作业的能力

> 知识点：操作系统概述。

---

#填空题
1.产生死锁的原因是______________ 和______________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：死锁。

2.实时系统通常采用 方法来提高可靠性。
<textarea rows="5" cols="70"></textarea> 

> 知识点：操作系统概述。
> 双工体制

3.与同一个临界资源相联系的临界区称为________________________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：同步互斥。

4.用户程序调用操作系统有关功能的途径是 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：中断、异常与系统调用。
> 利用系统调用命令

5.可变分区的分配策略有______________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：连续内存分配。

6.有２个同类临界资源，被５个并发进程访问，使用信号量机制实现互斥，则初值为＿＿，信号量值的变化范围为＿＿。
<textarea rows="5" cols="70"></textarea> 

> 知识点：信号量。

7.解决外零头的办法有_________________________________________________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：物理内存管理实验。

8.操作系统的基本特征一般包括：______________ 、共享、虚拟、异步性。
<textarea rows="5" cols="70"></textarea> 

> 知识点：操作系统概述。

9.在操作系统控制下的多个程序的执行顺序和每个程序的执行时间是不确定的，这种现象称为操作系统的______________________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：操作系统概述。

10.进程调度的两种基本方式为______________ 和______________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：进程状态与控制。

11.一般说来，用户程序中所使用的地址是____________________ ,而内存中各存储单元的地址是________________________
；将前者转变为后者的过程称作_______________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：虚拟内存管理实验。

12.系统中有4MB内存，最大有效物理地址为________________ ，如果采用分页管理，页长1KB，全部内存可分为____________ 页帧。
<textarea rows="5" cols="70"></textarea> 

> 知识点：虚拟内存管理实验。

13.操作系统的基本类型有_________________________________________________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：操作系统概述。

14.一般说来，用户程序中所使用的地址是____________________ ,而内存中各存储单元的地址是________________________
；将前者转变为后者的过程称作_______________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：虚拟内存管理实验。

15.分时系统的特征为____________________________________________________ 。
<textarea rows="5" cols="70"></textarea> 

> 知识点：操作系统概述。

#问答题
1.资源分配图：
     第五题：
    一、  （10分）银行家算法(Banker's Algorithm)是一种在资源分配过程中避免出现死锁的算法，资源管理者可以有进程申请资源时，使用银行家算法来判断分配相应资源后是否可能出现死锁。试回答下列问题。
    1）形成死锁的条件是什么？
    2）试用伪代码描述银行家算法。
    3）假设系统中有A、B、C和D这四类资源，有P1、P2和P3这三个进程正在使用这些资源。
    下面某次资源申请后的资源占用情况。请问这个状态是否安全？如果是安全的，请给出一个可能的资源分配和回收序列。
    当前的可用资源情况：
    A B C D
    3 1 1 2
    当前各进程的已分配资源情况：
      A B C D
    P1 1 0 3 3
    P2 1 2 2 1
    P3 1 2 1 0
    各进程声称的最大资源申请情况：
    A B C D
    P1 1 2 3 4
    P2 3 3 2 2
    P3 1 3 5 0
<textarea rows="5" cols="70"></textarea> 

> 知识点：中断、异常与系统调用。

2.在一个页式存储管理系统中，某作业的页表如下表所示。已知页面大小为1024字节，用户区的基址为1000，试将逻辑地址1011、2148、3000、4000、5
012转换为相应的物理地址。  页号| 块号
---|---
0| 2
1| 3
2| 1
3| 6
<textarea rows="5" cols="70"></textarea> 

> 知识点：非连续内存分配。
>     ```
>     页号＝[逻辑地址/页长]
>     页内地址＝逻辑地址 mod 页长
>     物理地址＝块号块长+块内地址+用户区基址
>     1011： 21024+1011+1000＝4059
>     2148： 页号：2    块号：3
>                31024+100+1000＝
>     ```
>     

3."在一个请求分页系统中，分别采用FIFO和 LRU页面置换算法时，假如一个作业的页面访问顺序为4，3，2，1，4，3，5，4，3，2，
l，5，当分配给该作业的物理块数M为4时，试试写出页面访问的过程，并计算访问中所发生的缺页次数和缺页率？"
<textarea rows="5" cols="70"></textarea> 

> 知识点：置换算法。
> (1) FIFO置换算法 页面走向 4 3 2 1 4 3 5 4 3 2 1 5 物理块 4 3 2 1 1 1 5 4 3 2 1 5 4 3 2 2
> 2 1 5 4 3 2 1 4 3 3 3 2 1 5 4 3 2 4 4 4 3 2 1 5 4 3 缺页中断 √ √ √ √ √ √ √ √ √ √
> 用FIFO置换算法产生缺页次数10次 (2) LRU置换算法 页面走向 4 3 2 1 4 3 5 4 3 2 1 5 物理块 4 3 2 1 4 3 5
> 4 3 2 1 5 4 3 2 1 4 3 5 4 3 2 1 4 3 2 1 4 3 5 4 3 2 4 3 2 1 1 1 5 4 3 缺页中断 √ √
> √ √ √ √ √ √ 用LRU置换算法产生缺页次数8次

4.(20140606-期末考试试题&参考答案.docx)文件系统
(12分)uCore实现了一个简单的文件系统Simple FS，假设该文件系统现已经装载到一个硬盘中（disk0）, 该硬盘的大小为20M,
目前有三个文件A.txt,B.txt和C.txt存放在该硬盘中，三个文件的大小分别是48K, 1M和4M。
1）简要描述SFS文件系统中文件数据的组织结构（即：SFS文件的数据的存放位置组织方式）。
2）请根据Simple FS的设计实现情况，画出该文件系统当前在disk0上的布局情况，需要给出相应结构的名称和起始块号。
<textarea rows="5" cols="70"></textarea> 

> 知识点：文件系统实验。
> 1) 一个superblock维护基本信息（1'），多个freemap（数量由分区大小确定，1'），一个根目录inode（1'）；
> 目录和文件均由一个inode和具体数据块组成，其中inode包含文件的基本属性、12个直接索引和一级/二级索引表的块地址（1'），目录的数据块中存放（文件名
> 、inode地址）的数组（1'），文件的数据块中存放文件的具体内容（1'）。
> 2）（除了0、1、2以外，其它块地址均可变，言之有理即可）
> （2分）
> 0 superblock
> 1 根目录inode
> 2 freemap（640K，只需要1块）
> 3 根目录的数据块（包含A.txt、B.txt、C.txt的inode的地址）
> （1分）
> 4 A.txt的inode（包含12个直接索引块的地址）
> 5-16 A.txt的数据块
> （2分）
> 17 B.txt的inode（包含12个直接索引块和1个一级间接索引）
> 18-29 B.txt的直接索引数据
> 30 B.txt的一级间接索引（包含244个数据块地址）
> 31-274 B.txt的一级间接索引块
> （1分）
> 275 C.txt的inode（包含12个直接索引块和1个一级间接索引）
> 276-287 C.txt的一级间接索引块
> 288 C.txt的一级间接索引（包含1012个数据块地址）
> 289-1300 C.txt的一级间接索引块  

5.(20150309_操作系统试题_doc)什么是页式管理？静态页式管理可以实现虚存吗？
<textarea rows="5" cols="70"></textarea> 

> 知识点：非连续内存分配。
>   

6."在一间酒吧里有三个音乐爱好者队列，第一队的音乐爱好者只有随身听，第二队的只有音乐磁带，第三队只有电池。而要听音乐就必须随身听，音乐磁带和电池这三种物品俱全
。酒吧老板依次出售这三种物品中的任意两种。当一名音乐爱好者得到这三种物品并听完一首乐曲后，酒吧老板才能再一次出售这三种物品中的任意两种。于是第二名音乐爱好者
得到这三种物品，并开始听乐曲。全部买卖就这样进行下去。试用P，V操作正确解决这一买卖。"
<textarea rows="5" cols="70"></textarea> 

> 知识点：信号量。
> #include  #include  #include  #include  #include  #define ROUND 10 const char
> GOODS[3][20] = { "Walkman", "Tape", "Battery" }; const char WANT[3][20] = {
> "Tape&amp;Battery;", "Walkman&amp;Battery;", "Walkman&amp;Tape;" }; int
> sema_flag; int condvar_flag; semaphore_t listener[3]; semaphore_t seller;
> struct proc_struct listener_sema_proc[3]; struct proc_struct
> seller_sema_proc; void listener_sema(void arg){ int i = (int) arg;
> while(sema_flag){ down(&amp;listener;[i]); if (sema_flag){ cprintf("No %d
> listener has %s, and bought %s. sema 
> ",i,GOODS[i],WANT[i]);
> up(&amp;seller;); } } cprintf("No %d listener quit! sema
> ",i); } void
> seller_sema(void arg){ int i; int pos; for(i=0;i<ROUND;i ++){ pos = rand() %
> 3; cprintf("Iter %d : Seller is selling: %s. sema 
> ",i,WANT[pos]);
> up(&amp;listener;[pos]); down(&amp;seller;); } sema_flag = 0; for(i = 0;i <
> 3;i ++) up(&amp;listener;[i]); cprintf("Seller quit! sema
> "); } monitor_t
> lmt, mtp2= &amp;lmt; struct proc_struct listener_condvar_proc[3]; struct
> proc_struct seller_condvar_proc; void seller_condvar(void arg){ int i; int
> pos; for(i = 0;i < ROUND;i ++){ down(&amp;mtp2-;>mutex); pos = rand() % 3;
> cprintf("Iter %d : Seller is selling: %s. condvar
> ",i,WANT[pos]);
> cond_signal(&amp;mtp2-;>cv[pos + 1]); cond_wait(&amp;mtp2-;>cv[0]); if
> (mtp2->next_count > 0) up(&amp;mtp2-;>next); else up(&amp;mtp2-;>mutex); }
> condvar_flag = 0; down(&amp;mtp2-;>mutex); for(i = 0;i < 3;i ++)
> cond_signal(&amp;mtp2-;>cv[i + 1]); cprintf("Seller_condvar quit! 
> "); if
> (mtp2->next_count > 0) up(&amp;mtp2-;>next); else up(&amp;mtp2-;>mutex); }
> void listener_condvar(void arg){ int num = (int)arg; down(&amp;mtp2-;>mutex);
> cprintf("No %d listener is waiting
> ", num); cond_wait(&amp;mtp2-;>cv[num+1]);
> if (mtp2->next_count > 0) up(&amp;mtp2-;>next); else up(&amp;mtp2-;>mutex);
> while(condvar_flag){ down(&amp;mtp2-;>mutex); if(condvar_flag){ cprintf("No %d
> listener has %s, and bought %s and is listening music now.condvar
> ",num,GOODS[num],WANT[num]); cond_signal(&amp;mtp2-;>cv[0]);
> cond_wait(&amp;mtp2-;>cv[num + 1]); } if (mtp2->next_count > 0)
> up(&amp;mtp2-;>next); else up(&amp;mtp2-;>mutex); } cprintf("No %d listener
> quit! condvar 
> ",num); } void check_sync(void) {/ 吸烟者问题拓展一（北大1999) / int i,
> pid; //check semaphore sem_init(&amp;seller;, 0); pid =
> kernel_thread(seller_sema, NULL, 0); if (pid <= 0) { panic("create seller_sema
> failed.
> "); } seller_sema_proc = find_proc(pid);
> set_proc_name(seller_sema_proc, "seller_sema_proc"); sema_flag = 1; for(i = 0;
> i < 3; ++i){ sem_init(&amp;listener;[i], 0); pid =
> kernel_thread(listener_sema, (void )i, 0); if (pid <= 0) { panic("create
> No.%d listener_sema failed.
> ", i); } listener_sema_proc[i] = find_proc(pid);
> set_proc_name(listener_sema_proc[i], "listener_sema_proc"); } //check
> condition variable monitor_init(&amp;lmt;, 4); pid =
> kernel_thread(seller_condvar, NULL, 0); if (pid <= 0) { panic("create
> seller_condvar failed.
> "); } seller_condvar_proc = find_proc(pid);
> set_proc_name(seller_condvar_proc, "seller_condvar_proc"); condvar_flag = 1;
> for(i = 0; i < 3; ++i){ pid = kernel_thread(listener_condvar, (void )i, 0);
> if (pid <= 0) { panic("create No.%d listener_condvar failed.
> "); }
> listener_condvar_proc[i] = find_proc(pid);
> set_proc_name(listener_condvar_proc[i], "listener_condvar_proc"); } }

7."设P,Q,R共享一个缓冲区,P,Q构成一对生产者-消费者,R既为生产者又为消费?者。使用P,V 实现其同步。"
<textarea rows="5" cols="70"></textarea> 

> 知识点：信号量。
> Semaphore 方法 设置三个信号量：full(itemCounter)、empty(vacancyCounter)和mutex。
> full表示有数据的缓冲块数目，初值是0；empty表示空的缓冲块数初值是n；mutex用于访问缓冲区时的互斥，初值是1。
> 三种进程，consumer,producer,both，both表示既是producer又是consumer。 producer 伪码 while true
> p(empty); P(mutex); produce one; v(mutex); v(full); end while consumer 伪码
> while true p(full); P(mutex); consume one; v(mutex); v(empty); end while both
> 伪码 if empty>=1 then begin p(empty); p(mutex); product one; v(mutex); v(full);
> end if full>=1 then begin p(full); p(mutex); consume one; v(mutex); v(empty);
> end Monitor 方法
> 设置一个monitor，内有两个条件变量：notFull和notEmpty。其中，notFull表示缓存满，notEmpty表示缓存空 producer
> 伪码 lock.Acquire(); while (count == n) notFull.Wait(&amp;lock;); produce one;
> count++; notEmpty.Signal(); end while lock.Release(); consumer 伪码
> lock.Acquire(); while (count == 0); notEmpty.Wait(&amp;lock;); consume one;
> count--; notFull.Signal(); end while lock.Release(); both 伪码 lock.Acquire();
> notEmpty.Wait(&amp;lock;); consume one; count--; notFull.Signal();
> notFull.Wait(&amp;lock;); produce one; count++; notEmpty.Signal();
> lock.Release();

8."1）描述伙伴系统（Buddy System）中对物理内存的分配和回收过程。2）假定一个操作系统内核中由伙伴系统管理的物理内存有1MB，试描述按下面顺序进行
物理内存分配和回收过程中，每次分配完成后的分配区域的首地址和大小，或每次回收完成后的空闲区域队列（要求说明，每个空闲块的首地址和大小）。建议给出分配和回收的
中间过程。 a) 进程A申请50KB； b) 进程B申请100KB； c) 进程C申请40KB； d) 进程D申请70KB； e) 进程B释放100KB；
f) 进程E申请127KB； g) 进程D释放70KB； h) 进程A释放50KB； i) 进程E释放127KB； j) 进程C释放40KB；"
<textarea rows="5" cols="70"></textarea> 

> 知识点：连续内存分配。
>  整个空间被分成2U大小；（2分）  分配：找到2U大小的块，  满足2U-1 < s <= 2U（2分）  如果比它大，就划分成两个等大小的块（2分） 释放：相邻且大小相同2U-1的两块中第一块起始地址为2U倍数（2分）时，合并（2分）； a) 进程A申请50KB；Addr:0,Size:64KB b) 进程B申请100KB；Addr:128K,Size:128KB c) 进程C申请40KB；Addr:64K,Size:64KB d) 进程D申请70KB；Addr:256K,Size:128KB e) 进程B释放100KB；Addr:128K,Size:128KB f) 进程E申请127KB；Addr:128K,Size:128KB g) 进程D释放70KB；Addr:256K,Size:512KB h) 进程A释放50KB；Addr:0,Size:64KB i) 进程E释放127KB；Addr:128K,Size:128KB j) 进程C释放40KB；Addr:0,Size:1024KB

9."1）试用图示描述32位X86系统在采用4KB页面大小时的虚拟地址结构和地址转换过程。2）在采用4KB页面大小的32位X86的ucore虚拟存储系统中，进程
页面的起始地址由宏VPT确定。 #define VPT 0x0D000000
请计算：2a)试给出页目录中自映射页表项的虚拟地址；2b)虚拟地址0X87654321对应的页目录项和页表项的虚拟地址。"
<textarea rows="5" cols="70"></textarea> 

> 知识点：非连续内存分配。
> 1）（12分）地址划分：10＋10＋12（6分）
> 地址转换过程关键点：两级页面（2分）、缺页处理（2分）（分配物理页面、更新页表项、重新访问）（有一个就给2分） 2a）（4分） 自映射页表项地址4分
> 每个地址3分，每个地址中的三段，二进制每段1分；（结果对了，就给全分） 0D00 0000 0000 1101 0000 0000 0000 0000
> 0000 0000 0000 1101 0000 0011 0100 0000 1101 0000 0X0D0340D0 2b）
> 虚拟地址0X87654321对应的页目录项和页表项的虚拟地址（4分,每个2分，二进制对，就给全分） 87654321 1000 0111 0110 0101
> 0100 0011 0010 0001 PDE: 0000 1101 0000 0011 0100 1000 0111 01 00 0X0D034874
> PTE: 0000 1101 00 10 00 01 11 01 10 01 01 01 00 00 0X0D21 D950

10.1）系统调用接口是操作系统内核向用户进程提供操作系统服务的接口。试描述用户进程通过系统调用使用操作系统服务的过程。2）gettime_msec是一个获取当前
系统时间的系统调用。请补全该系统调用的实现代码。
    ```
	    =============libs-user-ucore/ulib.c=============
	    unsigned int
	    gettime_msec(void) {
	        return (unsigned int)sys_gettime();
	    }
	    =============libs-user-ucore/syscall.c=============
	    size_t
	    sys_gettime(void) {
	        return (size_t) _--YOUR CODE 4--_;
	    }
	    =============libs-user-ucore/arch/i386/syscall.c=============
	    #define MAX_ARGS            5
	    uint32_t
	    syscall(int num, ...) {
	        va_list ap;
	        va_start(ap, num);
	        uint32_t a[MAX_ARGS];
	        int i;
	        for (i = 0; i < MAX_ARGS; i ++) {
	            a[i] = va_arg(ap, uint32_t);
	        }
	        va_end(ap);
	        uint32_t ret;
	        asm volatile (
	            "int %1;"
	            : "=a" (ret)
	            : "i" (T_SYSCALL),
	              "a" (num),
	              "d" (a[0]),
	              "c" (a[1]),
	              "b" (a[2]),
	              "D" (a[3]),
	              "S" (a[4])
	            : "cc", "memory");
	        return ret;
	    }
	    =============libs-user-ucore/common/unistd.h=============
	    / syscall number /
	    #define SYS_exit            1
	    #define SYS_fork            2
	    #define SYS_wait            3
	    #define SYS_exec            4
	    #define SYS_clone           5
	    #define SYS_exit_thread     9
	    #define SYS_yield           10
	    #define SYS_sleep           11
	    #define SYS_kill            12
	    #define SYS_gettime         17
	    #define SYS_getpid          18
	    #define SYS_brk             19
	    ……
	    =============kern-ucore/arch/i386/glue-ucore/trap.c=============
	    static void
	    trap_dispatch(struct trapframe tf) {
	        char c;
	        int ret;
	        switch (tf->tf_trapno) {
	        case T_DEBUG:
	        case T_BRKPT:
	            debug_monitor(tf);
	            break;
	        case T_PGFLT:
	            if ((ret = pgfault_handler(tf)) != 0) {
	                print_trapframe(tf);
	                if (pls_read(current) == NULL) {
	                    panic("handle pgfault failed. %e
	", ret);
	                }
	                else {
	                    if (trap_in_kernel(tf)) {
	                        panic("handle pgfault failed in kernel mode. %e
	", ret);
	                    }
	                    kprintf("killed by kernel.
	");
	                    do_exit(-E_KILLED);
	                }
	            }
	            break;
	        case T_SYSCALL:
	            _--YOUR CODE 5--_;
	            break;
	        case IRQ_OFFSET + IRQ_TIMER:
	            ticks ++;
	            assert(pls_read(current) != NULL);
	            run_timer_list();
	            break;
	        case IRQ_OFFSET + IRQ_COM1:
	        case IRQ_OFFSET + IRQ_KBD:
	            if ((c = cons_getc()) == 13) {
	                debug_monitor(tf);
	            }
	            else {
	                extern void dev_stdin_write(char c);
	                dev_stdin_write(c);
	            }
	            break;
	        case IRQ_OFFSET + IRQ_IDE1:
	        case IRQ_OFFSET + IRQ_IDE2:
	            / do nothing /
	            break;
	        default:
	            print_trapframe(tf);
	            if (pls_read(current) != NULL) {
	                kprintf("unhandled trap.
	");
	                do_exit(-E_KILLED);
	            }
	            panic("unexpected trap in kernel.
	");
	        }
	    }
	    void
	    trap(struct trapframe tf) {
	        // used for previous projects
	        if (pls_read(current) == NULL) {
	            trap_dispatch(tf);
	        }
	        else {
	            // keep a trapframe chain in stack
	            struct trapframe otf = pls_read(current)->tf;
	            pls_read(current)->tf = tf;
	            bool in_kernel = trap_in_kernel(tf);
	            _--YOUR CODE 6--_;
	            pls_read(current)->tf = otf;
	            if (!in_kernel) {
	                may_killed();
	                if (pls_read(current)->need_resched) {
	                    schedule();
	                }
	            }
	        }
	    }
	    =============kern-ucore/arch/i386/syscall/syscall.c=============
	    ……
	    static uint32_t
	    sys_gettime(uint32_t arg[]) {
	        return (int)ticks;
	    }
	    ……
	    static uint32_t (syscalls[])(uint32_t arg[]) = {
	        [SYS_exit]              sys_exit,
	        [SYS_fork]              sys_fork,
	        [SYS_wait]              sys_wait,
	        [SYS_exec]              sys_exec,
	        [SYS_clone]             sys_clone,
	        [SYS_exit_thread]       sys_exit_thread,
	        [SYS_yield]             sys_yield,
	        [SYS_kill]              sys_kill,
	        [SYS_sleep]             sys_sleep,
	        [SYS_gettime]           _--YOUR CODE 7--_,
	        [SYS_getpid]            sys_getpid,
	    ……
	    };
	    #define NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))
	    void
	    syscall(void) {
	        struct trapframe tf = pls_read(current)->tf;
	        uint32_t arg[5];
	        int num = tf->tf_regs.reg_eax;
	        if (num >= 0 && num < NUM_SYSCALLS) {
	            if (syscalls[num] != NULL) {
	                arg[0] = tf->tf_regs.reg_edx;
	                arg[1] = tf->tf_regs.reg_ecx;
	                arg[2] = tf->tf_regs.reg_ebx;
	                arg[3] = tf->tf_regs.reg_edi;
	                arg[4] = tf->tf_regs.reg_esi;
	                tf->tf_regs.reg_eax = _--YOUR CODE 8--_;
	                return ;
	            }
	        }
	        print_trapframe(tf);
	        panic("undefined syscall %d, pid = %d, name = %s.
	",
	                num, pls_read(current)->pid, pls_read(current)->name);
	    }
	    ```
<textarea rows="5" cols="70"></textarea> 

> 知识点：中断、异常与系统调用。
> 1）系统调用的过程：（8分，每个关键词1分）
> 1.准备参数和系统调用号；2. 执行系统中断；3. CPU响应中断，并依据中断号找到系统调用处理例程；4.
> 系统调用处理例程依据系统调用号找到对应系统调用实现代码；5.获取系统调用参数；6.
> 执行系统调用功能7.准备返回结果；8.执行中断返回到用户态；9.获取返回结果；
> 2）（10分，每个空2分）
>     ```
>         return (size_t) _--YOUR CODE 4--_;
>         return (size_t)syscall(SYS_gettime);//必须有参数
>             _--YOUR CODE 5--_;
>     syscall();//不能有参数
>             _--YOUR CODE 6--_;
>     trap_dispatch(tf);
>         [SYS_gettime]           _--YOUR CODE 7--_,
>     [SYS_gettime]           sys_gettime,
>                 tf->tf_regs.reg_eax = _--YOUR CODE 8--_;
>     tf->tf_regs.reg_eax = syscalls[num](arg);
>     ```
>     

