{
    "status":"ok",
    "knowledge":[
        "置换算法"
    ],
    "degree_of_difficulty":1,
    "explain":"算法：（4分）占用页面按置换时间先后排序；缺页时置换最先进入内存的页面； 实现： map_swappable() //record the page\naccess situlation /LAB3 EXERCISE 2: YOUR CODE/ //(1)link the most recent\narrival page at the back of the pra_list_head qeueue. list_add(head, entry);//\n（3分） swap_out_victim() / Select the victim / /LAB3 EXERCISE 2: YOUR CODE/\n//(1) unlink the earliest arrival page in front of pra_list_head qeueue //(2)\nset the addr of addr of this page to ptr_page / Select the tail /\nlist_entry_t le = head->prev; // 找到链表尾（2分） assert(head!=le); struct Page p =\nle2page(le, pra_page_link); //找到物理页面数据结构，并保存 （2分） list_del(le); //\n从链表中取出页面（2分） assert(p !=NULL); ptr_page = p; //返回被置换的物理页面数据结构指针 （2分） return\n0;\n",
    "question":"\"试描述FIFO页面替换算法的基本原理，并swap_fifo.c中未完成FIFA页面替换算法实验函数map_swappable()和swap_out_vic\ntim() 。 =============Defs.h (libs)============= /   to_struct - get the\nstruct from a ptr  @ptr: a struct pointer of member  @type: the type of the\nstruct this is embedded in  @member: the name of the member within the struct\n / #define to_struct(ptr, type, member) \\ ((type )((char )(ptr) -\noffsetof(type, member))) =============Memlayout.h (kern\\mm)============= //\nconvert list entry to page #define le2page(le, member) \\ to_struct((le),\nstruct Page, member) =============List.h (libs)============= #ifndef\n__LIBS_LIST_H__ #define __LIBS_LIST_H__ #ifndef __ASSEMBLER__ #include  /  \nSimple doubly linked list implementation.   Some of the internal functions\n(\"__xxx\") are useful when manipulating  whole lists rather than single\nentries, as sometimes we already know  the next/prev entries and we can\ngenerate better code by using them  directly rather than using the generic\nsingle-entry routines.  / struct list_entry { struct list_entry prev,\nnext; }; typedef struct list_entry list_entry_t; static inline void\nlist_init(list_entry_t elm) __attribute__((always_inline)); static inline\nvoid list_add(list_entry_t listelm, list_entry_t elm)\n__attribute__((always_inline)); static inline void\nlist_add_before(list_entry_t listelm, list_entry_t elm)\n__attribute__((always_inline)); static inline void list_add_after(list_entry_t\nlistelm, list_entry_t elm) __attribute__((always_inline)); static inline\nvoid list_del(list_entry_t listelm) __attribute__((always_inline)); static\ninline void list_del_init(list_entry_t listelm)\n__attribute__((always_inline)); static inline bool list_empty(list_entry_t\nlist) __attribute__((always_inline)); static inline list_entry_t\nlist_next(list_entry_t listelm) __attribute__((always_inline)); static\ninline list_entry_t list_prev(list_entry_t listelm)\n__attribute__((always_inline)); static inline void __list_add(list_entry_t\nelm, list_entry_t prev, list_entry_t next) __attribute__((always_inline));\nstatic inline void __list_del(list_entry_t prev, list_entry_t next)\n__attribute__((always_inline)); /   list_init - initialize a new entry \n@elm: new entry to be initialized  / static inline void\nlist_init(list_entry_t elm) { elm->prev = elm->next = elm; } /   list_add\n- add a new entry  @listelm: list head to add after  @elm: new entry to be\nadded   Insert the new element @elm after the element @listelm which  is\nalready in the list.  / static inline void list_add(list_entry_t listelm,\nlist_entry_t elm) { list_add_after(listelm, elm); } /   list_add_before -\nadd a new entry  @listelm: list head to add before  @elm: new entry to be\nadded   Insert the new element @elm before the element @listelm which  is\nalready in the list.  / static inline void list_add_before(list_entry_t\nlistelm, list_entry_t elm) { __list_add(elm, listelm->prev, listelm); } / \n list_add_after - add a new entry  @listelm: list head to add after  @elm:\nnew entry to be added   Insert the new element @elm after the element\n@listelm which  is already in the list.  / static inline void\nlist_add_after(list_entry_t listelm, list_entry_t elm) { __list_add(elm,\nlistelm, listelm->next); } /   list_del - deletes entry from list \n@listelm: the element to delete from the list   Note: list_empty() on\n@listelm does not return true after this, the entry is  in an undefined\nstate.  / static inline void list_del(list_entry_t listelm) {\n__list_del(listelm->prev, listelm->next); } /   list_del_init - deletes\nentry from list and reinitialize it.  @listelm: the element to delete from\nthe list.   Note: list_empty() on @listelm returns true after this.  /\nstatic inline void list_del_init(list_entry_t listelm) { list_del(listelm);\nlist_init(listelm); } /   list_empty - tests whether a list is empty \n@list: the list to test.  / static inline bool list_empty(list_entry_t\nlist) { return list->next == list; } /   list_next - get the next entry \n@listelm: the list head / static inline list_entry_t \nlist_next(list_entry_t listelm) { return listelm->next; } /   list_prev -\nget the previous entry  @listelm: the list head / static inline\nlist_entry_t  list_prev(list_entry_t listelm) { return listelm->prev; } / \n Insert a new entry between two known consecutive entries.   This is only\nfor internal list manipulation where we know  the prev/next entries already!\n / static inline void __list_add(list_entry_t elm, list_entry_t prev,\nlist_entry_t next) { prev->next = next->prev = elm; elm->next = next;\nelm->prev = prev; } /   Delete a list entry by making the prev/next entries\npoint to each other.   This is only for internal list manipulation where we\nknow  the prev/next entries already!  / static inline void\n__list_del(list_entry_t prev, list_entry_t next) { prev->next = next;\nnext->prev = prev; } #endif / !__ASSEMBLER__ / #endif / !__LIBS_LIST_H__ /\n============= Swap_fifo.c (kern\\mm)============= #include  #include  #include\n\\#include  #include  #include  #include  / [wikipedia]The simplest Page\nReplacement Algorithm(PRA) is a FIFO algorithm.  (1) Prepare: In order to\nimplement FIFO PRA, we should manage all swappable pages, so we can  link\nthese pages into pra_list_head according the time order. At first you should \nbe familiar to the struct list in list.h. struct list is a simple doubly\nlinked list  implementation. You should know howto USE: list_init,\nlist_add(list_add_after),  list_add_before, list_del, list_next, list_prev.\nAnother tricky method is to transform  a general list struct to a special\nstruct (such as struct page). You can find some MACRO:  le2page (in\nmemlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in proc.h),etc. /\nlist_entry_t pra_list_head; /  (2) _fifo_init_mm: init pra_list_head and let\nmm->sm_priv point to the addr of pra_list_head.  Now, From the memory control\nstruct mm_struct, we can access FIFO PRA / static int _fifo_init_mm(struct\nmm_struct mm) { list_init(&amp;pra;_list_head); mm->sm_priv =\n&amp;pra;_list_head; //cprintf(\" mm->sm_priv %x in\nfifo_init_mm\n\",mm->sm_priv); return 0; } /  (3)_fifo_map_swappable:\nAccording FIFO PRA, we should link the most recent arrival page at the back of\npra_list_head qeueue / static int _fifo_map_swappable(struct mm_struct mm,\nuintptr_t addr, struct Page page, int swap_in) { list_entry_t\nhead=(list_entry_t) mm->sm_priv; list_entry_t entry=&(page->pra_page_link);\nassert(entry != NULL && head != NULL); //record the page access situlation\n/LAB3 EXERCISE 2: YOUR CODE/ //(1)link the most recent arrival page at the\nback of the pra_list_head qeueue. ===Your code 2=== return 0; } / \n(4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the earliest\narrival page in front of pra_list_head qeueue,  then set the addr of addr of\nthis page to ptr_page. / static int _fifo_swap_out_victim(struct mm_struct\nmm, struct Page  ptr_page, int in_tick) { list_entry_t\nhead=(list_entry_t) mm->sm_priv; assert(head != NULL); assert(in_tick==0);\n/ Select the victim / /LAB3 EXERCISE 2: YOUR CODE/ //(1) unlink the\nearliest arrival page in front of pra_list_head qeueue //(2) set the addr of\naddr of this page to ptr_page / Select the tail / ===Your code 3=== return\n0; } static int _fifo_check_swap(void) { cprintf(\"write Virt Page c in\nfifo_check_swap\n\"); (unsigned char )0x3000 = 0x0c; assert(pgfault_num==4);\ncprintf(\"write Virt Page a in fifo_check_swap\n\"); (unsigned char )0x1000 =\n0x0a; assert(pgfault_num==4); cprintf(\"write Virt Page d in\nfifo_check_swap\n\"); (unsigned char )0x4000 = 0x0d; assert(pgfault_num==4);\ncprintf(\"write Virt Page b in fifo_check_swap\n\"); (unsigned char )0x2000 =\n0x0b; assert(pgfault_num==4); cprintf(\"write Virt Page e in\nfifo_check_swap\n\"); (unsigned char )0x5000 = 0x0e; assert(pgfault_num==5);\ncprintf(\"write Virt Page b in fifo_check_swap\n\"); (unsigned char )0x2000 =\n0x0b; assert(pgfault_num==5); cprintf(\"write Virt Page a in\nfifo_check_swap\n\"); (unsigned char )0x1000 = 0x0a; assert(pgfault_num==6);\ncprintf(\"write Virt Page b in fifo_check_swap\n\"); (unsigned char )0x2000 =\n0x0b; assert(pgfault_num==7); cprintf(\"write Virt Page c in\nfifo_check_swap\n\"); (unsigned char )0x3000 = 0x0c; assert(pgfault_num==8);\ncprintf(\"write Virt Page d in fifo_check_swap\n\"); (unsigned char )0x4000 =\n0x0d; assert(pgfault_num==9); return 0; } static int _fifo_init(void) { return\n0; } static int _fifo_set_unswappable(struct mm_struct mm, uintptr_t addr) {\nreturn 0; } static int _fifo_tick_event(struct mm_struct mm) { return 0; }\nstruct swap_manager swap_manager_fifo = { .name = \"fifo swap manager\", .init =\n&_fifo_init, .init_mm = &_fifo_init_mm, .tick_event = &_fifo_tick_event,\n.map_swappable = &_fifo_map_swappable, .set_unswappable =\n&_fifo_set_unswappable, .swap_out_victim = &_fifo_swap_out_victim, .check_swap\n= &_fifo_check_swap, }; \"\n",
    "source":"网络",
    "answer":"算法：（4分）占用页面按置换时间先后排序；缺页时置换最先进入内存的页面； 实现： map_swappable() //record the page\naccess situlation /LAB3 EXERCISE 2: YOUR CODE/ //(1)link the most recent\narrival page at the back of the pra_list_head qeueue. list_add(head, entry);//\n（3分） swap_out_victim() / Select the victim / /LAB3 EXERCISE 2: YOUR CODE/\n//(1) unlink the earliest arrival page in front of pra_list_head qeueue //(2)\nset the addr of addr of this page to ptr_page / Select the tail /\nlist_entry_t le = head->prev; // 找到链表尾（2分） assert(head!=le); struct Page p =\nle2page(le, pra_page_link); //找到物理页面数据结构，并保存 （2分） list_del(le); //\n从链表中取出页面（2分） assert(p !=NULL); ptr_page = p; //返回被置换的物理页面数据结构指针 （2分） return\n0;\n",
    "type":"question_answer",
    "q_number":1011
}