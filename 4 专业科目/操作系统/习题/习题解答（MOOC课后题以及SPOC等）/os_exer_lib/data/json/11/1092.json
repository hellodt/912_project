{
    "status":"ok",
    "knowledge":[
        "进程状态与控制"
    ],
    "degree_of_difficulty":1,
    "explain":"1）fork()系统调用的执行过程： 进程通过调用fork（）进入内核，在内核完成子进程的复制（2分）后，放入就绪队列；父进程返回子进程的标识（2分）；子进\n程在调度执行时返回用户态，返回值为0（2分），从fork（）后的指令开始子进程的执行（1分）； 2）\n    ```\n        proc->parent = _--YOUR CODE 13--_;\n     proc->parent = current; （1分）\n            proc->pid = _--YOUR CODE 14--_;\n    proc->pid = get_pid();//分配新标识（2分）\n        ret = _--YOUR CODE 15--_;\n       ret = proc->pid;//返回子进程标识；（2分）\n        proc->context.eip = (uintptr_t) _--YOUR CODE 16--_;\n    proc->context.rip = (uintptr_t)forkret;//IP指向forkret （2分）\n    ```\n\n",
    "question":"1）试描述ucore的进程创建系统调用fork（）的基本过程。2）请补全fork系统调用的实现代码。\n    ```\n\t    =============kern-ucore/process/proc.c=============\n\t    // get_pid - alloc a unique pid for process\n\t    static int\n\t    get_pid(void) {\n\t    ……\n\t    }\n\t    ……\n\t    int\n\t    do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe tf) {\n\t        int ret = -E_NO_FREE_PROC;\n\t        struct proc_struct proc;\n\t        if (nr_process >= MAX_PROCESS) {\n\t            goto fork_out;\n\t        }\n\t        ret = -E_NO_MEM;\n\t        if ((proc = alloc_proc()) == NULL) {\n\t            goto fork_out;\n\t        }\n\t        proc->parent = _--YOUR CODE 13--_;\n\t        list_init(&(proc->thread_group));\n\t        assert(current->wait_state == 0);\n\t        assert(current->time_slice >= 0);\n\t        proc->time_slice = current->time_slice / 2;\n\t        current->time_slice -= proc->time_slice;\n\t        if (setup_kstack(proc) != 0) {\n\t            goto bad_fork_cleanup_proc;\n\t        }\n\t        if (copy_sem(clone_flags, proc) != 0) {\n\t            goto bad_fork_cleanup_kstack;\n\t        }\n\t        if (copy_fs(clone_flags, proc) != 0) {\n\t            goto bad_fork_cleanup_sem;\n\t        }\n\t        if (copy_mm(clone_flags, proc) != 0) {\n\t            goto bad_fork_cleanup_fs;\n\t        }\n\t        if (copy_thread(clone_flags, proc, stack, tf) != 0) {\n\t            goto bad_fork_cleanup_sem;\n\t        }\n\t        bool intr_flag;\n\t        local_intr_save(intr_flag);\n\t        {\n\t            proc->pid = _--YOUR CODE 14--_;\n\t            hash_proc(proc);\n\t            set_links(proc);\n\t            if (clone_flags & CLONE_THREAD) {\n\t                list_add_before(&(current->thread_group), &(proc->thread_group));\n\t            }\n\t        }\n\t        local_intr_restore(intr_flag);\n\t        wakeup_proc(proc);\n\t        ret = _--YOUR CODE 15--_;\n\t    fork_out:\n\t        return ret;\n\t    bad_fork_cleanup_fs:\n\t        put_fs(proc);\n\t    bad_fork_cleanup_sem:\n\t        put_sem_queue(proc);\n\t    bad_fork_cleanup_kstack:\n\t        put_kstack(proc);\n\t    bad_fork_cleanup_proc:\n\t        kfree(proc);\n\t        goto fork_out;\n\t    }\n\t    =============kern-ucore/arch/i386/process/proc.c=============\n\t    // forkret -- the first kernel entry point of a new thread/process\n\t    // NOTE: the addr of forkret is setted in copy_thread function\n\t    //       after switch_to, the current proc will execute here.\n\t    static void\n\t    forkret(void) {\n\t        forkrets(pls_read(current)->tf);\n\t    }\n\t    ……\n\t    // copy_thread - setup the trapframe on the  process's kernel stack top and\n\t    //             - setup the kernel entry point and stack of process\n\t    int\n\t    copy_thread(uint32_t clone_flags, struct proc_struct proc,\n\t                uintptr_t esp, struct trapframe tf) {\n\t        proc->tf = (struct trapframe )(proc->kstack + KSTACKSIZE) - 1;\n\t        (proc->tf) = tf;\n\t        proc->tf->tf_regs.reg_eax = 0;\n\t        proc->tf->tf_esp = esp;\n\t        proc->tf->tf_eflags |= FL_IF;\n\t        proc->context.eip = (uintptr_t) _--YOUR CODE 16--_;\n\t        proc->context.esp = (uintptr_t)(proc->tf);\n\t        return 0;\n\t    }\n\t    ```\n    \n",
    "source":"网络",
    "answer":"1）fork()系统调用的执行过程： 进程通过调用fork（）进入内核，在内核完成子进程的复制（2分）后，放入就绪队列；父进程返回子进程的标识（2分）；子进\n程在调度执行时返回用户态，返回值为0（2分），从fork（）后的指令开始子进程的执行（1分）； 2）\n    ```\n        proc->parent = _--YOUR CODE 13--_;\n     proc->parent = current; （1分）\n            proc->pid = _--YOUR CODE 14--_;\n    proc->pid = get_pid();//分配新标识（2分）\n        ret = _--YOUR CODE 15--_;\n       ret = proc->pid;//返回子进程标识；（2分）\n        proc->context.eip = (uintptr_t) _--YOUR CODE 16--_;\n    proc->context.rip = (uintptr_t)forkret;//IP指向forkret （2分）\n    ```\n\n",
    "type":"question_answer",
    "q_number":1092
}