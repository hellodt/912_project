{
    "status":"ok",
    "knowledge":[
        "同步互斥"
    ],
    "degree_of_difficulty":1,
    "explain":"三个信号量，共13分（初值1分，共3分；两对mutex，每对2分；两对\nrcount_mutex，每对1分；两对waiter_mutex，每对2分）；计数变量2分（条件1分，加一和减一1分）；\n只会配对使用PV原语，给4分；\n    ```\n    var\n    waiter_mutex, mutex, rcount_mutex:semaphore;\n    reader_counter:integer;\n    waiter_mutex,mutex,rcount_mutex:=1;\n    reader_counter:=0;\n    cobegin\n    Procedure Reader\n    begin\n    while TRUE\n    {\n    p(waiter_mutex);\n    p(rcount_mutex); (没有这一句会导致reader_counter读和写冲突)\n    if reader_counter ==0 then\n    p(mutex);\n    reader_counter:=reader_counter+1;\n    v(rcount_mutex);\n    v(waiter_mutex);\n    Reading;\n    p(rcount_mutex);\n    reader_counter:=reader_counter-1;\n    if reader_counter==0 then\n    v(mutex);\n    v(rcount_mutex);\n    };\n    end\n    Procedure Writer\n    begin\n    while TRUE\n    {\n    p(waiter_mutex);\n    p(mutex);\n    Writing;\n    v(mutex);\n    v(waiter_mutex);（这一句放在Writing的前面好像也行。我不确信。）\n    }\n    coend\n    ```\n\n",
    "question":"(15分)公平的读者-写者（Reader-Writer\nProblem）问题是指，多个读者进程（Reader）与多个写者进程（Writer）共享一个数据区；读者进程和写者进程对共享数据区的访问满足下列条件。\n1）多个读者进程可以同时对共享数据区进行访问；\n2）多个写者进程只能对共享数据区进行互斥访问；\n3）读者进程与写者进程只能对共享数据区进行互斥访问；\n4）当有写者进程等待时，其后到达的读者进程不能先于该写者进程对共享数据区进行访问；\n5）当有读者进程等待时，其后到达的写者进程不能先于该读者进程对共享数据区进行访问；\n试用信号量机制实现读者进程Reader（）和写者进程\nWriter（）。要求：用信号量方法（不允许使用信号量集），并给出信号量定义和初始值；在代码中要有适当的注释，以说明信号量定义的作用和代码的含义；用类 C\n语言描述共享变量和函数。\n",
    "source":"网络",
    "answer":"三个信号量，共13分（初值1分，共3分；两对mutex，每对2分；两对\nrcount_mutex，每对1分；两对waiter_mutex，每对2分）；计数变量2分（条件1分，加一和减一1分）；\n只会配对使用PV原语，给4分；\n    ```\n    var\n    waiter_mutex, mutex, rcount_mutex:semaphore;\n    reader_counter:integer;\n    waiter_mutex,mutex,rcount_mutex:=1;\n    reader_counter:=0;\n    cobegin\n    Procedure Reader\n    begin\n    while TRUE\n    {\n    p(waiter_mutex);\n    p(rcount_mutex); (没有这一句会导致reader_counter读和写冲突)\n    if reader_counter ==0 then\n    p(mutex);\n    reader_counter:=reader_counter+1;\n    v(rcount_mutex);\n    v(waiter_mutex);\n    Reading;\n    p(rcount_mutex);\n    reader_counter:=reader_counter-1;\n    if reader_counter==0 then\n    v(mutex);\n    v(rcount_mutex);\n    };\n    end\n    Procedure Writer\n    begin\n    while TRUE\n    {\n    p(waiter_mutex);\n    p(mutex);\n    Writing;\n    v(mutex);\n    v(waiter_mutex);（这一句放在Writing的前面好像也行。我不确信。）\n    }\n    coend\n    ```\n\n",
    "type":"question_answer",
    "q_number":1064
}