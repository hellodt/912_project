{
    "status":"ok",
    "knowledge":[
        "连续内存分配"
    ],
    "degree_of_difficulty":1,
    "explain":"1)\n![](files/attach/images/content/20150326/14273449548411.jpg)\n分配：1）把用户要求的大小转成_2的幂_（1分）；2）从空闲数组对应大小开始向大的方向找，直到_有比需要大小不小的空闲块_（1分）；3）如果比需要的大，_切\n半_（2分）后留下一个，另一个_放入空闲数组_（1分）；直到得到一个需要大小的块；\n回收：1）回收块_按地址顺序_（1分）放入对应大小的空闲链；2）与相邻空闲块进行可能的合并（1分），合并条件：_相邻_（1分）且小地址的那一块的起始地址是_\n当前块大小的2倍的整数倍_（2分）；\n只画图，没有描述的，给4分；\n2)8分，每个空2分；\n    ```\n                _--YOUR CODE 9--_(le);\n    list_del(le);\n                    _--YOUR CODE 10--_(&free;_list(cur_order), &(buddy->page_link));\n    list_add(&free;_list(cur_order), &(buddy->page_link));\n            _--YOUR CODE 11--_(&(buddy->page_link));\n    list_del(&(buddy->page_link));\n        _--YOUR CODE 12--_(&free;_list(order), &(page->page_link));\n    list_add(&free;_list(order), &(page->page_link));\n    ```\n\n",
    "question":"1）试利用图示描述伙伴系统（Buddy System）中对物理内存的分配和回收过程。2）请补全下面伙伴系统实现中所缺的代码。\n    ```\n\t    =============kern-ucore/arch/i386/mm/buddy_pmm.c=============\n\t    // {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}\n\t    // from 2^0 ~ 2^10\n\t    #define MAX_ORDER 10\n\t    static free_area_t free_area[MAX_ORDER + 1];\n\t    //x from 0 ~ MAX_ORDER\n\t    #define free_list(x) (free_area[x].free_list)\n\t    #define nr_free(x) (free_area[x].nr_free)\n\t    #define MAX_ZONE_NUM 10\n\t    struct Zone {\n\t        struct Page mem_base;\n\t    } zones[MAX_ZONE_NUM] = {{NULL}};\n\t    //buddy_init - init the free_list(0 ~ MAX_ORDER) & reset nr_free(0 ~ MAX_ORDER)\n\t    static void\n\t    buddy_init(void) {\n\t        int i;\n\t        for (i = 0; i <= MAX_ORDER; i ++) {\n\t            list_init(&free;_list(i));\n\t            nr_free(i) = 0;\n\t        }\n\t    }\n\t    //buddy_init_memmap - build free_list for Page base follow  n continuing pages.\n\t    static void\n\t    buddy_init_memmap(struct Page base, size_t n) {\n\t    ……\n\t    }\n\t    //getorder - return order, the minmal 2^order >= n\n\t    static inline size_t\n\t    getorder(size_t n) {\n\t        size_t order, order_size;\n\t        for (order = 0, order_size = 1; order <= MAX_ORDER; order ++, order_size <<= 1) {\n\t            if (n <= order_size) {\n\t                return order;\n\t            }\n\t        }\n\t        panic(\"getorder failed. %d\n\t\", n);\n\t    }\n\t    //buddy_alloc_pages_sub - the actual allocation implimentation, return a page whose size >=n,\n\t    //                      - the remaining free parts insert to other free list\n\t    static inline struct Page \n\t    buddy_alloc_pages_sub(size_t order) {\n\t        assert(order <= MAX_ORDER);\n\t        size_t cur_order;\n\t        for (cur_order = order; cur_order <= MAX_ORDER; cur_order ++) {\n\t            if (!list_empty(&free;_list(cur_order))) {\n\t                list_entry_t le = list_next(&free;_list(cur_order));\n\t                struct Page page = le2page(le, page_link);\n\t                nr_free(cur_order) --;\n\t                _--YOUR CODE 9--_(le);\n\t                size_t size = 1 << cur_order;\n\t                while (cur_order > order) {\n\t                    cur_order --;\n\t                    size >>= 1;\n\t                    struct Page buddy = page + size;\n\t                    buddy->property = cur_order;\n\t                    SetPageProperty(buddy);\n\t                    nr_free(cur_order) ++;\n\t                    _--YOUR CODE 10--_(&free;_list(cur_order), &(buddy->page_link));\n\t                }\n\t                ClearPageProperty(page);\n\t                return page;\n\t            }\n\t        }\n\t        return NULL;\n\t    }\n\t    //buddy_alloc_pages - call buddy_alloc_pages_sub to alloc 2^order>=n pages\n\t    static struct Page \n\t    buddy_alloc_pages(size_t n) {\n\t        assert(n > 0);\n\t        size_t order = getorder(n), order_size = (1 << order);\n\t        struct Page page = buddy_alloc_pages_sub(order);\n\t        if (page != NULL && n != order_size) {\n\t            free_pages(page + n, order_size - n);\n\t        }\n\t        return page;\n\t    }\n\t    //page_is_buddy - Does this page belong to the No. zone_num Zone & this page\n\t    //              -  be in the continuing page block whose size is 2^order pages?\n\t    static inline bool\n\t    page_is_buddy(struct Page page, size_t order, int zone_num) {\n\t        if (page2ppn(page) < npage) {\n\t            if (page->zone_num == zone_num) {\n\t                return !PageReserved(page) && PageProperty(page) && page->property == order;\n\t            }\n\t        }\n\t        return 0;\n\t    }\n\t    //page2idx - get the related index number idx of continuing page block which this page belongs to\n\t    static inline ppn_t\n\t    page2idx(struct Page page) {\n\t        return page - zones[page->zone_num].mem_base;\n\t    }\n\t    //idx2page - get the related page according to the index number idx of continuing page block\n\t    static inline struct Page \n\t    idx2page(int zone_num, ppn_t idx) {\n\t        return zones[zone_num].mem_base + idx;\n\t    }\n\t    //buddy_free_pages_sub - the actual free implimentation, should consider how to\n\t    //                     - merge the adjacent buddy block\n\t    static void\n\t    buddy_free_pages_sub(struct Page base, size_t order) {\n\t        ppn_t buddy_idx, page_idx = page2idx(base);\n\t        assert((page_idx & ((1 << order) - 1)) == 0);\n\t        struct Page p = base;\n\t        for (; p != base + (1 << order); p ++) {\n\t            assert(!PageReserved(p) && !PageProperty(p));\n\t            p->flags = 0;\n\t            set_page_ref(p, 0);\n\t        }\n\t        int zone_num = base->zone_num;\n\t        while (order < MAX_ORDER) {\n\t            buddy_idx = page_idx ^ (1 << order);\n\t            struct Page buddy = idx2page(zone_num, buddy_idx);\n\t            if (!page_is_buddy(buddy, order, zone_num)) {\n\t                break;\n\t            }\n\t            nr_free(order) --;\n\t            _--YOUR CODE 11--_(&(buddy->page_link));\n\t            ClearPageProperty(buddy);\n\t            page_idx &= buddy_idx;\n\t            order ++;\n\t        }\n\t        struct Page page = idx2page(zone_num, page_idx);\n\t        page->property = order;\n\t        SetPageProperty(page);\n\t        nr_free(order) ++;\n\t        _--YOUR CODE 12--_(&free;_list(order), &(page->page_link));\n\t    }\n\t    //buddy_free_pages - call buddy_free_pages_sub to free n continuing page block\n\t    static void\n\t    buddy_free_pages(struct Page base, size_t n) {\n\t        assert(n > 0);\n\t        if (n == 1) {\n\t            buddy_free_pages_sub(base, 0);\n\t        }\n\t        else {\n\t            size_t order = 0, order_size = 1;\n\t            while (n >= order_size) {\n\t                assert(order <= MAX_ORDER);\n\t                if ((page2idx(base) & order_size) != 0) {\n\t                    buddy_free_pages_sub(base, order);\n\t                    base += order_size;\n\t                    n -= order_size;\n\t                }\n\t                order ++;\n\t                order_size <<= 1;\n\t            }\n\t            while (n != 0) {\n\t                while (n < order_size) {\n\t                    order --;\n\t                    order_size >>= 1;\n\t                }\n\t                buddy_free_pages_sub(base, order);\n\t                base += order_size;\n\t                n -= order_size;\n\t            }\n\t        }\n\t    }\n\t    //buddy_nr_free_pages - get the nr: the number of free pages\n\t    static size_t\n\t    buddy_nr_free_pages(void) {\n\t        size_t ret = 0, order = 0;\n\t        for (; order <= MAX_ORDER; order ++) {\n\t            ret += nr_free(order)  (1 << order);\n\t        }\n\t        return ret;\n\t    }\n\t    //buddy_check - check the correctness of buddy system\n\t    static void\n\t    buddy_check(void) {\n\t    ……\n\t    }\n\t    //the buddy system pmm\n\t    const struct pmm_manager buddy_pmm_manager = {\n\t        .name = \"buddy_pmm_manager\",\n\t        .init = buddy_init,\n\t        .init_memmap = buddy_init_memmap,\n\t        .alloc_pages = buddy_alloc_pages,\n\t        .free_pages = buddy_free_pages,\n\t        .nr_free_pages = buddy_nr_free_pages,\n\t        .check = buddy_check,\n\t    };\n\t    ```\n    \n",
    "source":"网络",
    "answer":"1)\n![](files/attach/images/content/20150326/14273449548411.jpg)\n分配：1）把用户要求的大小转成_2的幂_（1分）；2）从空闲数组对应大小开始向大的方向找，直到_有比需要大小不小的空闲块_（1分）；3）如果比需要的大，_切\n半_（2分）后留下一个，另一个_放入空闲数组_（1分）；直到得到一个需要大小的块；\n回收：1）回收块_按地址顺序_（1分）放入对应大小的空闲链；2）与相邻空闲块进行可能的合并（1分），合并条件：_相邻_（1分）且小地址的那一块的起始地址是_\n当前块大小的2倍的整数倍_（2分）；\n只画图，没有描述的，给4分；\n2)8分，每个空2分；\n    ```\n                _--YOUR CODE 9--_(le);\n    list_del(le);\n                    _--YOUR CODE 10--_(&free;_list(cur_order), &(buddy->page_link));\n    list_add(&free;_list(cur_order), &(buddy->page_link));\n            _--YOUR CODE 11--_(&(buddy->page_link));\n    list_del(&(buddy->page_link));\n        _--YOUR CODE 12--_(&free;_list(order), &(page->page_link));\n    list_add(&free;_list(order), &(page->page_link));\n    ```\n\n",
    "type":"question_answer",
    "q_number":1090
}