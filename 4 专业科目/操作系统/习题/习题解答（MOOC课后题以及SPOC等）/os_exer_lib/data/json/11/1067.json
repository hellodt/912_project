{
    "status":"ok",
    "knowledge":[
        "进程状态与控制"
    ],
    "degree_of_difficulty":1,
    "explain":"第一问5分；第二问11分；\n1）yield()的工作过程：（1）设置调度标志need_sched（2分）；（2）在系统调用返回时检查调度标志，并进行线程切换（2分）；（3）再次调度yi\neld()所在线程继续执行时返回用户态（1分）；\n2）\n    ```\n    return ……(1)……;\n    return syscall(SYS_yield);\n    case ……(2)……:\n        case T_SYSCALL:\n    if (pls_read(current)->need_resched) {\n                    ……(3)……;\n                }\n            if (pls_read(current)->need_resched) {\n                    schedule();\n                }\n    current->need_resched = ……(4)……;\n    current->need_resched = 0;\n    next = ……(5)……;\n    next = sched_class_pick_next();\n    next = ……(6)……;\n    next = sched_class_pick_next();\n    if (next == NULL) {\n                next = ……(7)……;\n            }\n    if (next == NULL) {\n                next = idleproc;\n            }\n    if (next != current) {\n                ……(8)……;\n            }\n    if (next != current) {\n                proc_run(next);\n            }\n    mp_set_mm_pagetable(next->mm);\n                ……(9)……;\n                mp_set_mm_pagetable(next->mm);\n                switch_to(&(prev->context), &(next->context));\n    current->need_resched = ……(10)……;\n    current->need_resched = 1;\n    return ……(11)……;\n    return do_yield();\n    ```\n\n",
    "question":"(16分)下面是ucore内核中与yield()系统调用实现相关源代码，可实现用户线程主动放弃CPU使用权的功能。\n1）试描述ucore中用户进程利用yield()进行主动让出CPU的工作过程；\n2）请补全其中所缺的代码，以正确完成从用户态函数yield()的功能。提示：每处需要补全的代码最少只需要一行，一共有11个空要填。当然，你可以在需要补全代码\n的地方写多行来表达需要实现的功能，也允许修改已给出的代码。\n    ```\n\t    libs-user-ucore/syscall.h\n\t    ================= libs-user-ucore/syscall.h ========================\n\t    #ifndef __USER_LIBS_SYSCALL_H__\n\t    #define __USER_LIBS_SYSCALL_H__\n\t    #include\n\t    ......\n\t    int sys_yield(void);\n\t    ......\n\t    #endif / !__USER_LIBS_SYSCALL_H__ /\n\t    =============================================================\n\t    libs-user-ucore/arch/i386/syscall.c\n\t    =============libs-user-ucore/arch/i386/syscall.c====================\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #define MAX_ARGS            5\n\t    uint32_t\n\t    syscall(int num, ...) {\n\t        va_list ap;\n\t        va_start(ap, num);\n\t        uint32_t a[MAX_ARGS];\n\t        int i;\n\t        for (i = 0; i < MAX_ARGS; i ++) {\n\t            a[i] = va_arg(ap, uint32_t);\n\t        }\n\t        va_end(ap);\n\t        uint32_t ret;\n\t        asm volatile (\n\t            \"int %1;\"\n\t            : \"=a\" (ret)\n\t            : \"i\" (T_SYSCALL),\n\t              \"a\" (num),\n\t              \"d\" (a[0]),\n\t              \"c\" (a[1]),\n\t              \"b\" (a[2]),\n\t              \"D\" (a[3]),\n\t              \"S\" (a[4])\n\t            : \"cc\", \"memory\");\n\t        return ret;\n\t    }\n\t    =============================================================\n\t    libs-user-ucore/syscall.c\n\t    ==================libs-user-ucore/syscall.c========================\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    extern uintptr_t syscall (int num, ...);\n\t    ......\n\t    int\n\t    sys_yield(void) {\n\t        return ……(1)……;\n\t    }\n\t    ......\n\t    =============================================================\n\t    kern-ucore/glue-ucore/libs/unistd.h\n\t    =============kern-ucore/glue-ucore/libs/unistd.h===================\n\t    #ifndef __LIBS_UNISTD_H__\n\t    #define __LIBS_UNISTD_H__\n\t    #define T_SYSCALL           0x80\n\t    / syscall number /\n\t    ......\n\t    #define SYS_yield           10\n\t    ......\n\t    #endif / !__LIBS_UNISTD_H__ /\n\t    =============================================================\n\t    kern-ucore/arch/i386/glue-ucore/trap.c\n\t    ============= kern-ucore/arch/i386/glue-ucore/trap.c ===============\n\t    ......\n\t    static void\n\t    trap_dispatch(struct trapframe tf) {\n\t        char c;\n\t        int ret;\n\t        switch (tf->tf_trapno) {\n\t        case T_DEBUG:\n\t        case T_BRKPT:\n\t            debug_monitor(tf);\n\t            break;\n\t        case T_PGFLT:\n\t            if ((ret = pgfault_handler(tf)) != 0) {\n\t                print_trapframe(tf);\n\t                if (pls_read(current) == NULL) {\n\t                    panic(\"handle pgfault failed. %e\n\t\", ret);\n\t                }\n\t                else {\n\t                    if (trap_in_kernel(tf)) {\n\t                        panic(\"handle pgfault failed in kernel mode. %e\n\t\", ret);\n\t                    }\n\t                    kprintf(\"killed by kernel.\n\t\");\n\t                    do_exit(-E_KILLED);\n\t                }\n\t            }\n\t            break;\n\t        case ……(2)……:\n\t            syscall();\n\t            break;\n\t        case IRQ_OFFSET + IRQ_TIMER:\n\t            ticks ++;\n\t            assert(pls_read(current) != NULL);\n\t            run_timer_list();\n\t            break;\n\t        case IRQ_OFFSET + IRQ_COM1:\n\t        case IRQ_OFFSET + IRQ_KBD:\n\t            if ((c = cons_getc()) == 13) {\n\t                debug_monitor(tf);\n\t            }\n\t            else {\n\t                extern void dev_stdin_write(char c);\n\t                dev_stdin_write(c);\n\t            }\n\t            break;\n\t        case IRQ_OFFSET + IRQ_IDE1:\n\t        case IRQ_OFFSET + IRQ_IDE2:\n\t            / do nothing /\n\t            break;\n\t        default:\n\t            print_trapframe(tf);\n\t            if (pls_read(current) != NULL) {\n\t                kprintf(\"unhandled trap.\n\t\");\n\t                do_exit(-E_KILLED);\n\t            }\n\t            panic(\"unexpected trap in kernel.\n\t\");\n\t        }\n\t    }\n\t    void\n\t    trap(struct trapframe tf) {\n\t        // used for previous projects\n\t        if (pls_read(current) == NULL) {\n\t            trap_dispatch(tf);\n\t        }\n\t        else {\n\t            // keep a trapframe chain in stack\n\t            struct trapframe otf = pls_read(current)->tf;\n\t            pls_read(current)->tf = tf;\n\t            bool in_kernel = trap_in_kernel(tf);\n\t            trap_dispatch(tf);\n\t            pls_read(current)->tf = otf;\n\t            if (!in_kernel) {\n\t                may_killed();\n\t                if (pls_read(current)->need_resched) {\n\t                    ……(3)……;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    =============================================================\n\t    kern-ucore/schedule/sched.c\n\t    =============kern-ucore/schedule/sched.c=========================\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #define current (pls_read(current))\n\t    #define idleproc (pls_read(idleproc))\n\t    ......\n\t    #include\n\t    #define MT_SUPPORT\n\t    void\n\t    schedule(void) {\n\t        bool intr_flag;\n\t        struct proc_struct next;\n\t    #ifndef MT_SUPPORT\n\t        list_entry_t head;\n\t        int lapic_id = pls_read(lapic_id);\n\t    #endif\n\t        local_intr_save(intr_flag);\n\t        int lcpu_count = pls_read(lcpu_count);\n\t        {\n\t            current->need_resched = ……(4)……;\n\t    #ifndef MT_SUPPORT\n\t            if (current->mm)\n\t            {\n\t                assert(current->mm->lapic == lapic_id);\n\t                current->mm->lapic = -1;\n\t            }\n\t    #endif\n\t            if (current->state == PROC_RUNNABLE && current->pid >= lcpu_count) {\n\t                sched_class_enqueue(current);\n\t            }\n\t    #ifndef MT_SUPPORT\n\t            list_init(&head;);\n\t            while (1)\n\t            {\n\t                next = ……(5)……;\n\t                if (next != NULL) sched_class_dequeue(next);\n\t                if (next && next->mm && next->mm->lapic != -1)\n\t                {\n\t                    list_add(&head;, &(next->run_link));\n\t                }\n\t                else\n\t                {\n\t                    list_entry_t cur;\n\t                    while ((cur = list_next(&head;)) != &head;)\n\t                    {\n\t                        list_del_init(cur);\n\t                        sched_class_enqueue(le2proc(cur, run_link));\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\t    #else\n\t            next = ……(6)……;\n\t            if (next != NULL)\n\t                sched_class_dequeue(next);\n\t    #endif  / !MT_SUPPORT /\n\t            if (next == NULL) {\n\t                next = ……(7)……;\n\t            }\n\t            next->runs ++;\n\t            / Collect information here/\n\t            if (sched_collect_info) {\n\t                int lcpu_count = pls_read(lcpu_count);\n\t                int lcpu_idx = pls_read(lcpu_idx);\n\t                int loc = sched_info_head[lcpu_idx];\n\t                int prev = sched_info_pid[loclcpu_count + lcpu_idx];\n\t                if (next->pid == prev)\n\t                    sched_info_times[loclcpu_count + lcpu_idx] ++;\n\t                else {\n\t                    sched_info_head[lcpu_idx] ++;\n\t                    if (sched_info_head[lcpu_idx] >= PGSIZE / sizeof(uint16_t) / lcpu_count)\n\t                        sched_info_head[lcpu_idx] = 0;\n\t                    loc = sched_info_head[lcpu_idx];\n\t                    uint16_t prev_pid = sched_info_pid[loclcpu_count + lcpu_idx];\n\t                    uint16_t prev_times = sched_info_times[loclcpu_count + lcpu_idx];\n\t                    if (prev_times > 0 && prev_pid >= lcpu_count + 2)\n\t                        sched_slices[lcpu_idx][prev_pid % SLICEPOOL_SIZE] += prev_times;\n\t                    sched_info_pid[loclcpu_count + lcpu_idx] = next->pid;\n\t                    sched_info_times[loclcpu_count + lcpu_idx] = 1;\n\t                }\n\t            }\n\t    #ifndef MT_SUPPORT\n\t            assert(!next->mm || next->mm->lapic == -1);\n\t            if (next->mm)\n\t                next->mm->lapic = lapic_id;\n\t    #endif\n\t            if (next != current) {\n\t                ……(8)……;\n\t            }\n\t        }\n\t        local_intr_restore(intr_flag);\n\t    }\n\t    void\n\t    add_timer(timer_t timer) {\n\t        bool intr_flag;\n\t        local_intr_save(intr_flag);\n\t        {\n\t            assert(timer->expires > 0 && timer->proc != NULL);\n\t            assert(list_empty(&(timer->timer_link)));\n\t            list_entry_t le = list_next(&timer;_list);\n\t            while (le != &timer;_list) {\n\t                timer_t next = le2timer(le, timer_link);\n\t                if (timer->expires < next->expires) {\n\t                    next->expires -= timer->expires;\n\t                    break;\n\t                }\n\t                timer->expires -= next->expires;\n\t                le = list_next(le);\n\t            }\n\t            list_add_before(le, &(timer->timer_link));\n\t        }\n\t        local_intr_restore(intr_flag);\n\t    }\n\t    ......\n\t    =============================================================\n\t    kern-ucore/process/proc.c\n\t    ================kern-ucore/process/proc.c========================\n\t    ......\n\t    // proc_run - make process \"proc\" running on cpu\n\t    // NOTE: before call switch_to, should load  base addr of \"proc\"'s new PDT\n\t    void\n\t    proc_run(struct proc_struct proc) {\n\t        if (proc != current) {\n\t            bool intr_flag;\n\t            struct proc_struct prev = current, next = proc;\n\t            // kprintf(\"(%d) => %d\n\t\", lapic_id, next->pid);\n\t            local_intr_save(intr_flag);\n\t            {\n\t                pls_write(current, proc);\n\t                load_rsp0(next->kstack + KSTACKSIZE);\n\t                mp_set_mm_pagetable(next->mm);\n\t                ……(9)……;\n\t            }\n\t            local_intr_restore(intr_flag);\n\t        }\n\t    }\n\t    ......\n\t    // do_yield - ask the scheduler to reschedule\n\t    int\n\t    do_yield(void) {\n\t        current->need_resched = ……(10)……;\n\t        return 0;\n\t    }\n\t    ......\n\t    =============================================================\n\t    kern-ucore/arch/i386/syscall/syscall.c\n\t    =============kern-ucore/arch/i386/syscall/syscall.c=================\n\t    ......\n\t    static uint32_t\n\t    sys_yield(uint32_t arg[]) {\n\t        return ……(11)……;\n\t    }\n\t    ......\n\t    static uint32_t (syscalls[])(uint32_t arg[]) = {\n\t    ......\n\t        [SYS_yield]             sys_yield,\n\t    ......\n\t    };\n\t    #define NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))\n\t    void\n\t    syscall(void) {\n\t        struct trapframe tf = pls_read(current)->tf;\n\t        uint32_t arg[5];\n\t        int num = tf->tf_regs.reg_eax;\n\t        if (num >= 0 && num < NUM_SYSCALLS) {\n\t            if (syscalls[num] != NULL) {\n\t                arg[0] = tf->tf_regs.reg_edx;\n\t                arg[1] = tf->tf_regs.reg_ecx;\n\t                arg[2] = tf->tf_regs.reg_ebx;\n\t                arg[3] = tf->tf_regs.reg_edi;\n\t                arg[4] = tf->tf_regs.reg_esi;\n\t                tf->tf_regs.reg_eax = syscalls[num](arg);\n\t                return ;\n\t            }\n\t        }\n\t        print_trapframe(tf);\n\t        panic(\"undefined syscall %d, pid = %d, name = %s.\n\t\",\n\t                num, pls_read(current)->pid, pls_read(current)->name);\n\t    }\n\t    =============================================================\n\t    ```\n    \n",
    "source":"网络",
    "answer":"第一问5分；第二问11分；\n1）yield()的工作过程：（1）设置调度标志need_sched（2分）；（2）在系统调用返回时检查调度标志，并进行线程切换（2分）；（3）再次调度yi\neld()所在线程继续执行时返回用户态（1分）；\n2）\n    ```\n    return ……(1)……;\n    return syscall(SYS_yield);\n    case ……(2)……:\n        case T_SYSCALL:\n    if (pls_read(current)->need_resched) {\n                    ……(3)……;\n                }\n            if (pls_read(current)->need_resched) {\n                    schedule();\n                }\n    current->need_resched = ……(4)……;\n    current->need_resched = 0;\n    next = ……(5)……;\n    next = sched_class_pick_next();\n    next = ……(6)……;\n    next = sched_class_pick_next();\n    if (next == NULL) {\n                next = ……(7)……;\n            }\n    if (next == NULL) {\n                next = idleproc;\n            }\n    if (next != current) {\n                ……(8)……;\n            }\n    if (next != current) {\n                proc_run(next);\n            }\n    mp_set_mm_pagetable(next->mm);\n                ……(9)……;\n                mp_set_mm_pagetable(next->mm);\n                switch_to(&(prev->context), &(next->context));\n    current->need_resched = ……(10)……;\n    current->need_resched = 1;\n    return ……(11)……;\n    return do_yield();\n    ```\n\n",
    "type":"question_answer",
    "q_number":1067
}