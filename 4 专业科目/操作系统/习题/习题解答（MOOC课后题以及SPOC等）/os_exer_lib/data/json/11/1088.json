{
    "status":"ok",
    "knowledge":[
        "进程状态与控制"
    ],
    "degree_of_difficulty":1,
    "explain":"1）函数调用和返回的过程：\n1.参数压栈；2.函数调用跳转（指令指针（2分）和栈顶指针（2分）压栈（2分））；3.函数执行；4. 函数返回（指令指针和栈顶指针退栈（2分））\n没有指针压退栈，但有参数压退栈的，给1分；\n2）（6分，每空2分）\n    ```\n            uint32_t args = (uint32_t ) _--YOUR CODE 1--_;\n            uint32_t args = (uint32_t )ebp + 2;\n           eip = ((uint32_t ) _--YOUR CODE 2--_;\n           eip = ((uint32_t )ebp)[1];\n            ebp = ((uint32_t ) _--YOUR CODE 3--_;\n            ebp = ((uint32_t )ebp)[0];\n    ```\n\n",
    "question":"1）试描述进程执行中利用堆栈实现函数调用和返回的过程。2）请补全下面print_stackframe()函数所缺的代码，以利用函数调用时保存在堆栈中的信息输\n出嵌套调用的函数入口地址和参数信息。\n    ```\n\t    =============kern-ucore/arch/i386/debug/kdebug.c=============\n\t    / \n\t      print_debuginfo - read and print the stat information for the address @eip,\n\t      and info.eip_fn_addr should be the first address of the related function.\n\t      /\n\t    void\n\t    print_debuginfo(uintptr_t eip) {\n\t    ……\n\t    }\n\t    static uint32_t read_eip(void) __attribute__((noinline));\n\t    static uint32_t\n\t    read_eip(void) {\n\t    ……\n\t    }\n\t    / \n\t      print_stackframe - print a list of the saved eip values from the nested 'call'\n\t      instructions that led to the current point of execution\n\t     \n\t      The x86 stack pointer, namely esp, points to the lowest location on the stack\n\t      that is currently in use. Everything below that location in stack is free. Pushing\n\t      a value onto the stack will invole decreasing the stack pointer and then writing\n\t      the value to the place that stack pointer pointes to. And popping a value do the\n\t      opposite.\n\t     \n\t      The ebp (base pointer) register, in contrast, is associated with the stack\n\t      primarily by software convention. On entry to a C function, the function's\n\t      prologue code normally saves the previous function's base pointer by pushing\n\t      it onto the stack, and then copies the current esp value into ebp for the duration\n\t      of the function. If all the functions in a program obey this convention,\n\t      then at any given point during the program's execution, it is possible to trace\n\t      back through the stack by following the chain of saved ebp pointers and determining\n\t      exactly what nested sequence of function calls caused this particular point in the\n\t      program to be reached. This capability can be particularly useful, for example,\n\t      when a particular function causes an assert failure or panic because bad arguments\n\t      were passed to it, but you aren't sure who passed the bad arguments. A stack\n\t      backtrace lets you find the offending function.\n\t     \n\t      The inline function read_ebp() can tell us the value of current ebp. And the\n\t      non-inline function read_eip() is useful, it can read the value of current eip,\n\t      since while calling this function, read_eip() can read the caller's eip from\n\t      stack easily.\n\t     \n\t      In print_debuginfo(), the function debuginfo_eip() can get enough information about\n\t      calling-chain. Finally print_stackframe() will trace and print them for debugging.\n\t     \n\t      Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping\n\t      to the kernel entry, the value of ebp has been set to zero, that's the boundary.\n\t      /\n\t    void\n\t    print_stackframe(void) {\n\t        uint32_t ebp = read_ebp(), eip = read_eip();\n\t        int i, j;\n\t        for (i = 0; ebp != 0 && i < 10; i ++) {\n\t            kprintf(\"ebp:0x%08x eip:0x%08x args:\", ebp, eip);\n\t            uint32_t args = (uint32_t ) _--YOUR CODE 1--_;\n\t            for (j = 0; j < 4; j ++) {\n\t                kprintf(\"0x%08x \", args[j]);\n\t            }\n\t            kprintf(\"\n\t\");\n\t            print_debuginfo(eip - 1);\n\t            eip = ((uint32_t ) _--YOUR CODE 2--_;\n\t            ebp = ((uint32_t ) _--YOUR CODE 3--_;\n\t        }\n\t    }\n\t    ```\n    \n",
    "source":"网络",
    "answer":"1）函数调用和返回的过程：\n1.参数压栈；2.函数调用跳转（指令指针（2分）和栈顶指针（2分）压栈（2分））；3.函数执行；4. 函数返回（指令指针和栈顶指针退栈（2分））\n没有指针压退栈，但有参数压退栈的，给1分；\n2）（6分，每空2分）\n    ```\n            uint32_t args = (uint32_t ) _--YOUR CODE 1--_;\n            uint32_t args = (uint32_t )ebp + 2;\n           eip = ((uint32_t ) _--YOUR CODE 2--_;\n           eip = ((uint32_t )ebp)[1];\n            ebp = ((uint32_t ) _--YOUR CODE 3--_;\n            ebp = ((uint32_t )ebp)[0];\n    ```\n\n",
    "type":"question_answer",
    "q_number":1088
}