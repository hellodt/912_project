{
    "status":"ok",
    "knowledge":[
        "虚拟内存管理实验"
    ],
    "degree_of_difficulty":1,
    "explain":"if (ptep & PTE_P) {//判断页面存在（2分）\nstruct Page page = pte2page(ptep);//获取物理页面数据结构指针（1分）\nif (page_ref_dec(page) == 0) {//物理页面数据结构中引用计数减一（2分）\nfree_page(page); //释放占用页面（2分）\n}\nptep = 0; //页表项内容清除（2分）\ntlb_invalidate(pgdir, la); //更新TLB（1分）\n}\n",
    "question":"（10分）当一个进程释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构Page进行清除处理，使得此物理内存页成为空闲。同时，还需把表示\n虚地址与物理地址映射关系的二级页表项清除，这个工作由page_remove_pte函数完成。\npage_remove_pte函数的调用关系图如下所示。请补全在 kern/mm/pmm.c中的page_remove_pte函数。\n![](files/attach/images/content/20150326/14273428621019.png)\n图1 page_remove_pte函数的调用关系图\n=============Pmm.h (kern\\mm)=============\n\\#define alloc_page() alloc_pages(1)\n\\#define free_page(page) free_pages(page, 1)\n......\nstatic inline struct Page \npte2page(pte_t pte) {\nif (!(pte & PTE_P)) {\npanic(\"pte2page called with invalid pte\");\n}\nreturn pa2page(PTE_ADDR(pte));\n}\n......\nstatic inline int\npage_ref_inc(struct Page page) {\npage->ref += 1;\nreturn page->ref;\n}\nstatic inline int\npage_ref_dec(struct Page page) {\npage->ref -= 1;\nreturn page->ref;\n}\n......\n=============Pmm.c (kern\\mm)=============\n......\n//page_remove_pte - free an Page sturct which is related linear address la\n// - and clean(invalidate) pte which is related linear address la\n//note: PT is changed, so the TLB need to be invalidate\nstatic inline void\npage_remove_pte(pde_t pgdir, uintptr_t la, pte_t ptep) {\n/ LAB2 EXERCISE 3: YOUR CODE\n\n Please check if ptep is valid, and tlb must be manually updated if mapping is updated\n\n Maybe you want help comment, BELOW comments can help you finish the code\n\n Some Useful MACROs and DEFINEs, you can use them in below implementation.\n MACROs or Functions:\n struct Page page pte2page(ptep): get the according page from the value of a ptep\n free_page : free a page\n page_ref_dec(page) : decrease page->ref. NOTICE: ff page->ref == 0 , then this page should be free.\n tlb_invalidate(pde_t pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being\n edited are the ones currently in use by the processor.\n DEFINEs:\n PTE_P 0x001 // page table/directory entry flags bit : Present\n/\n\\#if 0\nif (0) { //(1) check if page directory is present\nstruct Page page = NULL; //(2) find corresponding page to pte\n//(3) decrease page reference\n//(4) and free this page when page reference reachs 0\n//(5) clear second page table entry\n//(6) flush tlb\n}\n\\#endif\n===Your code 1===\n}\n......\n// invalidate a TLB entry, but only if the page tables being\n// edited are the ones currently in use by the processor.\nvoid\ntlb_invalidate(pde_t pgdir, uintptr_t la) {\nif (rcr3() == PADDR(pgdir)) {\ninvlpg((void )la);\n}\n}\nstatic void\ncheck_alloc_page(void) {\npmm_manager->check();\ncprintf(\"check_alloc_page() succeeded!\n\");\n}\n=============Mmu.h (kern\\mm)=============\n/ page table/directory entry flags /\n\\#define PTE_P 0x001 // Present\n\\#define PTE_W 0x002 // Writeable\n\\#define PTE_U 0x004 // User\n\\#define PTE_PWT 0x008 // Write-Through\n\\#define PTE_PCD 0x010 // Cache-Disable\n\\#define PTE_A 0x020 // Accessed\n\\#define PTE_D 0x040 // Dirty\n\\#define PTE_PS 0x080 // Page Size\n\\#define PTE_MBZ 0x180 // Bits must be zero\n\\#define PTE_AVAIL 0xE00 // Available for software use\n// The PTE_AVAIL bits aren't used by the kernel or interpreted by the\n// hardware, so user processes are allowed to set them arbitrarily.\n\\#define PTE_USER (PTE_U | PTE_W | PTE_P)\n",
    "source":"网络",
    "answer":"if (ptep & PTE_P) {//判断页面存在（2分）\nstruct Page page = pte2page(ptep);//获取物理页面数据结构指针（1分）\nif (page_ref_dec(page) == 0) {//物理页面数据结构中引用计数减一（2分）\nfree_page(page); //释放占用页面（2分）\n}\nptep = 0; //页表项内容清除（2分）\ntlb_invalidate(pgdir, la); //更新TLB（1分）\n}\n",
    "type":"question_answer",
    "q_number":1055
}