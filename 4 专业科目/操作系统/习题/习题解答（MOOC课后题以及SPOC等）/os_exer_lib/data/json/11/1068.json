{
    "status":"ok",
    "knowledge":[
        "文件系统"
    ],
    "degree_of_difficulty":1,
    "explain":"第1问6分；第2问6分；第3问6分；\n1）文件内部数据块存储位置和顺序的组织方法\n（3分）前12块的数据块编号组成一个直接索引数组，存于\"uint32_t direct[SFS_NDIRECT]; / direct blocks /\"\n（3分）后面的数据块编号组成一个一级索引数组，指向该索引的指针为\"uint32_t indirect; / indirect blocks /\"\n2）在一个SFS文件的最后附加一个新数据块实现方法：\n通过判断数据块编号是在直接索引、一级索引还是二级索引（3分）；在相应数组元素处填入数据块编号（3分）；\n3）每两个空1分；\n    ```\n    / inode (on disk) /\n    struct sfs_disk_inode {\n        uint32_t size;                                  / size of the file (in bytes) /\n        uint16_t type;                                  / one of SYS_TYPE_ above /\n        uint16_t nlinks;                                / # of hard links to this file /\n        uint32_t blocks;                                / ……(1)……文件占用数据块数 /\n        uint32_t direct[SFS_NDIRECT];                   / ……(2)……直接索引数组 /\n        uint32_t indirect;                              / ……(3)……1级索引指针 /\n    //    uint32_t db_indirect;                           / double indirect blocks /\n    //   unused\n    };\n        if (nblks < SFS_L0_NBLKS) {\t/ ……(4)……最后一个数据块序号位于直接索引块 /\n            inode->direct[nblks] = ino;\t/ ……(5)……将最后一个数据块的序号存入对应直接索引数组元素中 /\n        }\n        else if (nblks < SFS_L1_NBLKS) {\t/ ……(6)…… 最后一个数据块序号位于1级索引块  /\n            nblks -= SFS_L0_NBLKS;\t\t/ ……(7)……计算1级索引数组下标 /\n            update_cache(sfs, &(file->l1), &(inode->indirect));\n            uint32_t data = file->l1->cache;\n            data[nblks] = ino;\t\t\t/ ……(8)……将最后一个数据块的序号存入对应1级索引数组元素中/\n        }\n        else if (nblks < SFS_L2_NBLKS) {\t/ ……(9)…… 最后一个数据块序号位于2级索引块/\n            nblks -= SFS_L1_NBLKS;\t\t/ ……(10)……计算2级索引数组下标/\n            update_cache(sfs, &(file->l2), &(inode->db_indirect));\n            uint32_t data2 = file->l2->cache;\n            update_cache(sfs, &(file->l1), &data2;[nblks / SFS_BLK_NENTRY]);\n            uint32_t data1 = file->l1->cache;\n            data1[nblks % SFS_BLK_NENTRY] = ino;\t/ ……(11)…… 将最后一个数据块的序号存入对应2级索引数组中第2级子数组元素中/\n        }\n        file->nblks ++;\n        inode->size += size;\n        inode->blocks ++;\t/ ……(12)……文件数据占用的数据块总数加1 /\n    }\n    ```\n\n",
    "question":"(18分)文件系统是操作系统内核中用于持久保存数据的功能模块。\n1）试描述SFS文件系统中的文件存储组织，即文件内部数据块存储位置和顺序的组织方法；\n2）试描述ucore文件系统在一个SFS文件的最后附加一个新数据块实现方法；\n3）试解释下面 ucore代码中文件系统实现中与append_block()函数相关的指定代码行的作用。注意：需要解释的代码共有12处。\n    ```\n\t    kern/fs/sfs/sfs.h\n\t    ========================kern/fs/sfs/sfs.h========================\n\t    #ifndef __KERN_FS_SFS_SFS_H__\n\t    #define __KERN_FS_SFS_SFS_H__\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #define SFS_MAGIC            0x2f8dbe2a              / magic number for sfs /\n\t    #define SFS_BLKSIZE          PGSIZE                  / size of block /\n\t    #define SFS_NDIRECT          12                      / # of direct blocks in inode /\n\t    #define SFS_MAX_INFO_LEN     31                      / max length of infomation /\n\t    #define SFS_MAX_FNAME_LEN    FS_MAX_FNAME_LEN        / max length of filename /\n\t    #define SFS_MAX_FILE_SIZE    (1024UL  1024  128)   / max file size (128M) /\n\t    #define SFS_BLKN_SUPER       0                   / block the superblock lives in /\n\t    #define SFS_BLKN_ROOT        1                   / location of the root dir inode /\n\t    #define SFS_BLKN_FREEMAP     2                   / 1st block of the freemap /\n\t    / # of bits in a block /\n\t    #define SFS_BLKBITS                                 (SFS_BLKSIZE  CHAR_BIT)\n\t    / # of entries in a block /\n\t    #define SFS_BLK_NENTRY                              (SFS_BLKSIZE / sizeof(uint32_t))\n\t    / file types /\n\t    #define SFS_TYPE_INVAL                              0       / Should not appear on disk /\n\t    #define SFS_TYPE_FILE                               1\n\t    #define SFS_TYPE_DIR                                2\n\t    #define SFS_TYPE_LINK                               3\n\t    /\n\t      On-disk superblock\n\t     /\n\t    struct sfs_super {\n\t        uint32_t magic;                                 / magic number, should be SFS_MAGIC /\n\t        uint32_t blocks;                                / # of blocks in fs /\n\t        uint32_t unused_blocks;                         / # of unused blocks in fs /\n\t        char info[SFS_MAX_INFO_LEN + 1];                / infomation for sfs  /\n\t    };\n\t    / inode (on disk) /\n\t    struct sfs_disk_inode {\n\t        uint32_t size;                                  / size of the file (in bytes) /\n\t        uint16_t type;                                  / one of SYS_TYPE_ above /\n\t        uint16_t nlinks;                                / # of hard links to this file /\n\t        uint32_t blocks;                                / ……(1)…… /\n\t        uint32_t direct[SFS_NDIRECT];                   / ……(2)…… /\n\t        uint32_t indirect;                              / ……(3)…… /\n\t    //    uint32_t db_indirect;                           / double indirect blocks /\n\t    //   unused\n\t    };\n\t    / file entry (on disk) /\n\t    struct sfs_disk_entry {\n\t        uint32_t ino;                                   / inode number /\n\t        char name[SFS_MAX_FNAME_LEN + 1];               / file name /\n\t    };\n\t    #define sfs_dentry_size                             \\\n\t        sizeof(((struct sfs_disk_entry )0)->name)\n\t    / inode for sfs /\n\t    struct sfs_inode {\n\t        struct sfs_disk_inode din;                     / on-disk inode /\n\t        uint32_t ino;                                   / inode number /\n\t        bool dirty;                                     / true if inode modified /\n\t        int reclaim_count;                              / kill inode if it hits zero /\n\t        semaphore_t sem;                                / semaphore for din /\n\t        list_entry_t inode_link;         / entry for linked-list in sfs_fs /\n\t        list_entry_t hash_link;          / entry for hash linked-list in sfs_fs /\n\t    };\n\t    #define le2sin(le, member)                          \\\n\t        to_struct((le), struct sfs_inode, member)\n\t    / filesystem for sfs /\n\t    struct sfs_fs {\n\t        struct sfs_super super;                         / on-disk superblock /\n\t        struct device dev;                             / device mounted on /\n\t        struct bitmap freemap;                         / blocks in use are mared 0 /\n\t        bool super_dirty;                               / true if super/freemap modified /\n\t        void sfs_buffer;                  / buffer for non-block aligned io /\n\t        semaphore_t fs_sem;                             / semaphore for fs /\n\t        semaphore_t io_sem;                             / semaphore for io /\n\t        semaphore_t mutex_sem;              / semaphore for link/unlink and rename /\n\t        list_entry_t inode_list;                        / inode linked-list /\n\t        list_entry_t hash_list;                        / inode hash linked-list /\n\t    };\n\t    / hash for sfs /\n\t    #define SFS_HLIST_SHIFT                             10\n\t    #define SFS_HLIST_SIZE                              (1 << SFS_HLIST_SHIFT)\n\t    #define sin_hashfn(x)                               (hash32(x, SFS_HLIST_SHIFT))\n\t    / size of freemap (in bits) /\n\t    #define sfs_freemap_bits(super)           ROUNDUP((super)->blocks, SFS_BLKBITS)\n\t    / size of freemap (in blocks) /\n\t    #define sfs_freemap_blocks(super)         ROUNDUP_DIV((super)->blocks, SFS_BLKBITS)\n\t    struct fs;\n\t    struct inode;\n\t    void sfs_init(void);\n\t    int sfs_mount(const char devname);\n\t    void lock_sfs_fs(struct sfs_fs sfs);\n\t    void lock_sfs_io(struct sfs_fs sfs);\n\t    void lock_sfs_mutex(struct sfs_fs sfs);\n\t    void unlock_sfs_fs(struct sfs_fs sfs);\n\t    void unlock_sfs_io(struct sfs_fs sfs);\n\t    void unlock_sfs_mutex(struct sfs_fs sfs);\n\t    int sfs_rblock(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\n\t    int sfs_wblock(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\n\t    int sfs_rbuf(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\n\t    int sfs_wbuf(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\n\t    int sfs_sync_super(struct sfs_fs sfs);\n\t    int sfs_sync_freemap(struct sfs_fs sfs);\n\t    int sfs_clear_block(struct sfs_fs sfs, uint32_t blkno, uint32_t nblks);\n\t    int sfs_load_inode(struct sfs_fs sfs, struct inode node_store, uint32_t ino);\n\t    #endif / !__KERN_FS_SFS_SFS_H__ /\n\t    =============================================================\n\t    tools/mksfs.c\n\t    ======================= tools/mksfs.c===========================\n\t    ......\n\t    #define SFS_MAGIC                               0x2f8dbe2a\n\t    #define SFS_NDIRECT                             12\n\t    #define SFS_BLKSIZE                             4096                                    // 4K\n\t    #define SFS_MAX_NBLKS                           (1024UL  512)                          // 4K  512K\n\t    #define SFS_MAX_INFO_LEN                        31\n\t    #define SFS_MAX_FNAME_LEN                       255\n\t    #define SFS_MAX_FILE_SIZE                       (1024UL  1024  128)                   // 128M\n\t    #define SFS_BLKBITS                             (SFS_BLKSIZE  CHAR_BIT)\n\t    #define SFS_TYPE_FILE                           1\n\t    #define SFS_TYPE_DIR                            2\n\t    #define SFS_TYPE_LINK                           3\n\t    #define SFS_BLKN_SUPER                          0\n\t    #define SFS_BLKN_ROOT                           1\n\t    #define SFS_BLKN_FREEMAP                        2\n\t    struct cache_block {\n\t        uint32_t ino;\n\t        struct cache_block hash_next;\n\t        void cache;\n\t    };\n\t    struct cache_inode {\n\t        struct inode {\n\t            uint32_t size;\n\t            uint16_t type;\n\t            uint16_t nlinks;\n\t            uint32_t blocks;\n\t            uint32_t direct[SFS_NDIRECT];\n\t            uint32_t indirect;\n\t            uint32_t db_indirect;\n\t        } inode;\n\t        ino_t real;\n\t        uint32_t ino;\n\t        uint32_t nblks;\n\t        struct cache_block l1, l2;\n\t        struct cache_inode hash_next;\n\t    };\n\t    struct sfs_fs {\n\t        struct {\n\t            uint32_t magic;\n\t            uint32_t blocks;\n\t            uint32_t unused_blocks;\n\t            char info[SFS_MAX_INFO_LEN + 1];\n\t        } super;\n\t        struct subpath {\n\t            struct subpath next, prev;\n\t            char subname;\n\t        } __sp_nil, sp_root, sp_end;\n\t        int imgfd;\n\t        uint32_t ninos, next_ino;\n\t        struct cache_inode root;\n\t        struct cache_inode inodes[HASH_LIST_SIZE];\n\t        struct cache_block blocks[HASH_LIST_SIZE];\n\t    };\n\t    struct sfs_entry {\n\t        uint32_t ino;\n\t        char name[SFS_MAX_FNAME_LEN + 1];\n\t    };\n\t    static uint32_t\n\t    sfs_alloc_ino(struct sfs_fs sfs) {\n\t        if (sfs->next_ino < sfs->ninos) {\n\t            sfs->super.unused_blocks --;\n\t            return sfs->next_ino ++;\n\t        }\n\t        bug(\"out of disk space.\n\t\");\n\t    }\n\t    ......\n\t    #define show_fullpath(sfs, name) subpath_show(stderr, sfs, name)\n\t    void open_dir(struct sfs_fs sfs, struct cache_inode current, struct cache_inode parent);\n\t    void open_file(struct sfs_fs sfs, struct cache_inode file, const char filename, int fd);\n\t    void open_link(struct sfs_fs sfs, struct cache_inode file, const char filename);\n\t    #define SFS_BLK_NENTRY                          (SFS_BLKSIZE / sizeof(uint32_t))\n\t    #define SFS_L0_NBLKS                            SFS_NDIRECT\n\t    #define SFS_L1_NBLKS                            (SFS_BLK_NENTRY + SFS_L0_NBLKS)\n\t    #define SFS_L2_NBLKS                            (SFS_BLK_NENTRY  SFS_BLK_NENTRY + SFS_L1_NBLKS)\n\t    #define SFS_LN_NBLKS                            (SFS_MAX_FILE_SIZE / SFS_BLKSIZE)\n\t    static void\n\t    update_cache(struct sfs_fs sfs, struct cache_block cbp, uint32_t inop) {\n\t        uint32_t ino = inop;\n\t        struct cache_block cb = cbp;\n\t        if (ino == 0) {\n\t            cb = alloc_cache_block(sfs, 0);\n\t            ino = cb->ino;\n\t        }\n\t        else if (cb == NULL || cb->ino != ino) {\n\t            cb = search_cache_block(sfs, ino);\n\t            assert(cb != NULL && cb->ino == ino);\n\t        }\n\t        cbp = cb, inop = ino;\n\t    }\n\t    static void\n\t    append_block(struct sfs_fs sfs, struct cache_inode file, size_t size, uint32_t ino, const char filename) {\n\t        static_assert(SFS_LN_NBLKS <= SFS_L2_NBLKS);\n\t        assert(size <= SFS_BLKSIZE);\n\t        uint32_t nblks = file->nblks;\n\t        struct inode inode = &(file->inode);\n\t        if (nblks >= SFS_LN_NBLKS) {\n\t            open_bug(sfs, filename, \"file is too big.\n\t\");\n\t        }\n\t        if (nblks < SFS_L0_NBLKS) {\t/ ……(4)…… /\n\t            inode->direct[nblks] = ino;\t/ ……(5)…… /\n\t        }\n\t        else if (nblks < SFS_L1_NBLKS) {\t/ ……(6)…… /\n\t            nblks -= SFS_L0_NBLKS;\t\t/ ……(7)…… /\n\t            update_cache(sfs, &(file->l1), &(inode->indirect));\n\t            uint32_t data = file->l1->cache;\n\t            data[nblks] = ino;\t\t\t/ ……(8)…… /\n\t        }\n\t        else if (nblks < SFS_L2_NBLKS) {\t/ ……(9)…… /\n\t            nblks -= SFS_L1_NBLKS;\t\t/ ……(10)…… /\n\t            update_cache(sfs, &(file->l2), &(inode->db_indirect));\n\t            uint32_t data2 = file->l2->cache;\n\t            update_cache(sfs, &(file->l1), &data2;[nblks / SFS_BLK_NENTRY]);\n\t            uint32_t data1 = file->l1->cache;\n\t            data1[nblks % SFS_BLK_NENTRY] = ino;\t/ ……(11)…… /\n\t        }\n\t        file->nblks ++;\n\t        inode->size += size;\n\t        inode->blocks ++;\t/ ……(12)…… /\n\t    }\n\t    ......\n\t    =============================================================\n\t    ```\n    \n",
    "source":"网络",
    "answer":"第1问6分；第2问6分；第3问6分；\n1）文件内部数据块存储位置和顺序的组织方法\n（3分）前12块的数据块编号组成一个直接索引数组，存于\"uint32_t direct[SFS_NDIRECT]; / direct blocks /\"\n（3分）后面的数据块编号组成一个一级索引数组，指向该索引的指针为\"uint32_t indirect; / indirect blocks /\"\n2）在一个SFS文件的最后附加一个新数据块实现方法：\n通过判断数据块编号是在直接索引、一级索引还是二级索引（3分）；在相应数组元素处填入数据块编号（3分）；\n3）每两个空1分；\n    ```\n    / inode (on disk) /\n    struct sfs_disk_inode {\n        uint32_t size;                                  / size of the file (in bytes) /\n        uint16_t type;                                  / one of SYS_TYPE_ above /\n        uint16_t nlinks;                                / # of hard links to this file /\n        uint32_t blocks;                                / ……(1)……文件占用数据块数 /\n        uint32_t direct[SFS_NDIRECT];                   / ……(2)……直接索引数组 /\n        uint32_t indirect;                              / ……(3)……1级索引指针 /\n    //    uint32_t db_indirect;                           / double indirect blocks /\n    //   unused\n    };\n        if (nblks < SFS_L0_NBLKS) {\t/ ……(4)……最后一个数据块序号位于直接索引块 /\n            inode->direct[nblks] = ino;\t/ ……(5)……将最后一个数据块的序号存入对应直接索引数组元素中 /\n        }\n        else if (nblks < SFS_L1_NBLKS) {\t/ ……(6)…… 最后一个数据块序号位于1级索引块  /\n            nblks -= SFS_L0_NBLKS;\t\t/ ……(7)……计算1级索引数组下标 /\n            update_cache(sfs, &(file->l1), &(inode->indirect));\n            uint32_t data = file->l1->cache;\n            data[nblks] = ino;\t\t\t/ ……(8)……将最后一个数据块的序号存入对应1级索引数组元素中/\n        }\n        else if (nblks < SFS_L2_NBLKS) {\t/ ……(9)…… 最后一个数据块序号位于2级索引块/\n            nblks -= SFS_L1_NBLKS;\t\t/ ……(10)……计算2级索引数组下标/\n            update_cache(sfs, &(file->l2), &(inode->db_indirect));\n            uint32_t data2 = file->l2->cache;\n            update_cache(sfs, &(file->l1), &data2;[nblks / SFS_BLK_NENTRY]);\n            uint32_t data1 = file->l1->cache;\n            data1[nblks % SFS_BLK_NENTRY] = ino;\t/ ……(11)…… 将最后一个数据块的序号存入对应2级索引数组中第2级子数组元素中/\n        }\n        file->nblks ++;\n        inode->size += size;\n        inode->blocks ++;\t/ ……(12)……文件数据占用的数据块总数加1 /\n    }\n    ```\n\n",
    "type":"question_answer",
    "q_number":1068
}