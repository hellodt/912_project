{
    "status":"ok",
    "knowledge":[
        "中断、异常与系统调用"
    ],
    "degree_of_difficulty":1,
    "explain":"1）系统调用的过程：（8分，每个关键词1分）\n1.准备参数和系统调用号；2. 执行系统中断；3. CPU响应中断，并依据中断号找到系统调用处理例程；4.\n系统调用处理例程依据系统调用号找到对应系统调用实现代码；5.获取系统调用参数；6.\n执行系统调用功能7.准备返回结果；8.执行中断返回到用户态；9.获取返回结果；\n2）（10分，每个空2分）\n    ```\n        return (size_t) _--YOUR CODE 4--_;\n        return (size_t)syscall(SYS_gettime);//必须有参数\n            _--YOUR CODE 5--_;\n    syscall();//不能有参数\n            _--YOUR CODE 6--_;\n    trap_dispatch(tf);\n        [SYS_gettime]           _--YOUR CODE 7--_,\n    [SYS_gettime]           sys_gettime,\n                tf->tf_regs.reg_eax = _--YOUR CODE 8--_;\n    tf->tf_regs.reg_eax = syscalls[num](arg);\n    ```\n\n",
    "question":"1）系统调用接口是操作系统内核向用户进程提供操作系统服务的接口。试描述用户进程通过系统调用使用操作系统服务的过程。2）gettime_msec是一个获取当前\n系统时间的系统调用。请补全该系统调用的实现代码。\n    ```\n\t    =============libs-user-ucore/ulib.c=============\n\t    unsigned int\n\t    gettime_msec(void) {\n\t        return (unsigned int)sys_gettime();\n\t    }\n\t    =============libs-user-ucore/syscall.c=============\n\t    size_t\n\t    sys_gettime(void) {\n\t        return (size_t) _--YOUR CODE 4--_;\n\t    }\n\t    =============libs-user-ucore/arch/i386/syscall.c=============\n\t    #define MAX_ARGS            5\n\t    uint32_t\n\t    syscall(int num, ...) {\n\t        va_list ap;\n\t        va_start(ap, num);\n\t        uint32_t a[MAX_ARGS];\n\t        int i;\n\t        for (i = 0; i < MAX_ARGS; i ++) {\n\t            a[i] = va_arg(ap, uint32_t);\n\t        }\n\t        va_end(ap);\n\t        uint32_t ret;\n\t        asm volatile (\n\t            \"int %1;\"\n\t            : \"=a\" (ret)\n\t            : \"i\" (T_SYSCALL),\n\t              \"a\" (num),\n\t              \"d\" (a[0]),\n\t              \"c\" (a[1]),\n\t              \"b\" (a[2]),\n\t              \"D\" (a[3]),\n\t              \"S\" (a[4])\n\t            : \"cc\", \"memory\");\n\t        return ret;\n\t    }\n\t    =============libs-user-ucore/common/unistd.h=============\n\t    / syscall number /\n\t    #define SYS_exit            1\n\t    #define SYS_fork            2\n\t    #define SYS_wait            3\n\t    #define SYS_exec            4\n\t    #define SYS_clone           5\n\t    #define SYS_exit_thread     9\n\t    #define SYS_yield           10\n\t    #define SYS_sleep           11\n\t    #define SYS_kill            12\n\t    #define SYS_gettime         17\n\t    #define SYS_getpid          18\n\t    #define SYS_brk             19\n\t    ……\n\t    =============kern-ucore/arch/i386/glue-ucore/trap.c=============\n\t    static void\n\t    trap_dispatch(struct trapframe tf) {\n\t        char c;\n\t        int ret;\n\t        switch (tf->tf_trapno) {\n\t        case T_DEBUG:\n\t        case T_BRKPT:\n\t            debug_monitor(tf);\n\t            break;\n\t        case T_PGFLT:\n\t            if ((ret = pgfault_handler(tf)) != 0) {\n\t                print_trapframe(tf);\n\t                if (pls_read(current) == NULL) {\n\t                    panic(\"handle pgfault failed. %e\n\t\", ret);\n\t                }\n\t                else {\n\t                    if (trap_in_kernel(tf)) {\n\t                        panic(\"handle pgfault failed in kernel mode. %e\n\t\", ret);\n\t                    }\n\t                    kprintf(\"killed by kernel.\n\t\");\n\t                    do_exit(-E_KILLED);\n\t                }\n\t            }\n\t            break;\n\t        case T_SYSCALL:\n\t            _--YOUR CODE 5--_;\n\t            break;\n\t        case IRQ_OFFSET + IRQ_TIMER:\n\t            ticks ++;\n\t            assert(pls_read(current) != NULL);\n\t            run_timer_list();\n\t            break;\n\t        case IRQ_OFFSET + IRQ_COM1:\n\t        case IRQ_OFFSET + IRQ_KBD:\n\t            if ((c = cons_getc()) == 13) {\n\t                debug_monitor(tf);\n\t            }\n\t            else {\n\t                extern void dev_stdin_write(char c);\n\t                dev_stdin_write(c);\n\t            }\n\t            break;\n\t        case IRQ_OFFSET + IRQ_IDE1:\n\t        case IRQ_OFFSET + IRQ_IDE2:\n\t            / do nothing /\n\t            break;\n\t        default:\n\t            print_trapframe(tf);\n\t            if (pls_read(current) != NULL) {\n\t                kprintf(\"unhandled trap.\n\t\");\n\t                do_exit(-E_KILLED);\n\t            }\n\t            panic(\"unexpected trap in kernel.\n\t\");\n\t        }\n\t    }\n\t    void\n\t    trap(struct trapframe tf) {\n\t        // used for previous projects\n\t        if (pls_read(current) == NULL) {\n\t            trap_dispatch(tf);\n\t        }\n\t        else {\n\t            // keep a trapframe chain in stack\n\t            struct trapframe otf = pls_read(current)->tf;\n\t            pls_read(current)->tf = tf;\n\t            bool in_kernel = trap_in_kernel(tf);\n\t            _--YOUR CODE 6--_;\n\t            pls_read(current)->tf = otf;\n\t            if (!in_kernel) {\n\t                may_killed();\n\t                if (pls_read(current)->need_resched) {\n\t                    schedule();\n\t                }\n\t            }\n\t        }\n\t    }\n\t    =============kern-ucore/arch/i386/syscall/syscall.c=============\n\t    ……\n\t    static uint32_t\n\t    sys_gettime(uint32_t arg[]) {\n\t        return (int)ticks;\n\t    }\n\t    ……\n\t    static uint32_t (syscalls[])(uint32_t arg[]) = {\n\t        [SYS_exit]              sys_exit,\n\t        [SYS_fork]              sys_fork,\n\t        [SYS_wait]              sys_wait,\n\t        [SYS_exec]              sys_exec,\n\t        [SYS_clone]             sys_clone,\n\t        [SYS_exit_thread]       sys_exit_thread,\n\t        [SYS_yield]             sys_yield,\n\t        [SYS_kill]              sys_kill,\n\t        [SYS_sleep]             sys_sleep,\n\t        [SYS_gettime]           _--YOUR CODE 7--_,\n\t        [SYS_getpid]            sys_getpid,\n\t    ……\n\t    };\n\t    #define NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))\n\t    void\n\t    syscall(void) {\n\t        struct trapframe tf = pls_read(current)->tf;\n\t        uint32_t arg[5];\n\t        int num = tf->tf_regs.reg_eax;\n\t        if (num >= 0 && num < NUM_SYSCALLS) {\n\t            if (syscalls[num] != NULL) {\n\t                arg[0] = tf->tf_regs.reg_edx;\n\t                arg[1] = tf->tf_regs.reg_ecx;\n\t                arg[2] = tf->tf_regs.reg_ebx;\n\t                arg[3] = tf->tf_regs.reg_edi;\n\t                arg[4] = tf->tf_regs.reg_esi;\n\t                tf->tf_regs.reg_eax = _--YOUR CODE 8--_;\n\t                return ;\n\t            }\n\t        }\n\t        print_trapframe(tf);\n\t        panic(\"undefined syscall %d, pid = %d, name = %s.\n\t\",\n\t                num, pls_read(current)->pid, pls_read(current)->name);\n\t    }\n\t    ```\n    \n",
    "source":"网络",
    "answer":"1）系统调用的过程：（8分，每个关键词1分）\n1.准备参数和系统调用号；2. 执行系统中断；3. CPU响应中断，并依据中断号找到系统调用处理例程；4.\n系统调用处理例程依据系统调用号找到对应系统调用实现代码；5.获取系统调用参数；6.\n执行系统调用功能7.准备返回结果；8.执行中断返回到用户态；9.获取返回结果；\n2）（10分，每个空2分）\n    ```\n        return (size_t) _--YOUR CODE 4--_;\n        return (size_t)syscall(SYS_gettime);//必须有参数\n            _--YOUR CODE 5--_;\n    syscall();//不能有参数\n            _--YOUR CODE 6--_;\n    trap_dispatch(tf);\n        [SYS_gettime]           _--YOUR CODE 7--_,\n    [SYS_gettime]           sys_gettime,\n                tf->tf_regs.reg_eax = _--YOUR CODE 8--_;\n    tf->tf_regs.reg_eax = syscalls[num](arg);\n    ```\n\n",
    "type":"question_answer",
    "q_number":1089
}