{
    "status":"ok",
    "knowledge":[
        "处理机调度"
    ],
    "degree_of_difficulty":1,
    "explain":"基本原理7分；填空9分；斜堆2分；\n_基本原理_\n1）\nTickets: Abstract, relative, and uniform resource rights（2分）\nStrides (stride = stride1 / tickets): Intervals between selections（2分）\nPasses (pass += stride)（2分）\n? Virtual time index for next selection\n? Clients with smallest pass gets selected（1分）\n2）\nrq->lab6_run_pool = ……(1)……;\nrq->lab6_run_pool =\nskew_heap_insert(rq->lab6_run_pool, &(proc->lab6_run_pool),\nproc_stride_comp_f);\nrq->lab6_run_pool = ……(2)……;\nrq->lab6_run_pool =\nskew_heap_remove(rq->lab6_run_pool, &(proc->lab6_run_pool),\nproc_stride_comp_f);\nelse p->lab6_stride = ……(3)……;\nelse p->lab6_stride += BIG_STRIDE / p->lab6_priority;\nif (proc->time_slice > 0) {\n……(4)……;\n}\nif (proc->time_slice == 0) {\n……(5)……;\n}\nif (proc->time_slice > 0) {\nproc->time_slice --;\n}\nif (proc->time_slice == 0) {\nproc->need_resched = 1;\n}\nstruct sched_class default_sched_class = {\n.name = \"stride_scheduler\",\n.init = stride_init,\n.enqueue = ……(6)……,\n.dequeue = ……(7)……,\n.pick_next = ……(8)……,\n.proc_tick = ……(9)……,\n};\n.enqueue = stride_enqueue,\n.dequeue = stride_dequeue,\n.pick_next = stride_pick_next,\n.proc_tick = stride_proc_tick,\n3）就绪线程形成一个树状结构，根优先级（pass）最小（1分）；按斜堆的规则进行就绪线程的插入和删除（1分）；\n",
    "question":"(18分)调度器是操作系统内核中依据调度算法进行进程切换选择的模块。\n1）试描述步进调度算法(Stride Scheduling)的基本原理。\n2）请补全下面 ucore代码中调度器和步进调度算法实现中所缺代码，以实现调度器和调度算法的功能。提示：每处需要补全的代码最少只需要一行，一共有9个空要填。\n当然，你可以在需要补全代码的地方写多行来表达需要实现的功能，也允许修改已给出的代码。\n3）试描述斜堆(skew heap)在这个步进调度算法中的作用。\n    ```\n\t    kern/process/proc.h\n\t    ==================== kern/process/proc.h ========================\n\t    #ifndef __KERN_PROCESS_PROC_H__\n\t    #define __KERN_PROCESS_PROC_H__\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    // process's state in his life cycle\n\t    enum proc_state {\n\t        PROC_UNINIT = 0,  // uninitialized\n\t        PROC_SLEEPING,    // sleeping\n\t        PROC_RUNNABLE,    // runnable(maybe running)\n\t        PROC_ZOMBIE,      // almost dead, and wait parent proc to reclaim his resource\n\t    };\n\t    // Saved registers for kernel context switches.\n\t    // Don't need to save all the %fs etc. segment registers,\n\t    // because they are constant across kernel contexts.\n\t    // Save all the regular registers so we don't need to care\n\t    // which are caller save, but not the return register %eax.\n\t    // (Not saving %eax just simplifies the switching code.)\n\t    // The layout of context must match code in switch.S.\n\t    struct context {\n\t        uint32_t eip;\n\t        uint32_t esp;\n\t        uint32_t ebx;\n\t        uint32_t ecx;\n\t        uint32_t edx;\n\t        uint32_t esi;\n\t        uint32_t edi;\n\t        uint32_t ebp;\n\t    };\n\t    #define PROC_NAME_LEN               15\n\t    #define MAX_PROCESS                 4096\n\t    #define MAX_PID                     (MAX_PROCESS  2)\n\t    extern list_entry_t proc_list;\n\t    struct proc_struct {\n\t        enum proc_state state;                      // Process state\n\t        int pid;                                    // Process ID\n\t        int runs;                                   // the running times of Proces\n\t        uintptr_t kstack;                           // Process kernel stack\n\t        volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?\n\t        struct proc_struct parent;                 // the parent process\n\t        struct mm_struct mm;                       // Process's memory management field\n\t        struct context context;                     // Switch here to run process\n\t        struct trapframe tf;                       // Trap frame for current interrupt\n\t        uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)\n\t        uint32_t flags;                             // Process flag\n\t        char name[PROC_NAME_LEN + 1];               // Process name\n\t        list_entry_t list_link;                     // Process link list\n\t        list_entry_t hash_link;                     // Process hash list\n\t        int exit_code;                              // exit code (be sent to parent proc)\n\t        uint32_t wait_state;                        // waiting state\n\t        struct proc_struct cptr, yptr, optr;     // relations between processes\n\t        struct run_queue rq;                       // running queue contains Process\n\t        list_entry_t run_link;                      // the entry linked in run queue\n\t        int time_slice;                             // time slice for occupying the CPU\n\t        skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool\n\t        uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process\n\t        uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)\n\t    };\n\t    #define PF_EXITING                  0x00000001      // getting shutdown\n\t    #define WT_CHILD                    (0x00000001 | WT_INTERRUPTED)\n\t    #define WT_INTERRUPTED               0x80000000                    // the wait state could be interrupted\n\t    #define le2proc(le, member)         \\\n\t        to_struct((le), struct proc_struct, member)\n\t    extern struct proc_struct idleproc, initproc, current;\n\t    void proc_init(void);\n\t    void proc_run(struct proc_struct proc);\n\t    int kernel_thread(int (fn)(void ), void arg, uint32_t clone_flags);\n\t    char set_proc_name(struct proc_struct proc, const char name);\n\t    char get_proc_name(struct proc_struct proc);\n\t    void cpu_idle(void) __attribute__((noreturn));\n\t    struct proc_struct find_proc(int pid);\n\t    int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe tf);\n\t    int do_exit(int error_code);\n\t    int do_yield(void);\n\t    int do_execve(const char name, size_t len, unsigned char binary, size_t size);\n\t    int do_wait(int pid, int code_store);\n\t    int do_kill(int pid);\n\t    void lab6_set_priority(uint32_t priority);\n\t    #endif / !__KERN_PROCESS_PROC_H__ /\n\t    =============================================================\n\t    kern/schedule/default_sched.c\n\t    =============kern/schedule/default_sched.c========================\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #define USE_SKEW_HEAP 1\n\t    / You should define the BigStride constant here/\n\t    / LAB6: YOUR CODE /\n\t    #define BIG_STRIDE    0x7FFFFFFF / ??? /\n\t    / The compare function for two skew_heap_node_t's and the\n\t      corresponding procs/\n\t    static int\n\t    proc_stride_comp_f(void a, void b)\n\t    {\n\t         struct proc_struct p = le2proc(a, lab6_run_pool);\n\t         struct proc_struct q = le2proc(b, lab6_run_pool);\n\t         int32_t c = p->lab6_stride - q->lab6_stride;\n\t         if (c > 0) return 1;\n\t         else if (c == 0) return 0;\n\t         else return -1;\n\t    }\n\t    /\n\t      stride_init initializes the run-queue rq with correct assignment for\n\t      member variables, including:\n\t     \n\t        - run_list: should be a empty list after initialization.\n\t        - lab6_run_pool: NULL\n\t        - proc_num: 0\n\t        - max_time_slice: no need here, the variable would be assigned by the caller.\n\t     \n\t      hint: see proj13.1/libs/list.h for routines of the list structures.\n\t     /\n\t    static void\n\t    stride_init(struct run_queue rq) {\n\t         / LAB6: YOUR CODE /\n\t         list_init(&(rq->run_list));\n\t         rq->lab6_run_pool = NULL;\n\t         rq->proc_num = 0;\n\t    }\n\t    /\n\t      stride_enqueue inserts the process ``proc'' into the run-queue\n\t      ``rq''. The procedure should verify/initialize the relevant members\n\t      of ``proc'', and then put the ``lab6_run_pool'' node into the\n\t      queue(since we use priority queue here). The procedure should also\n\t      update the meta date in ``rq'' structure.\n\t     \n\t      proc->time_slice denotes the time slices allocation for the\n\t      process, which should set to rq->max_time_slice.\n\t     \n\t      hint: see proj13.1/libs/skew_heap.h for routines of the priority\n\t      queue structures.\n\t     /\n\t    static void\n\t    stride_enqueue(struct run_queue rq, struct proc_struct proc) {\n\t         / LAB6: YOUR CODE /\n\t    #if USE_SKEW_HEAP\n\t         rq->lab6_run_pool = ……(1)……;\n\t    #else\n\t         assert(list_empty(&(proc->run_link)));\n\t         list_add_before(&(rq->run_list), &(proc->run_link));\n\t    #endif\n\t         if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {\n\t              proc->time_slice = rq->max_time_slice;\n\t         }\n\t         proc->rq = rq;\n\t         rq->proc_num ++;\n\t    }\n\t    /\n\t      stride_dequeue removes the process ``proc'' from the run-queue\n\t      ``rq'', the operation would be finished by the skew_heap_remove\n\t      operations. Remember to update the ``rq'' structure.\n\t     \n\t      hint: see proj13.1/libs/skew_heap.h for routines of the priority\n\t      queue structures.\n\t     /\n\t    static void\n\t    stride_dequeue(struct run_queue rq, struct proc_struct proc) {\n\t         / LAB6: YOUR CODE /\n\t    #if USE_SKEW_HEAP\n\t         rq->lab6_run_pool =  ……(2)……;\n\t    #else\n\t         assert(!list_empty(&(proc->run_link)) && proc->rq == rq);\n\t         list_del_init(&(proc->run_link));\n\t    #endif\n\t         rq->proc_num --;\n\t    }\n\t    /\n\t      stride_pick_next pick the element from the ``run-queue'', with the\n\t      minimum value of stride, and returns the corresponding process\n\t      pointer. The process pointer would be calculated by macro le2proc,\n\t      see proj13.1/kern/process/proc.h for definition. Return NULL if\n\t      there is no process in the queue.\n\t     \n\t      When one proc structure is selected, remember to update the stride\n\t      property of the proc. (stride += BIG_STRIDE / priority)\n\t     \n\t      hint: see proj13.1/libs/skew_heap.h for routines of the priority\n\t      queue structures.\n\t     /\n\t    static struct proc_struct \n\t    stride_pick_next(struct run_queue rq) {\n\t         / LAB6: YOUR CODE /\n\t    #if USE_SKEW_HEAP\n\t         if (rq->lab6_run_pool == NULL) return NULL;\n\t         struct proc_struct p = le2proc(rq->lab6_run_pool, lab6_run_pool);\n\t    #else\n\t         list_entry_t le = list_next(&(rq->run_list));\n\t         if (le == &rq-;>run_list)\n\t              return NULL;\n\t         struct proc_struct p = le2proc(le, run_link);\n\t         le = list_next(le);\n\t         while (le != &rq-;>run_list)\n\t         {\n\t              struct proc_struct q = le2proc(le, run_link);\n\t              if ((int32_t)(p->lab6_stride - q->lab6_stride) > 0)\n\t                   p = q;\n\t              le = list_next(le);\n\t         }\n\t    #endif\n\t         if (p->lab6_priority == 0)\n\t              p->lab6_stride += BIG_STRIDE;\n\t         else p->lab6_stride = ……(3)……;\n\t         return p;\n\t    }\n\t    /\n\t      stride_proc_tick works with the tick event of current process. You\n\t      should check whether the time slices for current process is\n\t      exhausted and update the proc struct ``proc''. proc->time_slice\n\t      denotes the time slices left for current\n\t      process. proc->need_resched is the flag variable for process\n\t      switching.\n\t     /\n\t    static void\n\t    stride_proc_tick(struct run_queue rq, struct proc_struct proc) {\n\t         / LAB6: YOUR CODE /\n\t         if (proc->time_slice > 0) {\n\t              ……(4)……;\n\t         }\n\t         if (proc->time_slice == 0) {\n\t              ……(5)……;\n\t         }\n\t    }\n\t    struct sched_class default_sched_class = {\n\t         .name = \"stride_scheduler\",\n\t         .init = stride_init,\n\t         .enqueue = ……(6)……,\n\t         .dequeue = ……(7)……,\n\t         .pick_next = ……(8)……,\n\t         .proc_tick = ……(9)……,\n\t    };\n\t    =============================================================\n\t    libs/skew_heap.h\n\t    ====================libs/skew_heap.h============================\n\t    #ifndef __LIBS_SKEW_HEAP_H__\n\t    #define __LIBS_SKEW_HEAP_H__\n\t    struct skew_heap_entry {\n\t         struct skew_heap_entry parent, left, right;\n\t    };\n\t    typedef struct skew_heap_entry skew_heap_entry_t;\n\t    typedef int(compare_f)(void a, void b);\n\t    static inline void skew_heap_init(skew_heap_entry_t a) __attribute__((always_inline));\n\t    static inline skew_heap_entry_t skew_heap_merge(\n\t         skew_heap_entry_t a, skew_heap_entry_t b,\n\t         compare_f comp);\n\t    static inline skew_heap_entry_t skew_heap_insert(\n\t         skew_heap_entry_t a, skew_heap_entry_t b,\n\t         compare_f comp) __attribute__((always_inline));\n\t    static inline skew_heap_entry_t skew_heap_remove(\n\t         skew_heap_entry_t a, skew_heap_entry_t b,\n\t         compare_f comp) __attribute__((always_inline));\n\t    static inline void\n\t    skew_heap_init(skew_heap_entry_t a)\n\t    {\n\t         a->left = a->right = a->parent = NULL;\n\t    }\n\t    static inline skew_heap_entry_t \n\t    skew_heap_merge(skew_heap_entry_t a, skew_heap_entry_t b,\n\t                    compare_f comp)\n\t    {\n\t         if (a == NULL) return b;\n\t         else if (b == NULL) return a;\n\t         skew_heap_entry_t l, r;\n\t         if (comp(a, b) == -1)\n\t         {\n\t              r = a->left;\n\t              l = skew_heap_merge(a->right, b, comp);\n\t              a->left = l;\n\t              a->right = r;\n\t              if (l) l->parent = a;\n\t              return a;\n\t         }\n\t         else\n\t         {\n\t              r = b->left;\n\t              l = skew_heap_merge(a, b->right, comp);\n\t              b->left = l;\n\t              b->right = r;\n\t              if (l) l->parent = b;\n\t              return b;\n\t         }\n\t    }\n\t    static inline skew_heap_entry_t \n\t    skew_heap_insert(skew_heap_entry_t a, skew_heap_entry_t b,\n\t                     compare_f comp)\n\t    {\n\t         skew_heap_init(b);\n\t         return skew_heap_merge(a, b, comp);\n\t    }\n\t    static inline skew_heap_entry_t \n\t    skew_heap_remove(skew_heap_entry_t a, skew_heap_entry_t b,\n\t                     compare_f comp)\n\t    {\n\t         skew_heap_entry_t p   = b->parent;\n\t         skew_heap_entry_t rep = skew_heap_merge(b->left, b->right, comp);\n\t         if (rep) rep->parent = p;\n\t         if (p)\n\t         {\n\t              if (p->left == b)\n\t                   p->left = rep;\n\t              else p->right = rep;\n\t              return a;\n\t         }\n\t         else return rep;\n\t    }\n\t    #endif  / !__LIBS_SKEW_HEAP_H__ /\n\t    =============================================================\n\t    ```\n    \n",
    "source":"网络",
    "answer":"基本原理7分；填空9分；斜堆2分；\n_基本原理_\n1）\nTickets: Abstract, relative, and uniform resource rights（2分）\nStrides (stride = stride1 / tickets): Intervals between selections（2分）\nPasses (pass += stride)（2分）\n? Virtual time index for next selection\n? Clients with smallest pass gets selected（1分）\n2）\nrq->lab6_run_pool = ……(1)……;\nrq->lab6_run_pool =\nskew_heap_insert(rq->lab6_run_pool, &(proc->lab6_run_pool),\nproc_stride_comp_f);\nrq->lab6_run_pool = ……(2)……;\nrq->lab6_run_pool =\nskew_heap_remove(rq->lab6_run_pool, &(proc->lab6_run_pool),\nproc_stride_comp_f);\nelse p->lab6_stride = ……(3)……;\nelse p->lab6_stride += BIG_STRIDE / p->lab6_priority;\nif (proc->time_slice > 0) {\n……(4)……;\n}\nif (proc->time_slice == 0) {\n……(5)……;\n}\nif (proc->time_slice > 0) {\nproc->time_slice --;\n}\nif (proc->time_slice == 0) {\nproc->need_resched = 1;\n}\nstruct sched_class default_sched_class = {\n.name = \"stride_scheduler\",\n.init = stride_init,\n.enqueue = ……(6)……,\n.dequeue = ……(7)……,\n.pick_next = ……(8)……,\n.proc_tick = ……(9)……,\n};\n.enqueue = stride_enqueue,\n.dequeue = stride_dequeue,\n.pick_next = stride_pick_next,\n.proc_tick = stride_proc_tick,\n3）就绪线程形成一个树状结构，根优先级（pass）最小（1分）；按斜堆的规则进行就绪线程的插入和删除（1分）；\n",
    "type":"question_answer",
    "q_number":1063
}