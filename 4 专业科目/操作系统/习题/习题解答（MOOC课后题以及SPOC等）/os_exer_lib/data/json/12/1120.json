{
    "status":"ok",
    "knowledge":[
        ""
    ],
    "degree_of_difficulty":1,
    "explain":"Code1： tf->tf_trapno Code 2: ret = pgfault_handler(tf) Code 3: page - pages;\nCode 4: page2ppn(page) << PGSHIFT Code 5: page2pa(page) | PTE_P | perm;\n\\--------------------------------- 评分标准 5个空，每个3分； 第4个空中，对了前半部分，给2分；移位正确给1分；\n第5个空中，每一个部分1分\n",
    "question":"下面是ucore中用于按需分页处理过程的内核代码。请补全其中所缺的代码，以正确完成按需分页过程.\n    ```\n\t    kern/trap/trap.h\n\t    ---------------------------------\n\t    ...\n\t    struct trapframe {\n\t        struct pushregs tf_regs;\n\t        uint16_t tf_es;\n\t        uint16_t tf_padding1;\n\t        uint16_t tf_ds;\n\t        uint16_t tf_padding2;\n\t        uint32_t tf_trapno;\n\t        / below here defined by x86 hardware /\n\t        uint32_t tf_err;\n\t        uintptr_t tf_eip;\n\t        uint16_t tf_cs;\n\t        uint16_t tf_padding3;\n\t        uint32_t tf_eflags;\n\t        // below here only when crossing rings, such as from user to kernel\n\t        uintptr_t tf_esp;\n\t        uint16_t tf_ss;\n\t        uint16_t tf_padding4;\n\t    } __attribute__((packed));\n\t    ...\n\t    ---------------------------------\n\t    kern/trap/trap.c\n\t    ---------------------------------\n\t    ...\n\t    static int\n\t    pgfault_handler(struct trapframe tf) {\n\t        extern struct mm_struct check_mm_struct;\n\t    }\n\t    print_pgfault(tf);\n\t        if (check_mm_struct != NULL) {\n\t            return do_pgfault(check_mm_struct, tf->tf_err, rcr2());\n\t        }\n\t        panic(\"unhandled page fault.\n\t\");\n\t    }\n\t    static void\n\t    trap_dispatch(struct trapframe tf) {\n\t    char c;\n\t    int ret;\n\t    switch ( --YOUR CODE 1-- ) {\n\t         .YOUR..\n\t    case T_PGFLT:\n\t    if ( --YOUR CODE 2-- ) != 0) {\n\t    print_trapframe(trapf);\n\t    if (current == NULL) {\n\t    panic(\"handle pgfault failed. %e\n\t\",              ret);\n\t    }\n\t    else { ... }\n\t    }\n\t    break;\n\t      ...\n\t    }\n\t    void\n\t    trap(struct trapframe tf) {\n\t        // dispatch based on what type of trap occurred\n\t        trap_dispatch(tf);\n\t    }\n\t    ...\n\t    // do_pgfault - interrupt handler to process the page fault execption\n\t    int\n\t    do_pgfault(struct mm_struct mm, uint32_t error_code, uintptr_t addr) {\n\t        int ret = -E_INVAL;\n\t        struct vma_struct vma = find_vma(mm, addr);\n\t        if (vma == NULL || vma->vm_start > addr) {\n\t            goto failed;\n\t        }\n\t        switch (error_code & 3) {\n\t        default:\n\t                / default is 3: write, present /\n\t        case 2: / write, not present /\n\t            if (!(vma->vm_flags & VM_WRITE)) {\n\t                goto failed;\n\t            }\n\t            break;\n\t        case 1: / read, present /\n\t            goto failed;\n\t        case 0: / read, not present /\n\t            if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {\n\t                goto failed;\n\t            }\n\t        }\n\t        uint32_t perm = PTE_U;\n\t        if (vma->vm_flags & VM_WRITE) {\n\t            perm |= PTE_W;\n\t        }\n\t        addr = ROUNDDOWN(addr, PGSIZE);\n\t        ret = -E_NO_MEM;\n\t        if (pgdir_alloc_page(mm->pgdir, addr, perm) == 0) {\n\t            goto failed;\n\t        }\n\t        ret = 0;\n\t    failed:\n\t        return ret;\n\t    }\n\t    ...\n\t    ---------------------------------\n\t    Pmm.h\n\t    ---------------------------------\n\t    ...\n\t    //ppn is physical page number\n\t    static inline ppn_t\n\t    page2ppn(struct Page page) {\n\t        return --YOUR CODE 3--;\n\t    }\n\t    //pa is physical address\n\t    static inline uintptr_t\n\t    page2pa(struct Page page) {\n\t        return --YOUR CODE 4--;\n\t    }\n\t    ...\n\t    ---------------------------------\n\t    pmm.c\n\t    ---------------------------------\n\t    ...\n\t    // virtual address of physicall page array\n\t    struct Page pages;\n\t    // amount of physical memory (in pages)\n\t    size_t npage = 0;\n\t    // virtual address of boot-time page directory\n\t    pde_t boot_pgdir = NULL;\n\t    ……\n\t    // pgdir_alloc_page - call alloc_page & page_insert functions to\n\t    //                  - allocate a page size memory & setup an addr map\n\t    //                  - pa<->la with linear address la and the PDT pgdir\n\t    struct Page \n\t    pgdir_alloc_page(pde_t pgdir, uintptr_t la, uint32_t perm) {\n\t        struct Page page = alloc_page();\n\t        if (page != NULL) {\n\t            if (page_insert(pgdir, page, la, perm) != 0) {\n\t                free_page(page);\n\t                return NULL;\n\t            }\n\t        }\n\t        return page;\n\t    }\n\t    ...\n\t    //page_insert - build the map of phy addr of an Page with the linear addr la\n\t    // paramemters:\n\t    //  pgdir: the kernel virtual base address of PDT\n\t    //  page:  the Page which need to map\n\t    //  la:    the linear address need to map\n\t    //  perm:  the permission of this Page which is setted in related pte\n\t    // return value: always 0\n\t    //note: PT is changed, so the TLB need to be invalidate\n\t    int\n\t    page_insert(pde_t pgdir, struct Page page, uintptr_t la, uint32_t perm) {\n\t        pte_t ptep = get_pte(pgdir, la, 1);\n\t        if (ptep == NULL) {\n\t            return -E_NO_MEM;\n\t        }\n\t        page_ref_inc(page);\n\t        if (ptep & PTE_P) {\n\t            struct Page p = pte2page(ptep);\n\t            if (p == page) {\n\t                page_ref_dec(page);\n\t            }\n\t            else {\n\t                page_remove_pte(pgdir, la, ptep);\n\t            }\n\t        }\n\t        ptep = --YOUR CODE 5--\n\t        tlb_invalidate(pgdir, la);\n\t        return 0;\n\t    }\n\t    ---------------------------------\n\t    ```\n    \n",
    "source":"网络",
    "answer":"Code1： tf->tf_trapno Code 2: ret = pgfault_handler(tf) Code 3: page - pages;\nCode 4: page2ppn(page) << PGSHIFT Code 5: page2pa(page) | PTE_P | perm;\n\\--------------------------------- 评分标准 5个空，每个3分； 第4个空中，对了前半部分，给2分；移位正确给1分；\n第5个空中，每一个部分1分\n",
    "type":"question_answer",
    "q_number":1120
}