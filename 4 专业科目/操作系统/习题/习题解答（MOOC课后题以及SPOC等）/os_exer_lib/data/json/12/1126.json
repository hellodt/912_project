{
    "status":"error",
    "knowledge":[
        "启动和中断处理实验"
    ],
    "degree_of_difficulty":1,
    "explain":"解释\n",
    "question":"系统调用访问过程\n第一题： 一、（2362H2分）下面是与read()系统调用实现相关源代码。请补全其中所缺的代码，以正确完成从用户态函数read()到内核态函数sysfil\ne_read()的参数传递和返回过程。提示：每处需要补全的代码只需要一行，一共有10个空要填。\n    ```\n\t    user/libs/file.c\n\t    ---------------------------------\n\t    ...\n\t    int\n\t    read(int fd, void base, size_t len) {\n\t        ...(1)...\n\t    }\n\t    ...\n\t    ---------------------------------\n\t    user/libs/syscall.c\n\t    ---------------------------------\n\t    ...\n\t    #define MAX_ARGS\n\t    static inline int\n\t    syscall(int num, ...) {\n\t              int ret;\n\t              va_list ap;\n\t             va_start(ap, num);\n\t             uint32_t a[MAX_ARGS];\n\t             int i;\n\t             for (i = 0; i < MAX_ARGS; i ++) {\n\t                       a[i] = va_arg(ap, uint32_t);\n\t             }\n\t             va_end(ap);\n\t             asm volatile (\n\t                                \"int %1;\"\n\t                                : \"=a\" (ret)\n\t                                : \"i\" (T_SYSCALL),\n\t                                  \"a\" (num),\n\t                                  \"d\" (a[0]),\n\t                                  \"c\" (a[1]),\n\t                                  \"b\" (a[2]),\n\t                                  \"D\" (a[3]),\n\t                                  \"S\" (a[4])\n\t                                : \"cc\", \"memory\");\n\t             return ret;\n\t    }\n\t    ...\n\t    int\n\t    sys_read(int fd, void base, size_t len) {\n\t             ...(2)...\n\t    }\n\t    ...\n\t    ---------------------------------\n\t    libs/stdarg.h\n\t    ---------------------------------\n\t    ...\n\t    typedef char  va_list;\n\t    #define __va_size(type)                                                              \\\n\t             ((sizeof(type) + (sizeof(long) - 1)) / sizeof(long)  sizeof(long))\n\t    #define va_start(ap, last)                                                    \\\n\t             ((ap) = (va_list)&(last) + __va_size(last))\n\t    #define va_arg(ap, type)                                                    \\\n\t             ((type )((ap) += __va_size(type), (ap) - __va_size(type)))\n\t    #define va_end(ap)             ((void)0)\n\t    ...\n\t    ---------------------------------\n\t    libs/unistd.h\n\t    ---------------------------------\n\t    ...\n\t    #define T_SYSCALL                           0x80\n\t    / syscall number /\n\t    ...\n\t    #define SYS_read                       102\n\t    #define SYS_write                      103\n\t    ...\n\t    ---------------------------------\n\t    kern/syscall/syscall.c\n\t    ---------------------------------\n\t    ...\n\t    struct trapframe {\n\t             struct pushregs tf_regs;\n\t             uint16_t tf_es;\n\t             uint16_t tf_padding1;\n\t             uint16_t tf_ds;\n\t             uint16_t tf_padding2;\n\t             uint32_t tf_trapno;\n\t             / below here defined by x86 hardware /\n\t             uint32_t tf_err;\n\t             uintptr_t tf_eip;\n\t             uint16_t tf_cs;\n\t             uint16_t tf_padding3;\n\t             uint32_t tf_eflags;\n\t             / below here only when crossing rings, such as from user to kernel /\n\t             uintptr_t tf_esp;\n\t             uint16_t tf_ss;\n\t             uint16_t tf_padding4;\n\t    };\n\t    ...\n\t    ---------------------------------\n\t    kern/trap/trap.c\n\t    ---------------------------------\n\t    ...\n\t    static void\n\t    trap_dispatch(struct trapframe tf) {\n\t             char c;\n\t             int ret;\n\t             switch (...(3)...) {\n\t             case T_DEBUG:\n\t             case T_BRKPT:\n\t                       debug_monitor(tf);\n\t                       break;\n\t             case T_PGFLT:\n\t                       if ((ret = pgfault_handler(tf)) != 0) {\n\t                                print_trapframe(tf);\n\t                                if (current == NULL) {\n\t                                         panic(\"handle pgfault failed. %e\n\t\", ret);\n\t                                }\n\t                                else {\n\t                                         if (trap_in_kernel(tf)) {\n\t                                                   panic(\"handle pgfault failed in kernel mode. %e\n\t\", ret);\n\t                                         }\n\t                                         cprintf(\"killed by kernel.\n\t\");\n\t                                         do_exit(-E_KILLED);\n\t                                }\n\t                       }\n\t                       break;\n\t             case T_SYSCALL:\n\t                       ...(4)...\n\t                       break;\n\t             case IRQ_OFFSET + IRQ_TIMER:\n\t                       ticks ++;\n\t                       assert(current != NULL);\n\t                       run_timer_list();\n\t                       break;\n\t             case IRQ_OFFSET + IRQ_COM1:\n\t             case IRQ_OFFSET + IRQ_KBD:\n\t                      if ((c = cons_getc()) == 13) {\n\t                                debug_monitor(tf);\n\t                       }\n\t                       else {\n\t                                extern void dev_stdin_write(char c);\n\t                                dev_stdin_write(c);\n\t                       }\n\t                       break;\n\t             case IRQ_OFFSET + IRQ_IDE1:\n\t             case IRQ_OFFSET + IRQ_IDE2:\n\t                       / do nothing /\n\t                       break;\n\t             default:\n\t                       print_trapframe(tf);\n\t                       if (current != NULL) {\n\t                                cprintf(\"unhandled trap.\n\t\");\n\t                                do_exit(-E_KILLED);\n\t                       }\n\t                       panic(\"unexpected trap in kernel.\n\t\");\n\t             }\n\t    }\n\t    void\n\t    trap(struct trapframe tf) {\n\t             // used for previous projects\n\t             if (current == NULL) {\n\t                       trap_dispatch(tf);\n\t             }\n\t             else {\n\t                       // keep a trapframe chain in stack\n\t                       struct trapframe otf = current->tf;\n\t                       current->tf = tf;\n\t                       bool in_kernel = trap_in_kernel(tf);\n\t                       ...(5)...\n\t                       current->tf = otf;\n\t                       if (!in_kernel) {\n\t                                if (current->flags & PF_EXITING) {\n\t                                         do_exit(-E_KILLED);\n\t                                }\n\t                                if (current->need_resched) {\n\t                                         schedule();\n\t                                }\n\t                       }\n\t             }\n\t    }\n\t    ...\n\t    ---------------------------------\n\t    kern/syscall/syscall.c\n\t    ---------------------------------\n\t    ...\n\t    static int\n\t    sys_read(uint32_t arg[]) {\n\t             int fd = (int)arg[0];\n\t             size_t len = (size_t)...(6)...;\n\t             void base = (void )...(7)...;\n\t             ...(8a)...\n\t    }\n\t    ...\n\t    static int (syscalls[])(uint32_t arg[]) = {\n\t    ...\n\t             [SYS_read]                               sys_read,\n\t             [SYS_write]                              sys_write,\n\t    ...\n\t             [SYS_mkfifo]                            sys_mkfifo,\n\t    };\n\t    #define NUM_SYSCALLS          ((sizeof(syscalls)) / (sizeof(syscalls[0])))\n\t    void\n\t    syscall(void) {\n\t             struct trapframe tf = current->tf;\n\t             uint32_t arg[5];\n\t             int num = tf->...(8b)...;\n\t             if (num >= 0 && num < NUM_SYSCALLS) {\n\t                       if (syscalls[num] != NULL) {\n\t                                arg[0] = tf->tf_regs.reg_edx;\n\t                                arg[1] = tf->tf_regs.reg_ecx;\n\t                                arg[2] = tf->tf_regs.reg_ebx;\n\t                                arg[3] = tf->tf_regs.reg_edi;\n\t                                arg[4] = tf->tf_regs.reg_esi;\n\t                                tf->tf_regs.reg_eax = ...(9)...;\n\t                                return ;\n\t                       }\n\t             }\n\t             print_trapframe(tf);\n\t             panic(\"undefined syscall %d, pid = %d, name = %s.\n\t\",\n\t                                num, current->pid, current->name);\n\t    }\n\t    ...\n\t    ---------------------------------\n\t    kern/fs/sysfile.c\n\t    ---------------------------------\n\t    ...\n\t    int\n\t    sysfile_read(int fd, void base, size_t len) {\n\t             struct mm_struct mm = current->mm;\n\t             if (len == 0) {\n\t                       return 0;\n\t             }\n\t             if (!file_testfd(fd, 1, 0)) {\n\t                       return -E_INVAL;\n\t             }\n\t             void buffer;\n\t             if ((buffer = kmalloc(IOBUF_SIZE)) == NULL) {\n\t                       return -E_NO_MEM;\n\t             }\n\t             int ret = 0;\n\t             size_t copied = 0, alen;\n\t             while (len != 0) {\n\t                       if ((alen = IOBUF_SIZE) > len) {\n\t                                alen = len;\n\t                       }\n\t                       ret = ...(10)...;\n\t                       if (alen != 0) {\n\t                                lock_mm(mm);\n\t                                {\n\t                                         if (copy_to_user(mm, base, buffer, alen)) {\n\t                                                   assert(len >= alen);\n\t                                                   base += alen, len -= alen, copied += alen;\n\t                                         }\n\t                                         else if (ret == 0) {\n\t                                                   ret = -E_INVAL;\n\t                                         }\n\t                                }\n\t                                unlock_mm(mm);\n\t                       }\n\t                       if (ret != 0 || alen == 0) {\n\t                                goto out;\n\t                       }\n\t             }\n\t    out:\n\t             kfree(buffer);\n\t             if (copied != 0) {\n\t                       return copied;\n\t             }\n\t             return ret;\n\t    }\n\t    ...\n\t    ---------------------------------\n\t    kern/fs/file.c\n\t    ---------------------------------\n\t    ...\n\t    int\n\t    file_read(int fd, void base, size_t len, size_t copied_store) {\n\t             int ret;\n\t             struct file file;\n\t             copied_store = 0;\n\t             if ((ret = fd2file(fd, &file;)) != 0) {\n\t                       return ret;\n\t             }\n\t             if (!file->readable) {\n\t                       return -E_INVAL;\n\t             }\n\t             filemap_acquire(file);\n\t             struct iobuf __iob, iob = iobuf_init(&__iob, base, len, file->pos);\n\t             ret = vop_read(file->node, iob);\n\t             size_t copied = iobuf_used(iob);\n\t             if (file->status == FD_OPENED) {\n\t                       file->pos += copied;\n\t             }\n\t             copied_store = copied;\n\t             filemap_release(file);\n\t             return ret;\n\t    }\n\t    ...\n\t    ---------------------------------\n\t    ```\n    \n",
    "source":"网络",
    "answer":"解释\n",
    "type":"question_answer",
    "q_number":1126
}