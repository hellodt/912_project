{
    "status":"error",
    "knowledge":[
        "启动和中断处理实验"
    ],
    "degree_of_difficulty":1,
    "explain":"解释\n",
    "question":"管程：实现代码填空、读者优先的应用代码完成；\n第四题： 一、 （22分）管程是操作系统提供的一种进程同步机制，利用管程可解决进程间通信时遇到的同步互斥问题。读者-写者问题（Reader-writer\nproblem）是一个经典的同步问题。写者优先的读者-写者问题是指，假定有多个并发的读进程和写进程都要访问一个共享的数据结构，要求：(1)读写互斥；(2)写\n写互斥；(3)允许多个读进程同时访问；(4)只要有写进程提出申请，其后提出申请的读进程就必须等待该写进程完成访问\n。下面是ucore中管程机制和写者优先的读者-写者问题的实现代码。请尝试补全其中所缺的代码，以正确实现管程机制和读者-\n写者间的读写操作协调。提示：文件“cdt_wf.c”中的补全代码可能需要在一处加多行代码，其他需要补全的代码只需要一行，一共有11个空要填。\n    ```\n\t    condition.h\n\t    -----------------------------------------------\n\t    …\n\t    typedef struct {\n\t          int numWaiting;\n\t      int valid;\n\t      wait_queue_t wait_queue;\n\t    } condition_t;\n\t    #define cdtid2cdt(cdt_id)                       \\\n\t        ((condition_t )((uintptr_t)(cdt_id) + KERNBASE))\n\t    #define cdt2cdtid(cdt)                          \\\n\t        ((cdt_t)((uintptr_t)(cdt) - KERNBASE))\n\t    void\n\t    condition_value_init(condition_t cdt) {\n\t      ...(1)...\n\t      cdt->valid=1;\n\t            wait_queue_init(&(cdt->wait_queue));\n\t    }\n\t    int\n\t    condition_init(){\n\t      condition_t cdt;\n\t      if ((cdt = kmalloc(sizeof(condition_t))) != NULL) {\n\t        condition_value_init( cdt );\n\t          }\n\t        if (cdt != NULL) {\n\t              return cdt2cdtid(cdt);\n\t          }\n\t      return -E_INVAL;\n\t    }\n\t    int\n\t    condition_free(cdt_t cdt_id) {\n\t          condition_t cdt = cdtid2cdt(cdt_id);\n\t          int ret = -E_INVAL;\n\t          if (cdt != NULL) {\n\t              bool intr_flag;\n\t              local_intr_save(intr_flag);\n\t              {\n\t                    cdt->valid = 0, ret = 0;\n\t                    wakeup_queue(&(cdt->wait_queue), WT_INTERRUPTED, 1);\n\t              kfree(cdt);\n\t              }\n\t              local_intr_restore(intr_flag);\n\t          }\n\t      return ret;\n\t    }\n\t    int\n\t    condition_wait(cdt_t cdt_id, klock_t kl_id){\n\t      condition_t cdt = cdtid2cdt(cdt_id);\n\t          bool intr_flag;\n\t          local_intr_save(intr_flag);\n\t      ...(2)...\n\t          wait_t __wait, wait = &__wait;\n\t          ...(3)...\n\t          local_intr_restore(intr_flag);\n\t          sys_unlock(kl_id);\n\t          schedule();\n\t          sys_lock(kl_id);\n\t          //local_intr_save(intr_flag);\n\t          //wait_current_del(&(cdt->wait_queue), wait);\n\t          //local_intr_restore(intr_flag);\n\t          if (wait->wakeup_flags != WT_UCONDITION) {\n\t              return wait->wakeup_flags;\n\t          }\n\t          return 0;\n\t    }\n\t    int\n\t    condition_signal(cdt_t cdt_id){\n\t          condition_t cdt = cdtid2cdt(cdt_id);\n\t          if (cdt == NULL) {\n\t        return -E_INVAL;\n\t      }\n\t      bool intr_flag;\n\t          local_intr_save(intr_flag);\n\t      if (cdt->numWaiting > 0) {\n\t              wait_t wait;\n\t              if ((wait = wait_queue_first(&(cdt->wait_queue))) != NULL) {\n\t                    assert(wait->proc->wait_state == WT_UCONDITION);\n\t                    ...(4)...\n\t            }\n\t        ...(5)...\n\t          }\n\t          local_intr_restore(intr_flag);\n\t      return 0;\n\t    }\n\t    …\n\t    -----------------------------------------------\n\t    ulib.c\n\t    -----------------------------------------------\n\t    …\n\t    cdt_t\n\t    cdt_init(){\n\t      return sys_cdt_init();\n\t    }\n\t    int\n\t    cdt_signal(cdt_t cdt_id){\n\t      return sys_cdt_signal(cdt_id);\n\t    }\n\t    int\n\t    cdt_wait(cdt_t cdt_id ,klock_t klock_id){\n\t      return sys_cdt_wait(cdt_id ,klock_id);\n\t    }\n\t    int\n\t    cdt_free(cdt_t cdt_id){\n\t      return sys_cdt_free(cdt_id);\n\t    }\n\t    klock_t\n\t    klock_init(){\n\t      return sys_klock_init();\n\t    }\n\t    int\n\t    klock_aquire(klock_t klock_id){\n\t      return sys_klock_aquire(klock_id);\n\t    }\n\t    int\n\t    klock_release(klock_t klock_id){\n\t      return sys_klock_release(klock_id);\n\t    }\n\t    int\n\t    klock_free(klock_t klock_id){\n\t      return sys_klock_free(klock_id);\n\t    }\n\t    …\n\t    -----------------------------------------------\n\t    cdt_wf.c\n\t    -----------------------------------------------\n\t    …\n\t    int active_reader ;    // # count of active readers\n\t    int active_writer ;  // # count of active writers\n\t    int waiting_reader ;   // # count of waiting readers\n\t    int waiting_writer ;   // # count of waiting writers\n\t    cdt_t cdt_okToRead;\n\t    cdt_t cdt_okToWrite;\n\t    klock_t lock;\n\t    void\n\t    failed(void) {\n\t        cprintf(\"FAIL: T.T\n\t\");\n\t        exit(-1);\n\t    }\n\t    void\n\t    init(void) {\n\t        if ((cdt_okToRead = cdt_init()) < 0 || (cdt_okToWrite = cdt_init()) < 0) {\n\t            failed();\n\t        }\n\t        if ((lock = klock_init()) < 0) {\n\t            failed();\n\t        }\n\t        if ((active_reader = shmem_malloc(sizeof(int))) == NULL || (active_writer = shmem_malloc(sizeof(int))) == NULL\n\t      || (waiting_reader = shmem_malloc(sizeof(int))) == NULL || (waiting_writer = shmem_malloc(sizeof(int))) == NULL) {\n\t            failed();\n\t        }\n\t        active_reader = active_writer = waiting_reader = waiting_writer = 0;\n\t    }\n\t    void\n\t    check_init_value(void) {\n\t        if (cdt_okToRead < 0 || cdt_okToWrite < 0 ) {\n\t      failed();\n\t        }\n\t        if (lock < 0 ) {\n\t            failed();\n\t        }\n\t        if (active_reader != 0 || active_writer != 0 || waiting_reader != 0 || waiting_writer != 0) {\n\t            failed();\n\t        }\n\t    }\n\t    void\n\t    free_wf(void){\n\t      if (  cdt_free(cdt_okToRead) < 0 ||  cdt_free(cdt_okToWrite) < 0 ){\n\t        scprintf(\" conditon free failed! \n\t\");\n\t        exit(-1);\n\t      }\n\t      if (  klock_free(lock) < 0 ){\n\t        scprintf(\" kernal lock free failed! \n\t\");\n\t        exit(-1);\n\t      }\n\t    }\n\t    void\n\t    start_read(void) {\n\t      klock_aquire(lock);\n\t            ...(6)...\n\t            klock_release(lock);\n\t    }\n\t    void\n\t    done_read(void) {\n\t      klock_aquire(lock);\n\t            ...(7)...\n\t      klock_release(lock);\n\t    }\n\t    void\n\t    start_write(void) {\n\t      klock_aquire(lock);\n\t            ...(8)...\n\t      klock_release(lock);\n\t    }\n\t    void\n\t    done_write(void) {\n\t      klock_aquire(lock);\n\t            ...(9)...\n\t            if ((waiting_writer) > 0) {\n\t                 ...(10)...\n\t            }\n\t            else if ((waiting_reader) > 0) {\n\t        int wakecount=0;\n\t        while(...(11)...){\n\t          cdt_signal(cdt_okToRead);\n\t          wakecount++;\n\t        }\n\t            }\n\t      klock_release(lock);\n\t    }\n\t    void\n\t    writer(int id, int time) {\n\t      scprintf(\"writer %d: (pid:%d) arrive \n\t\", id, getpid());\n\t            start_write();\n\t            scprintf(\"    writer_wf %d: (pid:%d) start %d\n\t\", id, getpid(), time);\n\t          sleep(time);\n\t          scprintf(\"    writer_wf %d: (pid:%d) end %d\n\t\", id, getpid(), time);\n\t            done_write();\n\t    }\n\t    void\n\t    reader(int id, int time) {\n\t          scprintf(\"reader %d: (pid:%d) arrive\n\t\", id, getpid());\n\t        start_read();\n\t          scprintf(\"    reader_wf %d: (pid:%d) start %d\n\t\", id, getpid(), time);\n\t          sleep(time);\n\t          scprintf(\"    reader_wf %d: (pid:%d) end %d\n\t\", id, getpid(), time);\n\t      done_read();\n\t    }\n\t    void\n\t    read_test_wf(void) {\n\t    …\n\t    }\n\t    void\n\t    write_test_wf(void) {\n\t    …\n\t    }\n\t    void\n\t    read_write_test_wf(void) {\n\t    …\n\t    }\n\t    int\n\t    main(void) {\n\t        init();\n\t        read_test_wf();\n\t        write_test_wf();\n\t        read_write_test_wf();\n\t        free_wf();\n\t        cprintf(\"condition reader_writer_wf_test pass..\n\t\");\n\t        return 0;\n\t    }\n\t    -----------------------------------------------\n\t    wait.c\n\t    -----------------------------------------------\n\t    …\n\t    void\n\t    wait_init(wait_t wait, struct proc_struct proc) {\n\t        wait->proc = proc;\n\t        wait->wakeup_flags = WT_INTERRUPTED;\n\t        list_init(&(wait->wait_link));\n\t    }\n\t    void\n\t    wait_queue_init(wait_queue_t queue) {\n\t        list_init(&(queue->wait_head));\n\t    }\n\t    void\n\t    wait_queue_add(wait_queue_t queue, wait_t wait) {\n\t        assert(list_empty(&(wait->wait_link)) && wait->proc != NULL);\n\t        wait->wait_queue = queue;\n\t        list_add_before(&(queue->wait_head), &(wait->wait_link));\n\t    }\n\t    void\n\t    wait_queue_del(wait_queue_t queue, wait_t wait) {\n\t        assert(!list_empty(&(wait->wait_link)) && wait->wait_queue == queue);\n\t        list_del_init(&(wait->wait_link));\n\t    }\n\t    wait_t \n\t    wait_queue_next(wait_queue_t queue, wait_t wait) {\n\t        assert(!list_empty(&(wait->wait_link)) && wait->wait_queue == queue);\n\t        list_entry_t le = list_next(&(wait->wait_link));\n\t        if (le != &(queue->wait_head)) {\n\t            return le2wait(le, wait_link);\n\t        }\n\t        return NULL;\n\t    }\n\t    wait_t \n\t    wait_queue_prev(wait_queue_t queue, wait_t wait) {\n\t        assert(!list_empty(&(wait->wait_link)) && wait->wait_queue == queue);\n\t        list_entry_t le = list_prev(&(wait->wait_link));\n\t        if (le != &(queue->wait_head)) {\n\t            return le2wait(le, wait_link);\n\t        }\n\t        return NULL;\n\t    }\n\t    wait_t \n\t    wait_queue_first(wait_queue_t queue) {\n\t        list_entry_t le = list_next(&(queue->wait_head));\n\t        if (le != &(queue->wait_head)) {\n\t            return le2wait(le, wait_link);\n\t        }\n\t        return NULL;\n\t    }\n\t    wait_t \n\t    wait_queue_last(wait_queue_t queue) {\n\t        list_entry_t le = list_prev(&(queue->wait_head));\n\t        if (le != &(queue->wait_head)) {\n\t            return le2wait(le, wait_link);\n\t        }\n\t        return NULL;\n\t    }\n\t    bool\n\t    wait_queue_empty(wait_queue_t queue) {\n\t        return list_empty(&(queue->wait_head));\n\t    }\n\t    bool\n\t    wait_in_queue(wait_t wait) {\n\t        return !list_empty(&(wait->wait_link));\n\t    }\n\t    void\n\t    wakeup_wait(wait_queue_t queue, wait_t wait, uint32_t wakeup_flags, bool del) {\n\t        if (del) {\n\t            wait_queue_del(queue, wait);\n\t        }\n\t        wait->wakeup_flags = wakeup_flags;\n\t        wakeup_proc(wait->proc);\n\t    }\n\t    void\n\t    wakeup_first(wait_queue_t queue, uint32_t wakeup_flags, bool del) {\n\t        wait_t wait;\n\t        if ((wait = wait_queue_first(queue)) != NULL) {\n\t            wakeup_wait(queue, wait, wakeup_flags, del);\n\t        }\n\t    }\n\t    void\n\t    wakeup_queue(wait_queue_t queue, uint32_t wakeup_flags, bool del) {\n\t        wait_t wait;\n\t        if ((wait = wait_queue_first(queue)) != NULL) {\n\t            if (del) {\n\t                do {\n\t                    wakeup_wait(queue, wait, wakeup_flags, 1);\n\t                } while ((wait = wait_queue_first(queue)) != NULL);\n\t            }\n\t            else {\n\t                do {\n\t                    wakeup_wait(queue, wait, wakeup_flags, 0);\n\t                } while ((wait = wait_queue_next(queue, wait)) != NULL);\n\t            }\n\t        }\n\t    }\n\t    void\n\t    wait_current_set(wait_queue_t queue, wait_t wait, uint32_t wait_state) {\n\t        assert(current != NULL);\n\t        wait_init(wait, current);\n\t        current->state = PROC_SLEEPING;\n\t        current->wait_state = wait_state;\n\t        wait_queue_add(queue, wait);\n\t    }\n\t    -----------------------------------------------\n\t    proc.h\n\t    -----------------------------------------------\n\t    …\n\t    //the wait state\n\t    #define WT_CHILD        (0x00000001 | WT_INTERRUPTED)  // wait child process\n\t    #define WT_TIMER        (0x00000002 | WT_INTERRUPTED)  // wait timer\n\t    #define WT_KSWAPD       0x00000003                    // wait kswapd to free page\n\t    #define WT_KSEM         0x00000100                    // wait kernel semaphore\n\t    #define WT_USEM         (0x00000101 | WT_INTERRUPTED)  // wait user semaphore\n\t    #define WT_EVENT_SEND  (0x00000110 | WT_INTERRUPTED)  // wait the sending event\n\t    #define WT_EVENT_RECV  (0x00000111 | WT_INTERRUPTED)  // wait the recving event\n\t    #define WT_MBOX_SEND   (0x00000120 | WT_INTERRUPTED)  // wait the sending mbox\n\t    #define WT_MBOX_RECV   (0x00000121 | WT_INTERRUPTED)  // wait the recving mbox\n\t    #define WT_UCONDITION  (0x00000130 | WT_INTERRUPTED)  // wait user condition    --liuruilin\n\t    #define WT_INTERRUPTED 0x80000000 // the wait state could be interrupted\n\t    …\n\t    -----------------------------------------------\n\t    ```\n    \n",
    "source":"网络",
    "answer":"解释\n",
    "type":"question_answer",
    "q_number":1129
}