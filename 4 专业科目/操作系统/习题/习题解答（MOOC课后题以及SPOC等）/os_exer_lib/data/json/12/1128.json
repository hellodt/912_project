{
    "status":"error",
    "knowledge":[
        "中断、异常与系统调用"
    ],
    "degree_of_difficulty":1,
    "explain":"解释\n",
    "question":"调度算法：\n     第三题：\n    一、   (18分)调度器是操作系统内核中依据调度算法进行进程切换选择的模块。1）试描述时间片轮转算法（Round Robin）的基本原理。2）下面代码是ucore中调度器和时间片轮转算法的实现代码。请补全其中所缺代码，以实现调度器和调度算法的功能。提示：每处需要补全的代码只需要一行，一共有7个空要填。\n    ```\n\t    sched.h\n\t    -----------------------------------------------\n\t    …\n\t    struct proc_struct;\n\t    typedef struct {\n\t      unsigned int expires;\n\t      struct proc_struct proc;\n\t      list_entry_t timer_link;\n\t    } timer_t;\n\t    #define le2timer(le, member)      \\\n\t      to_struct((le), timer_t, member)\n\t    static inline timer_t \n\t    timer_init(timer_t timer, struct proc_struct proc, int expires) {\n\t      timer->expires = expires;\n\t      timer->proc = proc;\n\t      list_init(&(timer->timer_link));\n\t      return timer;\n\t    }\n\t    struct run_queue;\n\t    struct sched_class {\n\t      const char name;\n\t      void (init)(struct run_queue rq);\n\t      void (enqueue)(struct run_queue rq, struct proc_struct proc);\n\t      void (dequeue)(struct run_queue rq, struct proc_struct proc);\n\t      struct proc_struct (pick_next)(struct run_queue rq);\n\t      void (proc_tick)(struct run_queue rq, struct proc_struct proc);\n\t    };\n\t    struct run_queue {\n\t      list_entry_t run_list;\n\t      unsigned int proc_num;\n\t      int max_time_slice;\n\t      list_entry_t rq_link;\n\t    };\n\t    #define le2rq(le, member)     \\\n\t      to_struct((le), struct run_queue, member)\n\t    void sched_init(void);\n\t    void wakeup_proc(struct proc_struct proc);\n\t    void schedule(void);\n\t    void add_timer(timer_t timer);\n\t    void del_timer(timer_t timer);\n\t    void run_timer_list(void);\n\t    extern struct proc_struct idleproc, initproc, current;\n\t    extern struct proc_struct kswapd;\n\t    …\n\t    -----------------------------------------------\n\t    sched.c\n\t    -----------------------------------------------\n\t    …\n\t    static list_entry_t timer_list;\n\t    static struct sched_class sched_class;\n\t    static struct run_queue rq;\n\t    static inline void\n\t    sched_class_enqueue(struct proc_struct proc) {\n\t      if (proc != idleproc) {\n\t        sched_class->enqueue(rq, proc);\n\t      }\n\t    }\n\t    static inline void\n\t    sched_class_dequeue(struct proc_struct proc) {\n\t      sched_class->dequeue(rq, proc);\n\t    }\n\t    static inline struct proc_struct \n\t    sched_class_pick_next(void) {\n\t      return sched_class->pick_next(rq);\n\t    }\n\t    static void\n\t    sched_class_proc_tick(struct proc_struct proc) {\n\t      if (proc != idleproc) {\n\t        sched_class->proc_tick(rq, proc);\n\t      }\n\t      else {\n\t        proc->need_resched = 1;\n\t      }\n\t    }\n\t    static struct run_queue __rq[4];\n\t    void\n\t    sched_init(void) {\n\t      list_init(&timer;_list);\n\t      rq = __rq;\n\t      list_init(&(rq->rq_link));\n\t      rq->max_time_slice = 8;\n\t      int i;\n\t      for (i = 1; i < sizeof(__rq) / sizeof(__rq[0]); i ++) {\n\t        list_add_before(&(rq->rq_link), &(__rq[i].rq_link));\n\t        __rq[i].max_time_slice = rq->max_time_slice  (1 << i);\n\t      }\n\t      sched_class = &MLFQ;_sched_class;\n\t      sched_class->init(rq);\n\t      cprintf(\"sched class: %s\n\t\", sched_class->name);\n\t    }\n\t    void\n\t    wakeup_proc(struct proc_struct proc) {\n\t      assert(proc->state != PROC_ZOMBIE);\n\t      bool intr_flag;\n\t      local_intr_save(intr_flag);\n\t      {\n\t        if (proc->state != PROC_RUNNABLE) {\n\t          proc->state = PROC_RUNNABLE;\n\t          proc->wait_state = 0;\n\t          sched_class_enqueue(proc);\n\t        }\n\t        else {\n\t          warn(\"wakeup runnable process.\n\t\");\n\t        }\n\t      }\n\t      local_intr_restore(intr_flag);\n\t    }\n\t    void\n\t    schedule(void) {\n\t      bool intr_flag;\n\t      struct proc_struct next;\n\t      local_intr_save(intr_flag);\n\t      {\n\t        current->need_resched = 0;\n\t        if (current->state == PROC_RUNNABLE) {\n\t          ...(1)...\n\t        }\n\t        if ((next = sched_class_pick_next()) != NULL) {\n\t          ...(2)...\n\t        }\n\t      }\n\t      local_intr_restore(intr_flag);\n\t      if (next == NULL) {\n\t        next = ...(3)...;\n\t      }\n\t      next->runs ++;\n\t      if (next != current) {\n\t        ...(4)...\n\t      }\n\t    }\n\t    …\n\t    -----------------------------------------------\n\t    sched_RR.c\n\t    -----------------------------------------------\n\t    …\n\t    static void\n\t    RR_init(struct run_queue rq) {\n\t      list_init(&(rq->run_list));\n\t      rq->proc_num = 0;\n\t    }\n\t    static void\n\t    RR_enqueue(struct run_queue rq, struct proc_struct proc) {\n\t      assert(list_empty(&(proc->run_link)));\n\t      list_add_before(&(rq->run_list), &(proc->run_link));\n\t      if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {\n\t        ...(5)...\n\t      }\n\t      proc->rq = rq;\n\t      rq->proc_num ++;\n\t    }\n\t    static void\n\t    RR_dequeue(struct run_queue rq, struct proc_struct proc) {\n\t      assert(!list_empty(&(proc->run_link)) && proc->rq == rq);\n\t      list_del_init(&(proc->run_link));\n\t      rq->proc_num --;\n\t    }\n\t    static struct proc_struct \n\t    RR_pick_next(struct run_queue rq) {\n\t      list_entry_t le = list_next(&(rq->run_list));\n\t      if (le != &(rq->run_list)) {\n\t        return le2proc(le, run_link);\n\t      }\n\t      return NULL;\n\t    }\n\t    static void\n\t    RR_proc_tick(struct run_queue rq, struct proc_struct proc) {\n\t      if (proc->time_slice > 0) {\n\t        ...(6)...\n\t      }\n\t      if (proc->time_slice == 0) {\n\t        ...(7)...\n\t      }\n\t    }\n\t    struct sched_class RR_sched_class = {\n\t      .name = \"RR_scheduler\",\n\t      .init = RR_init,\n\t      .enqueue = RR_enqueue,\n\t      .dequeue = RR_dequeue,\n\t      .pick_next = RR_pick_next,\n\t      .proc_tick = RR_proc_tick,\n\t    };\n\t    -----------------------------------------------\n\t    proc.c\n\t    -----------------------------------------------\n\t    …\n\t    // proc_run - make process \"proc\" running on cpu\n\t    // NOTE: before call switch_to, should load  base addr of \"proc\"'s new PDT\n\t    void\n\t    proc_run(struct proc_struct proc) {\n\t        if (proc != current) {\n\t            bool intr_flag;\n\t            struct proc_struct prev = current, next = proc;\n\t            local_intr_save(intr_flag);\n\t            {\n\t                current = proc;\n\t                load_esp0(next->kstack + KSTACKSIZE);\n\t                lcr3(next->cr3);\n\t                switch_to(&(prev->context), &(next->context));\n\t            }\n\t            local_intr_restore(intr_flag);\n\t        }\n\t    }\n\t    …\n\t    -----------------------------------------------\n\t    ```\n    \n",
    "source":"网络",
    "answer":"解释\n",
    "type":"question_answer",
    "q_number":1128
}