{
    "status":"ok",
    "knowledge":[
        "信号量"
    ],
    "degree_of_difficulty":1,
    "explain":"前面的实现方法中可能出现多个写和读同时等待同一个锁打开，一旦锁打开，会随机挑选一个操作执行，但我们知道在写操作之后加入的读操作是不能在写操作之前执行的，所以\n上述的方法会 有错误产生。 可以考虑建立一个读写操作队列，给队列设置两个队列锁（read锁锁定read操作，write锁锁定write操作），每次挑选队列中\n最早加入的操作执行，由于数组删除很复杂，所以采用循环数组。以信号量实现为例，管程的实现方法也是对前一位同学的代码做出相应类似的修改即可。贴出主要代码(读写队\n列操作部分，monitor不再赘述，跟很多人是一样的)： 变量定义 #define OP_NUM 200; //操作队列上限 int op_num = 0;\n//队列当前等待数目 int op_list[OP_NUM]; //等待队列，奇数为读，偶数为写 int start=0;//队首位置 int\nend=-1;//队尾位置 semaphore_t op_sem;//队首和队尾位置,等待数目锁 semaphore_t\nlist_read_sem;//队列读互斥锁 semaphore_t list_write_sem;//队列写互斥锁 读操作 int read_op(int\nid){ down(&amp;list;_write_sem);//只锁写操作 cprintf(\"No.%d Reader is\nreading\n\",i); do_sleep(50); cprintf(\"No.%d Reader finished reading\n\",i);\nup(&amp;list;_write_sem); cprintf(\"No.%d Reader Sem Proc Quit\n\",i); return 0;\n} 写操作 int write_op(int id){ down(&amp;list;_write_sem);\ndown(&amp;list;_read_sem);//同时锁定读写操作 cprintf(\"No.%d Writer is writing\n\",i);\ndo_sleep(50); cprintf(\"No.%d Writer finished writing\n\",i);\nup(&amp;list;_write_sem); up(&amp;list;_read_sem);//同时解锁 cprintf(\"No.%d Writer\nSem Proc Quit\n\",i); return 0; } 加入操作 int add_op(int id){\ndown(&amp;op;_sem);//锁定队列信息 if(op_num>OP_NUM) return -1;//队列已满\nend=(end+1)%OP_NUM; op_list[end]=id; op_num_sem++; up(&amp;op;_sem); return 0;\n} 队列执行操作 int run_op(){ if(op_num==0) return -1;//队列为空\nif(op_list[start]%2==1){//读操作 read_op(op_list[start]); } else{\nwrite_op(op_list[start]); } down(&amp;op;_sem);//锁住队列信息\nstart=(start+1)%OP_NUM; op_num--; up(&amp;op;_sem); return 0; }\n",
    "question":"\"有一个许多进程共享的数据区，有一些只读这个数据区的进程(reader)和一些只往数据区中写数据的进程(writer)；此外还需满足如下条件：\n1.任意多的读进程可以同时读这个文件。 2.一次只有一个写进程可以往文件中写。 3.如果一个写进程正在往文件中写时，则禁止任何读进程和其他写进程。\n实现基于先来先服务策略的读者－写者的问题，具体要求描述如下： 1.存在m个读者和n个写者，共享同一个缓冲区。\n2.当没有读者在读，写者在写时，读者写者均可进入读或写。 3.当有读者在读时： (1) 写者来了，则写者等待。 (2)\n读者来了，则分两种情况处理：无写者等待，则读者可以直接进入读操作，如果有写者等待，则读者必须依次等待。 4.当有写者在写时，写者或读者来了，均需等待。\n5.当写者写完后，如果等待队列中第一个是写者，则唤醒该写者；如果等待队列中第一个是读者，则唤醒该队列中从读者开始连续的所有读者。\n6.当最后一个读者读后，如果有写者在等待，则唤醒第一个等待的写者。\"\n",
    "source":"网络",
    "answer":"前面的实现方法中可能出现多个写和读同时等待同一个锁打开，一旦锁打开，会随机挑选一个操作执行，但我们知道在写操作之后加入的读操作是不能在写操作之前执行的，所以\n上述的方法会 有错误产生。 可以考虑建立一个读写操作队列，给队列设置两个队列锁（read锁锁定read操作，write锁锁定write操作），每次挑选队列中\n最早加入的操作执行，由于数组删除很复杂，所以采用循环数组。以信号量实现为例，管程的实现方法也是对前一位同学的代码做出相应类似的修改即可。贴出主要代码(读写队\n列操作部分，monitor不再赘述，跟很多人是一样的)： 变量定义 #define OP_NUM 200; //操作队列上限 int op_num = 0;\n//队列当前等待数目 int op_list[OP_NUM]; //等待队列，奇数为读，偶数为写 int start=0;//队首位置 int\nend=-1;//队尾位置 semaphore_t op_sem;//队首和队尾位置,等待数目锁 semaphore_t\nlist_read_sem;//队列读互斥锁 semaphore_t list_write_sem;//队列写互斥锁 读操作 int read_op(int\nid){ down(&amp;list;_write_sem);//只锁写操作 cprintf(\"No.%d Reader is\nreading\n\",i); do_sleep(50); cprintf(\"No.%d Reader finished reading\n\",i);\nup(&amp;list;_write_sem); cprintf(\"No.%d Reader Sem Proc Quit\n\",i); return 0;\n} 写操作 int write_op(int id){ down(&amp;list;_write_sem);\ndown(&amp;list;_read_sem);//同时锁定读写操作 cprintf(\"No.%d Writer is writing\n\",i);\ndo_sleep(50); cprintf(\"No.%d Writer finished writing\n\",i);\nup(&amp;list;_write_sem); up(&amp;list;_read_sem);//同时解锁 cprintf(\"No.%d Writer\nSem Proc Quit\n\",i); return 0; } 加入操作 int add_op(int id){\ndown(&amp;op;_sem);//锁定队列信息 if(op_num>OP_NUM) return -1;//队列已满\nend=(end+1)%OP_NUM; op_list[end]=id; op_num_sem++; up(&amp;op;_sem); return 0;\n} 队列执行操作 int run_op(){ if(op_num==0) return -1;//队列为空\nif(op_list[start]%2==1){//读操作 read_op(op_list[start]); } else{\nwrite_op(op_list[start]); } down(&amp;op;_sem);//锁住队列信息\nstart=(start+1)%OP_NUM; op_num--; up(&amp;op;_sem); return 0; }\n",
    "type":"question_answer",
    "q_number":869
}