{
    "status":"ok",
    "knowledge":[
        "信号量"
    ],
    "degree_of_difficulty":1,
    "explain":"Semaphore 方法\n可把共享缓冲区中的n个缓冲块视为共享资源，生产者写人数据的缓冲块成为消费者可用资源，而消费者读出数据后的缓冲块成为生产者的可用资源。为此，可设\n置三个信号量：itemCounter、vacancyCounter和mutex。其中：\n itemCounter表示有数据的缓冲块数目，初值是0;\n vacancyCounter表示空的缓冲块数初值是n;\n mutex用于访问缓冲区时的互斥，初值是1。\nproducer 伪码\n    ```\n    procedure producer() {\n        while (true) {\n            item = produceItem();\n            vacancyCounter->P();\n                mutex->P();\n                    Add item to buffer;\n                mutex->V();\n            itemCounter->V();\n        }\n    }\n    ```\nconsumer 伪码\n    ```\n    procedure consumer() {\n        while (true) {\n            itemCounter->P();\n                mutex->P();\n                    Remove from buffer;\n                mutex->V();\n            vacancyCounter->V();\n        }\n    }\n    ```\nMonitor 方法\n设置一个管程，内有两个condition variable：notFull和notEmpty。其中，notFull表示缓存满，notEmpty表示缓存空\nproducer 伪码\n    ```\n    procedure producer() {\n        lock->Acquire();\n        while (count == n)\n            notFull.Wait(&lock;);\n        Add c to the buffer;\n        count++;\n        notEmpty.Signal();\n        lock->Release();\n    }\n    ```\nconsumer 伪码\n    ```\n    procedure consumer() {\n        lock->Acquire();\n        while (count == 0)\n            notEmpty.Wait(&lock;);\n        Remove c from buffer;\n        count--;\n        notFull.Signal();\n        lock->Release();\n    }\n    ```\n\n",
    "question":"(操作系统之PV金典)生产者一消费者问题 (producer-consumer problem)，也称有限缓冲问题 (Bounded-buffer\nproblem)，是指若干进程通过有限的共享缓冲区交换数据时的缓冲区资源使用问题。\n假设“生产者”进程不断向共享缓冲区写人数据(即生产数据)，而“消费者”进程不断从共享缓冲区读出数据(即消费数据)；共享缓冲区共有n个；任何时刻\n只能有一个进程可对共享缓冲区进行操作。所有生产者和消费者之间要协调，以完成对共享缓冲区的操作。  \n",
    "source":"网络",
    "answer":"Semaphore 方法\n可把共享缓冲区中的n个缓冲块视为共享资源，生产者写人数据的缓冲块成为消费者可用资源，而消费者读出数据后的缓冲块成为生产者的可用资源。为此，可设\n置三个信号量：itemCounter、vacancyCounter和mutex。其中：\n itemCounter表示有数据的缓冲块数目，初值是0;\n vacancyCounter表示空的缓冲块数初值是n;\n mutex用于访问缓冲区时的互斥，初值是1。\nproducer 伪码\n    ```\n    procedure producer() {\n        while (true) {\n            item = produceItem();\n            vacancyCounter->P();\n                mutex->P();\n                    Add item to buffer;\n                mutex->V();\n            itemCounter->V();\n        }\n    }\n    ```\nconsumer 伪码\n    ```\n    procedure consumer() {\n        while (true) {\n            itemCounter->P();\n                mutex->P();\n                    Remove from buffer;\n                mutex->V();\n            vacancyCounter->V();\n        }\n    }\n    ```\nMonitor 方法\n设置一个管程，内有两个condition variable：notFull和notEmpty。其中，notFull表示缓存满，notEmpty表示缓存空\nproducer 伪码\n    ```\n    procedure producer() {\n        lock->Acquire();\n        while (count == n)\n            notFull.Wait(&lock;);\n        Add c to the buffer;\n        count++;\n        notEmpty.Signal();\n        lock->Release();\n    }\n    ```\nconsumer 伪码\n    ```\n    procedure consumer() {\n        lock->Acquire();\n        while (count == 0)\n            notEmpty.Wait(&lock;);\n        Remove c from buffer;\n        count--;\n        notFull.Signal();\n        lock->Release();\n    }\n    ```\n\n",
    "type":"question_answer",
    "q_number":854
}