{
    "status":"ok",
    "knowledge":[
        "文件系统实验"
    ],
    "degree_of_difficulty":1,
    "explain":"第一问7分，第二问5分；\n1）\n（2分）在inode中的in_info和in_type增加fat32相关表示；\n（2分）在fs中的fs_info和fs_type增加fat32相关信息，并在创建inode时将新的fs赋给in_fs；\n（1分）实现fs中用函数指针定义的所有操作；\n（2分）实现inode_ops中定义的所有操作，并在创建inode时将其赋给in_ops。\n2）打开（2分）、查找、复制和关闭各1分\na. vop_lookup在disk1上查找该文件\nb. vop_open在disk1上打开A.txt；\nc. vop_lookup在disk0上找到待写文件的父目录；\nd. vop_getdirentry在该目录中查找待写文件是否存在，若存在则用vop_open打开，否则用vop_create创建；\ne. vop_read（disk1）和vop_write（disk0）在两个文件之间复制数据；\nf. vop_close分别关闭两个文件。\n",
    "question":"(20140606-期末考试试题&参考答案.docx)VFS\n(12分)uCore的文件管理主要由以下四个部分组成：通用文件系统访问接口层, 文件系统抽象层(VFS), 具体文件系统层以及外设接口层，其中VFS层的作用\n是用来管理不同的文件系统并向上提供一致的接口给内核其他部分访问，在ucore中我们已经实现了一个具体的文件系统：Simple\nFS，并将该文件系统装载到了disk0上，假设ucore又实现了一个文件系统FAT32，并将这个新的文件系统装载到了disk1上。\n1）请简单描述一下如何修改VFS层的数据结构使其可以有效的管理上述已安装的具体文件系统。 涉及VFS层的数据结构如下：\n    ```\n\t    struct file {\n\t        enum {\n\t            FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,\n\t        } status;\n\t        bool readable;\n\t        bool writable;\n\t        int fd;\n\t        off_t pos;\n\t        struct inode node;\n\t        atomic_t open_count;\n\t    };\n\t    struct inode {\n\t        union {\n\t            struct device __device_info;\n\t            struct sfs_inode __sfs_inode_info;\n\t        } in_info;\n\t        enum {\n\t            inode_type_device_info = 0x1234,\n\t            inode_type_sfs_inode_info,\n\t        } in_type;\n\t        atomic_t ref_count;\n\t        atomic_t open_count;\n\t        struct fs in_fs;\n\t        const struct inode_ops in_ops;\n\t    };\n\t    struct fs {\n\t        union {\n\t            struct sfs_fs __sfs_info;\n\t        } fs_info;\n\t        enum {\n\t            fs_type_sfs_info,\n\t        } fs_type;\n\t        int (fs_sync)(struct fs fs);\n\t        struct inode (fs_get_root)(struct fs fs);\n\t        int (fs_unmount)(struct fs fs);\n\t        void (fs_cleanup)(struct fs fs);\n\t    };\n\t    struct inode_ops {\n\t        unsigned long vop_magic;\n\t        int (vop_open)(struct inode node, uint32_t open_flags);\n\t        int (vop_close)(struct inode node);\n\t        int (vop_read)(struct inode node, struct iobuf iob);\n\t        int (vop_write)(struct inode node, struct iobuf iob);\n\t        int (vop_getdirentry)(struct inode node, struct iobuf iob);\n\t        int (vop_create)(struct inode node, const char name, bool excl, struct inode node_store);\n\t        int (vop_lookup)(struct inode node, char path, struct inode node_store);\n\t        ……\n\t    };\n\t    ```\n2）两个具体文件系统均已实现了对数据文件的4种基本操作。现在有某个用户态进程执行了一个copy（source_path, dest_path,...）函数，\n该函数是把disk1根目录下的一个文件A.txt拷贝到了disk0的根目录下（不用考虑文件的大小），请结合ucore中对数据文件的操作流程描述一下这个函数的\n执行过程。  \n",
    "source":"网络",
    "answer":"第一问7分，第二问5分；\n1）\n（2分）在inode中的in_info和in_type增加fat32相关表示；\n（2分）在fs中的fs_info和fs_type增加fat32相关信息，并在创建inode时将新的fs赋给in_fs；\n（1分）实现fs中用函数指针定义的所有操作；\n（2分）实现inode_ops中定义的所有操作，并在创建inode时将其赋给in_ops。\n2）打开（2分）、查找、复制和关闭各1分\na. vop_lookup在disk1上查找该文件\nb. vop_open在disk1上打开A.txt；\nc. vop_lookup在disk0上找到待写文件的父目录；\nd. vop_getdirentry在该目录中查找待写文件是否存在，若存在则用vop_open打开，否则用vop_create创建；\ne. vop_read（disk1）和vop_write（disk0）在两个文件之间复制数据；\nf. vop_close分别关闭两个文件。\n",
    "type":"question_answer",
    "q_number":847
}