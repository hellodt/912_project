{
    "status":"error",
    "knowledge":[
        "文件系统"
    ],
    "degree_of_difficulty":1,
    "explain":"解释\n",
    "question":"在ucore中采用的文件系统是UNIX文件系统UFS的简化版本SFS。请完成如下任务。 1）描述UFS的多级间接索引文件（Multi-level\nIndexed Allocation）的存储结构； 2）补全下面文件系统代码。\n    ```\n\t    kern/fs/sfs/sfs.h\n\t    ---------------------------------\n\t    #ifndef __KERN_FS_SFS_SFS_H__\n\t    #define __KERN_FS_SFS_SFS_H__\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #define SFS_MAGIC                                   0x2f8dbe2a              / magic number for sfs /\n\t    #define SFS_BLKSIZE                                 PGSIZE                  / size of block /\n\t    #define SFS_NDIRECT                                 12                      / # of direct blocks in inode /\n\t    #define SFS_MAX_INFO_LEN                            31                      / max length of infomation /\n\t    #define SFS_MAX_FNAME_LEN                           FS_MAX_FNAME_LEN        / max length of filename /\n\t    #define SFS_MAX_FILE_SIZE                           (1024UL  1024  128)   / max file size (128M) /\n\t    #define SFS_BLKN_SUPER                              0                       / block the superblock lives in /\n\t    #define SFS_BLKN_ROOT                               1                       / location of the root dir inode /\n\t    #define SFS_BLKN_FREEMAP                            2                       / 1st block of the freemap /\n\t    / # of bits in a block /\n\t    #define SFS_BLKBITS                                 (SFS_BLKSIZE  CHAR_BIT)\n\t    / # of entries in a block /\n\t    #define SFS_BLK_NENTRY                              (SFS_BLKSIZE / sizeof(uint32_t))\n\t    / file types /\n\t    #define SFS_TYPE_INVAL                              0       / Should not appear on disk /\n\t    #define SFS_TYPE_FILE                               1\n\t    #define SFS_TYPE_DIR                                2\n\t    #define SFS_TYPE_LINK                               3\n\t    /\n\t      On-disk superblock\n\t     /\n\t    struct sfs_super {\n\t        uint32_t magic;                                 / magic number, should be SFS_MAGIC /\n\t        uint32_t blocks;                                / # of blocks in fs /\n\t        uint32_t unused_blocks;                         / # of unused blocks in fs /\n\t        char info[SFS_MAX_INFO_LEN + 1];                / infomation for sfs  /\n\t    };\n\t    / inode (on disk) /\n\t    struct sfs_disk_inode {\n\t        uint32_t size;                                  / size of the file (in bytes) /\n\t        uint16_t type;                                  / one of SYS_TYPE_ above /\n\t        uint16_t nlinks;                                / # of hard links to this file /\n\t        uint32_t blocks;                                / # of blocks /\n\t        uint32_t direct[SFS_NDIRECT];                   / direct blocks /\n\t        uint32_t indirect;                              / indirect blocks /\n\t    //    uint32_t db_indirect;                           / double indirect blocks /\n\t    //   unused\n\t    };\n\t    / file entry (on disk) /\n\t    struct sfs_disk_entry {\n\t        uint32_t ino;                                   / inode number /\n\t        char name[SFS_MAX_FNAME_LEN + 1];               / file name /\n\t    };\n\t    #define sfs_dentry_size                             \\\n\t        sizeof(((struct sfs_disk_entry )0)->name)\n\t    / inode for sfs /\n\t    struct sfs_inode {\n\t        struct sfs_disk_inode din;                     / on-disk inode /\n\t        uint32_t ino;                                   / inode number /\n\t        bool dirty;                                     / true if inode modified /\n\t        int reclaim_count;                              / kill inode if it hits zero /\n\t        semaphore_t sem;                                / semaphore for din /\n\t        list_entry_t inode_link;                        / entry for linked-list in sfs_fs /\n\t        list_entry_t hash_link;                         / entry for hash linked-list in sfs_fs /\n\t    };\n\t    #define le2sin(le, member)                          \\\n\t        to_struct((le), struct sfs_inode, member)\n\t    / filesystem for sfs /\n\t    struct sfs_fs {\n\t        struct sfs_super super;                         / on-disk superblock /\n\t        struct device dev;                             / device mounted on /\n\t        struct bitmap freemap;                         / blocks in use are mared 0 /\n\t        bool super_dirty;                               / true if super/freemap modified /\n\t        void sfs_buffer;                               / buffer for non-block aligned io /\n\t        semaphore_t fs_sem;                             / semaphore for fs /\n\t        semaphore_t io_sem;                             / semaphore for io /\n\t        semaphore_t mutex_sem;                          / semaphore for link/unlink and rename /\n\t        list_entry_t inode_list;                        / inode linked-list /\n\t        list_entry_t hash_list;                        / inode hash linked-list /\n\t    };\n\t    / hash for sfs /\n\t    #define SFS_HLIST_SHIFT                             10\n\t    #define SFS_HLIST_SIZE                              (1 << SFS_HLIST_SHIFT)\n\t    #define sin_hashfn(x)                               (hash32(x, SFS_HLIST_SHIFT))\n\t    / size of freemap (in bits) /\n\t    #define sfs_freemap_bits(super)                     ROUNDUP((super)->blocks, SFS_BLKBITS)\n\t    / size of freemap (in blocks) /\n\t    #define sfs_freemap_blocks(super)                   ROUNDUP_DIV((super)->blocks, SFS_BLKBITS)\n\t    struct fs;\n\t    struct inode;\n\t    void sfs_init(void);\n\t    int sfs_mount(const char devname);\n\t    void lock_sfs_fs(struct sfs_fs sfs);\n\t    void lock_sfs_io(struct sfs_fs sfs);\n\t    void lock_sfs_mutex(struct sfs_fs sfs);\n\t    void unlock_sfs_fs(struct sfs_fs sfs);\n\t    void unlock_sfs_io(struct sfs_fs sfs);\n\t    void unlock_sfs_mutex(struct sfs_fs sfs);\n\t    int sfs_rblock(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\n\t    int sfs_wblock(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\n\t    int sfs_rbuf(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\n\t    int sfs_wbuf(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\n\t    int sfs_sync_super(struct sfs_fs sfs);\n\t    int sfs_sync_freemap(struct sfs_fs sfs);\n\t    int sfs_clear_block(struct sfs_fs sfs, uint32_t blkno, uint32_t nblks);\n\t    int sfs_load_inode(struct sfs_fs sfs, struct inode node_store, uint32_t ino);\n\t    #endif / !__KERN_FS_SFS_SFS_H__ /\n\t    kern/fs/sfs/sfs_inode.c\n\t    ---------------------------------\n\t    static int\n\t    sfs_bmap_get_sub_nolock(struct sfs_fs sfs, uint32_t entp, uint32_t index, bool create, uint32_t ino_store) {\n\t        assert(index < SFS_BLK_NENTRY);\n\t        int ret;\n\t        uint32_t ent, ino = 0;\n\t        off_t offset = index  sizeof(uint32_t);\n\t        if ((ent = entp) != 0) {\n\t            if ((ret = sfs_rbuf(sfs, &ino;, sizeof(uint32_t), ent, offset)) != 0) {\n\t                ___(1)___\n\t                return ret;\n\t            }\n\t            if (ino != 0 || !create) {\n\t                goto out;\n\t            }\n\t        }\n\t        else {\n\t            if (!create) {\n\t                goto out;\n\t            }\n\t            if ((ret = sfs_block_alloc(sfs, &ent;)) != 0) {\n\t                return ret;\n\t            }\n\t        }\n\t        if ((ret = sfs_block_alloc(sfs, &ino;)) != 0) {\n\t            goto failed_cleanup;\n\t        }\n\t        if ((ret = sfs_wbuf(sfs, &ino;, sizeof(uint32_t), ent, offset)) != 0) {\n\t             ___(2)___\n\t            sfs_block_free(sfs, ino);\n\t            goto failed_cleanup;\n\t        }\n\t    out:\n\t        if (ent != entp) {\n\t            entp = ent;\n\t        }\n\t        ino_store = ino;\n\t        return 0;\n\t    failed_cleanup:\n\t        if (ent != entp) {\n\t            sfs_block_free(sfs, ent);\n\t        }\n\t        return ret;\n\t    }\n\t    static int\n\t    sfs_bmap_get_nolock(struct sfs_fs sfs, struct sfs_inode sin, uint32_t index, bool create, uint32_t ino_store) {\n\t        struct sfs_disk_inode din = sin->din;\n\t        int ret;\n\t        uint32_t ent, ino;\n\t        if (index < SFS_NDIRECT) {\n\t             ___(3)___\n\t            if ((ino = din->direct[index]) == 0 && create) {\n\t                if ((ret = sfs_block_alloc(sfs, &ino;)) != 0) {\n\t                    return ret;\n\t                }\n\t                din->direct[index] = ino;\n\t                sin->dirty = 1;\n\t            }\n\t            goto out;\n\t        }\n\t        index -= SFS_NDIRECT;\n\t             ___(4)___\n\t        if (index < SFS_BLK_NENTRY) {\n\t            ent = din->indirect;\n\t            if ((ret = sfs_bmap_get_sub_nolock(sfs, &ent;, index, create, &ino;)) != 0) {\n\t             ___(5)___\n\t                return ret;\n\t            }\n\t            if (ent != din->indirect) {\n\t                assert(din->indirect == 0);\n\t                din->indirect = ent;\n\t                sin->dirty = 1;\n\t            }\n\t            goto out;\n\t        }\n\t        index -= SFS_BLK_NENTRY;\n\t             ___(6)___\n\t        if ((ent = ino) != 0) {\n\t            if ((ret = sfs_bmap_get_sub_nolock(sfs, &ent;, index % SFS_BLK_NENTRY, create, &ino;)) != 0) {\n\t                return ret;\n\t            }\n\t        }\n\t    out:\n\t        assert(ino == 0 || sfs_block_inuse(sfs, ino));\n\t        ino_store = ino;\n\t        return 0;\n\t    }\n\t    static int\n\t    sfs_io_nolock(struct sfs_fs sfs, struct sfs_inode sin, void buf, off_t offset, size_t alenp, bool write) {\n\t        struct sfs_disk_inode din = sin->din;\n\t        assert(din->type != SFS_TYPE_DIR);\n\t        off_t endpos = offset + alenp, blkoff;\n\t        alenp = 0;\n\t        if (offset < 0 || offset >= SFS_MAX_FILE_SIZE || offset > endpos) {\n\t            return -E_INVAL;\n\t        }\n\t        if (offset == endpos) {\n\t            return 0;\n\t        }\n\t        if (endpos > SFS_MAX_FILE_SIZE) {\n\t            endpos = SFS_MAX_FILE_SIZE;\n\t        }\n\t        if (!write) {\n\t            if (offset >= din->size) {\n\t                return 0;\n\t            }\n\t            if (endpos > din->size) {\n\t                endpos = din->size;\n\t            }\n\t        }\n\t        int (sfs_buf_op)(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\n\t        int (sfs_block_op)(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\n\t        if (write) {\n\t            sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;\n\t             ___(7)___\n\t        }\n\t        else {\n\t            sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;\n\t        }\n\t        int ret = 0;\n\t        size_t size, alen = 0;\n\t        uint32_t ino;\n\t        uint32_t blkno = offset / SFS_BLKSIZE;\n\t        uint32_t nblks = endpos / SFS_BLKSIZE - blkno;\n\t        if ((blkoff = offset % SFS_BLKSIZE) != 0) {\n\t            size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);\n\t            if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino;)) != 0) {\n\t                goto out;\n\t            }\n\t            if ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != 0) {\n\t             ___(8)___\n\t                goto out;\n\t            }\n\t            alen += size;\n\t            if (nblks == 0) {\n\t                goto out;\n\t            }\n\t            buf += size, blkno ++, nblks --;\n\t        }\n\t        size = SFS_BLKSIZE;\n\t        while (nblks != 0) {\n\t            if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino;)) != 0) {\n\t                goto out;\n\t            }\n\t            if ((ret = sfs_block_op(sfs, buf, ino, 1)) != 0) {\n\t                goto out;\n\t            }\n\t            alen += size, buf += size, blkno ++, nblks --;\n\t        }\n\t        if ((size = endpos % SFS_BLKSIZE) != 0) {\n\t            if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino;)) != 0) {\n\t                goto out;\n\t            }\n\t            if ((ret = sfs_buf_op(sfs, buf, size, ino, 0)) != 0) {\n\t                goto out;\n\t            }\n\t            alen += size;\n\t        }\n\t    out:\n\t        alenp = alen;\n\t        if (offset + alen > sin->din->size) {\n\t            sin->din->size = offset + alen;\n\t            sin->dirty = 1;\n\t        }\n\t        return ret;\n\t    }\n\t    static int\n\t    sfs_read(struct inode node, struct iobuf iob) {\n\t        return sfs_io(node, iob, 0);\n\t             ___(9)___\n\t    }\n\t    static int\n\t    sfs_write(struct inode node, struct iobuf iob) {\n\t        return sfs_io(node, iob, 1);\n\t             ___(10)___\n\t    }\n\t    static inline int\n\t    sfs_io(struct inode node, struct iobuf iob, bool write) {\n\t        struct sfs_fs sfs = fsop_info(vop_fs(node), sfs);\n\t        struct sfs_inode sin = vop_info(node, sfs_inode);\n\t        int ret;\n\t        lock_sin(sin);\n\t        {\n\t            size_t alen = iob->io_resid;\n\t            ret = sfs_io_nolock(sfs, sin, iob->io_base, iob->io_offset, &alen;, write);\n\t             ___(11)___\n\t            if (alen != 0) {\n\t                iobuf_skip(iob, alen);\n\t            }\n\t        }\n\t        unlock_sin(sin);\n\t        return ret;\n\t    }\n\t    static const struct inode_ops sfs_node_dirops = {\n\t        .vop_magic                      = VOP_MAGIC,\n\t        .vop_open                       = sfs_opendir,\n\t        .vop_close                      = sfs_close,\n\t        .vop_read                       = NULL_VOP_ISDIR,\n\t        .vop_write                      = NULL_VOP_ISDIR,\n\t        .vop_fstat                      = sfs_fstat,\n\t        .vop_fsync                      = sfs_fsync,\n\t        .vop_mkdir                      = NULL_VOP_UNIMP,\n\t        .vop_link                       = NULL_VOP_UNIMP,\n\t        .vop_rename                     = NULL_VOP_UNIMP,\n\t        .vop_readlink                   = NULL_VOP_ISDIR,\n\t        .vop_symlink                    = NULL_VOP_UNIMP,\n\t        .vop_namefile                   = sfs_namefile,\n\t        .vop_getdirentry                = sfs_getdirentry,\n\t        .vop_reclaim                    = sfs_reclaim,\n\t        .vop_ioctl                      = NULL_VOP_INVAL,\n\t        .vop_gettype                    = sfs_gettype,\n\t        .vop_tryseek                    = NULL_VOP_ISDIR,\n\t        .vop_truncate                   = NULL_VOP_UNIMP,\n\t        .vop_create                     = NULL_VOP_UNIMP,\n\t        .vop_unlink                     = NULL_VOP_UNIMP,\n\t        .vop_lookup                     = sfs_lookup,\n\t        .vop_lookup_parent              = NULL_VOP_UNIMP,\n\t    };\n\t    static const struct inode_ops sfs_node_fileops = {\n\t        .vop_magic                      = VOP_MAGIC,\n\t        .vop_open                       = sfs_openfile,\n\t        .vop_close                      = sfs_close,\n\t        .vop_read                       = sfs_read,\n\t        .vop_write                      = sfs_write,\n\t        .vop_fstat                      = sfs_fstat,\n\t        .vop_fsync                      = sfs_fsync,\n\t        .vop_mkdir                      = NULL_VOP_NOTDIR,\n\t        .vop_link                       = NULL_VOP_NOTDIR,\n\t        .vop_rename                     = NULL_VOP_NOTDIR,\n\t        .vop_readlink                   = NULL_VOP_NOTDIR,\n\t        .vop_symlink                    = NULL_VOP_NOTDIR,\n\t        .vop_namefile                   = NULL_VOP_NOTDIR,\n\t        .vop_getdirentry                = NULL_VOP_NOTDIR,\n\t        .vop_reclaim                    = sfs_reclaim,\n\t        .vop_ioctl                      = NULL_VOP_INVAL,\n\t        .vop_gettype                    = sfs_gettype,\n\t        .vop_tryseek                    = sfs_tryseek,\n\t        .vop_truncate                   = sfs_truncfile,\n\t        .vop_create                     = NULL_VOP_NOTDIR,\n\t        .vop_unlink                     = NULL_VOP_NOTDIR,\n\t        .vop_lookup                     = NULL_VOP_NOTDIR,\n\t        .vop_lookup_parent              = NULL_VOP_NOTDIR,\n\t    };\n\t    ```\n    \n",
    "source":"网络",
    "answer":"解释\n",
    "type":"question_answer",
    "q_number":655
}