{
    "status":"error",
    "knowledge":[
        "处理机调度"
    ],
    "degree_of_difficulty":1,
    "explain":"解释\n",
    "question":"调度器是操作系统内核中依据调度算法进行进程切换选择的模块。请完成如下任务。\n1）试描述步进调度算法(Stride Scheduling)的基本原理。\n2）请给出下面测试程序（user/priority.c）执行时的进程调度顺序。建议说明每次进程切换后当前执行进程的ID、lab6_priority、lab6\n_stride和已切换次数。\n    ```\n\t    kern/process/proc.h\n\t    ---------------------------------\n\t    ...\n\t    struct proc_struct {\n\t        enum proc_state state;                      // Process state\n\t        int pid;                                    // Process ID\n\t        int runs;                                   // the running times of Proces\n\t        uintptr_t kstack;                           // Process kernel stack\n\t        volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?\n\t        struct proc_struct parent;                 // the parent process\n\t        struct mm_struct mm;                       // Process's memory management field\n\t        struct context context;                     // Switch here to run process\n\t        struct trapframe tf;                       // Trap frame for current interrupt\n\t        uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)\n\t        uint32_t flags;                             // Process flag\n\t        char name[PROC_NAME_LEN + 1];               // Process name\n\t        list_entry_t list_link;                     // Process link list\n\t        list_entry_t hash_link;                     // Process hash list\n\t        int exit_code;                              // exit code (be sent to parent proc)\n\t        uint32_t wait_state;                        // waiting state\n\t        struct proc_struct cptr, yptr, optr;     // relations between processes\n\t        struct run_queue rq;                       // running queue contains Process\n\t        list_entry_t run_link;                      // the entry linked in run queue\n\t        int time_slice;                             // time slice for occupying the CPU\n\t        skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool\n\t        uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process\n\t        uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)\n\t    };\n\t    user/priority.c\n\t    ---------------------------------\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #define TOTAL 6\n\t    / to get enough accuracy, MAX_TIME (the running time of each process) should >1000 mseconds. /\n\t    #define MAX_TIME  2000\n\t    unsigned int acc[TOTAL];\n\t    int status[TOTAL];\n\t    int pids[TOTAL];\n\t    static void\n\t    spin_delay(void)\n\t    {\n\t         int i;\n\t         volatile int j;\n\t         for (i = 0; i != 200; ++ i)\n\t         {\n\t              j = !j;\n\t         }\n\t    }\n\t    int\n\t    main(void) {\n\t         int i,time;\n\t         memset(pids, 0, sizeof(pids));\n\t         lab6_set_priority(TOTAL + 1);\n\t         for (i = 0; i < TOTAL; i ++) {\n\t              acc[i]=0;\n\t              if ((pids[i] = fork()) == 0) {\n\t                   lab6_set_priority(i + 1);\n\t                   acc[i] = 0;\n\t                   while (1) {\n\t                        spin_delay();\n\t                        ++ acc[i];\n\t                        if(acc[i]%4000==0) {\n\t                            if((time=gettime_msec())>MAX_TIME) {\n\t                                cprintf(\"child pid %d, acc %d, time %d\n\t\",getpid(),acc[i],time);\n\t                                exit(acc[i]);\n\t                            }\n\t                        }\n\t                   }\n\t              }\n\t              if (pids[i] < 0) {\n\t                   goto failed;\n\t              }\n\t         }\n\t         cprintf(\"main: fork ok,now need to wait pids.\n\t\");\n\t         for (i = 0; i < TOTAL; i ++) {\n\t             status[i]=0;\n\t             waitpid(pids[i],&status;[i]);\n\t             cprintf(\"main: pid %d, acc %d, time %d\n\t\",pids[i],status[i],gettime_msec());\n\t         }\n\t         cprintf(\"main: wait pids over\n\t\");\n\t         cprintf(\"stride sched correct result:\");\n\t         for (i = 0; i < TOTAL; i ++)\n\t         {\n\t             cprintf(\" %d\", (status[i]  2 / status[0] + 1) / 2);\n\t         }\n\t         cprintf(\"\n\t\");\n\t         return 0;\n\t    failed:\n\t         for (i = 0; i < TOTAL; i ++) {\n\t              if (pids[i] > 0) {\n\t                   kill(pids[i]);\n\t              }\n\t         }\n\t         panic(\"FAIL: T.T\n\t\");\n\t    }\n\t    ```\n    \n",
    "source":"网络",
    "answer":"解释\n",
    "type":"question_answer",
    "q_number":652
}