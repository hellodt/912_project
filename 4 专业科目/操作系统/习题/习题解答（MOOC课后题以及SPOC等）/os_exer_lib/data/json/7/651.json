{
    "status":"ok",
    "knowledge":[
        "缺页中断"
    ],
    "degree_of_difficulty":1,
    "explain":"1）缺页故障的处理流程：每点2分，共8分； 中断、权限检查、分配空闲页面并加载、没有空闲页面时的转换 2）7个填空，每个1分，变量不对扣0.5分，共7分；\n",
    "question":"在虚拟存储系统中，当由虚拟地址找不到对应的物理地址时，会产生缺页故障。请完成如下任务。 1）描述缺页故障（page_fault）的处理流程；\n2）补全下面缺页处理中所缺代码。\n    ```\n\t    kern/trap/trap.c\n\t    ---------------------------------\n\t    ...\n\t    static int\n\t    pgfault_handler(struct trapframe tf) {\n\t        extern struct mm_struct check_mm_struct;\n\t        if(check_mm_struct !=NULL) { //used for test check_swap\n\t                print_pgfault(tf);\n\t            }\n\t        struct mm_struct mm;\n\t        if (check_mm_struct != NULL) {\n\t            assert(current == idleproc);\n\t            mm = check_mm_struct;\n\t        }\n\t        else {\n\t            if (current == NULL) {\n\t                print_trapframe(tf);\n\t                print_pgfault(tf);\n\t                panic(\"unhandled page fault.\n\t\");\n\t            }\n\t            mm = current->mm;\n\t        }\n\t        return do_pgfault(mm, tf->tf_err, rcr2());\n\t             ____(1)____\n\t    }\n\t    ...\n\t    static void\n\t    trap_dispatch(struct trapframe tf) {\n\t        char c;\n\t        int ret=0;\n\t        switch (tf->tf_trapno) {\n\t        case T_DEBUG:\n\t        case T_BRKPT:\n\t            debug_monitor(tf);\n\t            break;\n\t        case T_PGFLT:\n\t            if ((ret = pgfault_handler(tf)) != 0) {\n\t             ___(2)___\n\t                print_trapframe(tf);\n\t                if (current == NULL) {\n\t                    panic(\"handle pgfault failed. ret=%d\n\t\", ret);\n\t                }\n\t                else {\n\t                    if (trap_in_kernel(tf)) {\n\t                        panic(\"handle pgfault failed in kernel mode. ret=%d\n\t\", ret);\n\t                    }\n\t                    cprintf(\"killed by kernel.\n\t\");\n\t                    panic(\"handle user mode pgfault failed. ret=%d\n\t\", ret);\n\t                    do_exit(-E_KILLED);\n\t                }\n\t            }\n\t            break;\n\t        case T_SYSCALL:\n\t            syscall();\n\t            break;\n\t        case IRQ_OFFSET + IRQ_TIMER:\n\t    //    LAB3 : If some page replacement algorithm need tick to change the priority of pages,\n\t    //    then you can add code here.\n\t            ticks ++;\n\t            assert(current != NULL);\n\t            run_timer_list();\n\t            break;\n\t        case IRQ_OFFSET + IRQ_COM1:\n\t        case IRQ_OFFSET + IRQ_KBD:\n\t            if ((c = cons_getc()) == 13) {\n\t                debug_monitor(tf);\n\t            }\n\t            else {\n\t                cprintf(\"%s [%03d] %c\n\t\",\n\t                        (tf->tf_trapno != IRQ_OFFSET + IRQ_KBD) ? \"serial\" : \"kbd\", c, c);\n\t            }\n\t            break;\n\t        case IRQ_OFFSET + IRQ_IDE1:\n\t        case IRQ_OFFSET + IRQ_IDE2:\n\t            / do nothing /\n\t            break;\n\t        default:\n\t            print_trapframe(tf);\n\t            if (current != NULL) {\n\t                cprintf(\"unhandled trap.\n\t\");\n\t                do_exit(-E_KILLED);\n\t            }\n\t            // in kernel, it must be a mistake\n\t            panic(\"unexpected trap in kernel.\n\t\");\n\t        }\n\t    }\n\t    kern/mm/vmm.c\n\t    ---------------------------------\n\t    // do_pgfault - interrupt handler to process the page fault execption\n\t    int\n\t    do_pgfault(struct mm_struct mm, uint32_t error_code, uintptr_t addr) {\n\t        int ret = -E_INVAL;\n\t        struct vma_struct vma = find_vma(mm, addr);\n\t        pgfault_num++;\n\t        if (vma == NULL ) {\n\t            cprintf(\"not valid addr %x, and  can not find it vma %x\n\t\", addr, vma);\n\t            goto failed;\n\t        }\n\t        else if (vma->vm_start > addr) {\n\t            cprintf(\"not valid addr %x, and  can not find it vma range[%x, %x]\n\t\", addr, vma->vm_start, vma->vm_end);\n\t            goto failed;\n\t        }\n\t        cprintf(\"valid addr %x, and find it in vma range[%x, %x]\n\t\", addr, vma->vm_start, vma->vm_end);\n\t        switch (error_code & 3) {\n\t        default:\n\t                / default is 3: write, present /\n\t        case 2: / write, not present /\n\t            if (!(vma->vm_flags & VM_WRITE)) {\n\t                cprintf(\"write, not present in do_pgfault failed\n\t\");\n\t                goto failed;\n\t            }\n\t            break;\n\t        case 1: / read, present /\n\t            cprintf(\"read, present in do_pgfault failed\n\t\");\n\t            goto failed;\n\t        case 0: / read, not present /\n\t            if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {\n\t                cprintf(\"read, not present in do_pgfault failed\n\t\");\n\t                goto failed;\n\t            }\n\t        }\n\t        uint32_t perm = PTE_U;\n\t        if (vma->vm_flags & VM_WRITE) {\n\t            perm |= PTE_W;\n\t        }\n\t        addr = ROUNDDOWN(addr, PGSIZE);\n\t        ret = -E_NO_MEM;\n\t        pte_t ptep;\n\t        // try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.\n\t        // (notice the 3th parameter '1')\n\t        if ((ptep = get_pte(mm->pgdir, addr, 1)) == NULL) {\n\t            cprintf(\"get_pte in do_pgfault failed\n\t\");\n\t            goto failed;\n\t        }\n\t        if (ptep == 0) { // if the phy addr isn't exist, then alloc a page & map the phy addr with logical addr\n\t            if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {\n\t             ___(3)___\n\t                cprintf(\"pgdir_alloc_page in do_pgfault failed\n\t\");\n\t                goto failed;\n\t            }\n\t        }\n\t        else {\n\t            struct Page page=NULL;\n\t            cprintf(\"do pgfault: ptep %x, pte %x\n\t\",ptep, ptep);\n\t            if (ptep & PTE_P) {\n\t                page = pte2page(ptep);\n\t             ___(4)___\n\t            } else{\n\t               // if this pte is a swap entry, then load data from disk to a page with phy addr\n\t               // and call page_insert to map the phy addr with logical addr\n\t               if(swap_init_ok) {\n\t                   if ((ret = swap_in(mm, addr, &page;)) != 0) {\n\t             ___(5)___\n\t                       cprintf(\"swap_in in do_pgfault failed\n\t\");\n\t                       goto failed;\n\t                   }\n\t               }\n\t               else {\n\t                cprintf(\"no swap_init_ok but ptep is %x, failed\n\t\",ptep);\n\t                goto failed;\n\t               }\n\t           }\n\t           page_insert(mm->pgdir, page, addr, perm);\n\t           swap_map_swappable(mm, addr, page, 1);\n\t       }\n\t       ret = 0;\n\t    failed:\n\t        return ret;\n\t    }\n\t    kern/mm/swap.c\n\t    ---------------------------------\n\t    ...\n\t    int\n\t    swap_out(struct mm_struct mm, int n, int in_tick)\n\t    {\n\t         int i;\n\t         for (i = 0; i != n; ++ i)\n\t         {\n\t              uintptr_t v;\n\t              //struct Page ptr_page=NULL;\n\t              struct Page page;\n\t              // cprintf(\"i %d, SWAP: call swap_out_victim\n\t\",i);\n\t              int r = sm->swap_out_victim(mm, &page;, in_tick);\n\t              if (r != 0) {\n\t                      cprintf(\"i %d, swap_out: call swap_out_victim failed\n\t\",i);\n\t                      break;\n\t              }\n\t              //assert(!PageReserved(page));\n\t              //cprintf(\"SWAP: choose victim page 0x%08x\n\t\", page);\n\t              v=page->pra_vaddr;\n\t              pte_t ptep = get_pte(mm->pgdir, v, 0);\n\t              assert((ptep & PTE_P) != 0);\n\t              if (swapfs_write( (page->pra_vaddr/PGSIZE+1)<<8, page) != 0) {\n\t             ___(6)___\n\t                        cprintf(\"SWAP: failed to save\n\t\");\n\t                        sm->map_swappable(mm, v, page, 0);\n\t                        continue;\n\t              }\n\t              else {\n\t                        cprintf(\"swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n\t\", i, v, page->pra_vaddr/PGSIZE+1);\n\t                        ptep = (page->pra_vaddr/PGSIZE+1)<<8;\n\t                        free_page(page);\n\t              }\n\t              tlb_invalidate(mm->pgdir, v);\n\t         }\n\t         return i;\n\t    }\n\t    int\n\t    swap_in(struct mm_struct mm, uintptr_t addr, struct Page ptr_result)\n\t    {\n\t         struct Page result = alloc_page();\n\t         assert(result!=NULL);\n\t         pte_t ptep = get_pte(mm->pgdir, addr, 0);\n\t         // cprintf(\"SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n\t\", ptep, (ptep)>>8, addr, result, (result-pages));\n\t         int r;\n\t         if ((r = swapfs_read((ptep), result)) != 0)\n\t             ___(7)___\n\t         {\n\t            assert(r!=0);\n\t         }\n\t         cprintf(\"swap_in: load disk swap entry %d with swap_page in vadr 0x%x free_area.nr_free %d\n\t\", (ptep)>>8, addr, free_area.nr_free);\n\t         ptr_result=result;\n\t         return 0;\n\t    }\n\t    kern/mm/pmm.h\n\t    ---------------------------------\n\t    ...\n\t    #define alloc_page() alloc_pages(1)\n\t    #define free_page(page) free_pages(page, 1)\n\t    kern/mm/pmm.c\n\t    ---------------------------------\n\t    ...\n\t    // pgdir_alloc_page - call alloc_page & page_insert functions to\n\t    //                  - allocate a page size memory & setup an addr map\n\t    //                  - pa<->la with linear address la and the PDT pgdir\n\t    struct Page \n\t    pgdir_alloc_page(pde_t pgdir, uintptr_t la, uint32_t perm) {\n\t        struct Page page = alloc_page();\n\t        if (page != NULL) {\n\t            if (page_insert(pgdir, page, la, perm) != 0) {\n\t                free_page(page);\n\t                return NULL;\n\t            }\n\t            if (swap_init_ok){\n\t                if(check_mm_struct!=NULL) {\n\t                    swap_map_swappable(check_mm_struct, la, page, 0);\n\t                    page->pra_vaddr=la;\n\t                    assert(page_ref(page) == 1);\n\t                    //cprintf(\"get No. %d  page: pra_vaddr %x, pra_link.prev %x, pra_link_next %x in pgdir_alloc_page\n\t\", (page-pages), page->pra_vaddr,page->pra_page_link.prev, page->pra_page_link.next);\n\t                }\n\t                else  {  //now current is existed, should fix it in the future\n\t                    //swap_map_swappable(current->mm, la, page, 0);\n\t                    //page->pra_vaddr=la;\n\t                    //assert(page_ref(page) == 1);\n\t                    //panic(\"pgdir_alloc_page: no pages. now current is existed, should fix it in the future\n\t\");\n\t                }\n\t            }\n\t        }\n\t        return page;\n\t    }\n\t    kern/fs/swapfs.c\n\t    ---------------------------------\n\t    ...\n\t    int\n\t    swapfs_read(swap_entry_t entry, struct Page page) {\n\t        return ide_read_secs(SWAP_DEV_NO, swap_offset(entry)  PAGE_NSECT, page2kva(page), PAGE_NSECT);\n\t    }\n\t    int\n\t    swapfs_write(swap_entry_t entry, struct Page page) {\n\t        return ide_write_secs(SWAP_DEV_NO, swap_offset(entry)  PAGE_NSECT, page2kva(page), PAGE_NSECT);\n\t    }\n\t    kern/mm/swap_fifo.c\n\t    ---------------------------------\n\t    ...\n\t    struct swap_manager swap_manager_fifo =\n\t    {\n\t         .name            = \"fifo swap manager\",\n\t         .init            = &_fifo_init,\n\t         .init_mm         = &_fifo_init_mm,\n\t         .tick_event      = &_fifo_tick_event,\n\t         .map_swappable   = &_fifo_map_swappable,\n\t         .set_unswappable = &_fifo_set_unswappable,\n\t         .swap_out_victim = &_fifo_swap_out_victim,\n\t         .check_swap      = &_fifo_check_swap,\n\t    };\n\t    ```\n    \n",
    "source":"网络",
    "answer":"1）缺页故障的处理流程：每点2分，共8分； 中断、权限检查、分配空闲页面并加载、没有空闲页面时的转换 2）7个填空，每个1分，变量不对扣0.5分，共7分；\n",
    "type":"question_answer",
    "q_number":651
}