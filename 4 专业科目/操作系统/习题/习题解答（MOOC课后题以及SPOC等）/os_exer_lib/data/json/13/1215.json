{
    "status":"ok",
    "knowledge":[
        "中断、异常与系统调用"
    ],
    "degree_of_difficulty":1,
    "explain":"C 应用程序一般无法直接访问硬件，也无法执行特权指令。所以，需要通过操作系统来间接完成相关的工作。而基于安全和可靠性的需求，\n应用程序运行在用户态，操作系统内核运行在内核态，导致应用程序无法通过函数调用来访问操作系统提供的各种服务，\n于是通过系统调用的方式就成了应用程序向OS发出请求并获得服务反馈的唯一通道和接口。 以ucore OS为例，在lab1的challenge练习中和lab5中，\n系统调用机制的初始化也是通过建立中断向量表来完成的（可查看lab1的challenge的答案中在trap.c中idt_init函数的实现），\n中断向量表描述了但应用程序产生一个用于系统调用的中断号时，对应的中断服务例程的具体虚拟地址在哪里，\n即建立了系统调用的中断号和中断服务例程的对应关系。这样当应用程序发出类似 “int 0x80”这样的指令时（可查看lab1的challenge的答案中在init.c中lab1_switch_to_kernel函数的实现），操作系统的中断服务例程会被调用，\n并完成相应的服务（可查看lab1的challenge的答案中在trap.c中trap_dispatch函数有关“case T_SWITCH_TOK:”的实现）。\n",
    "question":"系统调用的主要作用是（）\n",
    "source":"网络",
    "answer":"C",
    "type":"single_answer",
    "options":[
        "A.处理硬件问题",
        "B.应对软件异常",
        "C.给应用程序提供服务接口",
        "D.管理应用程序"
    ],
    "q_number":1215
}