{
    "status":"ok",
    "knowledge":[
        ""
    ],
    "question":"下面是采用信号量实现的管程机制的伪码。\n\n```\n 0 IMPLEMENTATION:\n 1   monitor mt {\n 2     -----variable in monitor-----------\n 3     semaphore mutex;                             // the mutex lock for going into the routines in monitor, should be initialized to 1\n 4     semaphore next;                              // the next  is used to down the signaling proc, some proc should wake up the sleeped cv.signaling proc. should be initialized to 0 \n 5     int next_count;                              // the number of of sleeped signaling proc, should be initialized to 0\n 6     condvar {int count, sempahore sem}  cv[N];   // the condvars in monitor, count initial value 0, sem initial value 0\n 7     other shared variables in mt;                // shared variables should protected by mutex lock\n 8     --------condvar wait---------------\n 9     cond_wait (cv) {\n 10         cv.count ++;\n 11        if(mt.next_count>0)\n 12           V(mt.next)                            // first perform the EXIT PROTOCOL \n 13        else\n 14           V(mt.mutex);\n 15        P(cv.sem);                               // now wait on the condition waiting queue (cv.sem)\n 16        cv.count --;\n 17     }\n 18    --------condvar signal--------------\n 19     cond_signal(cv) {\n 20         if(cv.count>0) {                       　// do nothing unless a process is waiting on condition waiting queue (cv.sem)\n 21            mt.next_count ++;\n 22            V(cv.sem);                     　     //　release the  waiting process which on  condition waiting queue (cv.sem)\n 23            P(mt.next);                          // wait on the \"next\" waiting queue for cv.signaling proc\n 24            mt.next_count--;\n 25         }\n 26      }\n 27    --------routines in monitor-------------\n 28    routineA_in_mt () {\n 29       P(mt.mutex);                              // ENTRY PROTOCOL (at the beginning of each monitor routines), wait for exclusive access to the monitor \n 30       ...\n 31       real body of routineA　　　　　　　　　　　　         // in here, may access shared variables, call cond_wait OR cond_signal\n 32       ...\n 33       if(next_count>0)                          // EXIT PROTOCOL (at the end of each monitor function)\n 34           V(mt.next);                           // if there are processes(sleeped cv.signaling proc) in the \"next\" queue, release one \n 35       else\n 36           V(mt.mutex);                          // otherwise, release the monitor\n 37    }\n```\n\n请说明管程的特征。",
    "explain":"管程的特征：1）只有一个进程在管程内执行；2）管程内执行的进程可通过条件变量暂时放弃管程控制权，进入等待状态；（4分）\n上述管程实现是hoare类型；（1分）\n",
    "degree_of_difficulty":1,
    "source":"2016期末",
    "answer":"管程的特征：1）只有一个进程在管程内执行；2）管程内执行的进程可通过条件变量暂时放弃管程控制权，进入等待状态；（4分）\n上述管程实现是hoare类型；（1分）\n",
    "type":"question_answer",
    "q_number":1566
}