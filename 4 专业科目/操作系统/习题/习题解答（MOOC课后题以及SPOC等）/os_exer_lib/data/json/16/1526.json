{
    "status":"ok",
    "knowledge":[
        ""
    ],
    "question":"在操作系统内核中进程切换是从函数schedule()中调用函数proc_run(next)，再调用用汇编实现的函数switch_to(&(prev->context), &(next->context))来完成的。请以图示方式给出在执行\"/kern/process/switch.S\"中第6、8、17、27和29行前时对应的内核栈中，“&(prev->context)”和“&(next->context)”的位置、栈顶指针esp指向的位置和内容。\n\n```\n-----/lab4/kern/process/switch.S -------\n1\t.text\n2\t.globl switch_to\n3\tswitch_to:                      # switch_to(from, to)\n4\t\n5\t    # save from's registers\n6\t    movl 4(%esp), %eax          # xxx\n7\t    popl 0(%eax)                # xxx\n8\t    movl %esp, 4(%eax)\n9\t    movl %ebx, 8(%eax)\n10\t    movl %ecx, 12(%eax)\n11\t    movl %edx, 16(%eax)\n12\t    movl %esi, 20(%eax)\n13\t    movl %edi, 24(%eax)\n14\t    movl %ebp, 28(%eax)\n15\t\n16\t    # restore to's registers\n17\t    movl 4(%esp), %eax          # xxx\n18\t                                # xxx\n19\t    movl 28(%eax), %ebp\n20\t    movl 24(%eax), %edi\n21\t    movl 20(%eax), %esi\n22\t    movl 16(%eax), %edx\n23\t    movl 12(%eax), %ecx\n24\t    movl 8(%eax), %ebx\n25\t    movl 4(%eax), %esp\n26\t\n27\t    pushl 0(%eax)               # xxx\n28\t\n29\t    ret\n30\t\n31\t\n\n-----/kern/process/proc.c----------\n86\tvoid switch_to(struct context *from, struct context *to);\n....\n208\t// proc_run - make process \"proc\" running on cpu\n209\t// NOTE: before call switch_to, should load  base addr of \"proc\"'s new PDT\n210\tvoid\n211\tproc_run(struct proc_struct *proc) {\n212\t    if (proc != current) {\n213\t        bool intr_flag;\n214\t        struct proc_struct *prev = current, *next = proc;\n215\t        local_intr_save(intr_flag);\n216\t        {\n217\t            current = proc;\n218\t            load_esp0(next->kstack + KSTACKSIZE);\n219\t            lcr3(next->cr3);\n220\t            switch_to(&(prev->context), &(next->context));\n221\t        }\n222\t        local_intr_restore(intr_flag);\n223\t    }\n224\t}\n\n--------/kern/process/proc.h -------\n19\t// Saved registers for kernel context switches.\n20\t// Don't need to save all the %fs etc. segment registers,\n21\t// because they are constant across kernel contexts.\n22\t// Save all the regular registers so we don't need to care\n23\t// which are caller save, but not the return register %eax.\n24\t// (Not saving %eax just simplifies the switching code.)\n25\t// The layout of context must match code in switch.S.\n26\tstruct context {\n27\t    uint32_t eip;\n28\t    uint32_t esp;\n29\t    uint32_t ebx;\n30\t    uint32_t ecx;\n31\t    uint32_t edx;\n32\t    uint32_t esi;\n33\t    uint32_t edi;\n34\t    uint32_t ebp;\n35\t};\n36\t\n---------------------------------------\n```",
    "explain":"暂无",
    "degree_of_difficulty":1,
    "source":"2016春期中",
    "answer":"暂无",
    "type":"question_answer",
    "q_number":1526
}