快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。

该方法的基本思想是：

1．先从数列中取出一个数作为基准数。

2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。

3．再对左右区间重复第二步，直到各区间只有一个数。



数据结构是对在计算机内存中（有时在磁盘中）的数据的一种安排
数据结构包括数组，链表，栈，二叉树，哈希表等等
算法对这些结构中的数据进行各种处理，例如，查找一条特殊的数据项或者对数据进行排序

软件工程研究的是由许多程序员参与的大型复杂的计算机程序的创建方法。
他强调的是程序的整体设计和如何依照最终用户需求而进行设计的问题。
软件工程关系者一个软件项目的整个生命周期，包括分析，设计，验证，编码，测试，生产和维护各阶段。

java内存回收机制  定时去查看new开辟的内存空间

插入 查找 删除  排序
c 搜索关键字 b a d 方法 .  数据类型

	// 二分查找 适合按从小到大顺序已经排好的 这样会降低插入的效率 要比较插入数据比之前的都要大
	public int find(long value) {
		int lowerBound = 0;
		int upperBound = nElems - 1;
		int curr;
		while (true) {
			curr = (lowerBound + upperBound) / 2;
			if (array[curr] == value)
				break;
			else if (lowerBound > upperBound) {
				return nElems;
			} else {
				if (array[curr] > value)
					upperBound = curr - 1;
				else
					lowerBound = curr + 1;
			}
		}
		return curr;
	}
有序数组比无序数组查找快多了
但是插入由于所有靠后的数据都需要移动以腾开空间，所以插入速度较慢
有序和无序删除都很慢
有序数组适合频繁查找，不适合插入和删除

时间复杂度

线性查找    	O(N)     
二分查找    	O(logN) 次之	
无序数组插入	O(1) 最好
有序数组插入	O(N) 一般
无序数组删除	O(N) 
有序数组删除	O(N) 
冒泡排序    	O(N*N) 最差

画出函数图   可以看出所用时间的对比

以B为底A的对数（大概）是结果等于1之前用B除以A的次数
线性查找需要的时间与数组中数据项的个数成正比
二分查找需要的时间与数组中数据项的个数的对数成正比

2（底数）^2（指数）
d  对的  b 错 new  d  接口 d 指数 3 8 6 假 a 常量 对象

冒泡排序
选择排序  一直找最小值  交换
插入排序  部分有序   后面（无序）和前面（有序）反着比较  比前一位小 就后移 一直到比前一位大  留出来的空位 就插入

三种时间复杂度都是O(N*N)

d  比较 交换或复制 错 a 假 b 假 三 下标小于或等于outer的进行排序 
c d 复制 b 下标小于outer的项部分有序 b


循环列队 基于数组，数组下标可以从数组尾端绕回到数组开始的位置

10 b 先进后出  后进先出 错 b 不动  45 错O（1） c  O（N） c 对 b 是
a

链表
class Link{
int data;
Link next;//引用
}
对象的引用 Object o=o2；将其指向已有的内存地址
对象的创建 Object o=new Object（）；新开辟内存地址
双向链表
class Link{
int data;
Link next;//引用
Link previous;//引用
}

归并排序
把数组分成两半 排序每一半，然后用merge（）方法把数组的两半归并成一个有序数组
O(N*logN)

在归并排序中，一个大数组的单个数据项的字数据项的子数组归并为两个数据项的子数组，然后两个数据项的子数组归并为4个数据项的子数组，如此下去知直到所有的数组数据项有序

递归方法可能效率低，有时可以用一个简单的循环或者是一个基于栈的方法来代替他


希尔排序  增量d  是插入排序的改版
d=1是插入排序
对于大数组开始增量也应该大，然后增量不断减小，直到变成1
d=3*h+1;   1  4  13  
划分排序
快速排序


二叉搜索树：一个节点的左节点的关键字值小于这个节点，右子节点的关键字值大于或等于这个父节点

	(57<63)63
	27		80
13	   51	   70		93
	     57(放这里)	
树的遍历最简单的事递归遍历（就像遍历文件夹一样）
前序
中序
后序












