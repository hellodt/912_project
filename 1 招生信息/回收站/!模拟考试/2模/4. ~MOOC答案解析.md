> https://zhanghuimeng.github.io/post/os-mooc-final-exam-analysis/

以下内容来自学堂在线《操作系统》在线课程的期末考试。因为只有单选题，所以没有什么难的。

------

1. 某基于动态分区存储管理的计算机系统，其主存容量为55MB（初始为空），采用最佳适配（Best Fit）算法，分配和释放的顺序为：分配15MB，分配30MB，释放15MB，分配8MB，分配7MB，则此时主存中最大空闲分区的大小是（ ）

- 7MB
- **8MB**
- 9MB
- 10MB

分配过程：

```
  
|----------------55MB--------------------||===15MB====|---------40MB---------------||===15MB====|======30MB======|---10MB----||---15MB----|======30MB======|---10MB----||---15MB----|======30MB======|=8MB=|-2MB-||=7MB=|-8MB-|======30MB======|=8MB=|-2MB-|
```

**EXPLANATION**

下面是分配过程的表示。
 0： 55
 15： (15), 40
 30： (15), (30), 10
 ~15: 15, (30), 10
 8: 15, (30), (8), 2
 7: (7), 8, (30), (8), 2

------

1. 在一个采用单地址方案（逻辑地址与物理地址是一一对应的）的分段存储系统中，内存地址长度为32位，其中段号占10位，则最大段长为（ ）

- 2^8字节
- 2^14字节
- **2^22字节**
- 2^24字节

**EXPLANATION**

在段访问机制中，如果采用的是单地址方案，则段号的位数+段内偏移的位数=地址长度，所以段内偏移占了32 - 10 = 22 比特。

------

1. 某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为2^10字节，页表项大小为4字节，逻辑地址结构为“|一级页号|二级页号|页内偏移量|”，逻辑地址空间大小为2^16页，则表示整个逻辑地址空间的一级页表中包含表项的个数至少为（ ）

- 64
- 128
- **256**
- 512

由于逻辑地址空间大小为2^16页，页大小为2^10字节，因此逻辑地址总长度为26，其中页内偏移量长度为10。我猜测一张页表最多占满一页，所以最多能够包含2^10/4=2^8=256个页表项。事实上，2^8*2^8恰好等于2^16（页），因此其实只有一种分配方法，就是一级页号长度=二级页号长度=8，每张页表都有256个页表项。

**EXPLANATION**

页大小为2^10B，页表项大小为4B，一页可以存放2^8个页表项，逻辑地址空间大小为2^16页，需要2^16个页表项，需要2^16/2^8 = 2^8 = 256个表项保存页表项。所以页目录表中包含的表项至少为256

------

1. 在CPU中具有TLB和高速缓存(CACHE)的分页式存储管理系统中时，每次CPU取指令或取操作数，至少要访问（）次主存

- **0**
- 1
- 2
- 3

一般取指令或取操作数需要经过以下过程：

- 查TLB 
  - TLB miss 
    - 从CR3寄存器中读出一级页表基地址，在一级页表中查出二级页表基地址
    - 在二级页表中查出页帧物理地址 
      - 如果该页在内存中则直接查到
      - 否则发生Page Fault，将对应页换入，重新执行上述过程
  - TLB hit 
    - 直接得到虚拟地址对应的物理地址
- 从物理地址中读数据

如果运气好的话，TLB hit，且对应的物理内存块缓存在cache中，则一次主存都不用访问。如果运气坏的话……我也想不起在ucore中最多会访问多少次主存了。

**EXPLANATION**

0次。因为CPU访问的页表项和要访问的内存单元可能会有缓存在TLB和cache中。

------

1. 对于下列3种操作：
    （1）整数除以0；
    （2）cos数学函数调用；
    （3）read系统调用；

会导致用户进程从用户态切换到内核态的操作是

- 1、2
- **1、3**
- 2、3
- 1、2、3

**EXPLANATION**

函数调用并不会切换到内核态，而除零操作引发中断，中断和系统调用都会切换到内核态进行相应处理

------

1. 在缺页处理过程中，操作系统执行的操作可能是下列操作：
    （1）修改页表(page table)
    （2）磁盘I/O
    （3）分配页框（page frame）
    中的（ ）

- 仅1、2
- 仅2、3
- 仅1、3
- **1、2、3**

**EXPLANATION**

如果还有可分配给程序的内存，那么会分配新的页框，修改页表，从磁盘读取内容放入到分配的页框中。

------

1. 一个虚拟存储器系统中，主存容量16MB，辅存容量2GB，地址寄存器位数32位。那么虚存最大容量为（ ）

- 2GB
- 16MB
- 2GB + 16MB
- **4GB**

这是常见的障眼法了。群里有人曾经提问过，虚存4GB连主存+辅存都放不下，那怎么能说虚存最大为4GB呢？老师的回答是这样的：虚存大小不会受到硬盘的大小限制，因为这是虚存。因为是虚存，所以实际用到多少鬼知道。而且，甚至可以没有硬盘——比如无盘工作站、分布式系统、透明计算……虚存最后不一定需要对应到实际的物理存储的。所以虚存大小只和地址位数有关。（如果以上内容逻辑混乱，那是因为老师在微信里的回答比较零散。）

**EXPLANATION**

虚拟存储器的最大容量跟虚拟地址空间有关，是2^32。

------

1. 某进程的页面访问顺序为1、3、2、4、2、3、1、2，系统最多分配3个物理页面，那么采用LRU算法时，进程运行过程中会发生（ ）缺页

- 三次
- 四次
- **五次**
- 六次

| 时间 | 访问页面 | 是否缺页 | 换出 | 栈顶（MRU） |      | 栈底（LRU） |
| ---- | -------- | -------- | ---- | ----------- | ---- | ----------- |
| 1    | 1        | 是       | -    | 1           | -    | -           |
| 2    | 3        | 是       | -    | 3           | 1    | -           |
| 3    | 2        | 是       | -    | 2           | 3    | 1           |
| 4    | 4        | 是       | 1    | 4           | 2    | 3           |
| 5    | 2        | 否       | -    | 2           | 4    | 3           |
| 6    | 3        | 否       | -    | 3           | 2    | 4           |
| 7    | 1        | 是       | 4    | 1           | 3    | 2           |
| 8    | 2        | 否       | -    | 2           | 1    | 3           |

**EXPLANATION**

解释：1（缺页） - 3（缺页） - 2（缺页） - 4（缺页，换出1） - 2 - 3 - 1（缺页，换出4） - 2

------

1. 设两个进程共用一个临界区资源对应的互斥信号量mutex。当一个进程进入了临界区，另一个进程等待时，mutex应该等于多少（）

- **-1**
- 0
- 1
- 2

在一般的实现下，如果信号量的值为负数，则它的相反数=等待进程个数。

**EXPLANATION**

两个进程共用一个临界区的互斥信号量mutex，那么mutex的取值范围应该是1到-1，1表示没有进程进入临界区并且也没有进程等待，0表示有一个进程进入临界区，-1表示有一个进程进入临界区并且另一个进程等待。

------

1. (1)多个进程对信号量S进行了6次P操作，2次V操作后，现在信号量的值是-3，与信号量S相关的处于阻塞状态的进程有几个（ ）

- 1
- 2
- **3**
- 4

1. (2)如10.(1)所描述的情况,信号量S的初值是（）

- **1**
- 2
- 3
- 4

等待进程数量为3。初值-6+2=-3，因此初值=1。

**EXPLANATION**

-3+6-2=1

------

1. 用于互斥的二值信号量可以初始化为（）

- **0或1**
- 0或-1
- 只能为1
- 任意值

事实上，用于互斥作用的信号量初值应该置1，用于条件等待作用的信号量初值应该置0。

**EXPLANATION**

通常操作系统区分计数信号量与二值信号量，二进制信号量的值只能为0或1

------

1. 设与某资源关联的信号量Sem初值为4，当前值为2。若M表示该资源的可用个数，N表示等待该资源的进程数，则M、N分别是（）

- 0、1
- 1、0
- 1、2
- **2、0**

显然可用个数为2，没有进程在等待。

**EXPLANATION**

信号量表示当前可用的相关资源数。当信号量Sem>0时，表示还有Sem个相关资源可用；而当信号量Sem<=0时，表示有|Sem|个进程在等待该资源。所以该资源可用数是2，等待该资源的进程数是0。

------

1. 有两个并发执行的进程P1和P2，共享初值为1的变量x。加1和减1操作的指令序列分别如下所示。

P1：对x执行加一操作

```
  
load R1,xinc R1store R1,x
```

P2：对x执行减一操作

```
  
load R2,xdec R2store R2,x
```

两个操作完成后，x的值（ ）

- 可能为-1或3
- 只能为1
- **可能为0、1或2**
- 可能为-1、0、1、1或2

**EXPLANATION**

依次执行P1-1，P1-2，P1-3，P2-1，P2-2，P2-3，得到的结果是1；依次执行P1-1，P1-2，P2-1，P2-2，P2-3，P1-3，得到的结果是2；依次执行P2-1，P2-2，P1-1，P1-2，P1-3，P2-3得到的结果是0

------

1. 资源的有序分配策略可以破坏死锁的（）条件

- 互斥
- 请求和保持
- 不剥夺
- **循环等待**

**EXPLANATION**

资源的有序分配策略属于死锁预防的一种，死锁预防是通过破坏4个必要条件中的1个或者多个以确保系统不会发生死锁。采用资源有序分配法是破坏了“环路”条件，即破坏了循环等待。

------

1. 若一个用户进程通过read系统调用读取一个磁盘文件中的数据，则下列关于此进程的叙述中，正确的是（）

I. 若文件的数据不在内存中，则该进程进入睡眠等待状态
 II. 请求read系统调用会导致CPU从用户态切到核心态
 III. read系统调用的参数应包含文件的名称

- **仅I、II**
- 仅I、III
- 仅II、III
- I、II和III

中间做错了，不是D。问题就在于，这个是read调用，不是open调用。

**EXPLANATION**

对于I，当所读文件的数据不在内存时，产生I/O请求，原进程进入阻塞状态，知道所需数据从外存调入内存后，才将该进程唤醒。对于II，read系统调用通过陷入将CPU从用户态进入核心态，从而获取操作系统提供的服务。对于III，读一个文件首先要用open系统调用打开该文件。open参数包含文件的路径名与文件名，read只需要open返回的文件描述符，不用文件名作为参数。read要求三个输入参数：1文件描述符fd；2buf缓冲区首地址；3传送的字节数n。read的功能试图从fd所指示的文件中读入n个字节的数据，并将它们送到buf所指示的缓冲区中。

------

1. 用户删除某文件的过程中，操作系统不可能执行的操作是（）

- **删除文件所在的目录**
- 删除与此文件关联的目录项
- 删除与此文件对应的文件控制块
- 释放与此文件关联的内存缓冲区

这个好像是常识。

**EXPLANATION**

删除文件不能删除文件所在的目录，而与此文件关联的目录项和文件控制块需要随着文件一同删除，同时释放文件关联的内存缓冲区。

------

1. 设文件A的当前引用计数值为1，先建立文件A的符号链接（软链接）文件B，再建立文件A的硬链接C，然后删除文件A。此时，文件B和文件C的引用计数分别是（）

- 0,1
- **1,1**
- 1,2
- 2,1

B是我随便选的，实际上我并不会算引用计数。

**EXPLANATION**

建立符号链接时，引用计数为1；建立硬链接时，引用计数加1。删除文件时，删除操作对于符号链接是不可见的，这并不影响符号链接文件；当以后通过符号链接访问文件时，发现文件不存在；但对于硬链接删除操作，引用计数值减1，若值大于0，则不会真正删除文件数据，因为还有其他的硬链接或文件索引指向此文件。当建立B时，A和B的引用计数值都为1.当建立C时，A和B的引用计数值分别为2和1。删除A时，C的引用计数值为2-1=1，B的引用计数值不变。

------

1. 在多用户操作系统中，某文件占用10个磁盘块，现在要把该文件磁盘块逐个读入主缓冲区，并送用户区进行分析。假设一个缓冲区与一个磁盘块大小相同，把一个磁盘块读入缓冲区的时间为100μs，将缓冲区的数据传送到用户区的时间是50μs，CPU对一块数据进行分析的时间为50μs。在单缓冲区和双缓冲区结构下，读入并分析完该文件的时间分别是（  ）

- 1500μs，1000μs
- 1550μs，1100μs
- 1550μs，1550μs
- 2000μs，2000μs

单缓冲区：(100+50) * 10 + 50 = 1550μs

双缓冲区：100 + 100*9 + 50 + 50 = 1100μs

**EXPLANATION**

单缓冲区下，当上一个磁盘块从缓冲区读入用户区完成时下一磁盘块才能开始读入，所以当最后一块磁盘块读入用户区完毕时，所用时间为150×10＝1500，加上处理最后一个磁盘块的cpu处理时间50，最后结果为1550。

双缓冲区下，读入第一个缓冲区之后可以立刻开始读入第二个缓冲区，读完第二个缓冲区之后，第一个缓冲区的数据已经传送到用户区，因此不存在等待磁盘块从缓冲区读入用户区的问题，也就是100×10＝1000，再加上最后一个缓冲区的数据传输到用户区并有CPU处理的时间50+50=100，总的时间是1000+100=1100。

------

1. 假设磁头当前位于第105道，正在向磁道序号增加的方向移动。现有一个磁道访问请求序列为35，45，12，68，110，180，170，195。采用SCAN调度（电梯调度）算法得到的磁道访问序列是()

- **110，170，180，195，68，45，35，12**
- 110，68，45，35，12，170，180，195
- 110，170，180，195，12，35，45，68
- 12，35，45，68，110，170，180，195

A对应的是SCAN算法（磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂到达该方向上最后的磁道；然后调换方向）

我猜测B对应的是SSTF算法（选择从磁臂当前位置需要移动最少的I/O请求）；C对应的是CLOOK算法（限制仅在一个方向上扫描；当最后一个请求也被访问过了后，磁臂返回到磁盘的另外一端再次进行扫描）；D不知道是啥。

**EXPLANATION**

SCAN调度算法就是电梯调度算法，顾名思义就是如果开始时磁头往外就一直要到最外面，然后再返回向里（磁头编号一般是最外面为0号往里增加），就像电梯若往下则一直要下到最底层才会再上升一样。

------

1. 某操作系统中建立了一个基于索引节点(index node)结构的文件系统very simple file system, 简称vsfs。

vsfs的用户操作包括(以函数形式表示):

- mkdir(“str”) - 创建一个新目录,目录名称为”str”
- creat(“str”) - 创建一个空文件,空文件名称为“str”
- fd=open(“str”), write(fd), close(fd) – 打开文件”str”,会返回一个整型数fd,  然后对文件写一个buffer,注意常规文件的最大size是一个data block,所以第二次写(写文件的语义是在上次写的位置后再写一个data  block)会报错(文件大小满了)。或者如果data block也满了,也会报错。
- link(“a1”,”b1”) - 对文件”a1”创建一个硬链接(hard link)文件”b1”
- unlink(“b1”) - 对文件“b1”取消一个硬链接,如果文件的链接数为0,则删除此文件

vsfs在硬盘上的布局:

- superblock : 可用inode数量,可用data block数量
- inode bitmap : inode的分配图(基于bitmap)
- inodes : inode的存储区域
- data bitmap : data block的分配图(基于bitmap)
- data : data block的存储区域

vsfs的关键数据结构:

- inode数据结构: 
  - inode : 包含3个fields, 用 list 表示 
    - file type: f -> 常规文件:regular file, d -> 目录文件:directory
    - data block addr of file content: -1 -> file is empty
    - reference count: file/directory的引用计数,注意directory的引用计数是指在此目录中的inode的个数
  - 注意:比如,刚创建的一个空文件inode: [f a:-1 r:1], 一个有1个硬链接的文件inode: [f a:10 r:2]
- 数据块内容结构: 
  - 一般文件的内容的表示:只是包含单个字符的list,即占一个data block,比如['a'], ['b'] .....
  - 目录内容的表示: 多个两元组(name, inode_number)形成的list,比如, 根目录[(.,0) (..,0)], 或者包含了一个'f'文件的根目录[(.,0) (..,0) (f,1)] 。
  - 注意: 
    - 一个目录的目录项的个数是有限的。 block.maxUsed = 32
    - data block的个数是有限的,为 fs.numData
    - inode的个数是有限的,为 fs.numInodes

完整文件系统的例子:

- fs.ibitmap:      inode bitmap 11110000
- fs.inodes:       [d a:0 r:5] [f a:1 r:1] [f a:-1 r:1] [d a:2 r:2] [] ...
- fs.dbitmap:    data bitmap 11100000
- fs.data:           [(.,0) (..,0) (y,1) (z,2) (x,3)] [u] [(.,3) (..,0)] [] ...

表明: 此文件系统有8个inode空间, 8个data blocks.  其中,根目录包含5个目录项，“.”,“..”,“y”,“z”,“x”。 而“y”是常规文件,并有文件内容,包含一个data  block,文件内容为“u”。“z”是一个空的常规文件。“x”是一个目录文件，是空目录。

如果vsfs初始状态为:

- inode bitmap     10000000
- inodes                 [d a:0 r:2] [] [] [] [] [] [] []
- data bitmap       10000000
- data                     [(.,0) (..,0)] [] [] [] [] [] [] []

请问接下来的连续6个状态变化的对应用户操作是什么?据此回答以下6个问题

------

1. (1)

- inode bitmap 11000000
- inodes [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []
- data bitmap 11000000
- data [(.,0) (..,0) (c,1)] [(.,1) (..,0)] [] [] [] [] [] []

对应用户操作是（ ）

- **mkdir("/c");**
- unlink("/c");
- creat("/c");
- fd=open(“/c”), write(fd), close(fd)

显然多了一个目录。

**EXPLANATION**

mkdir("/c");

------

1. (2)

- inode bitmap 11100000
- inodes [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [] [] [] [] []
- data bitmap 11000000
- data [(.,0) (..,0) (c,1)] [(.,1) (..,0) (h,2)] [] [] [] [] [] []

对应用户操作是（ ）

- mkdir("/c/h");
- unlink("/c/h");
- **creat("/c/h");**
- fd=open(“/c/h”), write(fd), close(fd)

在c目录下多了一个空文件h。

**EXPLANATION**

creat("/c/h");

------

1. (3)

- inode bitmap 11100000
- inodes [d a:0 r:3] [d a:1 r:4] [f a:-1 r:2] [] [] [] [] []
- data bitmap 11000000
- data [(.,0) (..,0) (c,1)] [(.,1) (..,0) (h,2) (p,2)] [] [] [] [] [] []

对应用户操作是（ ）

- mkdir("/c/p");
- creat("/c/p");
- **link("/c/h", "/c/p");**
- unlink("/c/h");

文件`/c/h`和目录`/c`的引用记录增加了，`/c`目录下多了一个`p`文件。

**EXPLANATION**

link("/c/h", "/c/p");

------

1. (4)

- inode bitmap 11100000
- inodes [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [] [] [] [] []
- data bitmap 11000000
- data [(.,0) (..,0) (c,1)] [(.,1) (..,0) (p,2)] [] [] [] [] [] []

对应用户操作是（ ）

- mkdir("/c/h");
- unlink("/c/p");
- link("/c/h", "/c/p");
- **unlink("/c/h");**

文件`/c/h`和目录`/c`的引用记录减少了，文件`/c/h`被删除了。

**EXPLANATION**

unlink("/c/h");

------

1. (5)

- inode bitmap 11000000
- inodes [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []
- data bitmap 11000000
- data [(.,0) (..,0) (c,1)] [(.,1) (..,0)] [] [] [] [] [] []

对应用户操作是（ ）

- mkdir("/c");
- unlink("/c");
- creat("/c/p");
- **unlink("/c/p");**

文件`/c/p`也被删除了。

**EXPLANATION**

unlink("/c/p");

------

1. (6)

- inode bitmap 11100000
- inodes [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [] [] [] [] []
- data bitmap 11000000
- data [(.,0) (..,0) (c,1)] [(.,1) (..,0) (f,2)] [] [] [] [] [] []

对应用户操作是（ ）

- mkdir("/c/f");
- **creat("/c/f");**
- link("/c","/c/f“);
- fd=open(“/c/f”), write(fd), close(fd)

新建了一个文件f。

**EXPLANATION**

creat("/c/f");